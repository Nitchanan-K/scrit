codechain patchfile version 2
treehash f503d574abd134279921e73c59b8266a06980f5ca55b7919e9dbb3f7f183b04c
+ f fb0817cc0ecb5117f11f49a0ebed1f888dbf56bbbc3da1ac755085d8e18673bb .gitattributes
utf8file 2
.codechain/*/* binary

- f 2709eb7b83939a52c5a7c7a5d92fc6b83be0d34a690ceef42890a4b0c01d6971 .secpkg
+ f bba865efa26d77b3cf89734c7e6c30954e9a4d5c5ca4b71c751ce050b28468d1 .secpkg
dmppatch 5
@@ -18,86 +18,86 @@
 t%22,%0A
-  %22Head%22: %225b13602a88fd3723122e4b9f00b89b9cc491286a9373877f5e718c63f320ce00%22,%0A
+  %22Head%22: %22a43b85ea4cb2f71374c2ff0c2c7897cbbaf257f2db6d8a32c94c82e29e0f6115%22,%0A
   %22D
- f 00546c8cb4b2a6422d1c5b810a3eafb07e3ccc05d392df7d3184cb3d6976e364 README.md
+ f d5881426e73575389b7e88ced2409b444b60af012fcb27ed0cdda551b72f9ec1 README.md
dmppatch 4
@@ -707,16 +707,104 @@
   make%0A%0A
+### Documentation%0A%0A- %5BSetting up a federation of Scrit mints%5D(doc/federation-setup.md)%0A%0A
 ### Supp
+ f d44cb530b2a28043eb4863a979e431e707bfa62a1210e92ae0b49084d237f1fa binencode/LICENSE
utf8file 20
Copyright (c) 2019 The Cypherlock authors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

+ f 5be9d3be11b64b7ce53fee82334ab8eb998fd31ed978de11fee94f96a94b6bc2 binencode/doc.go
utf8file 51
/*
Package binencode provides functions to encode values into length-encoded
slices. It can be used to work on secure memory. Only int16, int32, int64 and
[]byte are supported. Inserting and skipping zero bytes is supported.

Allocation-Free Serialization

This library supports efficient serialization/deserialization of most relevant
data types into byte slices. Message type and data type encoding are
supported, including variable length encodings. No support for stacked
structs exists or will be included.

It uses only pre-allocated memory so that manual allocation and thus memory
protection schemes are accessible.

Two methods for variable allocation are availble: With reflection and without
reflection, based only on language type annotations. This simplifies
development (reflect) while making it very easy to switch to efficient
runtime.

  type data struct {
    a int16
    b int32
    c int64
    d []byte
  }

  // ...

  v := &data{
    a: 1,
    b: 29381,
    c: 5098123,
    d: []byte("any string"),
     }

  // Define fields to include and their order in the output message.
  encodingScheme := []interface{}{v.a, v.b, v.c, v.d}

  // Calculate size of encoded message for manual allocation.
  size, _ := EncodeSize(encodingScheme...)

  // Serialize data into message using preallocated buffer and the defined
  // scheme.
  encodedData, _ := Encode(buf, encodingScheme...)

  // Decode message into the pre-allocated variable decribed by encodingScheme.
  _, _ := Decode(encodedData, encodingScheme)
*/
package binencode

+ f e025df52a8feb98362cefe5ae6a04e300ea07ff7443a0c6b17b96be56119f2af binencode/errors.go
utf8file 27
package binencode

import (
	"errors"
)

// ErrOutputSize is returned if the output buffer capacity is too small.
var ErrOutputSize = errors.New("binencode: output buffer capacity too small")

// ErrInputSize is returned if the input buffer length is too small.
var ErrInputSize = errors.New("binencode: input buffer length too small")

// ErrSliceSize is returned if the output slice is too small.
var ErrSliceSize = errors.New("binencode: output slice too small")

// ErrSliceExpected is returned if the slice has an unexpected length.
var ErrSliceExpected = errors.New("binencode: slice has unexpected length")

// ErrSliceExpectedLong is returned if the slice has an unexpected long length.
var ErrSliceExpectedLong = errors.New("binencode: slice has unexpected long length")

// ErrType is returned if an unexpected type is encountered.
var ErrType = errors.New("binencode: unexpected type encountered")

// ErrNil is returned when writing a type to a nil value.
var ErrNil = errors.New("binencode: cannot write type to nil value")

+ f f5fc36c70bc9ec17853e6044bb977d1984ef709122131c6089ea3bf960822fef binencode/lenprefixed.go
utf8file 370
package binencode

import (
	"encoding/binary"
	"reflect"
)

// Encode/decode into byteslices
// Type: 1 byte
// Length: 4 byte
// Data: [length]bytes (only for bytes)
// Encode/Decode move pointers into input/output slices further
// Encode/Decode check capacity of slices for ability
// - []byte (min,max)

// Encode16Size defines the size of an int16 encoding.
const Encode16Size = 3

// EncodeInt16 encodes an int16 into b. It returns b, advanced by the data written, as well as the length of data written.
func EncodeInt16(i int16, b []byte) (output []byte, n int, err error) {
	if cap(b) < Encode16Size {
		return b, 0, ErrOutputSize
	}
	b = b[0:Encode16Size]
	b[0] = 0x01
	binary.BigEndian.PutUint16(b[1:Encode16Size], uint16(i))
	return b[Encode16Size:], Encode16Size, nil
}

// DecodeInt16 decodes an Int16 from b, it advances and returns b as well as the number of bytes read.
func DecodeInt16(b []byte, i *int16) (output []byte, n int, err error) {
	if len(b) < Encode16Size {
		return b, 0, ErrInputSize
	}
	if b[0] != 0x01 {
		return b, 0, ErrType
	}
	if i == nil {
		return b, 0, ErrNil
	}
	*i = int16(binary.BigEndian.Uint16(b[1:Encode16Size]))
	return b[Encode16Size:], Encode16Size, nil
}

// Encode32Size defines the size of an int32 encoding.
const Encode32Size = 5

// EncodeInt32 encodes an int32 into b. It returns b, advanced by the data written, as well as the length of data written.
func EncodeInt32(i int32, b []byte) (output []byte, n int, err error) {
	if cap(b) < Encode32Size {
		return b, 0, ErrOutputSize
	}
	b = b[0:Encode32Size]
	b[0] = 0x02
	binary.BigEndian.PutUint32(b[1:Encode32Size], uint32(i))
	return b[Encode32Size:], Encode32Size, nil
}

// DecodeInt32 decodes an Int32 from b, it advances and returns b as well as the number of bytes read.
func DecodeInt32(b []byte, i *int32) (output []byte, n int, err error) {
	if len(b) < Encode32Size {
		return b, 0, ErrInputSize
	}
	if b[0] != 0x02 {
		return b, 0, ErrType
	}
	if i == nil {
		return b, 0, ErrNil
	}
	*i = int32(binary.BigEndian.Uint32(b[1:Encode32Size]))
	return b[Encode32Size:], Encode32Size, nil
}

// Encode64Size defines the size of an int64 encoding.
const Encode64Size = 9

// EncodeInt64 encodes an int64 into out. It returns out, advanced by the data written, as well as the length of data written.
func EncodeInt64(i int64, out []byte) (output []byte, n int, err error) {
	if cap(out) < Encode64Size {
		return out, 0, ErrOutputSize
	}
	out = out[0:Encode64Size]
	out[0] = 0x03
	binary.BigEndian.PutUint64(out[1:Encode64Size], uint64(i))
	return out[Encode64Size:], Encode64Size, nil
}

// DecodeInt64 decodes an Int64 from in, it advances and returns in as well as the number of bytes read.
func DecodeInt64(in []byte, i *int64) (output []byte, n int, err error) {
	if len(in) < Encode64Size {
		return in, 0, ErrInputSize
	}
	if in[0] != 0x03 {
		return in, 0, ErrType
	}
	if i == nil {
		return in, 0, ErrNil
	}
	*i = int64(binary.BigEndian.Uint64(in[1:Encode64Size]))
	return in[Encode64Size:], Encode64Size, nil
}

// EncodeBytesSize returns the number of bytes d would occupy in encoded form.
func EncodeBytesSize(d []byte) int {
	if d == nil {
		return 5
	}
	return 5 + len(d)
}

// DecodeBytesSize returns the number of bytes the output buffer requires. It returns false if the entry cannot be decoded.
func DecodeBytesSize(in []byte) (int, bool) {
	if in[0] != 0x04 {
		return 0, false
	}
	if len(in) < 5 {
		return 0, false
	}
	l := int(binary.BigEndian.Uint32(in[1:5]))
	if l < 0 {
		return 0, false
	}
	if len(in) < 5+l {
		return 0, false
	}
	return l, true
}

// DecodeBytesSizeLimits returns the number of bytes the output buffer requires. It returns false if the entry cannot be decoded.
// It takes the given limits into account.
func DecodeBytesSizeLimits(in []byte, minSize, maxSize int) (int, bool) {
	size, ok := DecodeBytesSize(in)
	if !ok {
		return 0, false
	}
	if size < minSize {
		return 0, false
	}
	if maxSize > 0 && size > maxSize {
		return 0, false
	}
	return size, true
}

// EncodeBytes encodes a byte slice d into out. It returns out, advanced by the data written, as well as the length of data written.
// If out == nil, a zero length slice will be encoded.
func EncodeBytes(d, out []byte) (output []byte, n int, err error) {
	var l int
	size := EncodeBytesSize(d)
	if cap(out) < size {
		return out, 0, ErrOutputSize
	}
	out = out[0:size]
	out[0] = 0x04
	if d == nil {
		l = 0
	} else {
		l = len(d)
	}
	binary.BigEndian.PutUint32(out[1:5], uint32(l))
	if l > 0 {
		copy(out[5:size], d)
	}
	return out[size:], size, nil
}

// DecodeBytes decodes a byteslice from in into out. It returns out, advanced by the data written, as well as the length of data written.
// If out points to a nil slize, a new slize of the appropriate length will be created. If it points to a slice of zero length, data will
// be copied into that slize. It is an error if the input data is larger then the capacity. If out points to a slice of non-zero length,
// the input data must have exactly that size.
func DecodeBytes(in []byte, out *[]byte) (output []byte, n int, err error) {
	var x []byte
	if in[0] != 0x04 {
		return in, 0, ErrType
	}
	size, _ := DecodeBytesSize(in)
	if len(in) < size+5 {
		return in, 0, ErrInputSize
	}
	if *out == nil {
		x = make([]byte, size)
		*out = x
	}
	x = *out
	if size > 0 {
		if cap(x) < size {
			return in, 0, ErrSliceExpectedLong
		}
		if len(x) > 0 && len(x) != size {
			return in, 0, ErrSliceExpected
		}
		x = x[0:size]
		copy(x, in[5:5+size])
	}
	*out = x
	return in[5+size:], 5 + size, nil
}

// SlicePointer is a convenience function to Decode bytes into arrays.
func SlicePointer(d []byte) *[]byte {
	return &d
}

// EncodeSkip skips l bytes in the output.
func EncodeSkip(skip int, out []byte) (output []byte, n int, err error) {
	if cap(out) < skip {
		return out, 0, ErrOutputSize
	}
	out = out[0:skip]
	return out[skip:], skip, nil
}

// DecodeSkip decodes a skip in the output.
func DecodeSkip(in []byte, skip int) (output []byte, n int, err error) {
	if len(in) < skip {
		return in, 0, ErrInputSize
	}
	return in[skip:], skip, nil
}

// EncodeSize returns the necessary size of a byteslize to contain the given input values.
// Only *int16, int16, *int32, int32, *int64, int64, []byte and *[]byte are supported for encoding.
// int values are considered to be skip instructions.
func EncodeSize(v ...interface{}) (int, error) {
	var s int
	for _, vi := range v {
		switch e := vi.(type) {
		case *int16:
			s += Encode16Size
		case int16:
			s += Encode16Size
		case *int32:
			s += Encode32Size
		case int32:
			s += Encode32Size
		case *int64:
			s += Encode64Size
		case int64:
			s += Encode64Size
		case *[]byte:
			s += EncodeBytesSize(*e)
		case []byte:
			s += EncodeBytesSize(e)
		case int:
			s += e
		default:
			return 0, ErrType
		}
	}
	return s, nil
}

// Encode the interfaces to out. If out == nil, a new slice will be allocated.
// Only *int16, int16, *int32, int32, *int64, int64, []byte and *[]byte are supported for encoding.
// int values are considered to be skip instructions.
func Encode(out []byte, v ...interface{}) ([]byte, error) {
	var err error
	var s, sc, n int
	if out == nil {
		s, err = EncodeSize(v...)
		if err != nil {
			return nil, err
		}
		out = make([]byte, 0, s)
	}
	orig := out
	for _, vi := range v {
		switch e := vi.(type) {
		case *int16:
			if out, n, err = EncodeInt16(*e, out); err != nil {
				return nil, err
			}
		case int16:
			if out, n, err = EncodeInt16(e, out); err != nil {
				return nil, err
			}
		case *int32:
			if out, n, err = EncodeInt32(*e, out); err != nil {
				return nil, err
			}
		case int32:
			if out, n, err = EncodeInt32(e, out); err != nil {
				return nil, err
			}
		case *int64:
			if out, n, err = EncodeInt64(*e, out); err != nil {
				return nil, err
			}
		case int64:
			if out, n, err = EncodeInt64(e, out); err != nil {
				return nil, err
			}
		case *[]byte:
			if out, n, err = EncodeBytes(*e, out); err != nil {
				return nil, err
			}
		case []byte:
			if out, n, err = EncodeBytes(e, out); err != nil {
				return nil, err
			}
		case int:
			if out, n, err = EncodeSkip(e, out); err != nil {
				return nil, err
			}
		default:
			return nil, ErrType
		}
		sc += n
	}
	return orig[0:sc], nil
}

// Decode in into v. Returns the remainder.
// Only *int16, *int32, *int64, []byte and *[]byte are supported for encoding.
// int values are considered to be skip instructions.
func Decode(in []byte, v ...interface{}) ([]byte, error) {
	var err error
	for _, vi := range v {
		switch e := vi.(type) {
		case *int16:
			if in, _, err = DecodeInt16(in, e); err != nil {
				return in, err
			}
		case *int32:
			if in, _, err = DecodeInt32(in, e); err != nil {
				return in, err
			}
		case *int64:
			if in, _, err = DecodeInt64(in, e); err != nil {
				return in, err
			}
		case *[]byte:
			if in, _, err = DecodeBytes(in, e); err != nil {
				return in, err
			}
		case int:
			if in, _, err = DecodeSkip(in, e); err != nil {
				return in, err
			}
		default:
			return in, ErrType
		}
	}
	return in, nil
}

// DescribeStruct returns a slice of pointers that can be used to encode and decode
// the struct v which must be given as a pointer. For production code this function
// should not be used since it uses reflection.
func DescribeStruct(v interface{}) []interface{} {
	str := reflect.ValueOf(v).Elem()
	values := make([]interface{}, 0, str.NumField())
	for i := 0; i < str.NumField(); i++ {
		if !str.Field(i).CanInterface() {
			continue
		}
		switch str.Field(i).Interface().(type) {
		case int16:
			values = append(values, str.Field(i).Addr().Interface().(*int16))
		case int32:
			values = append(values, str.Field(i).Addr().Interface().(*int32))
		case int64:
			values = append(values, str.Field(i).Addr().Interface().(*int64))
		case []byte:
			values = append(values, str.Field(i).Addr().Interface().(*[]byte))
		}
	}
	return values
}

+ f c320feb4425091ae1a14f15833a8b2bc013514be23d403567919d1f7d60e7415 binencode/lenprefixed_test.go
utf8file 280
package binencode

import (
	"bytes"
	"testing"

	"github.com/davecgh/go-spew/spew"
)

func TestInt16(t *testing.T) {
	var ta, tb int16
	d := make([]byte, 0, 10000)
	s := 0
	b, l, err := EncodeInt16(15, d)
	if err != nil {
		t.Errorf("EncodeInt16: %s", err)
	}
	s += l
	b, l, err = EncodeInt16(3, b)
	if err != nil {
		t.Errorf("EncodeInt16: %s", err)
	}
	s += l
	b, l, err = DecodeInt16(d[0:s], &ta)
	if err != nil {
		t.Errorf("DecodeInt16: %s", err)
	}
	b, l, err = DecodeInt16(b, &tb)
	if err != nil {
		t.Errorf("DecodeInt16: %s", err)
	}
	if ta != 15 || tb != 3 {
		t.Error("Decoded values don't match")
	}
}

func TestInt32(t *testing.T) {
	var ta, tb int32
	d := make([]byte, 0, 10000)
	s := 0
	b, l, err := EncodeInt32(15, d)
	if err != nil {
		t.Errorf("EncodeInt32: %s", err)
	}
	s += l
	b, l, err = EncodeInt32(3, b)
	if err != nil {
		t.Errorf("EncodeInt32: %s", err)
	}
	s += l
	b, l, err = DecodeInt32(d[0:s], &ta)
	if err != nil {
		t.Errorf("DecodeInt32: %s", err)
	}
	b, l, err = DecodeInt32(b, &tb)
	if err != nil {
		t.Errorf("DecodeInt32: %s", err)
	}
	if ta != 15 || tb != 3 {
		t.Error("Decoded values don't match")
	}
}

func TestInt64(t *testing.T) {
	var ta, tb int64
	d := make([]byte, 0, 10000)
	s := 0
	b, l, err := EncodeInt64(15, d)
	if err != nil {
		t.Errorf("EncodeInt64: %s", err)
	}
	s += l
	b, l, err = EncodeInt64(3, b)
	if err != nil {
		t.Errorf("EncodeInt64: %s", err)
	}
	s += l
	b, l, err = DecodeInt64(d[0:s], &ta)
	if err != nil {
		t.Errorf("DecodeInt64: %s", err)
	}
	b, l, err = DecodeInt64(b, &tb)
	if err != nil {
		t.Errorf("DecodeInt64: %s", err)
	}
	if ta != 15 || tb != 3 {
		t.Error("Decoded values don't match")
	}
}

func TestBytes(t *testing.T) {
	td := []byte("test data 1234")
	s := EncodeBytesSize(td)
	if s != len(td)+5 {
		t.Error("EncodeBytesSize bad value")
	}
	tmp := make([]byte, 0, EncodeBytesSize(td)+2)
	_, n, err := EncodeBytes(td, tmp)
	if err != nil {
		t.Errorf("EncodeBytes: %s", err)
	}
	if n != s {
		t.Error("Encoding wrong size")
	}
	out := tmp[0:cap(tmp)]
	ds, ok := DecodeBytesSize(out)
	if !ok {
		t.Error("DecodeBytesSize not ok")
	}
	if ds != len(td) {
		t.Errorf("DecodeBytesSize wrong size: %d != %d", len(td), ds)
	}
	var td2 []byte
	if _, _, err := DecodeBytes(out, &td2); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
	if !bytes.Equal(td, td2) {
		t.Error("Decode failure, nil")
	}
	td3 := make([]byte, 0, ds+2)
	if _, _, err := DecodeBytes(out, &td3); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
	if !bytes.Equal(td, td3) {
		spew.Dump(td3)
		t.Error("Decode failure, cap")
	}
	td4 := make([]byte, ds)
	if _, _, err := DecodeBytes(out, &td4); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
	if !bytes.Equal(td, td4) {
		t.Error("Decode failure, len")
	}
	td5 := make([]byte, 3)
	if _, _, err := DecodeBytes(out, &td5); err == nil {
		t.Error("DecodeBytes Len short")
	}
	td5 = make([]byte, 100)
	if _, _, err := DecodeBytes(out, &td5); err == nil {
		t.Error("DecodeBytes Len excess")
	}
	td5 = make([]byte, 0, 3)
	if _, _, err := DecodeBytes(out, &td5); err == nil {
		t.Error("DecodeBytes Cap short")
	}
	var td6 [14]byte
	if _, _, err := DecodeBytes(out, SlicePointer(td6[:])); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
	if !bytes.Equal(td, td6[:]) {
		t.Error("Decode failure, array")
	}
}

func TestBytesZero(t *testing.T) {
	td := make([]byte, 0)
	s := EncodeBytesSize(td)
	if s != len(td)+5 {
		t.Error("EncodeBytesSize bad value")
	}
	tmp := make([]byte, 0, EncodeBytesSize(td)+2)
	_, _, err := EncodeBytes(td, tmp)
	if err != nil {
		t.Errorf("EncodeBytes: %s", err)
	}
	out := tmp[0:cap(tmp)]
	var td2 []byte
	if _, _, err := DecodeBytes(out, &td2); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
}

func TestBytesNil(t *testing.T) {
	var td []byte
	s := EncodeBytesSize(td)
	if s != len(td)+5 {
		t.Error("EncodeBytesSize bad value")
	}
	tmp := make([]byte, 0, EncodeBytesSize(td)+2)
	_, _, err := EncodeBytes(td, tmp)
	if err != nil {
		t.Errorf("EncodeBytes: %s", err)
	}
	out := tmp[0:cap(tmp)]
	var td2 []byte
	if _, _, err := DecodeBytes(out, &td2); err != nil {
		t.Errorf("DecodeBytes: %s", err)
	}
}

func TestSkip(t *testing.T) {
	td := []byte("1234567890")
	_, _, err := EncodeSkip(5, td[:0])
	if err != nil {
		t.Errorf("EncodeSkip: %s", err)
	}
	DecodeSkip(td[0:cap(td)], 5)
}

type testStruct struct {
	a int16
	b int32
	c int64
	d []byte
}

type testStruct2 struct {
	A int16
	B int32
	C int64
	D []byte
	c int32
}

func TestReflect(t *testing.T) {
	td := &testStruct2{
		A: 3,
		B: 15,
		C: 1239123,
		D: []byte("test value"),
	}
	td2 := new(testStruct2)
	desc := DescribeStruct(td)
	desc2 := DescribeStruct(td2)
	out, err := Encode(nil, desc...)
	if err != nil {
		t.Fatalf("Encode: %s", err)
	}
	_, err = Decode(out, desc2...)
	if err != nil {
		t.Errorf("Decode: %s", err)
	}
	if td.A != td2.A || td.B != td2.B || td.C != td2.C || !bytes.Equal(td.D, td2.D) {
		t.Error("Decode corrupt")
	}
}

func TestConvenience(t *testing.T) {
	td := &testStruct{
		a: 1,
		b: 2,
		c: 3,
		d: []byte("test"),
	}
	td2 := new(testStruct)
	val1 := []interface{}{td.a, 3, td.b, td.c, td.d}
	val2 := []interface{}{&td.a, 3, &td.b, &td.c, &td.d}
	val3 := []interface{}{&td2.a, 3, &td2.b, &td2.c, &td2.d}
	_, err := EncodeSize(val1...)
	if err != nil {
		t.Fatalf("EncodeSize: %s", err)
	}
	_, err = EncodeSize(val2...)
	if err != nil {
		t.Fatalf("EncodeSize Pointers: %s", err)
	}
	out, err := Encode(nil, val1...)
	if err != nil {
		t.Fatalf("Encode: %s", err)
	}
	out2, err := Encode(nil, val2...)
	if err != nil {
		t.Fatalf("Encode Pointers: %s", err)
	}
	if !bytes.Equal(out, out2) {
		t.Error("Encoded values should match")
	}
	rem, err := Decode(out, val3...)
	if err != nil {
		t.Errorf("Decode: %s", err)
	}
	if len(rem) != 0 {
		t.Error("There should be no remainder")
	}
	if td.a != td2.a || td.b != td2.b || td.c != td2.c || !bytes.Equal(td.d, td2.d) {
		t.Error("Decode corrupt")
	}
}

+ f 98a19e7a4806ec24ec9cae19e3cb6500df24500291b2ce1da39c9d5e761e75a5 binencode/type.go
utf8file 33
package binencode

import "encoding/binary"

// SetType can be used to set the type indicator of a marshalled type. It is always encoded in the first two bytes.
func SetType(d []byte, dataType uint16) error {
	if len(d) < 2 {
		return ErrOutputSize
	}
	binary.BigEndian.PutUint16(d[0:2], dataType)
	return nil
}

// GetType can be used to get the type indicator of a marshalled type. It is always encoded in the first two bytes.
func GetType(d []byte) (dataType uint16, err error) {
	if len(d) < 2 {
		return 0, ErrInputSize
	}
	return binary.BigEndian.Uint16(d[0:2]), nil
}

// GetTypeExpect can be used to test the type indicator of a marshalled type. It is always encoded in the first two bytes.
func GetTypeExpect(d []byte, dataType uint16) (err error) {
	t, err := GetType(d)
	if len(d) < 2 {
		return ErrInputSize
	}
	if t != dataType {
		return ErrType
	}
	return nil
}

+ f 0bfdf6a461b70eb6d4749346121ff7a1750c8495db7bcaf6e910678e2af9d720 cmd/integration_test.go
utf8file 221
package cmd

import (
	"bytes"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/frankbraun/codechain/command"
	"github.com/frankbraun/codechain/util/seckey"
	scritEngine "github.com/scritcash/scrit/engine/command"
	scritGov "github.com/scritcash/scrit/gov/command"
	scritDBCType "github.com/scritcash/scrit/gov/dbctype/command"
	scritEpoch "github.com/scritcash/scrit/gov/epoch/command"
	scritMint "github.com/scritcash/scrit/mint/command"
	scritKeyList "github.com/scritcash/scrit/mint/keylist/command"
)

// Test setting up a federation of Scrit mints (see doc/federation-setup.md).
func TestFederationSetup(t *testing.T) {
	tmpdir, err := ioutil.TempDir("", "scrit_integration_test")
	if err != nil {
		t.Fatalf("ioutil.TempDir() failed: %v", err)
	}
	//defer os.RemoveAll(tmpdir)

	// create separate mint directories
	mint1dir := filepath.Join(tmpdir, "mint1")
	mint2dir := filepath.Join(tmpdir, "mint2")
	mint3dir := filepath.Join(tmpdir, "mint3")
	if err := os.Mkdir(mint1dir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.Mkdir(mint2dir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.Mkdir(mint3dir, 0755); err != nil {
		t.Fatal(err)
	}

	// create identity key for mint 1
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint1dir); err != nil {
		t.Fatal(err)
	}
	seckey.TestPass = "test"
	command.TestComment = "Test Mint 1"
	if err := scritMint.KeyGen("scrit-mint keygen"); err != nil {
		t.Fatal(err)
	}

	// create identity key for mint 2
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint2dir); err != nil {
		t.Fatal(err)
	}
	command.TestComment = "Test Mint 2"
	if err := scritMint.KeyGen("scrit-mint keygen"); err != nil {
		t.Fatal(err)
	}

	// create identity key for mint 3
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint3dir); err != nil {
		t.Fatal(err)
	}
	command.TestComment = "Test Mint 3"
	if err := scritMint.KeyGen("scrit-mint keygen"); err != nil {
		t.Fatal(err)
	}

	// get identity key for mint 1
	stdout := os.Stdout
	tmpfile1, err := ioutil.TempFile("", "scrit_integration_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile1.Name())
	os.Stdout = tmpfile1
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint1dir); err != nil {
		t.Fatal(err)
	}
	if err := scritMint.Identity("scrit-mint identity"); err != nil {
		t.Fatal(err)
	}
	os.Stdout = stdout
	if err := tmpfile1.Close(); err != nil {
		t.Fatal(err)
	}
	buf, err := ioutil.ReadFile(tmpfile1.Name())
	if err != nil {
		t.Fatal(err)
	}
	lines := bytes.Split(buf, []byte("\n"))
	key1 := string(lines[len(lines)-2])

	// get identity key for mint 2
	tmpfile2, err := ioutil.TempFile("", "scrit_integration_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile2.Name())
	os.Stdout = tmpfile2
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint2dir); err != nil {
		t.Fatal(err)
	}
	if err := scritMint.Identity("scrit-mint identity"); err != nil {
		t.Fatal(err)
	}
	os.Stdout = stdout
	if err := tmpfile2.Close(); err != nil {
		t.Fatal(err)
	}
	buf, err = ioutil.ReadFile(tmpfile2.Name())
	if err != nil {
		t.Fatal(err)
	}
	lines = bytes.Split(buf, []byte("\n"))
	key2 := string(lines[len(lines)-2])

	// get identity key for mint 3
	tmpfile3, err := ioutil.TempFile("", "scrit_integration_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile3.Name())
	os.Stdout = tmpfile3
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint3dir); err != nil {
		t.Fatal(err)
	}
	if err := scritMint.Identity("scrit-mint identity"); err != nil {
		t.Fatal(err)
	}
	os.Stdout = stdout
	if err := tmpfile3.Close(); err != nil {
		t.Fatal(err)
	}
	buf, err = ioutil.ReadFile(tmpfile3.Name())
	if err != nil {
		t.Fatal(err)
	}
	lines = bytes.Split(buf, []byte("\n"))
	key3 := string(lines[len(lines)-2])

	// setup the federation (2-of-3):
	if err := os.Chdir(tmpdir); err != nil {
		t.Fatal(err)
	}
	err = scritGov.Start("scrit-gov start", "-m", "2", "-n", "3", key1, key2, key3)
	if err != nil {
		t.Fatal(err)
	}

	// define first DBC types (in denominations of 1, 2, and 5 EUR)
	err = scritDBCType.Add("scrit-gov dbctype add", "-currency", "EUR", "-amount", "100000000")
	if err != nil {
		t.Fatal(err)
	}
	err = scritDBCType.Add("scrit-gov dbctype add", "-currency", "EUR", "-amount", "200000000")
	if err != nil {
		t.Fatal(err)
	}
	err = scritDBCType.Add("scrit-gov dbctype add", "-currency", "EUR", "-amount", "500000000")
	if err != nil {
		t.Fatal(err)
	}

	// create key lists
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint1dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Create("scrit-mint keylist create", "-desc", "mint1", "https://mint1.example.com"); err != nil {
		t.Fatal(err)
	}
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint2dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Create("scrit-mint keylist create", "-desc", "mint2", "https://mint2.example.net"); err != nil {
		t.Fatal(err)
	}
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint3dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Create("scrit-mint keylist create", "-desc", "mint3", "https://mint3.example.org"); err != nil {
		t.Fatal(err)
	}

	// define the second signing epoch
	err = scritEpoch.Add("scrit-gov epoch add")
	if err != nil {
		t.Fatal(err)
	}

	// extend key lists
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint1dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Extend("scrit-mint keylist extend"); err != nil {
		t.Fatal(err)
	}
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint2dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Extend("scrit-mint keylist extend"); err != nil {
		t.Fatal(err)
	}
	if err := os.Setenv("SCRIT-MINTHOMEDIR", mint3dir); err != nil {
		t.Fatal(err)
	}
	if err := scritKeyList.Extend("scrit-mint keylist extend"); err != nil {
		t.Fatal(err)
	}

	// test configuration
	if err := scritEngine.ValidateConf("scrit-engine validateconf"); err != nil {
		t.Fatal(err)
	}

	if err := scritDBCType.List("scrit-gov dbctype list"); err != nil {
		t.Fatal(err)
	}
}

- f 762d1f353d4ab06c8a06130ae8f44882fe142567365fea1655e038ef6d3d143f cmd/scrit-engine/scrit-engine.go
+ f 495a845a152740f9bb5d44686606d00aede3ef840d44ef6a4a3404d4c037a2cf cmd/scrit-engine/scrit-engine.go
dmppatch 18
@@ -75,101 +75,280 @@
 t (%0A
+%09%22flag%22%0A
 %09%22fmt%22%0A
+%09%22os%22%0A
 %0A
-%09%22github.com/frankbraun/codechain/secpkg%22%0A%09%22github.com/frankbraun/codechain/util%22%0A
+%09%22github.com/scritcash/scrit/engine/command%22%0A
 )%0A%0A
+func usage() %7B%0A%09cmd := os.Args%5B0%5D%0A%09fmt.Fprintf(os.Stderr, %22Usage: %25s reissue %5B-d federation_dir%5D DBC%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s validateconf %5B-d federation_dir%5D%5Cn%22, cmd)%0A%09os.Exit(2)%0A%7D%0A%0A
 func
@@ -361,106 +361,426 @@
 ) %7B%0A
-%09if err := secpkg.UpToDate(%22scrit%22); err != nil %7B%0A%09%09util.Fatal(err)%0A
+%09if len(os.Args) %3C 2 %7B%0A%09%09usage()%0A%09%7D%0A%09argv0 := os.Args%5B0%5D + %22 %22 + os.Args%5B1%5D%0A%09args := os.Args%5B2:%5D%0A%09var err error%0A%09switch os.Args%5B1%5D %7B%0A%09case %22reissue%22:%0A%09%09err = command.Reissue(argv0, args...)%0A%09case %22validateconf%22:%0A%09%09err = command.ValidateConf(argv0, args...)%0A%09default:%0A%09%09usage()%0A%09%7D%0A%09if err != nil %7B%0A%09%09if err != flag.ErrHelp %7B%0A%09%09%09fmt.Fprintf(os.Stderr, %22%25s: error: %25s%5Cn%22, os.Args%5B0%5D, err)%0A%09%09%09os.Exit(1)%0A%09%09%7D%0A%09%09os.Exit(2)%0A
 %09%7D%0A
-%09fmt.Println(%22scrit-engine%22)%0A
 %7D%0A
- f 2dea14c9f61973b50fc0a7cc0994f6d3faecdb2cbec49f55b3b0232fd53048bc cmd/scrit-gov/scrit-gov.go
+ f 0425e5335ce14badf5fd0c634e456d8b8d4763fe20df05737dee5931f729e789 cmd/scrit-gov/scrit-gov.go
dmppatch 28
@@ -1,56 +1,36 @@
-// scrit-gov is a government helper tool for Scrit.%0A
+/// scrit-mint is a Scrit mint.%0A
 pack
@@ -52,139 +52,376 @@
 t (%0A
+%09%22flag%22%0A
 %09%22fmt%22%0A
+%09%22os%22%0A
 %0A
-%09%22github.com/frankbraun/codechain/secpkg%22%0A%09%22github.com/frankbraun/codechain/util%22%0A%09%22github.com/scritcash/scrit/netconf%22%0A
+%09%22github.com/scritcash/scrit/gov/command%22%0A
 )%0A%0A
+func usage() %7B%0A%09cmd := os.Args%5B0%5D%0A%09fmt.Fprintf(os.Stderr, %22Usage: %25s start%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s dbctype%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s epoch%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s mint%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s status%5Cn%22, cmd)%0A%09os.Exit(2)%0A%7D%0A%0A
 func
@@ -434,261 +434,571 @@
 ) %7B%0A
-%09if err := secpkg.UpToDate(%22scrit%22); err != nil %7B%0A%09%09util.Fatal(err)%0A
+%09if len(os.Args) %3C 2 %7B%0A%09%09usage()%0A
 %09%7D%0A
-%09net, err := netconf.LoadNetwork(netconf.DefNetConfFile)%0A%09if err != nil %7B%0A%09%09util.Fatal(err)%0A
+%09argv0 := os.Args%5B0%5D + %22 %22 + os.Args%5B1%5D%0A%09args := os.Args%5B2:%5D%0A%09var err error%0A%09switch os.Args%5B1%5D %7B%0A%09case %22start%22:%0A%09%09err = command.Start(argv0, args...)%0A%09case %22dbctype%22:%0A%09%09err = command.DBCType(argv0, args...)%0A%09case %22epoch%22:%0A%09%09err = command.Epoch(argv0, args...)%0A%09case %22mint%22:%0A%09%09err = command.Mint(argv0, args...)%0A%09case %22status%22:%0A%09%09err = command.Status(argv0, args...)%0A%09default:%0A%09%09usage()%0A
 %09%7D%0A
-%09if err := net.Validate(); err != nil %7B%0A%09%09util.Fatal(err)%0A
+%09if err != nil %7B%0A%09%09if err != flag.ErrHelp %7B%0A%09%09%09fmt.Fprintf(os.Stderr, %22%25s: error: %25s%5Cn%22, os.Args%5B0%5D, err)%0A%09%09%09os.Exit(1)%0A%09%09%7D%0A%09%09os.Exit(2)%0A
 %09%7D%0A
-%09fmt.Println(net.Marshal())%0A
 %7D%0A
- f 18e7463f0457568df7aceca60b99bd892efccc90126165553ba0ef5e0e256724 cmd/scrit-mint/scrit-mint.go
+ f 67f7dc02e58bab5c74df56a2462d5e90b770b3bc279f5d6d288281906d6546a6 cmd/scrit-mint/scrit-mint.go
dmppatch 19
@@ -51,101 +51,411 @@
 t (%0A
+%09%22flag%22%0A
 %09%22fmt%22%0A
+%09%22os%22%0A
 %0A
-%09%22github.com/frankbraun/codechain/secpkg%22%0A%09%22github.com/frankbraun/codechain/util%22%0A
+%09%22github.com/scritcash/scrit/mint/command%22%0A
 )%0A%0A
+func usage() %7B%0A%09cmd := os.Args%5B0%5D%0A%09fmt.Fprintf(os.Stderr, %22Usage: %25s keygen %5B-s seckey.bin%5D%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s keyfile -s seckey.bin %5B-c%5D%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s identity %5B-s seckey.bin%5D%5Cn%22, cmd)%0A%09fmt.Fprintf(os.Stderr, %22       %25s keylist -desc name %5B-s seckey.bin%5D%5Cn%22, cmd)%0A%09os.Exit(2)%0A%7D%0A%0A
 func
@@ -468,104 +468,530 @@
 ) %7B%0A
-%09if err := secpkg.UpToDate(%22scrit%22); err != nil %7B%0A%09%09util.Fatal(err)%0A
+%09if len(os.Args) %3C 2 %7B%0A%09%09usage()%0A%09%7D%0A%09argv0 := os.Args%5B0%5D + %22 %22 + os.Args%5B1%5D%0A%09args := os.Args%5B2:%5D%0A%09var err error%0A%09switch os.Args%5B1%5D %7B%0A%09case %22keygen%22:%0A%09%09err = command.KeyGen(argv0, args...)%0A%09case %22keyfile%22:%0A%09%09err = command.KeyFile(argv0, args...)%0A%09case %22identity%22:%0A%09%09err = command.Identity(argv0, args...)%0A%09case %22keylist%22:%0A%09%09err = command.KeyList(argv0, args...)%0A%09default:%0A%09%09usage()%0A
 %09%7D%0A
-%09fmt.Println(%22scrit-mint%22)%0A
+%09if err != nil %7B%0A%09%09if err != flag.ErrHelp %7B%0A%09%09%09fmt.Fprintf(os.Stderr, %22%25s: error: %25s%5Cn%22, os.Args%5B0%5D, err)%0A%09%09%09os.Exit(1)%0A%09%09%7D%0A%09%09os.Exit(2)%0A%09%7D%0A
 %7D%0A
+ f 89f48b4a41a74b421f3c93b45114864876bb2fa67b3d989ca60ac6d1def4f41e doc/federation-setup.md
utf8file 79
Setting up a federation of Scrit mints
--------------------------------------

This walkthrough shows how one would set up a federation of 3 Scrit
mints.

First each of the three mints has to generate their mint identity key:

    $ scrit-mint keygen

Afterwards they all display their identity key and send it to the
federation coordinator (one of the mints should manage the
[Codechain](https://github.com/frankbraun/codechain) for the new Scrit
federation).

    $ scrit-mint identity

Typical output looks like this:

    ed25519-fZLPEvdKwhvxU_asrnqbR9t1PV0FukT71f1iwExX_ic

Let's say we have the following three mint identity keys:

    ed25519-vVqGX7eEyH5DNxO_UHm2k8iJAvf-NNv2g1UbZnTnu44
    ed25519-boVnUGMNKkI1Pe72m8Kf_9KljL4DBvsOGxbr1wi9flo
    ed25519-er0Phn1PjBzbz3gBUEbFQUIbexZxufELZyzCyfT4A5U

Now we can setup the federation (2-of-3):

    $ scrit-gov start -m 2 -n 3 ed25519-vVqGX7eEyH5DNxO_UHm2k8iJAvf-NNv2g1UbZnTnu44 ed25519-boVnUGMNKkI1Pe72m8Kf_9KljL4DBvsOGxbr1wi9flo ed25519-er0Phn1PjBzbz3gBUEbFQUIbexZxufELZyzCyfT4A5U

Define first DBC types (in denominations of 1, 2, and 5 EUR):

    $ scrit-gov dbctype add -currency EUR -amount 100000000
    $ scrit-gov dbctype add -currency EUR -amount 200000000
    $ scrit-gov dbctype add -currency EUR -amount 500000000

Now each of the three mints creates their key lists:

    $ scrit-mint keylist create -desc mint_name https://mint.example.com

Define the second signing epoch

    $ scrit-gov epoch add

Now each of the three mints extend their key lists (can be skipped if
`scrit-gov epoch add` is called _before_ `scrit-mint keylist create`):

    $ scrit-mint keylist extend

Now the configuration directory for the federation looks like this:

    $ tree
    .
    ├── federation.json
    └── mints
        ├── ed25519-boVnUGMNKkI1Pe72m8Kf_9KljL4DBvsOGxbr1wi9flo.json
        ├── ed25519-er0Phn1PjBzbz3gBUEbFQUIbexZxufELZyzCyfT4A5U.json
        └── ed25519-vVqGX7eEyH5DNxO_UHm2k8iJAvf-NNv2g1UbZnTnu44.json

With `federation.json` generally defining the network (including the
siginig epochs, DBC types, and mints) and a key list for each individual
mint in the `mints` subdirectory.

This directory structure would typically be checked into a Codechain
with the mint identity keys as signers and the same quorum for changes
(2-of-3 in this example).

This Scrit federation config directory is then distributed and
automatically updated via Codechain's `secpkg` tool to Scrit wallet
users.

To test a configuration a user would execute the following in the
configuration directory:

    $ scrit-engine validateconf

To be continued...

+ f ccd0af8734bba60341f1c6d63b80007b4e141f92c1f4433007404b7c95faf85f engine/command/command.go
utf8file 3
// Package command implements the scrit-engine commands.
package command

+ f 32bd24751b6ee5d83b14ecc3fc3ec3748cec2bd5dc1a3d8ac67d805bc296c892 engine/command/reissue.go
utf8file 48
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func reissue(fed *netconf.Federation, dbc string) error {
	// TODO
	return nil
}

// Reissue implements the scrit-engine 'reissue' command.
func Reissue(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-d federation_dir] DBC\n", argv0)
		fmt.Fprintf(os.Stderr, "Reissue DBC.\n")
		fs.PrintDefaults()
	}
	dir := fs.String("d", ".", "Set federation directory")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 1 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	fed, err := netconf.LoadFederation(*dir)
	if err != nil {
		return err
	}
	dbc := fs.Arg(0)
	return reissue(fed, dbc)
}

+ f a22b35653842621c3e47ca9bbe7ca5f8e6ebd4a771f51f467e96f839257dc752 engine/command/validateconf.go
utf8file 41
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

// ValidateConf implements the scrit-engine 'validateconf' command.
func ValidateConf(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-d federation_dir]\n", argv0)
		fmt.Fprintf(os.Stderr, "Validate federation configuration.\n")
		fs.PrintDefaults()
	}
	dir := fs.String("d", ".", "Set federation directory")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	if _, err := netconf.LoadFederation(*dir); err != nil {
		return err
	}
	return nil
}

- f 8f358015173d94b7ddb3fc6a59918e9b1c7835d419ec281fcb67b1394853c0a2 go.mod
+ f 502388445a7a2214bdd2cd3ded1b82e311b2f3f7fe22a93e3cdc0974651651ab go.mod
dmppatch 4
@@ -41,79 +41,267 @@
 13%0A%0A
-require github.com/frankbraun/codechain v0.0.0-20191218191456-6ac37deb05ba%0A
+require (%0A%09github.com/davecgh/go-spew v1.1.1%0A%09github.com/fatih/color v1.9.0 // indirect%0A%09github.com/frankbraun/codechain v1.0.1%0A%09golang.org/x/crypto v0.0.0-20200115085410-6d4e4cb37c7d // indirect%0A%09golang.org/x/sys v0.0.0-20200116001909-b77594299b42 // indirect%0A)%0A
- f ac11564e0a923931ff1ea4182d52601af0aaf6300114e7540c0fb25c74252259 go.sum
+ f 3542eb645129546cd7c201596490d0f97cd70557e8693840103c935b58833a9e go.sum
dmppatch 40
@@ -86,107 +86,107 @@
 MU=%0A
-github.com/cloudflare/cloudflare-go v0.10.8/go.mod h1:+LCrBrz3ssRmKHnlTwQOUmi3tMcNi0H5UqpMUgKkwcg=%0A
+github.com/cloudflare/cloudflare-go v0.11.0/go.mod h1:/FTeLWG9RAMaxNx2eAJ17d5n0XzlfMjFhU9sjMuKcWo=%0A
 gith
@@ -731,245 +731,352 @@
 j4=%0A
-github.com/frankbraun/codechain v0.0.0-20191218191456-6ac37deb05ba h1:AK2cniO4o1knyGqnxCSoJTTKvdVQjkI+hS7g0rMkE28=%0Agithub.com/frankbraun/codechain v0.0.0-20191218191456-6ac37deb05ba/go.mod h1:YdqxqnsDP+JkdcE05I/hcUOxDnXjIP331/2KoYSVZdE=%0A
+github.com/fatih/color v1.9.0 h1:8xPHl4/q1VyqGIPif1F+1V3Y3lSmrq01EabUW3CoW5s=%0Agithub.com/fatih/color v1.9.0/go.mod h1:eQcE1qtQxscV5RaZvpXrrb8Drkc3/DdQ+uUYCNjL+zU=%0Agithub.com/frankbraun/codechain v1.0.1 h1:JNEcYrsk215JfNek7zFymeUJg8aWf//kUeovpgJdde4=%0Agithub.com/frankbraun/codechain v1.0.1/go.mod h1:9LOUqksyPAAhD3+syi8uYF8ywnFDWBIFxTsmfk+WLXo=%0A
 gith
@@ -1691,100 +1691,100 @@
 WE=%0A
-github.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=%0A
+github.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=%0A
 gith
@@ -2006,200 +2006,104 @@
 q8=%0A
-github.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=%0Agithub.com/olekukonko/tablewriter v0.0.2/go.mod h1:rSAaSIOAGT9odnlyGlUfAJaoc5w2fSBUmeGDbRWPxyQ=%0A
+github.com/olekukonko/tablewriter v0.0.4/go.mod h1:zq6QwlOf5SlnkVbMSr5EoBv3636FWnp+qbPhuoO21uA=%0A
 gith
@@ -2824,93 +2824,93 @@
 m4=%0A
-github.com/urfave/cli v1.22.1/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=%0A
+github.com/urfave/cli v1.22.2/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=%0A
 gola
@@ -3019,221 +3019,434 @@
 +w=%0A
-golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413 h1:ULYEB3JvPRE/IfO+9uO7vKV/xzVTO7XPAwm8xbf4w2g=%0Agolang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=%0A
+golang.org/x/crypto v0.0.0-20191227163750-53104e6ec876 h1:sKJQZMuxjOAR/Uo2LBfU90onWEf1dF4C+0hPJCc9Mpc=%0Agolang.org/x/crypto v0.0.0-20191227163750-53104e6ec876/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=%0Agolang.org/x/crypto v0.0.0-20200115085410-6d4e4cb37c7d h1:2+ZP7EfsZV7Vvmx3TIqSlSzATMkTAKqM14YGFPoSKjI=%0Agolang.org/x/crypto v0.0.0-20200115085410-6d4e4cb37c7d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=%0A
 gola
@@ -3552,115 +3552,115 @@
 lg=%0A
-golang.org/x/net v0.0.0-20191109021931-daa7c04131f5/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=%0A
+golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=%0A
 gola
@@ -4087,215 +4087,422 @@
 Es=%0A
-golang.org/x/sys v0.0.0-20191218084908-4a24b4065292 h1:Y8q0zsdcgAd+JU8VUA8p8Qv2YhuY9zevDG2ORt5qBUI=%0Agolang.org/x/sys v0.0.0-20191218084908-4a24b4065292/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0A
+golang.org/x/sys v0.0.0-20191224085550-c709ea063b76 h1:Dho5nD6R3PcW2SH1or8vS0dszDaXRxIw55lBX7XiE5g=%0Agolang.org/x/sys v0.0.0-20191224085550-c709ea063b76/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0Agolang.org/x/sys v0.0.0-20200116001909-b77594299b42 h1:vEOn+mP2zCOVzKckCZy6YsCtDblrpj/w7B9nxGNELpg=%0Agolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=%0A
 gola
+ f 4114c4547ed3cdc1b97683c431f212cf31c061b7f503fe661ea6ed60fef0bb8b gov/command/command.go
utf8file 3
// Package command implements the scrit-gov commands.
package command

+ f d3f45ee6208dff907f89704efff82f18b85a5026f98bdd5d42c4f15dd9aa0779 gov/command/dbctype.go
utf8file 36
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/scritcash/scrit/gov/dbctype/command"
)

func usageDBCType(cmd string) error {
	fmt.Fprintf(os.Stderr, "Usage: %s add\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s remove\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s list\n", cmd)
	return flag.ErrHelp
}

// DBCType implements the scrit-gov 'dbctype' command.
func DBCType(argv0 string, args ...string) error {
	if len(args) < 1 {
		return usageDBCType(argv0)
	}
	newArgv0 := argv0 + " " + args[0]
	newArgs := args[1:]
	switch args[0] {
	case "add":
		return command.Add(newArgv0, newArgs...)
	case "remove":
		return command.Remove(newArgv0, newArgs...)
	case "list":
		return command.List(newArgv0, newArgs...)
	default:
		return usageDBCType(argv0)
	}
}

+ f d8ab88d725c1babfc8fe1a24ad73e1e199e89c7e7ac7dee24e8f54986611b46b gov/command/epoch.go
utf8file 33
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/scritcash/scrit/gov/epoch/command"
)

func usageEpoch(cmd string) error {
	fmt.Fprintf(os.Stderr, "Usage: %s add\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s setquorum\n", cmd)
	return flag.ErrHelp
}

// Epoch implements the scrit-gov 'epoch' command.
func Epoch(argv0 string, args ...string) error {
	if len(args) < 1 {
		return usageEpoch(argv0)
	}
	newArgv0 := argv0 + " " + args[0]
	newArgs := args[1:]
	switch args[0] {
	case "add":
		return command.Add(newArgv0, newArgs...)
	case "setquorum":
		return command.SetQuorum(newArgv0, newArgs...)
	default:
		return usageEpoch(argv0)
	}
}

+ f 583578b1ca8fa69ee2950ede3c4ee227617bb715e4110c7f98d80a24db6b2963 gov/command/mint.go
utf8file 39
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/scritcash/scrit/gov/mint/command"
)

func usageMint(cmd string) error {
	fmt.Fprintf(os.Stderr, "Usage: %s add\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s remove\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s replace\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s list\n", cmd)
	return flag.ErrHelp
}

// Mint implements the scrit-gov 'mint' command.
func Mint(argv0 string, args ...string) error {
	if len(args) < 1 {
		return usageMint(argv0)
	}
	newArgv0 := argv0 + " " + args[0]
	newArgs := args[1:]
	switch args[0] {
	case "add":
		return command.Add(newArgv0, newArgs...)
	case "remove":
		return command.Remove(newArgv0, newArgs...)
	case "replace":
		return command.Replace(newArgv0, newArgs...)
	case "list":
		return command.List(newArgv0, newArgs...)
	default:
		return usageMint(argv0)
	}
}

+ f a8b8dd8be8ca5e6c322b825f684182a627a9d6e9173cf3d8e5f68163012f10e5 gov/command/start.go
utf8file 80
package command

import (
	"flag"
	"fmt"
	"os"
	"time"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
	"github.com/scritcash/scrit/util/def"
)

func start(
	filename string,
	m, n uint64,
	signStart, signEnd, validationEnd time.Time,
	mintIdentities []netconf.IdentityKey,
) error {
	exists, err := file.Exists(filename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("file '%s' exists already", filename)
	}
	net := netconf.NewNetwork(m, n, signStart, signEnd, validationEnd,
		mintIdentities)
	if err := net.Validate(); err != nil {
		return err
	}
	return net.Save(filename)
}

// Start implements the scrit-gov 'start' command.
func Start(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s mint_identity [...]\n", argv0)
		fmt.Fprintf(os.Stderr, "Start new Scrit %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	m := fs.Uint64("m", 2, "The quorum m")
	n := fs.Uint64("n", 3, "Number of mints n")
	startSign := fs.String("start-sign", netconf.DefStartTime().Format(time.RFC3339),
		"Start of signing epoch")
	signingPeriod := fs.Duration("signing-period", def.SigningPeriod, "Length of signing period")
	validationPeriod := fs.Duration("validation-period", def.ValidationPeriod, "Length of validation period")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() == 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	t, err := time.Parse(time.RFC3339, *startSign)
	if err != nil {
		return err
	}
	var keys []netconf.IdentityKey
	for _, arg := range fs.Args() {
		key, err := netconf.ParseIdentityKey(arg)
		if err != nil {
			return err
		}
		keys = append(keys, *key)
	}
	return start(netconf.DefNetConfFile, *m, *n, t, t.Add(*signingPeriod),
		t.Add(*signingPeriod).Add(*validationPeriod), keys)
}

+ f dc8baa17440932b4ba3198a2e4fede9e1a755756846e48a5f27d889206f4587d gov/command/status.go
utf8file 45
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

// Status implements the scrit-gov 'status' command.
func Status(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Print status of %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	if err := net.Validate(); err != nil {
		return err
	}
	fmt.Println(net.Marshal())
	return nil
}

+ f 4e79f2920ee779013e2c6f163f5acb6136788cbd53c85b2eabf0c1a2e4f656b1 gov/dbctype/command/add.go
utf8file 87
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func add(net *netconf.Network, currency string, amount uint64) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	// make sure DBCType has not been defined yet
	dbcTypes := net.DBCTypes()
	dbcType := netconf.DBCType{
		Currency: currency,
		Amount:   amount,
	}
	if dbcTypes[dbcType] {
		return fmt.Errorf("DBC type already defined: %v", dbcType)
	}
	// add DBCType
	net.DBCTypeAdd(dbcType)
	return nil
}

// Add implements the scrit-gov 'dbctype add' command.
func Add(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Add new DBC type to future epoch of %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	currency := fs.String("currency", "", "Currency of DBC type to add")
	amount := fs.Uint64("amount", 0, "Amount of DBC type to add")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *currency == "" {
		fmt.Fprintf(os.Stderr, "%s: option -currency is mandatory\n", argv0)
		return flag.ErrHelp
	}
	if *amount == 0 {
		fmt.Fprintf(os.Stderr, "%s: option -amount is mandatory\n", argv0)
		return flag.ErrHelp
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := add(net, *currency, *amount); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 8444be6bbfb8ef167ba7d9085ba28b8220919b8ab9f51a3b3c2fa0cbcd949867 gov/dbctype/command/command.go
utf8file 3
// Package command implements the scrit-gov dbctype commands.
package command

+ f a34d614d84ad7adb53573f00f574fde1e0925d259e55c602dfe3df434b6e4978 gov/dbctype/command/list.go
utf8file 59
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func list(net *netconf.Network) error {
	dbcTypes := netconf.DBCTypeMapToSortedArray(net.DBCTypes())
	for _, t := range dbcTypes {
		fmt.Printf("%s\t%d\n", t.Currency, t.Amount)
	}
	return nil
}

// List implements the scrit-gov 'dbctype list' command.
func List(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "List all DBC types that will be active in the last epoch of %s.\n",
			netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// list
	if err := list(net); err != nil {
		return err
	}
	return nil
}

+ f e1ddb67d9fdc021302a6af2cf3f5e4f782182e91b3c1bed8cfbb2c5d2907c752 gov/dbctype/command/remove.go
utf8file 87
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func remove(net *netconf.Network, currency string, amount uint64) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	// make sure DBCType has been defined
	dbcTypes := net.DBCTypes()
	dbcType := netconf.DBCType{
		Currency: currency,
		Amount:   amount,
	}
	if !dbcTypes[dbcType] {
		return fmt.Errorf("DBC type undefined: %v", dbcType)
	}
	// remove DBCType
	net.DBCTypeRemove(dbcType)
	return nil
}

// Remove implements the scrit-gov 'dbctype remove' command.
func Remove(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Remove existing DBC type in future epoch of %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	currency := fs.String("currency", "", "Currency of DBC type to remove")
	amount := fs.Uint64("amount", 0, "Amount of DBC type to remove")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *currency == "" {
		fmt.Fprintf(os.Stderr, "%s: option -currency is mandatory\n", argv0)
		return flag.ErrHelp
	}
	if *amount == 0 {
		fmt.Fprintf(os.Stderr, "%s: option -amount is mandatory\n", argv0)
		return flag.ErrHelp
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := remove(net, *currency, *amount); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 718e8a45efa21aeaa53f6ea1247f6ab40339a2f97eceac75e3757804a9a9de9d gov/epoch/command/add.go
utf8file 69
package command

import (
	"flag"
	"fmt"
	"os"
	"time"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
	"github.com/scritcash/scrit/util/def"
)

func add(net *netconf.Network, siginingPeriod, validationPeriod time.Duration) error {
	// TODO: check if signingPeriod and/or validationPeriod changes from the
	// period used in the last epoch.
	net.EpochAdd(siginingPeriod, validationPeriod)
	return nil
}

// Add implements the scrit-gov 'epoch add' command.
func Add(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Add new epoch to %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	signingPeriod := fs.Duration("signing-period", def.SigningPeriod, "Length of signing period")
	validationPeriod := fs.Duration("validation-period", def.ValidationPeriod, "Length of validation period")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := add(net, *signingPeriod, *validationPeriod); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f ef133e8e9a8523cb61fab179c9c7a3bf0a4f1221e7949240a7937ee1908800f0 gov/epoch/command/command.go
utf8file 3
// Package command implements the scrit-gov epoch commands.
package command

+ f 5d90248949e5a4bdab8d2de56e1b9dccd90089edb96bd9ed0952a29f35b380f3 gov/epoch/command/setquorum.go
utf8file 72
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func setQuorum(net *netconf.Network, m uint64) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	net.SetQuorum(m)
	return nil
}

// SetQuorum implements the scrit-gov 'epoch setquorum' command.
func SetQuorum(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Set quorum for future epoch of %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	m := fs.Uint64("m", 0, "The quorum m")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *m == 0 {
		fmt.Fprintf(os.Stderr, "%s: option -m is mandatory\n", argv0)
		return flag.ErrHelp
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := setQuorum(net, *m); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 2bc7312c3c7dfea3f6c3181ee1cb497c7c0af352184a1ca14217f523ec49155f gov/mint/command/add.go
utf8file 78
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func add(net *netconf.Network, key *netconf.IdentityKey) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	// make sure mint has not been added yet
	mints := net.Mints()
	if mints[key.MarshalID()] {
		return fmt.Errorf("mint already added: %v", key.MarshalID())
	}
	// add mint identity key
	net.MintAdd(key)
	return nil
}

// Add implements the scrit-gov 'mint add' command.
func Add(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s mint_identity\n", argv0)
		fmt.Fprintf(os.Stderr, "Add new mint_identity to %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 1 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// parse key
	key, err := netconf.ParseIdentityKey(fs.Arg(0))
	if err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := add(net, key); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 42e12aafad0ddc723416eacefa709a2c0fc63304f04c253d5e6b66bd2224d691 gov/mint/command/command.go
utf8file 3
// Package command implements the scrit-gov mint commands.
package command

+ f 267c7775d9a2937ee703a94f5fc44427331d04aeff5a1cc44453608947025b9f gov/mint/command/list.go
utf8file 64
package command

import (
	"flag"
	"fmt"
	"os"
	"sort"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func list(net *netconf.Network) error {
	var mints []string
	for m := range net.Mints() {
		mints = append(mints, m)
	}
	sort.Strings(mints)
	for _, m := range mints {
		fmt.Println(m)
	}
	return nil
}

// List implements the scrit-gov 'mint list' command.
func List(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "List all mints that will be active in the last epoch of %s.\n",
			netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// list
	if err := list(net); err != nil {
		return err
	}
	return nil
}

+ f 767ae518162befe090eff0c95493fd6f0aed25f2883c5c6e3f39bcbf2dd9dba1 gov/mint/command/remove.go
utf8file 78
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func remove(net *netconf.Network, key *netconf.IdentityKey) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	// make sure mint has been added before
	mints := net.Mints()
	if !mints[key.MarshalID()] {
		return fmt.Errorf("mint not added before: %v", key.MarshalID())
	}
	// remove mint identity key
	net.MintRemove(key)
	return nil
}

// Remove implements the scrit-gov 'mint remove' command.
func Remove(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s mint_identity\n", argv0)
		fmt.Fprintf(os.Stderr, "Remove mint_identity from %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 1 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// parse key
	key, err := netconf.ParseIdentityKey(fs.Arg(0))
	if err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := remove(net, key); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 29dae0ace9cd098f8355e8223851ecade640ae11361cc05f103c5ba37f313870 gov/mint/command/replace.go
utf8file 91
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/scritcash/scrit/netconf"
)

func replace(net *netconf.Network, r *netconf.KeyReplacement) error {
	// make sure network has a future epoch
	if err := net.HasFuture(); err != nil {
		return err
	}
	// make sure mint has been added before
	mints := net.Mints()
	if mints[r.NewKey.MarshalID()] {
		return fmt.Errorf("mint to replace to already added: %v", r.NewKey.MarshalID())
	}
	if !mints[r.OldKey.MarshalID()] {
		return fmt.Errorf("mint to replace from not added before: %v", r.OldKey.MarshalID())
	}
	// remove mint identity key
	net.MintReplace(r)
	return nil
}

// Replace implements the scrit-gov 'mint replace' command.
func Replace(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s new_mint_id old_mint_id signature\n", argv0)
		fmt.Fprintf(os.Stderr, "Replace old_mint_id with new_mint_id in %s.\n", netconf.DefNetConfFile)
		fmt.Fprintf(os.Stderr, "The signature is by old_mint_id over new_mint_id.\n")
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 3 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	// parse keys
	newKey, err := netconf.ParseIdentityKey(fs.Arg(0))
	if err != nil {
		return err
	}
	oldKey, err := netconf.ParseIdentityKey(fs.Arg(1))
	if err != nil {
		return err
	}
	sig := fs.Arg(2)
	r := netconf.NewKeyReplacement(newKey, oldKey, sig)
	if err := r.Verify(); err != nil {
		return err
	}
	// load
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	// validate
	if err := net.Validate(); err != nil {
		return err
	}
	// edit
	if err := replace(net, r); err != nil {
		return err
	}
	// validate again
	if err := net.Validate(); err != nil {
		return err
	}
	// save
	if err := net.Save(netconf.DefNetConfFile); err != nil {
		return err
	}
	return nil
}

+ f 4336f849838c48d8012563f7499e4a1cf1c287fd40b1046fe508f9753a8fd50f mint/command/command.go
utf8file 3
// Package command implements the scrit-mint commands.
package command

+ f df54a0dd72e043952a4502b888dd64d5b2a891289001325ab6e9ba9bca487272 mint/command/identity.go
utf8file 56
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/scritcash/scrit/mint/identity"
	"github.com/scritcash/scrit/netconf"
	"github.com/scritcash/scrit/util/homedir"
)

func showIdentity(homeDir, secKey string) error {
	sec, _, comment, err := identity.Load(homeDir, secKey)
	if err != nil {
		return err
	}
	ik := netconf.NewIdentityKeyEd25519Priv(sec)
	fmt.Println(string(comment))
	fmt.Println(ik.MarshalID()) // this must be the last output line!
	return nil
}

// Identity implements the scrit-mint 'identity' command.
func Identity(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-s seckey.bin]\n", argv0)
		fmt.Fprintf(os.Stderr, "Print mint identity.\n")
		fs.PrintDefaults()
	}
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	homeDir := homedir.ScritMint()
	if err := seckey.Check(homeDir, *secKey); err != nil {
		return err
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	return showIdentity(homeDir, *secKey)
}

+ f f60d43e53e471a358738d9714930552c6bf696fdefa1485e26a13558cd3069b3 mint/command/keyfile.go
utf8file 12
package command

import (
	"github.com/frankbraun/codechain/command"
	"github.com/scritcash/scrit/util/homedir"
)

// KeyFile implements the scrit-mint 'keyfile' command.
func KeyFile(argv0 string, args ...string) error {
	return command.KeyFile("scrit", homedir.ScritMint(), argv0, args...)
}

+ f b2524f691260392556762a644cb7ec9e230cdd1e13624639c39007f33394ba4e mint/command/keygen.go
utf8file 12
package command

import (
	"github.com/frankbraun/codechain/command"
	"github.com/scritcash/scrit/util/homedir"
)

// KeyGen implements the scrit-mint 'keygen' command.
func KeyGen(argv0 string, args ...string) error {
	return command.KeyGen("scrit", homedir.ScritMint(), argv0, args...)
}

+ f a6af1bc1c7bf0a52fcb5b218a35ab23b37aabea077c4d8a3677b04fb314b3e56 mint/command/keylist.go
utf8file 33
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/scritcash/scrit/mint/keylist/command"
)

func usageKeyList(cmd string) error {
	fmt.Fprintf(os.Stderr, "Usage: %s create\n", cmd)
	fmt.Fprintf(os.Stderr, "       %s extend\n", cmd)
	return flag.ErrHelp
}

// KeyList implements the scrit-mint 'keylist' command.
func KeyList(argv0 string, args ...string) error {
	if len(args) < 1 {
		return usageKeyList(argv0)
	}
	newArgv0 := argv0 + " " + args[0]
	newArgs := args[1:]
	switch args[0] {
	case "create":
		return command.Create(newArgv0, newArgs...)
	case "extend":
		return command.Extend(newArgv0, newArgs...)
	default:
		return usageKeyList(argv0)
	}
}

+ f a006b4cbd92c24c328c13d9346b3baeb4036edc9a34bb69503fba4319f8e02fd mint/identity/identity.go
utf8file 32
// Package identity defines helper functions related to mint identity keys.
package identity

import (
	"fmt"
	"io/ioutil"
	"path/filepath"

	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/seckey"
)

// Load secret key from homeDir/def.SecretsSubdir.
// If secKey is empty a secret key from homeDir/def.SecretsSubdir is loaded
// only if it contains exactly one secret.
func Load(homeDir, secKey string) (*[64]byte, *[64]byte, []byte, error) {
	if secKey == "" {
		secretDir := filepath.Join(homeDir, def.SecretsSubDir)
		files, err := ioutil.ReadDir(secretDir)
		if err != nil {
			return nil, nil, nil, err
		}
		if len(files) > 1 {
			return nil, nil, nil,
				fmt.Errorf("directory '%s' contains more than one secret file, use option -s",
					secretDir)
		}
		secKey = filepath.Join(secretDir, files[0].Name())
	}
	return seckey.Read(secKey)
}

+ f 54584eb22a82b6fef42374a0dbcad9d6bffc8eed946cb971b09eb5051d4735ab mint/keylist/command/command.go
utf8file 3
// Package command implements the scrit-mint keylist commands.
package command

+ f ab34f3fa0ea58e6e6d7af934c89a36cb12bc7ba136719d08b429619884c5a312 mint/keylist/command/create.go
utf8file 114
package command

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/scritcash/scrit/mint/identity"
	"github.com/scritcash/scrit/netconf"
	"github.com/scritcash/scrit/util/homedir"
)

func create(
	net *netconf.Network,
	homeDir, secKey, desc string,
	urls []string,
) error {
	// load identity key
	sec, _, _, err := identity.Load(homeDir, secKey)
	if err != nil {
		return err
	}
	ik := netconf.NewIdentityKeyEd25519Priv(sec)

	// make sure the '~/.config/scrit-mint/privkeylists' directory exists
	if err := os.MkdirAll(filepath.Join(homeDir, netconf.DefPrivKeyListDir), 0755); err != nil {
		return err
	}
	// make sure the 'mints' directory exists
	if err := os.MkdirAll(netconf.DefMintDir, 0755); err != nil {
		return err
	}

	id := ik.MarshalID()
	privFilename := filepath.Join(homeDir, netconf.DefPrivKeyListDir, id+".json")
	confFilename := filepath.Join(netconf.DefMintDir, id+".json")

	// make sure these files do not exist already
	exists, err := file.Exists(privFilename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("file '%s' exists already", privFilename)
	}
	exists, err = file.Exists(confFilename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("file '%s' exists already", confFilename)
	}

	// create key list and configuration file
	mint, err := netconf.NewMint(desc, ik, urls, net)
	if err != nil {
		return err
	}
	// save private key list
	if err := mint.Save(privFilename, 0700); err != nil {
		return err
	}
	// prune private keys
	mint.PrunePrivKeys()
	// save public configuration file
	return mint.Save(confFilename, 0755)
}

// Create implements the scrit-mint 'keylist create' command.
func Create(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s url [...]\n", argv0)
		fmt.Fprintf(os.Stderr, "Create key list for %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	desc := fs.String("desc", "", "Description of mint (name)")
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *desc == "" {
		return fmt.Errorf("%s: option -desc is mandatory", argv0)
	}
	if fs.NArg() == 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	homeDir := homedir.ScritMint()
	if err := seckey.Check(homeDir, *secKey); err != nil {
		return err
	}
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	if err := net.Validate(); err != nil {
		return err
	}
	return create(net, homeDir, *secKey, *desc, fs.Args())
}

+ f cc9e6f22c606feddd83e9443db55e8ea33a3ba9a4222b7984b3816f4bbd3db8e mint/keylist/command/extend.go
utf8file 89
package command

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/scritcash/scrit/mint/identity"
	"github.com/scritcash/scrit/netconf"
	"github.com/scritcash/scrit/util/homedir"
)

func extend(net *netconf.Network, homeDir, secKey string) error {
	// load identity key
	sec, _, _, err := identity.Load(homeDir, secKey)
	if err != nil {
		return err
	}
	ik := netconf.NewIdentityKeyEd25519Priv(sec)

	id := ik.MarshalID()
	privFilename := filepath.Join(homeDir, netconf.DefPrivKeyListDir, id+".json")
	confFilename := filepath.Join(netconf.DefMintDir, id+".json")

	// make sure these files exist already and are valid
	mint, err := netconf.LoadMint(privFilename)
	if err != nil {
		return err
	}
	if _, err := netconf.LoadMint(confFilename); err != nil {
		return err
	}

	// extend key list
	if err := mint.Extend(ik, net); err != nil {
		return err
	}

	// save private key list
	if err := mint.Save(privFilename, 0700); err != nil {
		return err
	}
	// prune private keys
	mint.PrunePrivKeys()
	// save public configuration file
	return mint.Save(confFilename, 0755)
}

// Extend implements the scrit-mint 'keylist extend' command.
func Extend(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Extend key list for %s.\n", netconf.DefNetConfFile)
		fs.PrintDefaults()
	}
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("scrit"); err != nil {
		return err
	}
	homeDir := homedir.ScritMint()
	if err := seckey.Check(homeDir, *secKey); err != nil {
		return err
	}
	net, err := netconf.LoadNetwork(netconf.DefNetConfFile)
	if err != nil {
		return err
	}
	if err := net.Validate(); err != nil {
		return err
	}
	return extend(net, homeDir, *secKey)
}

+ f 321002a6de11ec8692a4da0f5d2a37a796cf80e6ae5527325b2d23479c90491b mintcom/doc.go
utf8file 4
// Package mintcom implements the inter-mint communication protocol for Scrit
// mints.
package mintcom

+ f d0115e1896480ee12156c707e1e77c03b47d6a08022991e0f9e07e420b1c47b1 netconf/dbc_type.go
utf8file 30
package netconf

import (
	"sort"
)

// DBCType defines a DBC type.
type DBCType struct {
	Currency string // the DBC currency
	Amount   uint64 // the amount per DBC, last 8 digits are decimal places
}

// DBCTypeMapToSortedArray takes a map of DBCTypes and converts it to a sorted
// array.
func DBCTypeMapToSortedArray(m map[DBCType]bool) []DBCType {
	var dbcTypes []DBCType
	for t := range m {
		dbcTypes = append(dbcTypes, t)
	}
	sort.Slice(dbcTypes, func(i, j int) bool {
		if dbcTypes[i].Currency < dbcTypes[j].Currency ||
			(dbcTypes[i].Currency == dbcTypes[j].Currency &&
				dbcTypes[i].Amount < dbcTypes[j].Amount) {
			return true
		}
		return false
	})
	return dbcTypes
}

- f 9722f931868505df6e43cb313b1a002b8ca8e6ec044b66966dbe636eef33729f netconf/errors.go
+ f 22bbee8d202cf3ae2db08d4678dda17706b4ab3621a5e15d66fbc43b08800eb6 netconf/errors.go
dmppatch 8
@@ -946,122 +946,120 @@
 nd.%0A
-var ErrSignEpochEndNotBeforeValidateEnd = errors.New(%22netconf: signing epoch end is not before end validate end%22)%0A
+var ErrSignEpochEndNotBeforeValidateEnd = errors.New(%22netconf: signing epoch end is not before validation end%22)%0A
 %0A// 
@@ -1496,8 +1496,690 @@
 epoch%22)%0A
+%0A// ErrNoFuture is returned when a network has no epoch which starts in the future.%0Avar ErrNoFuture = errors.New(%22netconf: network has no epoch which starts in the future%22)%0A%0A// ErrMintsOverlap is returned if the sets MintsAdded, MintsRemoved, and MintsReplaced overlap.%0Avar ErrMintsOverlap = errors.New(%22netconf: the MintsAdded, MintsRemoved, and MintsReplaced sets overlap%22)%0A%0A// ErrDBCTypesOverlap is returned if the sets DBCTypesAdded and DBCTypesRemoved overlap.%0Avar ErrDBCTypesOverlap = errors.New(%22netconf: the DBCTypesAdded and DBCTypesRemoved sets overlap%22)%0A%0A// ErrNoURL is returned if a mint has no defined URL.%0Avar ErrNoURL = errors.New(%22netconf: mint has no defined URL%22)%0A
+ f 4176ce3303f2912b4b108fc9adaa8854c7088c0eabb806f86fcfbfb738db50c6 netconf/federation.go
utf8file 88
package netconf

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
)

// A Federation of Scrit mints.
type Federation struct {
	Network *Network         // the federation network
	Mints   map[string]*Mint // all mints in the network
}

func (f *Federation) validate() error {
	// for every mint we make sure the mint epochs match with the network epoch
	for _, m := range f.Mints {
		for i, e := range m.MintEpochs {
			if e.SignStart != f.Network.NetworkEpochs[i].SignStart {
				return errors.New("netconf: signing start mismatch")
			}
			if e.SignEnd != f.Network.NetworkEpochs[i].SignEnd {
				return errors.New("netconf: signing end mismatch")
			}
			if e.ValidateEnd != f.Network.NetworkEpochs[i].ValidateEnd {
				return errors.New("netconf: validation end mismatch")
			}
		}
	}

	// now we make sure that in the present we have enough mint epochs (quorum)
	i, err := f.Network.CurrentEpoch()
	if err != nil {
		return err
	}
	var q uint64
	for _, m := range f.Mints {
		if len(m.MintEpochs) > i {
			q++
		}
	}
	if q < f.Network.NetworkEpochs[i].QuorumM {
		return errors.New("netconf: not enough mints to reach quorum in present")
	}

	return nil
}

// LoadFederation loads a Scrit mint federation configuration from the given
// directory and validates it.
func LoadFederation(dir string) (*Federation, error) {
	var f Federation
	filename := filepath.Join(dir, DefNetConfFile)
	fmt.Printf("loading '%s'\n", filename)
	n, err := LoadNetwork(filename)
	if err != nil {
		return nil, err
	}
	fmt.Printf("validate '%s'\n", filename)
	if err := n.Validate(); err != nil {
		return nil, err
	}
	f.Network = n
	f.Mints = make(map[string]*Mint)

	// we try to load all mints ever known, but ignore errors.
	// f.validate() later checks that we have enough mints in the current signing
	// epoch available
	for mn := range n.AllMints() {
		filename := filepath.Join(dir, DefMintDir, mn+".json")
		m, err := LoadMint(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "WARNING loading '%s' failed: %s\n", filename, err)
			continue
		}
		if err := m.Validate(n); err != nil {
			fmt.Fprintf(os.Stderr, "WARNING validating '%s' failed: %s\n", filename, err)
			continue
		}
		f.Mints[mn] = m
	}
	if err := f.validate(); err != nil {
		return nil, err
	}
	return &f, nil
}

+ f 1ab081a5de18e2888de5323f8c902e9ad43f8a65cb58582ae6fd761854df0de4 netconf/federation_test.go
utf8file 131
package netconf

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/scritcash/scrit/util/def"
)

func TestLoadFederation(t *testing.T) {
	_, err := LoadFederation("testdata")
	if err != nil {
		t.Fatal(err)
	}
}

func TestFederation(t *testing.T) {
	tmpdir, err := ioutil.TempDir("", "scrit_federation_test")
	if err != nil {
		t.Fatalf("ioutil.TempDir() failed: %v", err)
	}
	defer os.RemoveAll(tmpdir)

	ik1, err := NewIdentityKey()
	if err != nil {
		t.Fatal(err)
	}
	ik2, err := NewIdentityKey()
	if err != nil {
		t.Fatal(err)
	}
	ik3, err := NewIdentityKey()
	if err != nil {
		t.Fatal(err)
	}
	iks := []IdentityKey{*ik1, *ik2, *ik3}
	start := DefStartTime()
	net := NewNetwork(2, 3, start, start.Add(def.SigningPeriod),
		start.Add(def.SigningPeriod).Add(def.ValidationPeriod), iks)

	m1, err := NewMint("mint1", ik1, []string{"https:\\mint1.example.com"}, net)
	if err != nil {
		t.Fatal(err)
	}
	m2, err := NewMint("mint2", ik2, []string{"https:\\mint2.example.net"}, net)
	if err != nil {
		t.Fatal(err)
	}
	m3, err := NewMint("mint3", ik3, []string{"https:\\mint3.example.org"}, net)
	if err != nil {
		t.Fatal(err)
	}

	if err := net.Validate(); err != nil {
		t.Error(err)
	}
	if err := m1.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m2.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m3.Validate(net); err != nil {
		t.Error(err)
	}

	net.EpochAdd(def.SigningPeriod, def.ValidationPeriod)
	if err := m1.Extend(ik1, net); err != nil {
		t.Error(err)
	}
	if err := m2.Extend(ik2, net); err != nil {
		t.Error(err)
	}
	if err := m3.Extend(ik3, net); err != nil {
		t.Error(err)
	}

	if err := net.Validate(); err != nil {
		t.Error(err)
	}
	if err := m1.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m2.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m3.Validate(net); err != nil {
		t.Error(err)
	}

	m1.PrunePrivKeys()
	m2.PrunePrivKeys()
	m3.PrunePrivKeys()

	if err := m1.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m2.Validate(net); err != nil {
		t.Error(err)
	}
	if err := m3.Validate(net); err != nil {
		t.Error(err)
	}

	filename := filepath.Join(tmpdir, DefNetConfFile)
	if err := net.Save(filename); err != nil {
		t.Fatal(err)
	}
	if err := os.Mkdir(filepath.Join(tmpdir, DefMintDir), 0755); err != nil {
		t.Fatal(err)
	}
	filename = filepath.Join(tmpdir, DefMintDir, ik1.MarshalID()+".json")
	if err := m1.Save(filename, 0755); err != nil {
		t.Fatal(err)
	}
	filename = filepath.Join(tmpdir, DefMintDir, ik2.MarshalID()+".json")
	if err := m2.Save(filename, 0755); err != nil {
		t.Fatal(err)
	}
	filename = filepath.Join(tmpdir, DefMintDir, ik3.MarshalID()+".json")
	if err := m3.Save(filename, 0755); err != nil {
		t.Fatal(err)
	}
	_, err = LoadFederation(tmpdir)
	if err != nil {
		t.Fatal(err)
	}
}

+ f 7f2366e7a0938e031024b16d3b56bf552b1d3d49e466fd3aaeafa461c8382dc2 netconf/identity_key.go
utf8file 71
package netconf

import (
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
)

// IdentityKey defines a mint identity key.
type IdentityKey struct {
	SigAlgo string             // signature algorithm
	PubKey  []byte             // public key
	privKey ed25519.PrivateKey // private key
}

// NewIdentityKey generates a new identity key.
func NewIdentityKey() (*IdentityKey, error) {
	var ik IdentityKey
	ik.SigAlgo = "ed25519" // TODO
	pubKey, privKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}
	ik.PubKey = pubKey
	ik.privKey = privKey
	return &ik, err
}

// ParseIdentityKey parses a mint identity key (one liner).
func ParseIdentityKey(iks string) (*IdentityKey, error) {
	var ik IdentityKey
	parts := strings.SplitN(iks, "-", 2)
	ik.SigAlgo = parts[0]
	pk, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return nil, fmt.Errorf("netconf: cannot parse identity key '%s': %s",
			iks, err)
	}
	ik.PubKey = pk
	return &ik, nil
}

// NewIdentityKeyEd25519Priv create a new Ed25519 identity key from the given
// Ed25519 private key.
func NewIdentityKeyEd25519Priv(privKey *[64]byte) *IdentityKey {
	var ik IdentityKey
	ik.SigAlgo = "ed25519"
	ik.PubKey = make([]byte, 32)
	copy(ik.PubKey, privKey[32:])
	ik.privKey = make([]byte, 64)
	copy(ik.privKey, privKey[:])
	return &ik
}

// MarshalID marshals identity key as ID.
func (ik *IdentityKey) MarshalID() string {
	return ik.SigAlgo + "-" + base64.RawURLEncoding.EncodeToString(ik.PubKey)
}

// Marshal ik as JSON string.
func (ik *IdentityKey) Marshal() string {
	jsn, err := json.MarshalIndent(ik, "", "  ")
	if err != nil {
		panic(err) // should never happen
	}
	return string(jsn)
}

+ f d0df93591225291acef7d3e4cc83f151fcd3b8763d2d03a85582e9759e101393 netconf/identity_key_test.go
utf8file 43
package netconf

import (
	"encoding/hex"
	"testing"
)

const (
	publicKey             = "38ff60e128224b4eb708a49de1908d7d61b447a8228459b216ac49c209910295"
	privateKey            = "4b75408909900de74555aa57bb667ab36e18d242f4962b317a0fedc2083891c038ff60e128224b4eb708a49de1908d7d61b447a8228459b216ac49c209910295"
	marshalledIdentityKey = "ed25519-OP9g4SgiS063CKSd4ZCNfWG0R6gihFmyFqxJwgmRApU"
)

var identityKey IdentityKey

func init() {
	var err error
	identityKey.SigAlgo = "ed25519"
	identityKey.PubKey, err = hex.DecodeString(publicKey)
	if err != nil {
		panic(err)
	}
	identityKey.privKey, err = hex.DecodeString(privateKey)
	if err != nil {
		panic(err)
	}
}

func TestIdentityKeyMarshal(t *testing.T) {
	iks := identityKey.MarshalID()
	if iks != marshalledIdentityKey {
		t.Errorf("identityKey.MarshalID() == %s != %s", iks, marshalledIdentityKey)
	}
	ik, err := ParseIdentityKey(iks)
	if err != nil {
		t.Error(err)
	}
	iks2 := ik.MarshalID()
	if iks2 != iks {
		t.Errorf("ik.MarshalID() == %s != %s", iks2, iks)
	}
}

+ f eeac18232c7b75e713fee8d3cf0347086b95e31fc0f99150c16a7d9a179a0e6c netconf/key_replacement.go
utf8file 37
package netconf

import (
	"crypto/ed25519"
	"encoding/base64"
	"fmt"
)

// KeyReplacement defines a mint identity key replacement.
type KeyReplacement struct {
	NewKey    IdentityKey // the new identity key
	OldKey    IdentityKey // the replaced identity key
	Signature string      // of new key by replaced key
}

// NewKeyReplacement returns a new key replacement from oldKey to newKey.
// The signature is from oldKey over newKey.
func NewKeyReplacement(newKey, oldKey *IdentityKey, sig string) *KeyReplacement {
	return &KeyReplacement{
		NewKey:    *newKey,
		OldKey:    *oldKey,
		Signature: sig,
	}
}

// Verify the signature of the given key replacement
func (r *KeyReplacement) Verify() error {
	sig, err := base64.RawURLEncoding.DecodeString(r.Signature)
	if err != nil {
		return err
	}
	if !ed25519.Verify(r.OldKey.PubKey, []byte(r.NewKey.MarshalID()), sig) {
		return fmt.Errorf("netconf: signature '%s' does not verify", sig)
	}
	return nil
}

- f 92cf76c56332ae628def961625c8c88bcf4ed664dcaf4344184926fa7b5ccad2 netconf/mint.go
+ f 697459bf78351af34b4aae2119c35e85f9262f12140ad1de8cc07ba3003247cf netconf/mint.go
dmppatch 48
@@ -19,16 +19,49 @@
 mport (%0A
+%09%22crypto/ed25519%22%0A%09%22crypto/rand%22%0A
 %09%22encodi
@@ -69,16 +69,26 @@
 g/json%22%0A
+%09%22errors%22%0A
 %09%22io/iou
@@ -96,16 +96,22 @@
 il%22%0A
+%09%22os%22%0A
 %09%22time%22%0A
 )%0A%0A/
@@ -110,73 +110,190 @@
 me%22%0A
+%0A%09%22github.com/frankbraun/codechain/util/file%22%0A%09%22github.com/scritcash/scrit/binencode%22%0A
 )%0A%0A
-// Mint defines the key list of a single mint for all epochs.%0A
+// Mint defines the key list of a single mint for all epochs and where to%0A// reach the mint.%0A
 type
@@ -311,342 +311,315 @@
 t %7B%0A
-%09Description     string      // description of mint (name)%0A%09MintIdentityKey IdentityKey // identity key of mint%0A%09MintEpochs      %5B%5DMintEpoch // corresponding to global epochs%0A%09URLs            %5B%5Dstring    // how to reach the mint%0A
+%09Description     string       // description of mint (name)%0A%09MintIdentityKey IdentityKey  // identity key of mint%0A%09MintEpochs      %5B%5D*MintEpoch // corresponding to global epochs%0A%09URLs            %5B%5Dstring     // how to reach the mint%0A
 %7D%0A%0A
-// MintEpoch defines the key list of a single mint for a single epoch and%0A// where to reach the mint.%0A
+// MintEpoch defines the key list of a single mint for a single epoch.%0A
 type
@@ -642,653 +642,3191 @@
 t %7B%0A
-%09SignStart   time.Time    // start of signing epoch%0A%09SignEnd     time.Time    // end of signing epoch%0A%09ValidateEnd time.Time    // end of validation epoch%0A%09KeyList     %5B%5DSigningKey // the key list%0A
+%09SignStart         time.Time     // start of signing epoch%0A%09SignEnd           time.Time     // end of signing epoch%0A%09ValidateEnd       time.Time     // end of validation epoch%0A%09KeyList           %5B%5D*SigningKey // the key list%0A%09KeyListSignatures %5B%5D%5B%5Dbyte      // signatures of key list (identity signature last)%0A%7D%0A%0Afunc (m *Mint) generateKeys(ik *IdentityKey, n *Network, start int) error %7B%0A%09dbcTypes := make(map%5BDBCType%5Dbool)%0A%09for i, e := range n.NetworkEpochs %7B%0A%09%09for _, add := range e.DBCTypesAdded %7B%0A%09%09%09dbcTypes%5Badd%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.DBCTypesRemoved %7B%0A%09%09%09delete(dbcTypes, remove)%0A%09%09%7D%0A%09%09if i %3E= start %7B%0A%09%09%09dbcs := DBCTypeMapToSortedArray(dbcTypes)%0A%09%09%09for _, dbc := range dbcs %7B%0A%09%09%09%09pubKey, privKey, err := ed25519.GenerateKey(rand.Reader)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09sk := &SigningKey%7B%0A%09%09%09%09%09Currency: dbc.Currency,%0A%09%09%09%09%09Amount:   dbc.Amount,%0A%09%09%09%09%09SigAlgo:  %22ed25519%22, // TODO%0A%09%09%09%09%09PubKey:   pubKey,%0A%09%09%09%09%09PrivKey:  privKey,%0A%09%09%09%09%7D%0A%09%09%09%09m.MintEpochs%5Bi%5D.KeyList = append(m.MintEpochs%5Bi%5D.KeyList, sk)%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%09return m.sign(ik, start)%0A
 %7D%0A%0A
-// SigningKey defines an entry in the key list.%0Atype SigningKey struct %7B%0A%09Currency          string // the currency this key signs%0A%09Amount            uint64 // the amount this key signs%0A%09SigAlgo           string // signature algorithm%0A%09PubKey            %5B%5Dbyte // public key%0A%09SelfSignature     %5B%5Dbyte // self signature%0A%09IdentitySignature %5B%5Dbyte // signature by identity key%0A
+// NewMint creates a new Scrit mint.%0Afunc NewMint(%0A%09description string,%0A%09ik *IdentityKey,%0A%09urls %5B%5Dstring,%0A%09n *Network,%0A) (*Mint, error) %7B%0A%09var m Mint%0A%09m.Description = description%0A%09m.MintIdentityKey = *ik%0A%09for _, ne := range n.NetworkEpochs %7B%0A%09%09me := &MintEpoch%7B%0A%09%09%09SignStart:   ne.SignStart,%0A%09%09%09SignEnd:     ne.SignEnd,%0A%09%09%09ValidateEnd: ne.ValidateEnd,%0A%09%09%7D%0A%09%09m.MintEpochs = append(m.MintEpochs, me)%0A%09%7D%0A%09m.URLs = urls%0A%09if err := m.generateKeys(ik, n, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &m, nil%0A%7D%0A%0A// Extend the mint's key list for the given network.%0Afunc (m *Mint) Extend(ik *IdentityKey, n *Network) error %7B%0A%09start := 0%0A%09for i, ne := range n.NetworkEpochs %7B%0A%09%09if i %3C len(m.MintEpochs) %7B%0A%09%09%09me := m.MintEpochs%5Bi%5D%0A%09%09%09if me.SignStart != ne.SignStart %7B%0A%09%09%09%09return errors.New(%22netconf: epoch signature starts do not match%22)%0A%09%09%09%7D%0A%09%09%09if me.SignEnd != ne.SignEnd %7B%0A%09%09%09%09return errors.New(%22netconf: epoch signature ends do not match%22)%0A%09%09%09%7D%0A%09%09%09if me.ValidateEnd != ne.ValidateEnd %7B%0A%09%09%09%09return errors.New(%22netconf: epoch validation ends do not match%22)%0A%09%09%09%7D%0A%09%09%7D else %7B%0A%09%09%09if start == 0 %7B%0A%09%09%09%09start = i%0A%09%09%09%7D%0A%09%09%09me := &MintEpoch%7B%0A%09%09%09%09SignStart:   ne.SignStart,%0A%09%09%09%09SignEnd:     ne.SignEnd,%0A%09%09%09%09ValidateEnd: ne.ValidateEnd,%0A%09%09%09%7D%0A%09%09%09m.MintEpochs = append(m.MintEpochs, me)%0A%09%09%7D%0A%09%7D%0A%09return m.generateKeys(ik, n, start)%0A%7D%0A%0A// PrunePrivKeys prunes all private keys from the given mint configuration.%0Afunc (m *Mint) PrunePrivKeys() %7B%0A%09for _, e := range m.MintEpochs %7B%0A%09%09for _, k := range e.KeyList %7B%0A%09%09%09k.PrivKey = nil%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// Save mint with perm to given filename%0Afunc (m *Mint) Save(filename string, perm os.FileMode) error %7B%0A%09jsn, err := json.MarshalIndent(m, %22%22, %22  %22)%0A%09if err != nil %7B%0A%09%09panic(err) // should never happen%0A%09%7D%0A%09exists, err := file.Exists(filename)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if exists %7B%0A%09%09if err := os.Rename(filename, filename+%22.bac%22); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D%0A%09if err := ioutil.WriteFile(filename, jsn, perm); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if exists %7B%0A%09%09return os.Remove(filename + %22.bac%22)%0A%09%7D%0A%09return nil%0A%0A
 %7D%0A%0A
-// LoadMint loads  a mint configuration from filename and return the%0A
+// LoadMint loads a mint configuration from filename and return the%0A
 // M
@@ -4074,16 +4074,1725 @@
  err%0A%7D%0A%0A
+// sign all mint epochs in mint%0Afunc (m *Mint) sign(ik *IdentityKey, start int) error %7B%0A%09for i := start; i %3C len(m.MintEpochs); i++ %7B%0A%09%09e := m.MintEpochs%5Bi%5D%0A%09%09if err := e.sign(ik); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// encode mint epoch.%0Afunc (me *MintEpoch) encode(ik *IdentityKey) (%5B%5Dbyte, error) %7B%0A%09encodingScheme := %5B%5Dinterface%7B%7D%7B%0A%09%09%5B%5Dbyte(ik.SigAlgo),%0A%09%09ik.PubKey,%0A%09%09me.SignStart.UTC().Unix(),%0A%09%09me.SignEnd.UTC().Unix(),%0A%09%09me.ValidateEnd.UTC().Unix(),%0A%09%7D%0A%09for _, k := range me.KeyList %7B%0A%09%09encodingScheme = append(encodingScheme,%0A%09%09%09%5B%5Dbyte(k.Currency),%0A%09%09%09int64(k.Amount),%0A%09%09%09%5B%5Dbyte(k.SigAlgo),%0A%09%09%09k.PubKey,%0A%09%09)%0A%09%7D%0A%09size, err := binencode.EncodeSize(encodingScheme...)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09buf := make(%5B%5Dbyte, size)%0A%09return binencode.Encode(buf, encodingScheme...)%0A%7D%0A%0A// sign mint epoch.%0Afunc (me *MintEpoch) sign(ik *IdentityKey) error %7B%0A%09enc, err := me.encode(ik)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09for _, k := range me.KeyList %7B%0A%09%09sig := ed25519.Sign(k.PrivKey, enc)%0A%09%09me.KeyListSignatures = append(me.KeyListSignatures, sig)%0A%09%7D%0A%09sig := ed25519.Sign(ik.privKey, enc)%0A%09me.KeyListSignatures = append(me.KeyListSignatures, sig)%0A%09return nil%0A%7D%0A%0A// Verify mint epoch.%0Afunc (me *MintEpoch) Verify(ik *IdentityKey) error %7B%0A%09enc, err := me.encode(ik)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09// check %22normal%22 key signatures%0A%09for i, k := range me.KeyList %7B%0A%09%09if !ed25519.Verify(k.PubKey, enc, me.KeyListSignatures%5Bi%5D) %7B%0A%09%09%09return errors.New(%22netconf: key signature doesn't verify%22)%0A%09%09%7D%0A%09%7D%0A%09// check identity key signature%0A%09if !ed25519.Verify(ik.PubKey, enc, me.KeyListSignatures%5Blen(me.KeyList)%5D) %7B%0A%09%09return errors.New(%22netconf: identity key signature doesn't verify%22)%0A%09%7D%0A%09return nil%0A%7D%0A%0A
 // Valid
@@ -5823,54 +5823,1448 @@
 on.%0A
-func (mint *Mint) Validate() error %7B%0A%09// TODO%0A
+func (m *Mint) Validate(net *Network) error %7B%0A%09// validate mint epoch transitions%0A%09for i := 1; i %3C len(m.MintEpochs); i++ %7B%0A%09%09// sign end i-1 == sign start i%0A%09%09if m.MintEpochs%5Bi-1%5D.SignEnd != m.MintEpochs%5Bi%5D.SignStart %7B%0A%09%09%09return ErrSignEpochWrongBoundaries%0A%09%09%7D%0A%09%09// validation end i-1 %3C= sign end i%0A%09%09if m.MintEpochs%5Bi-1%5D.ValidateEnd.After(m.MintEpochs%5Bi%5D.SignEnd) %7B%0A%09%09%09return ErrValidationLongerThanNextSigning%0A%09%09%7D%0A%09%7D%0A%0A%09// make sure we have the right amount of signing keys%0A%09// TODO: this test enforces only one siging key for each DBC type (with%0A%09dbcTypes := make(map%5BDBCType%5Dbool)%0A%09for i := 0; i %3C len(m.MintEpochs); i++ %7B%0A%09%09e := net.NetworkEpochs%5Bi%5D%0A%09%09for _, add := range e.DBCTypesAdded %7B%0A%09%09%09dbcTypes%5Badd%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.DBCTypesRemoved %7B%0A%09%09%09delete(dbcTypes, remove)%0A%09%09%7D%0A%09%09dbcs := DBCTypeMapToSortedArray(dbcTypes)%0A%09%09if len(dbcs) != len(m.MintEpochs%5Bi%5D.KeyList) %7B%0A%09%09%09return errors.New(%22netconf: lenght of key list doesn't equal number of DBC types%22)%0A%09%09%7D%0A%09%09for j, dbc := range dbcs %7B%0A%09%09%09if dbc.Currency != m.MintEpochs%5Bi%5D.KeyList%5Bj%5D.Currency %7B%0A%09%09%09%09return errors.New(%22netconf: key currency does not match DBC type%22)%0A%09%09%09%7D%0A%09%09%09if dbc.Amount != m.MintEpochs%5Bi%5D.KeyList%5Bj%5D.Amount %7B%0A%09%09%09%09return errors.New(%22netconf: key amount does not match DBC type%22)%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09for _, e := range m.MintEpochs %7B%0A%09%09if err := e.Verify(&m.MintIdentityKey); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D%0A%09if len(m.URLs) == 0 %7B%0A%09%09return ErrNoURL%0A%09%7D%0A
 %09ret
- f e77585b52f2b21a86b926e59fd50d4d652fb01a7becaffee804f60370f8160b1 netconf/mint_test.go
- f 83759ac947ce81f725bcebcfd782bc932d072e85b781e26a7d12c3f5ad605c1d netconf/netconf.go
+ f 63f732dc7b3dfbe576bea56d2dfa3b4d75534729e2970702dbb40912291ae597 netconf/netconf.go
dmppatch 8
@@ -73,16 +73,36 @@
 etconf%0A%0A
+import (%0A%09%22time%22%0A)%0A%0A
 // DefNe
@@ -167,42 +167,858 @@
 me.%0A
-const DefNetConfFile = %22network.json%22%0A
+const DefNetConfFile = %22federation.json%22%0A%0A// DefMintDir defines the default sub-directory for mint configurations.%0Aconst DefMintDir = %22mints%22%0A%0A// DefDBCDir defines the default sub-directory for DBC creation and%0A// destruction lists.%0Aconst DefDBCDir = %22dbcs%22%0A%0A// DefPrivKeyListDir defines the default sub-directory for private mint key lists.%0Aconst DefPrivKeyListDir = %22privkeylists%22%0A%0A// DefDBCCreate defines the name of the list of DBCs to be created.%0Aconst DefDBCCreate = %22create.json%22%0A%0A// DefDBCDestroyed defines the name of the list of destroyed DBCs.%0Aconst DefDBCDestroyed = %22destroyed.json%22%0A%0A// DefStartTime defines the default signing start: tomorrow at midnight.%0Afunc DefStartTime() time.Time %7B%0A%09now := time.Now().UTC()%0A%09year, month, day := now.Date()%0A%09t := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)%0A%09t = t.Add(time.Hour * 48)%0A%09return t%0A%7D%0A
- f f08d18ea1d45c51bfc550d5e8e99edd015b8dc260cc46d0fb60e85c96fac1b40 netconf/network.go
+ f c0b4252a6950b584cb030e1143d2aba6c816178e29b3f9db0c8a300eda5e256f netconf/network.go
dmppatch 57
@@ -36,16 +36,33 @@
 g/json%22%0A
+%09%22errors%22%0A%09%22fmt%22%0A
 %09%22io/iou
@@ -66,16 +66,76 @@
 ioutil%22%0A
+%09%22os%22%0A%09%22time%22%0A%0A%09%22github.com/frankbraun/codechain/util/file%22%0A
 )%0A%0A// Ne
@@ -253,16 +253,483 @@
 ochs%0A%7D%0A%0A
+// NewNetwork creates a new network configuration and returns the Network%0A// struct.%0Afunc NewNetwork(%0A%09m, n uint64,%0A%09signStart, signEnd, validateEnd time.Time,%0A%09mintIdentities %5B%5DIdentityKey,%0A) *Network %7B%0A%09var network Network%0A%09network.NetworkEpochs = %5B%5DNetworkEpoch%7B%0A%09%09%7B%0A%09%09%09QuorumM:        m,%0A%09%09%09NumberOfMintsN: n,%0A%09%09%09SignStart:      signStart,%0A%09%09%09SignEnd:        signEnd,%0A%09%09%09ValidateEnd:    validateEnd,%0A%09%09%09MintsAdded:     mintIdentities,%0A%09%09%7D,%0A%09%7D%0A%09return &network%0A%7D%0A%0A
 // LoadN
@@ -949,77 +949,73 @@
 %0A%09%7D%0A
-%09var net Network%0A%09if err := json.Unmarshal(data, &net); err != nil %7B%0A
+%09var n Network%0A%09if err := json.Unmarshal(data, &n); err != nil %7B%0A
 %09%09re
@@ -1035,103 +1035,103 @@
 %0A%09%7D%0A
-%09return &net, err%0A
+%09return &n, err%0A
 %7D%0A%0A
-// Validate the net configuration.%0Afunc (net *Network) Validate() error %7B%0A
+// Validate the network configuration.%0Afunc (n *Network) Validate() error %7B%0A
 %09// 
@@ -1162,47 +1162,45 @@
 och%0A
-%09for _, e := range net.NetworkEpochs %7B%0A
+%09for _, e := range n.NetworkEpochs %7B%0A
 %09%09if
@@ -1298,55 +1298,53 @@
 ons%0A
-%09for i := 1; i %3C len(net.NetworkEpochs); i++ %7B%0A
+%09for i := 1; i %3C len(n.NetworkEpochs); i++ %7B%0A
 %09%09//
@@ -1377,80 +1377,76 @@
 t i%0A
-%09%09if net.NetworkEpochs%5Bi-1%5D.SignEnd != net.NetworkEpochs%5Bi%5D.SignStart %7B%0A
+%09%09if n.NetworkEpochs%5Bi-1%5D.SignEnd != n.NetworkEpochs%5Bi%5D.SignStart %7B%0A
 %09%09%09r
@@ -1525,86 +1525,82 @@
 d i%0A
-%09%09if net.NetworkEpochs%5Bi-1%5D.ValidateEnd.After(net.NetworkEpochs%5Bi%5D.SignEnd) %7B%0A
+%09%09if n.NetworkEpochs%5Bi-1%5D.ValidateEnd.After(n.NetworkEpochs%5Bi%5D.SignEnd) %7B%0A
 %09%09%09r
@@ -1648,16 +1648,181 @@
 %09%09%7D%0A%09%7D%0A%0A
+%09// validate Mints%0A%09if err := n.MintsValidate(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// validate DBC types%0A%09if err := n.DBCTypesValidate(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A
 %09return 
@@ -1832,120 +1832,120 @@
 %0A%7D%0A%0A
-// Marshal net as string.%0Afunc (net *Network) Marshal() string %7B%0A%09jsn, err := json.MarshalIndent(net, %22%22, %22  %22)%0A
+// Marshal network as string.%0Afunc (n *Network) Marshal() string %7B%0A%09jsn, err := json.MarshalIndent(n, %22%22, %22  %22)%0A
 %09if 
@@ -2018,8 +2018,7514 @@
 (jsn)%0A%7D%0A
+%0A// Save network to filename. If filename exists already it will be%0A// overwritten!%0Afunc (n *Network) Save(filename string) error %7B%0A%09jsn, err := json.MarshalIndent(n, %22%22, %22  %22)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09exists, err := file.Exists(filename)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if exists %7B%0A%09%09if err := os.Rename(filename, filename+%22.bac%22); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D%0A%09if err := ioutil.WriteFile(filename, jsn, 0755); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if exists %7B%0A%09%09return os.Remove(filename + %22.bac%22)%0A%09%7D%0A%09return nil%0A%7D%0A%0A// HasFuture ensures that the network has an epoch which starts in the future.%0Afunc (n *Network) HasFuture() error %7B%0A%09e := n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D%0A%09if !e.SignStart.After(time.Now().UTC()) %7B%0A%09%09return ErrNoFuture%0A%09%7D%0A%09return nil%0A%7D%0A%0A// Mints returns a map of all mints in the network in the future.%0Afunc (n *Network) Mints() map%5Bstring%5Dbool %7B%0A%09mints := make(map%5Bstring%5Dbool)%0A%09for _, e := range n.NetworkEpochs %7B%0A%09%09for _, add := range e.MintsAdded %7B%0A%09%09%09mints%5Badd.MarshalID()%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.MintsRemoved %7B%0A%09%09%09delete(mints, remove.MarshalID())%0A%09%09%7D%0A%09%09for _, replace := range e.MintsReplaced %7B%0A%09%09%09delete(mints, replace.OldKey.MarshalID())%0A%09%09%09mints%5Breplace.NewKey.MarshalID()%5D = true%0A%09%09%7D%0A%09%7D%0A%09return mints%0A%7D%0A%0A// AllMints returns a map of all mints that were ever or will ever be part of%0A// the network.%0Afunc (n *Network) AllMints() map%5Bstring%5Dbool %7B%0A%09mints := make(map%5Bstring%5Dbool)%0A%09for _, e := range n.NetworkEpochs %7B%0A%09%09for _, add := range e.MintsAdded %7B%0A%09%09%09mints%5Badd.MarshalID()%5D = true%0A%09%09%7D%0A%09%09for _, replace := range e.MintsReplaced %7B%0A%09%09%09mints%5Breplace.NewKey.MarshalID()%5D = true%0A%09%09%7D%0A%09%7D%0A%09return mints%0A%7D%0A%0A// CurrentMints returns a map of all mints in the network at the current time%0Afunc (n *Network) CurrentMints() (map%5Bstring%5Dbool, error) %7B%0A%09c, err := n.CurrentEpoch()%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09mints := make(map%5Bstring%5Dbool)%0A%09for i := 0; i %3C= c; i++ %7B%0A%09%09e := n.NetworkEpochs%5Bi%5D%0A%09%09for _, add := range e.MintsAdded %7B%0A%09%09%09mints%5Badd.MarshalID()%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.MintsRemoved %7B%0A%09%09%09delete(mints, remove.MarshalID())%0A%09%09%7D%0A%09%09for _, replace := range e.MintsReplaced %7B%0A%09%09%09delete(mints, replace.OldKey.MarshalID())%0A%09%09%09mints%5Breplace.NewKey.MarshalID()%5D = true%0A%09%09%7D%0A%09%7D%0A%09return mints, nil%0A%7D%0A%0A// MintsValidate validates the mint types.%0Afunc (n *Network) MintsValidate() error %7B%0A%09mints := make(map%5Bstring%5Dbool)%0A%09for _, e := range n.NetworkEpochs %7B%0A%09%09// make sure the MintsAdded, MintsRemoved, and MintsReplaced sets are%0A%09%09// disjunct%0A%09%09if err := e.MintsDisjunct(); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09for _, add := range e.MintsAdded %7B%0A%09%09%09// make sure we do not add an exisiting mint%0A%09%09%09id := add.MarshalID()%0A%09%09%09if mints%5Bid%5D %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: mint already added: %25v%22, id)%0A%09%09%09%7D%0A%09%09%09mints%5Bid%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.MintsRemoved %7B%0A%09%09%09id := remove.MarshalID()%0A%09%09%09// make sure the mint to delete is actually there%0A%09%09%09_, present := mints%5Bid%5D%0A%09%09%09if !present %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: mint to remove not added: %25v%22, id)%0A%09%09%09%7D%0A%09%09%09delete(mints, id)%0A%09%09%7D%0A%09%09for _, replace := range e.MintsReplaced %7B%0A%09%09%09if err := replace.Verify(); err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09%09oldID := replace.OldKey.MarshalID()%0A%09%09%09newID := replace.NewKey.MarshalID()%0A%09%09%09// make sure the mint to replace is actually there%0A%09%09%09_, present := mints%5BoldID%5D%0A%09%09%09if !present %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: mint to replace not added: %25v%22, oldID)%0A%09%09%09%7D%0A%09%09%09delete(mints, oldID)%0A%09%09%09// make sure we do not replace to an exisiting mint%0A%09%09%09if mints%5BnewID%5D %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: mint to replace to already added: %25v%22, newID)%0A%09%09%09%7D%0A%09%09%09mints%5BnewID%5D = true%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// MintAdd adds the mint identity key to the network.%0A// Low-level function without error checking!%0Afunc (n *Network) MintAdd(key *IdentityKey) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsAdded =%0A%09%09append(n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsAdded, *key)%0A%7D%0A%0A// MintRemove removes the mint identity key from the network.%0A// Low-level function without error checking!%0Afunc (n *Network) MintRemove(key *IdentityKey) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsRemoved =%0A%09%09append(n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsRemoved, *key)%0A%7D%0A%0A// MintReplace replaces the old mint identity key with the new mint identity%0A// in the network.%0A// Low-level function without error checking!%0Afunc (n *Network) MintReplace(r *KeyReplacement) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsReplaced =%0A%09%09append(n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.MintsReplaced, *r)%0A%7D%0A%0A// DBCTypes returns a map of all DBCTypes in the network.%0Afunc (n *Network) DBCTypes() map%5BDBCType%5Dbool %7B%0A%09dbcTypes := make(map%5BDBCType%5Dbool)%0A%09for _, e := range n.NetworkEpochs %7B%0A%09%09for _, add := range e.DBCTypesAdded %7B%0A%09%09%09dbcTypes%5Badd%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.DBCTypesRemoved %7B%0A%09%09%09delete(dbcTypes, remove)%0A%09%09%7D%0A%09%7D%0A%09return dbcTypes%0A%7D%0A%0A// DBCTypesValidate validates the DBC types.%0Afunc (n *Network) DBCTypesValidate() error %7B%0A%09dbcTypes := make(map%5BDBCType%5Dbool)%0A%09for _, e := range n.NetworkEpochs %7B%0A%09%09// make sure the DBCTypesAdded and DBCTypesRemoved sets are disjunct%0A%09%09if err := e.DBCTypesDisjunct(); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09for _, add := range e.DBCTypesAdded %7B%0A%09%09%09// make sure we do not add an exisiting DBC type%0A%09%09%09if dbcTypes%5Badd%5D %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: DBC type already defined: %25v%22, add)%0A%09%09%09%7D%0A%09%09%09dbcTypes%5Badd%5D = true%0A%09%09%7D%0A%09%09for _, remove := range e.DBCTypesRemoved %7B%0A%09%09%09// make sure the type to delete is actually there%0A%09%09%09_, present := dbcTypes%5Bremove%5D%0A%09%09%09if !present %7B%0A%09%09%09%09return fmt.Errorf(%22netconf: DBC type not defined: %25v%22, remove)%0A%09%09%09%7D%0A%09%09%09delete(dbcTypes, remove)%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// DBCTypeAdd adds the DBC type to the network.%0A// Low-level function without error checking!%0Afunc (n *Network) DBCTypeAdd(dt DBCType) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.DBCTypesAdded =%0A%09%09append(n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.DBCTypesAdded, dt)%0A%7D%0A%0A// DBCTypeRemove removes the DBC type from the network.%0A// Low-level function without error checking!%0Afunc (n *Network) DBCTypeRemove(dt DBCType) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.DBCTypesRemoved =%0A%09%09append(n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.DBCTypesRemoved, dt)%0A%7D%0A%0A// EpochAdd adds another epoch with the given signing and validation period to%0A// the network.%0A// Low-level function without error checking!%0Afunc (n *Network) EpochAdd(signingPeriod, validationPeriod time.Duration) %7B%0A%09lastEpoch := n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D%0A%09var newEpoch NetworkEpoch%0A%09newEpoch.QuorumM = lastEpoch.QuorumM%0A%09newEpoch.NumberOfMintsN = lastEpoch.NumberOfMintsN%0A%09newEpoch.SignStart = lastEpoch.SignEnd%0A%09newEpoch.SignEnd = newEpoch.SignStart.Add(signingPeriod)%0A%09newEpoch.ValidateEnd = newEpoch.SignEnd.Add(validationPeriod)%0A%09n.NetworkEpochs = append(n.NetworkEpochs, newEpoch)%0A%7D%0A%0A// SetQuorum sets the quorum for the last epoch.%0A// Low-level function without error checking!%0Afunc (n *Network) SetQuorum(m uint64) %7B%0A%09n.NetworkEpochs%5Blen(n.NetworkEpochs)-1%5D.QuorumM = m%0A%7D%0A%0A// CurrentEpoch returns the current signing epoch number or an error if no%0A// such epoch exists.%0Afunc (n *Network) CurrentEpoch() (int, error) %7B%0A%09// make sure we still have a valid signing epoch%0A%09i := len(n.NetworkEpochs) - 1%0A%09now := time.Now().UTC()%0A%09if now.After(n.NetworkEpochs%5Bi%5D.SignEnd) %7B%0A%09%09return 0, errors.New(%22netconf: no valid signing epoch found%22)%0A%09%7D%0A%09// determine current epoch%0A%09for ; i %3E= 0; i-- %7B%0A%09%09if now.After(n.NetworkEpochs%5Bi%5D.SignStart) %7B%0A%09%09%09break%0A%09%09%7D%0A%09%7D%0A%09if i %3C 0 %7B%0A%09%09i = 0%0A%09%7D%0A%09return i, nil%0A%7D%0A
- f 7bd583cff2ab2b51b74f362c3b175fd960914de0cb70ff618a4cb188c4d51f46 netconf/network_epoch.go
+ f 5d3af73227a7728bfa37156622c789e7461853189e2f63315a58f8758c523968 netconf/network_epoch.go
dmppatch 43
@@ -166,1605 +166,724 @@
 t %7B%0A
-%09M                       uint64           // the quorum%0A%09N                       uint64           // total number of mints%0A%09SignStart               time.Time        // start of signing epoch%0A%09SignEnd                 time.Time        // end of signing epoch%0A%09ValidateEnd             time.Time        // end of validation epoch%0A%09MintsAdded              %5B%5DIdentityKey    // mints added in this epoch%0A%09MintsRemoved            %5B%5DIdentityKey    // mints removed in this epoch%0A%09MintsReplaced           %5B%5DKeyReplacement // mints replaced in this epoch%0A%09DBCTypesAdded           %5B%5DDBCType        // DBC types added in this epoch%0A%09DBCTypesRemoved         %5B%5DDBCType        // DBC types removed in this epoch%0A%09MonetarySupplyIncrease  %5B%5DNote           // new notes to print%0A%09MonetarySupplyReduction %5B%5DNote           // TODO: define burn process%0A%7D%0A%0A// IdentityKey defines a mint identity key.%0Atype IdentityKey struct %7B%0A%09SigAlgo string // signature algorithm%0A%09PubKey  %5B%5Dbyte // public key%0A%7D%0A%0A// KeyReplacement defines a mint identity key replacement.%0Atype KeyReplacement struct %7B%0A%09NewKey    IdentityKey // the new identity key%0A%09OldKey    IdentityKey // the replaced identity key%0A%09Signature string      // of new key by replaced key%0A%7D%0A%0A// DBCType defines a DBC type.%0Atype DBCType struct %7B%0A%09Currency string // the DBC currency%0A%09Amount   uint64 // per DBC%0A%7D%0A%0A// Note defines newly printed or burned DBCs.%0Atype Note struct %7B%0A%09Random         %5B16%5Dbyte // nonce%0A%09Quantity       uint64   // number of DBCs%0A%09Currency       string   // DBC currency%0A%09Amount         uint64   // per DBC%0A%09ReceiverPubKey %5B%5Dbyte   // recipient%0A
+%09QuorumM         uint64           // the quorum%0A%09NumberOfMintsN  uint64           // total number of mints%0A%09SignStart       time.Time        // start of signing epoch%0A%09SignEnd         time.Time        // end of signing epoch%0A%09ValidateEnd     time.Time        // end of validation epoch%0A%09MintsAdded      %5B%5DIdentityKey    %60json:%22,omitempty%22%60 // mints added in this epoch%0A%09MintsRemoved    %5B%5DIdentityKey    %60json:%22,omitempty%22%60 // mints removed in this epoch%0A%09MintsReplaced   %5B%5DKeyReplacement %60json:%22,omitempty%22%60 // mints replaced in this epoch%0A%09DBCTypesAdded   %5B%5DDBCType        %60json:%22,omitempty%22%60 // DBC types added in this epoch%0A%09DBCTypesRemoved %5B%5DDBCType        %60json:%22,omitempty%22%60 // DBC types removed in this epoch%0A
 %7D%0A%0A/
@@ -916,54 +916,50 @@
 ch.%0A
-func (epoch *NetworkEpoch) Validate() error %7B%0A
+func (e *NetworkEpoch) Validate() error %7B%0A
 %09// 
@@ -968,27 +968,29 @@
 %3E 0%0A
-%09if epoch.M == 0 %7B%0A
+%09if e.QuorumM == 0 %7B%0A
 %09%09re
@@ -1020,27 +1020,36 @@
 %3E 0%0A
-%09if epoch.N == 0 %7B%0A
+%09if e.NumberOfMintsN == 0 %7B%0A
 %09%09re
@@ -1080,32 +1080,43 @@
 = n%0A
-%09if epoch.M %3E epoch.N %7B%0A
+%09if e.QuorumM %3E e.NumberOfMintsN %7B%0A
 %09%09re
@@ -1152,35 +1152,46 @@
 n/2%0A
-%09if epoch.M %3C= epoch.N/2 %7B%0A
+%09if e.QuorumM %3C= e.NumberOfMintsN/2 %7B%0A
 %09%09re
@@ -1259,53 +1259,45 @@
 end%0A
-%09if !epoch.SignStart.Before(epoch.SignEnd) %7B%0A
+%09if !e.SignStart.Before(e.SignEnd) %7B%0A
 %09%09re
@@ -1384,55 +1384,47 @@
 end%0A
-%09if !epoch.SignEnd.Before(epoch.ValidateEnd) %7B%0A
+%09if !e.SignEnd.Before(e.ValidateEnd) %7B%0A
 %09%09re
@@ -1482,8 +1482,1353 @@
 n nil%0A%7D%0A
+%0A// MintsDisjunct make sure the MintsAdded, MintsRemoved, and MintsReplaced%0A// sets are disjunct.%0Afunc (e *NetworkEpoch) MintsDisjunct() error %7B%0A%09addedMints := make(map%5Bstring%5Dbool)%0A%09removedMints := make(map%5Bstring%5Dbool)%0A%09replacedMints := make(map%5Bstring%5Dbool)%0A%09// fill maps%0A%09for _, add := range e.MintsAdded %7B%0A%09%09addedMints%5Badd.MarshalID()%5D = true%0A%09%7D%0A%09for _, remove := range e.MintsRemoved %7B%0A%09%09removedMints%5Bremove.MarshalID()%5D = true%0A%09%7D%0A%09for _, replace := range e.MintsReplaced %7B%0A%09%09replacedMints%5Breplace.OldKey.MarshalID()%5D = true%0A%09%7D%0A%09// check%0A%09for _, replace := range e.MintsReplaced %7B%0A%09%09newID := replace.NewKey.MarshalID()%0A%09%09oldID := replace.OldKey.MarshalID()%0A%09%09if addedMints%5BnewID%5D %7C%7C removedMints%5BnewID%5D %7C%7C replacedMints%5BnewID%5D %7B%0A%09%09%09return ErrMintsOverlap%0A%09%09%7D%0A%09%09if addedMints%5BoldID%5D %7C%7C removedMints%5BoldID%5D %7B%0A%09%09%09return ErrMintsOverlap%0A%09%09%7D%0A%09%7D%0A%09for _, remove := range e.MintsRemoved %7B%0A%09%09if addedMints%5Bremove.MarshalID()%5D %7B%0A%09%09%09return ErrMintsOverlap%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// DBCTypesDisjunct makes sure the DBCTypesAdded and DBCTypesRemoved sets from the epoch are disjunct.%0Afunc (e *NetworkEpoch) DBCTypesDisjunct() error %7B%0A%09dbcTypes := make(map%5BDBCType%5Dbool)%0A%09for _, add := range e.DBCTypesAdded %7B%0A%09%09dbcTypes%5Badd%5D = true%0A%09%7D%0A%09for _, remove := range e.DBCTypesRemoved %7B%0A%09%09if dbcTypes%5Bremove%5D %7B%0A%09%09%09return ErrDBCTypesOverlap%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A
- f 6936247af9e59724c71e5dd8bea5a4afdfa23d08d6b73a2725275dc3d1b8541c netconf/network_epoch_test.go
+ f 966c6ffbd8c42463778343e20d6b5974bd76d350ddbfa9dd9d09376154d6de34 netconf/network_epoch_test.go
dmppatch 45
@@ -646,111 +646,126 @@
 ch%7B%0A
-%09%09%09%09M:           0,%0A%09%09%09%09N:           1,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        0,%0A%09%09%09%09NumberOfMintsN: 1,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -809,111 +809,126 @@
 ch%7B%0A
-%09%09%09%09M:           1,%0A%09%09%09%09N:           0,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        1,%0A%09%09%09%09NumberOfMintsN: 0,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -972,111 +972,126 @@
 ch%7B%0A
-%09%09%09%09M:           2,%0A%09%09%09%09N:           1,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        2,%0A%09%09%09%09NumberOfMintsN: 1,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -1139,112 +1139,127 @@
 ch%7B%0A
-%09%09%09%09M:           5,%0A%09%09%09%09N:           10,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        5,%0A%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -1312,112 +1312,127 @@
 ch%7B%0A
-%09%09%09%09M:           6,%0A%09%09%09%09N:           10,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        6,%0A%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -1471,112 +1471,127 @@
 ch%7B%0A
-%09%09%09%09M:           5,%0A%09%09%09%09N:           11,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        5,%0A%09%09%09%09NumberOfMintsN: 11,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -1644,112 +1644,127 @@
 ch%7B%0A
-%09%09%09%09M:           6,%0A%09%09%09%09N:           11,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09QuorumM:        6,%0A%09%09%09%09NumberOfMintsN: 11,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%7D
@@ -1803,83 +1803,103 @@
 ch%7B%0A
-%09%09%09%09M:         8,%0A%09%09%09%09N:         10,%0A%09%09%09%09SignStart: t1,%0A%09%09%09%09SignEnd:   t1,%0A
+%09%09%09%09QuorumM:        8,%0A%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t1,%0A
 %09%09%09%7D
@@ -1968,112 +1968,127 @@
 ch%7B%0A
-%09%09%09%09M:           8,%0A%09%09%09%09N:           10,%0A%09%09%09%09SignStart:   t1,%0A%09%09%09%09SignEnd:     t2,%0A%09%09%09%09ValidateEnd: t2,%0A
+%09%09%09%09QuorumM:        8,%0A%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09SignStart:      t1,%0A%09%09%09%09SignEnd:        t2,%0A%09%09%09%09ValidateEnd:    t2,%0A
 %09%09%09%7D
- f b393f0d39650c5e965038ab6bb0cd7ddbed2aa7a49e2254792ac07b9bbc278a3 netconf/network_test.go
+ f 36152e157a5ac5420ac14bd3cac2793565618f19a458cec993915aebfa41b027 netconf/network_test.go
dmppatch 24
@@ -248,16 +248,61 @@
 err)%0A%09%7D%0A
+%09_ = DBCTypeMapToSortedArray(net.DBCTypes())%0A
 %7D%0A%0Afunc 
@@ -451,122 +451,137 @@
 %09%09%7B%0A
-%09%09%09%09%09%09M:           8,%0A%09%09%09%09%09%09N:           10,%0A%09%09%09%09%09%09SignStart:   t1,%0A%09%09%09%09%09%09SignEnd:     t2,%0A%09%09%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09%09%09QuorumM:        8,%0A%09%09%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09%09%09SignStart:      t1,%0A%09%09%09%09%09%09SignEnd:        t2,%0A%09%09%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%09
@@ -595,122 +595,137 @@
 %09%09%7B%0A
-%09%09%09%09%09%09M:           8,%0A%09%09%09%09%09%09N:           10,%0A%09%09%09%09%09%09SignStart:   t1,%0A%09%09%09%09%09%09SignEnd:     t2,%0A%09%09%09%09%09%09ValidateEnd: t3,%0A
+%09%09%09%09%09%09QuorumM:        8,%0A%09%09%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09%09%09SignStart:      t1,%0A%09%09%09%09%09%09SignEnd:        t2,%0A%09%09%09%09%09%09ValidateEnd:    t3,%0A
 %09%09%09%09
@@ -825,122 +825,137 @@
 %09%09%7B%0A
-%09%09%09%09%09%09M:           8,%0A%09%09%09%09%09%09N:           10,%0A%09%09%09%09%09%09SignStart:   t1,%0A%09%09%09%09%09%09SignEnd:     t2,%0A%09%09%09%09%09%09ValidateEnd: t4,%0A
+%09%09%09%09%09%09QuorumM:        8,%0A%09%09%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09%09%09SignStart:      t1,%0A%09%09%09%09%09%09SignEnd:        t2,%0A%09%09%09%09%09%09ValidateEnd:    t4,%0A
 %09%09%09%09
@@ -969,122 +969,137 @@
 %09%09%7B%0A
-%09%09%09%09%09%09M:           8,%0A%09%09%09%09%09%09N:           10,%0A%09%09%09%09%09%09SignStart:   t2,%0A%09%09%09%09%09%09SignEnd:     t3,%0A%09%09%09%09%09%09ValidateEnd: t4,%0A
+%09%09%09%09%09%09QuorumM:        8,%0A%09%09%09%09%09%09NumberOfMintsN: 10,%0A%09%09%09%09%09%09SignStart:      t2,%0A%09%09%09%09%09%09SignEnd:        t3,%0A%09%09%09%09%09%09ValidateEnd:    t4,%0A
 %09%09%09%09
+ f ec9f345d837e0850c736708d141de1d6b713852e8ea1f37b9274aee205ddb7fb netconf/signing_key.go
utf8file 34
package netconf

import (
	"crypto/ed25519"
	"crypto/rand"
)

// SigningKey defines an entry in the key list.
type SigningKey struct {
	Currency string             // the currency this key signs, usually ISO 4217 codes
	Amount   uint64             // the amount this key signs, 8 digits after the dot
	SigAlgo  string             // signature algorithm
	PubKey   []byte             // public key
	PrivKey  ed25519.PrivateKey `json:",omitempty"` // private key
}

// NewSigningKey generates a new signing key.
func NewSigningKey(
	currency string,
	amount uint64,
) (*SigningKey, error) {
	var sk SigningKey
	sk.Currency = currency
	sk.Amount = amount
	sk.SigAlgo = "ed25519" // TODO
	pubKey, privKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}
	sk.PubKey = pubKey
	sk.PrivKey = privKey
	return &sk, nil
}

+ f 95c0f32310b1db1b563a128a16ca0aa912efbb88f567105c1a47bec7706fce97 netconf/signing_key_test.go
utf8file 13
package netconf

import (
	"testing"
)

func TestSigningKey(t *testing.T) {
	_, err := NewSigningKey("EUR", 100000000)
	if err != nil {
		t.Error(err)
	}
}

+ x 739d4195abe6f9df8aae4e6077df0eab81311fccbd4bad7862bd7829986f4e04 netconf/testdata/federation.json
utf8file 46
{
  "NetworkEpochs": [
    {
      "QuorumM": 2,
      "NumberOfMintsN": 3,
      "SignStart": "2020-01-18T00:00:00Z",
      "SignEnd": "2020-02-17T00:00:00Z",
      "ValidateEnd": "2020-03-18T00:00:00Z",
      "MintsAdded": [
        {
          "SigAlgo": "ed25519",
          "PubKey": "ECNmyLJ2ESzYmzX8nLE6/zXML/DSK4XXsvZ5KU88aYE="
        },
        {
          "SigAlgo": "ed25519",
          "PubKey": "WS5x4aMS5kB2H7Qy7vDJyaG577rNQmE4quLvEfKRFLc="
        },
        {
          "SigAlgo": "ed25519",
          "PubKey": "mn+b/U5fSlbqNbp6KXXF8DhUIow9MZnL12cSg/xUnt4="
        }
      ],
      "DBCTypesAdded": [
        {
          "Currency": "EUR",
          "Amount": 100000000
        },
        {
          "Currency": "EUR",
          "Amount": 200000000
        },
        {
          "Currency": "EUR",
          "Amount": 500000000
        }
      ]
    },
    {
      "QuorumM": 2,
      "NumberOfMintsN": 3,
      "SignStart": "2020-02-17T00:00:00Z",
      "SignEnd": "2020-03-18T00:00:00Z",
      "ValidateEnd": "2020-04-17T00:00:00Z"
    }
  ]
}
+ x 9713501dfbe7f8aead9da4aba29f7197e77e9a707a779fa7319dc3e8f001639c netconf/testdata/mints/ed25519-ECNmyLJ2ESzYmzX8nLE6_zXML_DSK4XXsvZ5KU88aYE.json
utf8file 74
{
  "Description": "mint1",
  "MintIdentityKey": {
    "SigAlgo": "ed25519",
    "PubKey": "ECNmyLJ2ESzYmzX8nLE6/zXML/DSK4XXsvZ5KU88aYE="
  },
  "MintEpochs": [
    {
      "SignStart": "2020-01-18T00:00:00Z",
      "SignEnd": "2020-02-17T00:00:00Z",
      "ValidateEnd": "2020-03-18T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "l3sAAHt8f1UMHl26S50/Uzu98a33Mb50xG/D08puYNo="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "kwY932Dxd9q04fb/GZZY1SPzRW5P9yemPKep3ofTBPU="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "2CBAC0OmXM3zZiG32Lj4ayRTRq0keiJ+j75fNC6tmv8="
        }
      ],
      "KeyListSignatures": [
        "gICK8fr7SD5wyHJ2n5GljKjIALHXg9S4OtRz7H3z8ZQFf4eriTiH0gq6X8Oa18dxTkmHIXpiN/CbIoZjZNKPBw==",
        "KvSVovC1pDETiXigXIxpdSFKNMzvropuKAzOMTbaInbe7BZzy8rpeVEznLJstxtRNRLRexV5S+0Sxg+9xVApAQ==",
        "02fSEEIWAHK+loulTq/vgPxZkfGzPqDXvgYq3G1/Qlg1mox80vB1lDIFyGz1OZFrE043LoZBir4k2LfZp4CUAA==",
        "rJF/ZuQxQKUbb+kcIsPn3LKXowxnomiF/nLjPW0W+w3tLKD+SBOgeBB+uw+aIsYHP5Zc4YZFECzxgBxiAp3/DQ=="
      ]
    },
    {
      "SignStart": "2020-02-17T00:00:00Z",
      "SignEnd": "2020-03-18T00:00:00Z",
      "ValidateEnd": "2020-04-17T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "Pj399UPlv+7+KlNdqIMp3rnzm5zaTF+3dGJyaI0WE7I="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "eD4/pgkN1OqFhN/+B77aJSaZg9pbxALhU69e6BMY7ls="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "H4g6lU8gVvSlr1ydh+c/NQnxYFmDAdEMNC/rjhSyLbs="
        }
      ],
      "KeyListSignatures": [
        "pyPp6tEWJy0K3M0wcF7d26LRLbywKBKfw3lBVo0skaTP7NugCceOD1qb5WbXwugO1IihmwVPgv4Z75NyDOmhDw==",
        "YVX29IknqHnQ0dowoaPA88aBwgyGLwVGlmFMxMzflhvEnrgidEphVNXOwGaCoK95MLhD1j6d6hoE9jwNh3EJDQ==",
        "JIRKILiZ+NWfyDoq6EkFzhHAFsVSE7G1BCCtBeCkLRX0gbVpO1JE1P3P1jx586xfEo0tokUgGWlqp+rACTPMCQ==",
        "8WPahi386BDIxFay6nfidTn6Kp7TeTrWqEYLicHPAu7tyNrETyalm+StkKGI7ZmJs80h9obt9KwXl3qVMbhwBw=="
      ]
    }
  ],
  "URLs": [
    "https://mint1.example.com"
  ]
}
+ x f16bda065e12472a97e4730a7832c5542359d96fe615d1431622fe52e2503ae4 netconf/testdata/mints/ed25519-WS5x4aMS5kB2H7Qy7vDJyaG577rNQmE4quLvEfKRFLc.json
utf8file 74
{
  "Description": "mint2",
  "MintIdentityKey": {
    "SigAlgo": "ed25519",
    "PubKey": "WS5x4aMS5kB2H7Qy7vDJyaG577rNQmE4quLvEfKRFLc="
  },
  "MintEpochs": [
    {
      "SignStart": "2020-01-18T00:00:00Z",
      "SignEnd": "2020-02-17T00:00:00Z",
      "ValidateEnd": "2020-03-18T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "JGKcqq8hgpO7flGbH0YSwYkZnkuoAMP7MDbyzVrY+Co="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "+rwQ4lzDoySNWZIJ0il8sm+23Ybis6oX5omhHEGmyHY="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "B0vsGpad0ajdAYvWmNkt2K/QDGVaKKuDzZzMJqngShc="
        }
      ],
      "KeyListSignatures": [
        "7P8uH1f8gaaPnhbXredVgVE20CMTT9RB6of9iYd5mh3YFBRWsiLsmJYAvEPm8+lEdnjEapQeVkCHY/Avt7rkCg==",
        "cbLAv/wBSYiNSCGrto+rLSGqSVXWgic0aZqeVlByuJcb2q6upDHrJPbiH+M8doShKcmU1ze1lWmjAM7pUqgNBQ==",
        "1Dqauw3DRfdhcud9DzYDHv5U2NbO7CPjYHrF0FS66C5Z+Y6nzCJjU6idwVi/5le5XunJCH7j+MB9csdZWYd/Cg==",
        "RMpkNXUfC0oekvCJt7kQat8j4tNy2X7Q78DxVzyQetpK/wwgliFEeZQ/hcL6VOBGlcp6mcDSFs5GaN+VEi9hAA=="
      ]
    },
    {
      "SignStart": "2020-02-17T00:00:00Z",
      "SignEnd": "2020-03-18T00:00:00Z",
      "ValidateEnd": "2020-04-17T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "mWr+BiJd9fEaoT8SWynItnssIlocJtLR/jK3ALC7wQE="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "miSaWMt+LqS0JoC00OkOAU3iOjOOmUb0pVnpWA3zeaI="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "Iqfx8c60CCpiTz50SGg7YOgAcyujBZtyF1Kyb4T9SCo="
        }
      ],
      "KeyListSignatures": [
        "ouNKfQResKXQCNXo53pS190KPYnHjywjR2NVydxIKaORvO9rpjlOCD99Ccua1j1MDlo6pBTHmr/10MV1aV5nBA==",
        "4vh9/oD/4yOHsn7m1F80kwQmvwKGI6sx7uP7ptkoZFIzYV9gyh728axudj6GIuXs2T72Iqt6CATZW2HB4Q8MCA==",
        "nmzpuMrHNRmrAcn8erZr51DkQdVKrSr42vvbmGRGWPCtws9NaWC1moLsVUu/NqJlsoF1NZC7Uf+cXT9eWcWHCA==",
        "Nqk3gYiHjczi8VY7bu0yQmmX5MG1DnGR1+AGeP5WQ0WIvC1FF1usO5FR86UxbQyfApL9p1XdAIHfbfZ2v5KsAg=="
      ]
    }
  ],
  "URLs": [
    "https://mint2.example.net"
  ]
}
+ x aa537ffd49f2a2ac78dbc23f50e553b6de02c84a32e12437eb883c6fe843eb42 netconf/testdata/mints/ed25519-mn-b_U5fSlbqNbp6KXXF8DhUIow9MZnL12cSg_xUnt4.json
utf8file 74
{
  "Description": "mint3",
  "MintIdentityKey": {
    "SigAlgo": "ed25519",
    "PubKey": "mn+b/U5fSlbqNbp6KXXF8DhUIow9MZnL12cSg/xUnt4="
  },
  "MintEpochs": [
    {
      "SignStart": "2020-01-18T00:00:00Z",
      "SignEnd": "2020-02-17T00:00:00Z",
      "ValidateEnd": "2020-03-18T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "RkTeCQxCSufivPjWe440K5xbBAcHGAeiFGsO7HHFIgU="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "XUPpLau1KEmUtboIPxRtuzi4Nzych1P4bBoIqG12yXk="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "OfpKVx1/r7d3/149ZPdu+l/N9sEH8LU0M44ZIrDDuWg="
        }
      ],
      "KeyListSignatures": [
        "92dsr9sP38RMy+PbKlJpfITTbwbyTmJhWE4NBwvjbDex1WhhdLe7D7I98x91yZ5xmp3YvtrL6TIWKCUhpR/4Dw==",
        "bG3sd+A/gvUJhNlD/NpqrwDA73MHsjzeDv/fnUNd5OEqV4e3C07j+N6syE9Rsq9O1pZxkvaUFhUmq1qYlkKWDA==",
        "obMbpVnEM+Lwzp4VwTDD9km62d4kNOGKXXs3cFGNtrSwAb3Ryitse7gkqzacBjEyZJE9oA8U9Oi7IiMTcTDoBw==",
        "+j+Q0tRLaLnDF5M0wQGBqSpTXvqvByINA3ECYIBTiz0qCqaOScSwUIPqvA6tQ7HWOOq68YDhjor+9Tm0G5JiAg=="
      ]
    },
    {
      "SignStart": "2020-02-17T00:00:00Z",
      "SignEnd": "2020-03-18T00:00:00Z",
      "ValidateEnd": "2020-04-17T00:00:00Z",
      "KeyList": [
        {
          "Currency": "EUR",
          "Amount": 100000000,
          "SigAlgo": "ed25519",
          "PubKey": "Srk8FyaxrAujDsnUQHXEj3gkNoEvc1clCfbgfU3ug2s="
        },
        {
          "Currency": "EUR",
          "Amount": 200000000,
          "SigAlgo": "ed25519",
          "PubKey": "ms0c57jpVub/hF+RBQ2T2JuxH4CVSkpmiQrBwI/S0Uw="
        },
        {
          "Currency": "EUR",
          "Amount": 500000000,
          "SigAlgo": "ed25519",
          "PubKey": "d2t8twlAzaNqBvp3HvOuFq8MmKoytRS6CdVZf18nnXY="
        }
      ],
      "KeyListSignatures": [
        "r+H7L2QEzo2RwqIyzHAlCR9aXXICFFNkG1Tb/dKtGksGzlfA/KsjCh+W7Ch9JcsewMF1CB+2i5Ys4MRPW9AcCg==",
        "swQQRAZvnhnoHLuMlcYhnVHEdrZ3cD1nETbvontSLgwSn1VLXl2ix78zPchQ0yO/C0gTrYGKjIAMDPX9kNcaDQ==",
        "iFgQoIasSqs9MSIafANmjWZFjNX2nysUzDi17P6wPWmfSDsXfqcQg039I2I91+YV3paMkpGdfOENae/lXZShDA==",
        "U+CZkqQK9Kv3840cUk74PtlsjyovkBugUF+K2S6+R5lXZqjwrQiyHJTLEBMbriItarApsfSLUAYW70aHxLQjBA=="
      ]
    }
  ],
  "URLs": [
    "https://mint3.example.org"
  ]
}
- f db1179a57b0e25616d64b62b2a9a3267fb63e3718fecb44d6e0d69d2296ec798 netconf/testdata/network.json
+ f 814a890c95aa84224f137c1f129a257ba0cb4d8a89eac7984e8cb3242494ce75 util/def/def.go
utf8file 13
// Package def defines default values used in Scrit.
package def

import (
	"time"
)

// SigningPeriod defines the default length of a signing epoch.
const SigningPeriod = 30 * 24 * time.Hour // 30d

// ValidationPeriod defines the default length of a validation epoch.
const ValidationPeriod = 30 * 24 * time.Hour // 30d

+ f fd859b351c5cdfc8b7a09959109aae396343f30ba7f77069ebd16cd5f3903fdf util/homedir/homedir.go
utf8file 13
// Package homedir implements helper methods to get the home directories of
// various tools.
package homedir

import (
	"github.com/frankbraun/codechain/util/homedir"
)

// ScritMint returns the home directory for 'scrit-mint'.
func ScritMint() string {
	return homedir.Get("scrit-mint")
}

+ f 1b93a317849ee09d3d7e4f1d20c2b78ddb230b4becb12d7c224c927b9d470251 vendor/github.com/davecgh/go-spew/LICENSE
utf8file 16
ISC License

Copyright (c) 2012-2016 Dave Collins <dave@davec.name>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

+ f 2703ee123fee0581e5d142d4e493cb83869a60bc2faa43502c2b5c448d5906f1 vendor/github.com/davecgh/go-spew/spew/bypass.go
utf8file 146
// Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// NOTE: Due to the following build constraints, this file will only be compiled
// when the code is not running on Google App Engine, compiled by GopherJS, and
// "-tags safe" is not added to the go build command line.  The "disableunsafe"
// tag is deprecated and thus should not be used.
// Go versions prior to 1.4 are disabled because they use a different layout
// for interfaces which make the implementation of unsafeReflectValue more complex.
// +build !js,!appengine,!safe,!disableunsafe,go1.4

package spew

import (
	"reflect"
	"unsafe"
)

const (
	// UnsafeDisabled is a build-time constant which specifies whether or
	// not access to the unsafe package is available.
	UnsafeDisabled = false

	// ptrSize is the size of a pointer on the current arch.
	ptrSize = unsafe.Sizeof((*byte)(nil))
)

type flag uintptr

var (
	// flagRO indicates whether the value field of a reflect.Value
	// is read-only.
	flagRO flag

	// flagAddr indicates whether the address of the reflect.Value's
	// value may be taken.
	flagAddr flag
)

// flagKindMask holds the bits that make up the kind
// part of the flags field. In all the supported versions,
// it is in the lower 5 bits.
const flagKindMask = flag(0x1f)

// Different versions of Go have used different
// bit layouts for the flags type. This table
// records the known combinations.
var okFlags = []struct {
	ro, addr flag
}{{
	// From Go 1.4 to 1.5
	ro:   1 << 5,
	addr: 1 << 7,
}, {
	// Up to Go tip.
	ro:   1<<5 | 1<<6,
	addr: 1 << 8,
}}

var flagValOffset = func() uintptr {
	field, ok := reflect.TypeOf(reflect.Value{}).FieldByName("flag")
	if !ok {
		panic("reflect.Value has no flag field")
	}
	return field.Offset
}()

// flagField returns a pointer to the flag field of a reflect.Value.
func flagField(v *reflect.Value) *flag {
	return (*flag)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + flagValOffset))
}

// unsafeReflectValue converts the passed reflect.Value into a one that bypasses
// the typical safety restrictions preventing access to unaddressable and
// unexported data.  It works by digging the raw pointer to the underlying
// value out of the protected value and generating a new unprotected (unsafe)
// reflect.Value to it.
//
// This allows us to check for implementations of the Stringer and error
// interfaces to be used for pretty printing ordinarily unaddressable and
// inaccessible values such as unexported struct fields.
func unsafeReflectValue(v reflect.Value) reflect.Value {
	if !v.IsValid() || (v.CanInterface() && v.CanAddr()) {
		return v
	}
	flagFieldPtr := flagField(&v)
	*flagFieldPtr &^= flagRO
	*flagFieldPtr |= flagAddr
	return v
}

// Sanity checks against future reflect package changes
// to the type or semantics of the Value.flag field.
func init() {
	field, ok := reflect.TypeOf(reflect.Value{}).FieldByName("flag")
	if !ok {
		panic("reflect.Value has no flag field")
	}
	if field.Type.Kind() != reflect.TypeOf(flag(0)).Kind() {
		panic("reflect.Value flag field has changed kind")
	}
	type t0 int
	var t struct {
		A t0
		// t0 will have flagEmbedRO set.
		t0
		// a will have flagStickyRO set
		a t0
	}
	vA := reflect.ValueOf(t).FieldByName("A")
	va := reflect.ValueOf(t).FieldByName("a")
	vt0 := reflect.ValueOf(t).FieldByName("t0")

	// Infer flagRO from the difference between the flags
	// for the (otherwise identical) fields in t.
	flagPublic := *flagField(&vA)
	flagWithRO := *flagField(&va) | *flagField(&vt0)
	flagRO = flagPublic ^ flagWithRO

	// Infer flagAddr from the difference between a value
	// taken from a pointer and not.
	vPtrA := reflect.ValueOf(&t).Elem().FieldByName("A")
	flagNoPtr := *flagField(&vA)
	flagPtr := *flagField(&vPtrA)
	flagAddr = flagNoPtr ^ flagPtr

	// Check that the inferred flags tally with one of the known versions.
	for _, f := range okFlags {
		if flagRO == f.ro && flagAddr == f.addr {
			return
		}
	}
	panic("reflect.Value read-only flag has changed semantics")
}

+ f e031e1d2ecf569146b2e6680247f1214bff6096dd8b74fcaae42267bf43bf377 vendor/github.com/davecgh/go-spew/spew/bypasssafe.go
utf8file 39
// Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// NOTE: Due to the following build constraints, this file will only be compiled
// when the code is running on Google App Engine, compiled by GopherJS, or
// "-tags safe" is added to the go build command line.  The "disableunsafe"
// tag is deprecated and thus should not be used.
// +build js appengine safe disableunsafe !go1.4

package spew

import "reflect"

const (
	// UnsafeDisabled is a build-time constant which specifies whether or
	// not access to the unsafe package is available.
	UnsafeDisabled = true
)

// unsafeReflectValue typically converts the passed reflect.Value into a one
// that bypasses the typical safety restrictions preventing access to
// unaddressable and unexported data.  However, doing this relies on access to
// the unsafe package.  This is a stub version which simply returns the passed
// reflect.Value when the unsafe package is not available.
func unsafeReflectValue(v reflect.Value) reflect.Value {
	return v
}

+ f 722fed0447e461ce618e13f6f984908dcae8e28558df2b62c7a94ebe58aad950 vendor/github.com/davecgh/go-spew/spew/common.go
utf8file 342
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package spew

import (
	"bytes"
	"fmt"
	"io"
	"reflect"
	"sort"
	"strconv"
)

// Some constants in the form of bytes to avoid string overhead.  This mirrors
// the technique used in the fmt package.
var (
	panicBytes            = []byte("(PANIC=")
	plusBytes             = []byte("+")
	iBytes                = []byte("i")
	trueBytes             = []byte("true")
	falseBytes            = []byte("false")
	interfaceBytes        = []byte("(interface {})")
	commaNewlineBytes     = []byte(",\n")
	newlineBytes          = []byte("\n")
	openBraceBytes        = []byte("{")
	openBraceNewlineBytes = []byte("{\n")
	closeBraceBytes       = []byte("}")
	asteriskBytes         = []byte("*")
	colonBytes            = []byte(":")
	colonSpaceBytes       = []byte(": ")
	openParenBytes        = []byte("(")
	closeParenBytes       = []byte(")")
	spaceBytes            = []byte(" ")
	pointerChainBytes     = []byte("->")
	nilAngleBytes         = []byte("<nil>")
	maxNewlineBytes       = []byte("<max depth reached>\n")
	maxShortBytes         = []byte("<max>")
	circularBytes         = []byte("<already shown>")
	circularShortBytes    = []byte("<shown>")
	invalidAngleBytes     = []byte("<invalid>")
	openBracketBytes      = []byte("[")
	closeBracketBytes     = []byte("]")
	percentBytes          = []byte("%")
	precisionBytes        = []byte(".")
	openAngleBytes        = []byte("<")
	closeAngleBytes       = []byte(">")
	openMapBytes          = []byte("map[")
	closeMapBytes         = []byte("]")
	lenEqualsBytes        = []byte("len=")
	capEqualsBytes        = []byte("cap=")
)

// hexDigits is used to map a decimal value to a hex digit.
var hexDigits = "0123456789abcdef"

// catchPanic handles any panics that might occur during the handleMethods
// calls.
func catchPanic(w io.Writer, v reflect.Value) {
	if err := recover(); err != nil {
		w.Write(panicBytes)
		fmt.Fprintf(w, "%v", err)
		w.Write(closeParenBytes)
	}
}

// handleMethods attempts to call the Error and String methods on the underlying
// type the passed reflect.Value represents and outputes the result to Writer w.
//
// It handles panics in any called methods by catching and displaying the error
// as the formatted value.
func handleMethods(cs *ConfigState, w io.Writer, v reflect.Value) (handled bool) {
	// We need an interface to check if the type implements the error or
	// Stringer interface.  However, the reflect package won't give us an
	// interface on certain things like unexported struct fields in order
	// to enforce visibility rules.  We use unsafe, when it's available,
	// to bypass these restrictions since this package does not mutate the
	// values.
	if !v.CanInterface() {
		if UnsafeDisabled {
			return false
		}

		v = unsafeReflectValue(v)
	}

	// Choose whether or not to do error and Stringer interface lookups against
	// the base type or a pointer to the base type depending on settings.
	// Technically calling one of these methods with a pointer receiver can
	// mutate the value, however, types which choose to satisify an error or
	// Stringer interface with a pointer receiver should not be mutating their
	// state inside these interface methods.
	if !cs.DisablePointerMethods && !UnsafeDisabled && !v.CanAddr() {
		v = unsafeReflectValue(v)
	}
	if v.CanAddr() {
		v = v.Addr()
	}

	// Is it an error or Stringer?
	switch iface := v.Interface().(type) {
	case error:
		defer catchPanic(w, v)
		if cs.ContinueOnMethod {
			w.Write(openParenBytes)
			w.Write([]byte(iface.Error()))
			w.Write(closeParenBytes)
			w.Write(spaceBytes)
			return false
		}

		w.Write([]byte(iface.Error()))
		return true

	case fmt.Stringer:
		defer catchPanic(w, v)
		if cs.ContinueOnMethod {
			w.Write(openParenBytes)
			w.Write([]byte(iface.String()))
			w.Write(closeParenBytes)
			w.Write(spaceBytes)
			return false
		}
		w.Write([]byte(iface.String()))
		return true
	}
	return false
}

// printBool outputs a boolean value as true or false to Writer w.
func printBool(w io.Writer, val bool) {
	if val {
		w.Write(trueBytes)
	} else {
		w.Write(falseBytes)
	}
}

// printInt outputs a signed integer value to Writer w.
func printInt(w io.Writer, val int64, base int) {
	w.Write([]byte(strconv.FormatInt(val, base)))
}

// printUint outputs an unsigned integer value to Writer w.
func printUint(w io.Writer, val uint64, base int) {
	w.Write([]byte(strconv.FormatUint(val, base)))
}

// printFloat outputs a floating point value using the specified precision,
// which is expected to be 32 or 64bit, to Writer w.
func printFloat(w io.Writer, val float64, precision int) {
	w.Write([]byte(strconv.FormatFloat(val, 'g', -1, precision)))
}

// printComplex outputs a complex value using the specified float precision
// for the real and imaginary parts to Writer w.
func printComplex(w io.Writer, c complex128, floatPrecision int) {
	r := real(c)
	w.Write(openParenBytes)
	w.Write([]byte(strconv.FormatFloat(r, 'g', -1, floatPrecision)))
	i := imag(c)
	if i >= 0 {
		w.Write(plusBytes)
	}
	w.Write([]byte(strconv.FormatFloat(i, 'g', -1, floatPrecision)))
	w.Write(iBytes)
	w.Write(closeParenBytes)
}

// printHexPtr outputs a uintptr formatted as hexadecimal with a leading '0x'
// prefix to Writer w.
func printHexPtr(w io.Writer, p uintptr) {
	// Null pointer.
	num := uint64(p)
	if num == 0 {
		w.Write(nilAngleBytes)
		return
	}

	// Max uint64 is 16 bytes in hex + 2 bytes for '0x' prefix
	buf := make([]byte, 18)

	// It's simpler to construct the hex string right to left.
	base := uint64(16)
	i := len(buf) - 1
	for num >= base {
		buf[i] = hexDigits[num%base]
		num /= base
		i--
	}
	buf[i] = hexDigits[num]

	// Add '0x' prefix.
	i--
	buf[i] = 'x'
	i--
	buf[i] = '0'

	// Strip unused leading bytes.
	buf = buf[i:]
	w.Write(buf)
}

// valuesSorter implements sort.Interface to allow a slice of reflect.Value
// elements to be sorted.
type valuesSorter struct {
	values  []reflect.Value
	strings []string // either nil or same len and values
	cs      *ConfigState
}

// newValuesSorter initializes a valuesSorter instance, which holds a set of
// surrogate keys on which the data should be sorted.  It uses flags in
// ConfigState to decide if and how to populate those surrogate keys.
func newValuesSorter(values []reflect.Value, cs *ConfigState) sort.Interface {
	vs := &valuesSorter{values: values, cs: cs}
	if canSortSimply(vs.values[0].Kind()) {
		return vs
	}
	if !cs.DisableMethods {
		vs.strings = make([]string, len(values))
		for i := range vs.values {
			b := bytes.Buffer{}
			if !handleMethods(cs, &b, vs.values[i]) {
				vs.strings = nil
				break
			}
			vs.strings[i] = b.String()
		}
	}
	if vs.strings == nil && cs.SpewKeys {
		vs.strings = make([]string, len(values))
		for i := range vs.values {
			vs.strings[i] = Sprintf("%#v", vs.values[i].Interface())
		}
	}
	return vs
}

// canSortSimply tests whether a reflect.Kind is a primitive that can be sorted
// directly, or whether it should be considered for sorting by surrogate keys
// (if the ConfigState allows it).
func canSortSimply(kind reflect.Kind) bool {
	// This switch parallels valueSortLess, except for the default case.
	switch kind {
	case reflect.Bool:
		return true
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return true
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return true
	case reflect.Float32, reflect.Float64:
		return true
	case reflect.String:
		return true
	case reflect.Uintptr:
		return true
	case reflect.Array:
		return true
	}
	return false
}

// Len returns the number of values in the slice.  It is part of the
// sort.Interface implementation.
func (s *valuesSorter) Len() int {
	return len(s.values)
}

// Swap swaps the values at the passed indices.  It is part of the
// sort.Interface implementation.
func (s *valuesSorter) Swap(i, j int) {
	s.values[i], s.values[j] = s.values[j], s.values[i]
	if s.strings != nil {
		s.strings[i], s.strings[j] = s.strings[j], s.strings[i]
	}
}

// valueSortLess returns whether the first value should sort before the second
// value.  It is used by valueSorter.Less as part of the sort.Interface
// implementation.
func valueSortLess(a, b reflect.Value) bool {
	switch a.Kind() {
	case reflect.Bool:
		return !a.Bool() && b.Bool()
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return a.Int() < b.Int()
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return a.Uint() < b.Uint()
	case reflect.Float32, reflect.Float64:
		return a.Float() < b.Float()
	case reflect.String:
		return a.String() < b.String()
	case reflect.Uintptr:
		return a.Uint() < b.Uint()
	case reflect.Array:
		// Compare the contents of both arrays.
		l := a.Len()
		for i := 0; i < l; i++ {
			av := a.Index(i)
			bv := b.Index(i)
			if av.Interface() == bv.Interface() {
				continue
			}
			return valueSortLess(av, bv)
		}
	}
	return a.String() < b.String()
}

// Less returns whether the value at index i should sort before the
// value at index j.  It is part of the sort.Interface implementation.
func (s *valuesSorter) Less(i, j int) bool {
	if s.strings == nil {
		return valueSortLess(s.values[i], s.values[j])
	}
	return s.strings[i] < s.strings[j]
}

// sortValues is a sort function that handles both native types and any type that
// can be converted to error or Stringer.  Other inputs are sorted according to
// their Value.String() value to ensure display stability.
func sortValues(values []reflect.Value, cs *ConfigState) {
	if len(values) == 0 {
		return
	}
	sort.Sort(newValuesSorter(values, cs))
}

+ f 13338e0275c2acda68b73a755fe09677e9b878d090e01d700b1162e19bb1e66f vendor/github.com/davecgh/go-spew/spew/config.go
utf8file 307
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package spew

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

// ConfigState houses the configuration options used by spew to format and
// display values.  There is a global instance, Config, that is used to control
// all top-level Formatter and Dump functionality.  Each ConfigState instance
// provides methods equivalent to the top-level functions.
//
// The zero value for ConfigState provides no indentation.  You would typically
// want to set it to a space or a tab.
//
// Alternatively, you can use NewDefaultConfig to get a ConfigState instance
// with default settings.  See the documentation of NewDefaultConfig for default
// values.
type ConfigState struct {
	// Indent specifies the string to use for each indentation level.  The
	// global config instance that all top-level functions use set this to a
	// single space by default.  If you would like more indentation, you might
	// set this to a tab with "\t" or perhaps two spaces with "  ".
	Indent string

	// MaxDepth controls the maximum number of levels to descend into nested
	// data structures.  The default, 0, means there is no limit.
	//
	// NOTE: Circular data structures are properly detected, so it is not
	// necessary to set this value unless you specifically want to limit deeply
	// nested data structures.
	MaxDepth int

	// DisableMethods specifies whether or not error and Stringer interfaces are
	// invoked for types that implement them.
	DisableMethods bool

	// DisablePointerMethods specifies whether or not to check for and invoke
	// error and Stringer interfaces on types which only accept a pointer
	// receiver when the current type is not a pointer.
	//
	// NOTE: This might be an unsafe action since calling one of these methods
	// with a pointer receiver could technically mutate the value, however,
	// in practice, types which choose to satisify an error or Stringer
	// interface with a pointer receiver should not be mutating their state
	// inside these interface methods.  As a result, this option relies on
	// access to the unsafe package, so it will not have any effect when
	// running in environments without access to the unsafe package such as
	// Google App Engine or with the "safe" build tag specified.
	DisablePointerMethods bool

	// DisablePointerAddresses specifies whether to disable the printing of
	// pointer addresses. This is useful when diffing data structures in tests.
	DisablePointerAddresses bool

	// DisableCapacities specifies whether to disable the printing of capacities
	// for arrays, slices, maps and channels. This is useful when diffing
	// data structures in tests.
	DisableCapacities bool

	// ContinueOnMethod specifies whether or not recursion should continue once
	// a custom error or Stringer interface is invoked.  The default, false,
	// means it will print the results of invoking the custom error or Stringer
	// interface and return immediately instead of continuing to recurse into
	// the internals of the data type.
	//
	// NOTE: This flag does not have any effect if method invocation is disabled
	// via the DisableMethods or DisablePointerMethods options.
	ContinueOnMethod bool

	// SortKeys specifies map keys should be sorted before being printed. Use
	// this to have a more deterministic, diffable output.  Note that only
	// native types (bool, int, uint, floats, uintptr and string) and types
	// that support the error or Stringer interfaces (if methods are
	// enabled) are supported, with other types sorted according to the
	// reflect.Value.String() output which guarantees display stability.
	SortKeys bool

	// SpewKeys specifies that, as a last resort attempt, map keys should
	// be spewed to strings and sorted by those strings.  This is only
	// considered if SortKeys is true.
	SpewKeys bool
}

// Config is the active configuration of the top-level functions.
// The configuration can be changed by modifying the contents of spew.Config.
var Config = ConfigState{Indent: " "}

// Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the formatted string as a value that satisfies error.  See NewFormatter
// for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Errorf(format, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Errorf(format string, a ...interface{}) (err error) {
	return fmt.Errorf(format, c.convertArgs(a)...)
}

// Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprint(w, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	return fmt.Fprint(w, c.convertArgs(a)...)
}

// Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprintf(w, format, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
	return fmt.Fprintf(w, format, c.convertArgs(a)...)
}

// Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
// passed with a Formatter interface returned by c.NewFormatter.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprintln(w, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
	return fmt.Fprintln(w, c.convertArgs(a)...)
}

// Print is a wrapper for fmt.Print that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Print(c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Print(a ...interface{}) (n int, err error) {
	return fmt.Print(c.convertArgs(a)...)
}

// Printf is a wrapper for fmt.Printf that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Printf(format, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Printf(format string, a ...interface{}) (n int, err error) {
	return fmt.Printf(format, c.convertArgs(a)...)
}

// Println is a wrapper for fmt.Println that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Println(c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Println(a ...interface{}) (n int, err error) {
	return fmt.Println(c.convertArgs(a)...)
}

// Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprint(c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Sprint(a ...interface{}) string {
	return fmt.Sprint(c.convertArgs(a)...)
}

// Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
// passed with a Formatter interface returned by c.NewFormatter.  It returns
// the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprintf(format, c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Sprintf(format string, a ...interface{}) string {
	return fmt.Sprintf(format, c.convertArgs(a)...)
}

// Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
// were passed with a Formatter interface returned by c.NewFormatter.  It
// returns the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprintln(c.NewFormatter(a), c.NewFormatter(b))
func (c *ConfigState) Sprintln(a ...interface{}) string {
	return fmt.Sprintln(c.convertArgs(a)...)
}

/*
NewFormatter returns a custom formatter that satisfies the fmt.Formatter
interface.  As a result, it integrates cleanly with standard fmt package
printing functions.  The formatter is useful for inline printing of smaller data
types similar to the standard %v format specifier.

The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), and %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).

Typically this function shouldn't be called directly.  It is much easier to make
use of the custom formatter by calling one of the convenience functions such as
c.Printf, c.Println, or c.Printf.
*/
func (c *ConfigState) NewFormatter(v interface{}) fmt.Formatter {
	return newFormatter(c, v)
}

// Fdump formats and displays the passed arguments to io.Writer w.  It formats
// exactly the same as Dump.
func (c *ConfigState) Fdump(w io.Writer, a ...interface{}) {
	fdump(c, w, a...)
}

/*
Dump displays the passed parameters to standard out with newlines, customizable
indentation, and additional debug information such as complete types and all
pointer addresses used to indirect to the final value.  It provides the
following features over the built-in printing facilities provided by the fmt
package:

	* Pointers are dereferenced and followed
	* Circular data structures are detected and handled properly
	* Custom Stringer/error interfaces are optionally invoked, including
	  on unexported types
	* Custom types which only implement the Stringer/error interfaces via
	  a pointer receiver are optionally invoked when passing non-pointer
	  variables
	* Byte arrays and slices are dumped like the hexdump -C command which
	  includes offsets, byte values in hex, and ASCII output

The configuration options are controlled by modifying the public members
of c.  See ConfigState for options documentation.

See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
get the formatted result as a string.
*/
func (c *ConfigState) Dump(a ...interface{}) {
	fdump(c, os.Stdout, a...)
}

// Sdump returns a string with the passed arguments formatted exactly the same
// as Dump.
func (c *ConfigState) Sdump(a ...interface{}) string {
	var buf bytes.Buffer
	fdump(c, &buf, a...)
	return buf.String()
}

// convertArgs accepts a slice of arguments and returns a slice of the same
// length with each argument converted to a spew Formatter interface using
// the ConfigState associated with s.
func (c *ConfigState) convertArgs(args []interface{}) (formatters []interface{}) {
	formatters = make([]interface{}, len(args))
	for index, arg := range args {
		formatters[index] = newFormatter(c, arg)
	}
	return formatters
}

// NewDefaultConfig returns a ConfigState with the following default settings.
//
// 	Indent: " "
// 	MaxDepth: 0
// 	DisableMethods: false
// 	DisablePointerMethods: false
// 	ContinueOnMethod: false
// 	SortKeys: false
func NewDefaultConfig() *ConfigState {
	return &ConfigState{Indent: " "}
}

+ f b28885f61e7032d7996e1d4152a0fd3b508a23d7d14c1428400d7524081854e0 vendor/github.com/davecgh/go-spew/spew/doc.go
utf8file 212
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
Package spew implements a deep pretty printer for Go data structures to aid in
debugging.

A quick overview of the additional features spew provides over the built-in
printing facilities for Go data types are as follows:

	* Pointers are dereferenced and followed
	* Circular data structures are detected and handled properly
	* Custom Stringer/error interfaces are optionally invoked, including
	  on unexported types
	* Custom types which only implement the Stringer/error interfaces via
	  a pointer receiver are optionally invoked when passing non-pointer
	  variables
	* Byte arrays and slices are dumped like the hexdump -C command which
	  includes offsets, byte values in hex, and ASCII output (only when using
	  Dump style)

There are two different approaches spew allows for dumping Go data structures:

	* Dump style which prints with newlines, customizable indentation,
	  and additional debug information such as types and all pointer addresses
	  used to indirect to the final value
	* A custom Formatter interface that integrates cleanly with the standard fmt
	  package and replaces %v, %+v, %#v, and %#+v to provide inline printing
	  similar to the default %v while providing the additional functionality
	  outlined above and passing unsupported format verbs such as %x and %q
	  along to fmt

Quick Start

This section demonstrates how to quickly get started with spew.  See the
sections below for further details on formatting and configuration options.

To dump a variable with full newlines, indentation, type, and pointer
information use Dump, Fdump, or Sdump:
	spew.Dump(myVar1, myVar2, ...)
	spew.Fdump(someWriter, myVar1, myVar2, ...)
	str := spew.Sdump(myVar1, myVar2, ...)

Alternatively, if you would prefer to use format strings with a compacted inline
printing style, use the convenience wrappers Printf, Fprintf, etc with
%v (most compact), %+v (adds pointer addresses), %#v (adds types), or
%#+v (adds types and pointer addresses):
	spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
	spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
	spew.Fprintf(someWriter, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
	spew.Fprintf(someWriter, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)

Configuration Options

Configuration of spew is handled by fields in the ConfigState type.  For
convenience, all of the top-level functions use a global state available
via the spew.Config global.

It is also possible to create a ConfigState instance that provides methods
equivalent to the top-level functions.  This allows concurrent configuration
options.  See the ConfigState documentation for more details.

The following configuration options are available:
	* Indent
		String to use for each indentation level for Dump functions.
		It is a single space by default.  A popular alternative is "\t".

	* MaxDepth
		Maximum number of levels to descend into nested data structures.
		There is no limit by default.

	* DisableMethods
		Disables invocation of error and Stringer interface methods.
		Method invocation is enabled by default.

	* DisablePointerMethods
		Disables invocation of error and Stringer interface methods on types
		which only accept pointer receivers from non-pointer variables.
		Pointer method invocation is enabled by default.

	* DisablePointerAddresses
		DisablePointerAddresses specifies whether to disable the printing of
		pointer addresses. This is useful when diffing data structures in tests.

	* DisableCapacities
		DisableCapacities specifies whether to disable the printing of
		capacities for arrays, slices, maps and channels. This is useful when
		diffing data structures in tests.

	* ContinueOnMethod
		Enables recursion into types after invoking error and Stringer interface
		methods. Recursion after method invocation is disabled by default.

	* SortKeys
		Specifies map keys should be sorted before being printed. Use
		this to have a more deterministic, diffable output.  Note that
		only native types (bool, int, uint, floats, uintptr and string)
		and types which implement error or Stringer interfaces are
		supported with other types sorted according to the
		reflect.Value.String() output which guarantees display
		stability.  Natural map order is used by default.

	* SpewKeys
		Specifies that, as a last resort attempt, map keys should be
		spewed to strings and sorted by those strings.  This is only
		considered if SortKeys is true.

Dump Usage

Simply call spew.Dump with a list of variables you want to dump:

	spew.Dump(myVar1, myVar2, ...)

You may also call spew.Fdump if you would prefer to output to an arbitrary
io.Writer.  For example, to dump to standard error:

	spew.Fdump(os.Stderr, myVar1, myVar2, ...)

A third option is to call spew.Sdump to get the formatted output as a string:

	str := spew.Sdump(myVar1, myVar2, ...)

Sample Dump Output

See the Dump example for details on the setup of the types and variables being
shown here.

	(main.Foo) {
	 unexportedField: (*main.Bar)(0xf84002e210)({
	  flag: (main.Flag) flagTwo,
	  data: (uintptr) <nil>
	 }),
	 ExportedField: (map[interface {}]interface {}) (len=1) {
	  (string) (len=3) "one": (bool) true
	 }
	}

Byte (and uint8) arrays and slices are displayed uniquely like the hexdump -C
command as shown.
	([]uint8) (len=32 cap=32) {
	 00000000  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 20  |............... |
	 00000010  21 22 23 24 25 26 27 28  29 2a 2b 2c 2d 2e 2f 30  |!"#$%&'()*+,-./0|
	 00000020  31 32                                             |12|
	}

Custom Formatter

Spew provides a custom formatter that implements the fmt.Formatter interface
so that it integrates cleanly with standard fmt package printing functions. The
formatter is useful for inline printing of smaller data types similar to the
standard %v format specifier.

The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).

Custom Formatter Usage

The simplest way to make use of the spew custom formatter is to call one of the
convenience functions such as spew.Printf, spew.Println, or spew.Printf.  The
functions have syntax you are most likely already familiar with:

	spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
	spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
	spew.Println(myVar, myVar2)
	spew.Fprintf(os.Stderr, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
	spew.Fprintf(os.Stderr, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)

See the Index for the full list convenience functions.

Sample Formatter Output

Double pointer to a uint8:
	  %v: <**>5
	 %+v: <**>(0xf8400420d0->0xf8400420c8)5
	 %#v: (**uint8)5
	%#+v: (**uint8)(0xf8400420d0->0xf8400420c8)5

Pointer to circular struct with a uint8 field and a pointer to itself:
	  %v: <*>{1 <*><shown>}
	 %+v: <*>(0xf84003e260){ui8:1 c:<*>(0xf84003e260)<shown>}
	 %#v: (*main.circular){ui8:(uint8)1 c:(*main.circular)<shown>}
	%#+v: (*main.circular)(0xf84003e260){ui8:(uint8)1 c:(*main.circular)(0xf84003e260)<shown>}

See the Printf example for details on the setup of variables being shown
here.

Errors

Since it is possible for custom Stringer/error interfaces to panic, spew
detects them and handles them internally by printing the panic information
inline with the output.  Since spew is intended to provide deep pretty printing
capabilities on structures, it intentionally does not return any errors.
*/
package spew

+ f 6d4be861a2b95e7cf5ee1be0258423e099643ca4702c6887040d696456c72d53 vendor/github.com/davecgh/go-spew/spew/dump.go
utf8file 510
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package spew

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"
)

var (
	// uint8Type is a reflect.Type representing a uint8.  It is used to
	// convert cgo types to uint8 slices for hexdumping.
	uint8Type = reflect.TypeOf(uint8(0))

	// cCharRE is a regular expression that matches a cgo char.
	// It is used to detect character arrays to hexdump them.
	cCharRE = regexp.MustCompile(`^.*\._Ctype_char$`)

	// cUnsignedCharRE is a regular expression that matches a cgo unsigned
	// char.  It is used to detect unsigned character arrays to hexdump
	// them.
	cUnsignedCharRE = regexp.MustCompile(`^.*\._Ctype_unsignedchar$`)

	// cUint8tCharRE is a regular expression that matches a cgo uint8_t.
	// It is used to detect uint8_t arrays to hexdump them.
	cUint8tCharRE = regexp.MustCompile(`^.*\._Ctype_uint8_t$`)
)

// dumpState contains information about the state of a dump operation.
type dumpState struct {
	w                io.Writer
	depth            int
	pointers         map[uintptr]int
	ignoreNextType   bool
	ignoreNextIndent bool
	cs               *ConfigState
}

// indent performs indentation according to the depth level and cs.Indent
// option.
func (d *dumpState) indent() {
	if d.ignoreNextIndent {
		d.ignoreNextIndent = false
		return
	}
	d.w.Write(bytes.Repeat([]byte(d.cs.Indent), d.depth))
}

// unpackValue returns values inside of non-nil interfaces when possible.
// This is useful for data types like structs, arrays, slices, and maps which
// can contain varying types packed inside an interface.
func (d *dumpState) unpackValue(v reflect.Value) reflect.Value {
	if v.Kind() == reflect.Interface && !v.IsNil() {
		v = v.Elem()
	}
	return v
}

// dumpPtr handles formatting of pointers by indirecting them as necessary.
func (d *dumpState) dumpPtr(v reflect.Value) {
	// Remove pointers at or below the current depth from map used to detect
	// circular refs.
	for k, depth := range d.pointers {
		if depth >= d.depth {
			delete(d.pointers, k)
		}
	}

	// Keep list of all dereferenced pointers to show later.
	pointerChain := make([]uintptr, 0)

	// Figure out how many levels of indirection there are by dereferencing
	// pointers and unpacking interfaces down the chain while detecting circular
	// references.
	nilFound := false
	cycleFound := false
	indirects := 0
	ve := v
	for ve.Kind() == reflect.Ptr {
		if ve.IsNil() {
			nilFound = true
			break
		}
		indirects++
		addr := ve.Pointer()
		pointerChain = append(pointerChain, addr)
		if pd, ok := d.pointers[addr]; ok && pd < d.depth {
			cycleFound = true
			indirects--
			break
		}
		d.pointers[addr] = d.depth

		ve = ve.Elem()
		if ve.Kind() == reflect.Interface {
			if ve.IsNil() {
				nilFound = true
				break
			}
			ve = ve.Elem()
		}
	}

	// Display type information.
	d.w.Write(openParenBytes)
	d.w.Write(bytes.Repeat(asteriskBytes, indirects))
	d.w.Write([]byte(ve.Type().String()))
	d.w.Write(closeParenBytes)

	// Display pointer information.
	if !d.cs.DisablePointerAddresses && len(pointerChain) > 0 {
		d.w.Write(openParenBytes)
		for i, addr := range pointerChain {
			if i > 0 {
				d.w.Write(pointerChainBytes)
			}
			printHexPtr(d.w, addr)
		}
		d.w.Write(closeParenBytes)
	}

	// Display dereferenced value.
	d.w.Write(openParenBytes)
	switch {
	case nilFound:
		d.w.Write(nilAngleBytes)

	case cycleFound:
		d.w.Write(circularBytes)

	default:
		d.ignoreNextType = true
		d.dump(ve)
	}
	d.w.Write(closeParenBytes)
}

// dumpSlice handles formatting of arrays and slices.  Byte (uint8 under
// reflection) arrays and slices are dumped in hexdump -C fashion.
func (d *dumpState) dumpSlice(v reflect.Value) {
	// Determine whether this type should be hex dumped or not.  Also,
	// for types which should be hexdumped, try to use the underlying data
	// first, then fall back to trying to convert them to a uint8 slice.
	var buf []uint8
	doConvert := false
	doHexDump := false
	numEntries := v.Len()
	if numEntries > 0 {
		vt := v.Index(0).Type()
		vts := vt.String()
		switch {
		// C types that need to be converted.
		case cCharRE.MatchString(vts):
			fallthrough
		case cUnsignedCharRE.MatchString(vts):
			fallthrough
		case cUint8tCharRE.MatchString(vts):
			doConvert = true

		// Try to use existing uint8 slices and fall back to converting
		// and copying if that fails.
		case vt.Kind() == reflect.Uint8:
			// We need an addressable interface to convert the type
			// to a byte slice.  However, the reflect package won't
			// give us an interface on certain things like
			// unexported struct fields in order to enforce
			// visibility rules.  We use unsafe, when available, to
			// bypass these restrictions since this package does not
			// mutate the values.
			vs := v
			if !vs.CanInterface() || !vs.CanAddr() {
				vs = unsafeReflectValue(vs)
			}
			if !UnsafeDisabled {
				vs = vs.Slice(0, numEntries)

				// Use the existing uint8 slice if it can be
				// type asserted.
				iface := vs.Interface()
				if slice, ok := iface.([]uint8); ok {
					buf = slice
					doHexDump = true
					break
				}
			}

			// The underlying data needs to be converted if it can't
			// be type asserted to a uint8 slice.
			doConvert = true
		}

		// Copy and convert the underlying type if needed.
		if doConvert && vt.ConvertibleTo(uint8Type) {
			// Convert and copy each element into a uint8 byte
			// slice.
			buf = make([]uint8, numEntries)
			for i := 0; i < numEntries; i++ {
				vv := v.Index(i)
				buf[i] = uint8(vv.Convert(uint8Type).Uint())
			}
			doHexDump = true
		}
	}

	// Hexdump the entire slice as needed.
	if doHexDump {
		indent := strings.Repeat(d.cs.Indent, d.depth)
		str := indent + hex.Dump(buf)
		str = strings.Replace(str, "\n", "\n"+indent, -1)
		str = strings.TrimRight(str, d.cs.Indent)
		d.w.Write([]byte(str))
		return
	}

	// Recursively call dump for each item.
	for i := 0; i < numEntries; i++ {
		d.dump(d.unpackValue(v.Index(i)))
		if i < (numEntries - 1) {
			d.w.Write(commaNewlineBytes)
		} else {
			d.w.Write(newlineBytes)
		}
	}
}

// dump is the main workhorse for dumping a value.  It uses the passed reflect
// value to figure out what kind of object we are dealing with and formats it
// appropriately.  It is a recursive function, however circular data structures
// are detected and handled properly.
func (d *dumpState) dump(v reflect.Value) {
	// Handle invalid reflect values immediately.
	kind := v.Kind()
	if kind == reflect.Invalid {
		d.w.Write(invalidAngleBytes)
		return
	}

	// Handle pointers specially.
	if kind == reflect.Ptr {
		d.indent()
		d.dumpPtr(v)
		return
	}

	// Print type information unless already handled elsewhere.
	if !d.ignoreNextType {
		d.indent()
		d.w.Write(openParenBytes)
		d.w.Write([]byte(v.Type().String()))
		d.w.Write(closeParenBytes)
		d.w.Write(spaceBytes)
	}
	d.ignoreNextType = false

	// Display length and capacity if the built-in len and cap functions
	// work with the value's kind and the len/cap itself is non-zero.
	valueLen, valueCap := 0, 0
	switch v.Kind() {
	case reflect.Array, reflect.Slice, reflect.Chan:
		valueLen, valueCap = v.Len(), v.Cap()
	case reflect.Map, reflect.String:
		valueLen = v.Len()
	}
	if valueLen != 0 || !d.cs.DisableCapacities && valueCap != 0 {
		d.w.Write(openParenBytes)
		if valueLen != 0 {
			d.w.Write(lenEqualsBytes)
			printInt(d.w, int64(valueLen), 10)
		}
		if !d.cs.DisableCapacities && valueCap != 0 {
			if valueLen != 0 {
				d.w.Write(spaceBytes)
			}
			d.w.Write(capEqualsBytes)
			printInt(d.w, int64(valueCap), 10)
		}
		d.w.Write(closeParenBytes)
		d.w.Write(spaceBytes)
	}

	// Call Stringer/error interfaces if they exist and the handle methods flag
	// is enabled
	if !d.cs.DisableMethods {
		if (kind != reflect.Invalid) && (kind != reflect.Interface) {
			if handled := handleMethods(d.cs, d.w, v); handled {
				return
			}
		}
	}

	switch kind {
	case reflect.Invalid:
		// Do nothing.  We should never get here since invalid has already
		// been handled above.

	case reflect.Bool:
		printBool(d.w, v.Bool())

	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		printInt(d.w, v.Int(), 10)

	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		printUint(d.w, v.Uint(), 10)

	case reflect.Float32:
		printFloat(d.w, v.Float(), 32)

	case reflect.Float64:
		printFloat(d.w, v.Float(), 64)

	case reflect.Complex64:
		printComplex(d.w, v.Complex(), 32)

	case reflect.Complex128:
		printComplex(d.w, v.Complex(), 64)

	case reflect.Slice:
		if v.IsNil() {
			d.w.Write(nilAngleBytes)
			break
		}
		fallthrough

	case reflect.Array:
		d.w.Write(openBraceNewlineBytes)
		d.depth++
		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
			d.indent()
			d.w.Write(maxNewlineBytes)
		} else {
			d.dumpSlice(v)
		}
		d.depth--
		d.indent()
		d.w.Write(closeBraceBytes)

	case reflect.String:
		d.w.Write([]byte(strconv.Quote(v.String())))

	case reflect.Interface:
		// The only time we should get here is for nil interfaces due to
		// unpackValue calls.
		if v.IsNil() {
			d.w.Write(nilAngleBytes)
		}

	case reflect.Ptr:
		// Do nothing.  We should never get here since pointers have already
		// been handled above.

	case reflect.Map:
		// nil maps should be indicated as different than empty maps
		if v.IsNil() {
			d.w.Write(nilAngleBytes)
			break
		}

		d.w.Write(openBraceNewlineBytes)
		d.depth++
		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
			d.indent()
			d.w.Write(maxNewlineBytes)
		} else {
			numEntries := v.Len()
			keys := v.MapKeys()
			if d.cs.SortKeys {
				sortValues(keys, d.cs)
			}
			for i, key := range keys {
				d.dump(d.unpackValue(key))
				d.w.Write(colonSpaceBytes)
				d.ignoreNextIndent = true
				d.dump(d.unpackValue(v.MapIndex(key)))
				if i < (numEntries - 1) {
					d.w.Write(commaNewlineBytes)
				} else {
					d.w.Write(newlineBytes)
				}
			}
		}
		d.depth--
		d.indent()
		d.w.Write(closeBraceBytes)

	case reflect.Struct:
		d.w.Write(openBraceNewlineBytes)
		d.depth++
		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
			d.indent()
			d.w.Write(maxNewlineBytes)
		} else {
			vt := v.Type()
			numFields := v.NumField()
			for i := 0; i < numFields; i++ {
				d.indent()
				vtf := vt.Field(i)
				d.w.Write([]byte(vtf.Name))
				d.w.Write(colonSpaceBytes)
				d.ignoreNextIndent = true
				d.dump(d.unpackValue(v.Field(i)))
				if i < (numFields - 1) {
					d.w.Write(commaNewlineBytes)
				} else {
					d.w.Write(newlineBytes)
				}
			}
		}
		d.depth--
		d.indent()
		d.w.Write(closeBraceBytes)

	case reflect.Uintptr:
		printHexPtr(d.w, uintptr(v.Uint()))

	case reflect.UnsafePointer, reflect.Chan, reflect.Func:
		printHexPtr(d.w, v.Pointer())

	// There were not any other types at the time this code was written, but
	// fall back to letting the default fmt package handle it in case any new
	// types are added.
	default:
		if v.CanInterface() {
			fmt.Fprintf(d.w, "%v", v.Interface())
		} else {
			fmt.Fprintf(d.w, "%v", v.String())
		}
	}
}

// fdump is a helper function to consolidate the logic from the various public
// methods which take varying writers and config states.
func fdump(cs *ConfigState, w io.Writer, a ...interface{}) {
	for _, arg := range a {
		if arg == nil {
			w.Write(interfaceBytes)
			w.Write(spaceBytes)
			w.Write(nilAngleBytes)
			w.Write(newlineBytes)
			continue
		}

		d := dumpState{w: w, cs: cs}
		d.pointers = make(map[uintptr]int)
		d.dump(reflect.ValueOf(arg))
		d.w.Write(newlineBytes)
	}
}

// Fdump formats and displays the passed arguments to io.Writer w.  It formats
// exactly the same as Dump.
func Fdump(w io.Writer, a ...interface{}) {
	fdump(&Config, w, a...)
}

// Sdump returns a string with the passed arguments formatted exactly the same
// as Dump.
func Sdump(a ...interface{}) string {
	var buf bytes.Buffer
	fdump(&Config, &buf, a...)
	return buf.String()
}

/*
Dump displays the passed parameters to standard out with newlines, customizable
indentation, and additional debug information such as complete types and all
pointer addresses used to indirect to the final value.  It provides the
following features over the built-in printing facilities provided by the fmt
package:

	* Pointers are dereferenced and followed
	* Circular data structures are detected and handled properly
	* Custom Stringer/error interfaces are optionally invoked, including
	  on unexported types
	* Custom types which only implement the Stringer/error interfaces via
	  a pointer receiver are optionally invoked when passing non-pointer
	  variables
	* Byte arrays and slices are dumped like the hexdump -C command which
	  includes offsets, byte values in hex, and ASCII output

The configuration options are controlled by an exported package global,
spew.Config.  See ConfigState for options documentation.

See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
get the formatted result as a string.
*/
func Dump(a ...interface{}) {
	fdump(&Config, os.Stdout, a...)
}

+ f f2bb8777293f2600e1201ce81edc32647d5b33af97592fc01f1125b74f799cbd vendor/github.com/davecgh/go-spew/spew/format.go
utf8file 420
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package spew

import (
	"bytes"
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

// supportedFlags is a list of all the character flags supported by fmt package.
const supportedFlags = "0-+# "

// formatState implements the fmt.Formatter interface and contains information
// about the state of a formatting operation.  The NewFormatter function can
// be used to get a new Formatter which can be used directly as arguments
// in standard fmt package printing calls.
type formatState struct {
	value          interface{}
	fs             fmt.State
	depth          int
	pointers       map[uintptr]int
	ignoreNextType bool
	cs             *ConfigState
}

// buildDefaultFormat recreates the original format string without precision
// and width information to pass in to fmt.Sprintf in the case of an
// unrecognized type.  Unless new types are added to the language, this
// function won't ever be called.
func (f *formatState) buildDefaultFormat() (format string) {
	buf := bytes.NewBuffer(percentBytes)

	for _, flag := range supportedFlags {
		if f.fs.Flag(int(flag)) {
			buf.WriteRune(flag)
		}
	}

	buf.WriteRune('v')

	format = buf.String()
	return format
}

// constructOrigFormat recreates the original format string including precision
// and width information to pass along to the standard fmt package.  This allows
// automatic deferral of all format strings this package doesn't support.
func (f *formatState) constructOrigFormat(verb rune) (format string) {
	buf := bytes.NewBuffer(percentBytes)

	for _, flag := range supportedFlags {
		if f.fs.Flag(int(flag)) {
			buf.WriteRune(flag)
		}
	}

	if width, ok := f.fs.Width(); ok {
		buf.WriteString(strconv.Itoa(width))
	}

	if precision, ok := f.fs.Precision(); ok {
		buf.Write(precisionBytes)
		buf.WriteString(strconv.Itoa(precision))
	}

	buf.WriteRune(verb)

	format = buf.String()
	return format
}

// unpackValue returns values inside of non-nil interfaces when possible and
// ensures that types for values which have been unpacked from an interface
// are displayed when the show types flag is also set.
// This is useful for data types like structs, arrays, slices, and maps which
// can contain varying types packed inside an interface.
func (f *formatState) unpackValue(v reflect.Value) reflect.Value {
	if v.Kind() == reflect.Interface {
		f.ignoreNextType = false
		if !v.IsNil() {
			v = v.Elem()
		}
	}
	return v
}

// formatPtr handles formatting of pointers by indirecting them as necessary.
func (f *formatState) formatPtr(v reflect.Value) {
	// Display nil if top level pointer is nil.
	showTypes := f.fs.Flag('#')
	if v.IsNil() && (!showTypes || f.ignoreNextType) {
		f.fs.Write(nilAngleBytes)
		return
	}

	// Remove pointers at or below the current depth from map used to detect
	// circular refs.
	for k, depth := range f.pointers {
		if depth >= f.depth {
			delete(f.pointers, k)
		}
	}

	// Keep list of all dereferenced pointers to possibly show later.
	pointerChain := make([]uintptr, 0)

	// Figure out how many levels of indirection there are by derferencing
	// pointers and unpacking interfaces down the chain while detecting circular
	// references.
	nilFound := false
	cycleFound := false
	indirects := 0
	ve := v
	for ve.Kind() == reflect.Ptr {
		if ve.IsNil() {
			nilFound = true
			break
		}
		indirects++
		addr := ve.Pointer()
		pointerChain = append(pointerChain, addr)
		if pd, ok := f.pointers[addr]; ok && pd < f.depth {
			cycleFound = true
			indirects--
			break
		}
		f.pointers[addr] = f.depth

		ve = ve.Elem()
		if ve.Kind() == reflect.Interface {
			if ve.IsNil() {
				nilFound = true
				break
			}
			ve = ve.Elem()
		}
	}

	// Display type or indirection level depending on flags.
	if showTypes && !f.ignoreNextType {
		f.fs.Write(openParenBytes)
		f.fs.Write(bytes.Repeat(asteriskBytes, indirects))
		f.fs.Write([]byte(ve.Type().String()))
		f.fs.Write(closeParenBytes)
	} else {
		if nilFound || cycleFound {
			indirects += strings.Count(ve.Type().String(), "*")
		}
		f.fs.Write(openAngleBytes)
		f.fs.Write([]byte(strings.Repeat("*", indirects)))
		f.fs.Write(closeAngleBytes)
	}

	// Display pointer information depending on flags.
	if f.fs.Flag('+') && (len(pointerChain) > 0) {
		f.fs.Write(openParenBytes)
		for i, addr := range pointerChain {
			if i > 0 {
				f.fs.Write(pointerChainBytes)
			}
			printHexPtr(f.fs, addr)
		}
		f.fs.Write(closeParenBytes)
	}

	// Display dereferenced value.
	switch {
	case nilFound:
		f.fs.Write(nilAngleBytes)

	case cycleFound:
		f.fs.Write(circularShortBytes)

	default:
		f.ignoreNextType = true
		f.format(ve)
	}
}

// format is the main workhorse for providing the Formatter interface.  It
// uses the passed reflect value to figure out what kind of object we are
// dealing with and formats it appropriately.  It is a recursive function,
// however circular data structures are detected and handled properly.
func (f *formatState) format(v reflect.Value) {
	// Handle invalid reflect values immediately.
	kind := v.Kind()
	if kind == reflect.Invalid {
		f.fs.Write(invalidAngleBytes)
		return
	}

	// Handle pointers specially.
	if kind == reflect.Ptr {
		f.formatPtr(v)
		return
	}

	// Print type information unless already handled elsewhere.
	if !f.ignoreNextType && f.fs.Flag('#') {
		f.fs.Write(openParenBytes)
		f.fs.Write([]byte(v.Type().String()))
		f.fs.Write(closeParenBytes)
	}
	f.ignoreNextType = false

	// Call Stringer/error interfaces if they exist and the handle methods
	// flag is enabled.
	if !f.cs.DisableMethods {
		if (kind != reflect.Invalid) && (kind != reflect.Interface) {
			if handled := handleMethods(f.cs, f.fs, v); handled {
				return
			}
		}
	}

	switch kind {
	case reflect.Invalid:
		// Do nothing.  We should never get here since invalid has already
		// been handled above.

	case reflect.Bool:
		printBool(f.fs, v.Bool())

	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		printInt(f.fs, v.Int(), 10)

	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		printUint(f.fs, v.Uint(), 10)

	case reflect.Float32:
		printFloat(f.fs, v.Float(), 32)

	case reflect.Float64:
		printFloat(f.fs, v.Float(), 64)

	case reflect.Complex64:
		printComplex(f.fs, v.Complex(), 32)

	case reflect.Complex128:
		printComplex(f.fs, v.Complex(), 64)

	case reflect.Slice:
		if v.IsNil() {
			f.fs.Write(nilAngleBytes)
			break
		}
		fallthrough

	case reflect.Array:
		f.fs.Write(openBracketBytes)
		f.depth++
		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
			f.fs.Write(maxShortBytes)
		} else {
			numEntries := v.Len()
			for i := 0; i < numEntries; i++ {
				if i > 0 {
					f.fs.Write(spaceBytes)
				}
				f.ignoreNextType = true
				f.format(f.unpackValue(v.Index(i)))
			}
		}
		f.depth--
		f.fs.Write(closeBracketBytes)

	case reflect.String:
		f.fs.Write([]byte(v.String()))

	case reflect.Interface:
		// The only time we should get here is for nil interfaces due to
		// unpackValue calls.
		if v.IsNil() {
			f.fs.Write(nilAngleBytes)
		}

	case reflect.Ptr:
		// Do nothing.  We should never get here since pointers have already
		// been handled above.

	case reflect.Map:
		// nil maps should be indicated as different than empty maps
		if v.IsNil() {
			f.fs.Write(nilAngleBytes)
			break
		}

		f.fs.Write(openMapBytes)
		f.depth++
		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
			f.fs.Write(maxShortBytes)
		} else {
			keys := v.MapKeys()
			if f.cs.SortKeys {
				sortValues(keys, f.cs)
			}
			for i, key := range keys {
				if i > 0 {
					f.fs.Write(spaceBytes)
				}
				f.ignoreNextType = true
				f.format(f.unpackValue(key))
				f.fs.Write(colonBytes)
				f.ignoreNextType = true
				f.format(f.unpackValue(v.MapIndex(key)))
			}
		}
		f.depth--
		f.fs.Write(closeMapBytes)

	case reflect.Struct:
		numFields := v.NumField()
		f.fs.Write(openBraceBytes)
		f.depth++
		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
			f.fs.Write(maxShortBytes)
		} else {
			vt := v.Type()
			for i := 0; i < numFields; i++ {
				if i > 0 {
					f.fs.Write(spaceBytes)
				}
				vtf := vt.Field(i)
				if f.fs.Flag('+') || f.fs.Flag('#') {
					f.fs.Write([]byte(vtf.Name))
					f.fs.Write(colonBytes)
				}
				f.format(f.unpackValue(v.Field(i)))
			}
		}
		f.depth--
		f.fs.Write(closeBraceBytes)

	case reflect.Uintptr:
		printHexPtr(f.fs, uintptr(v.Uint()))

	case reflect.UnsafePointer, reflect.Chan, reflect.Func:
		printHexPtr(f.fs, v.Pointer())

	// There were not any other types at the time this code was written, but
	// fall back to letting the default fmt package handle it if any get added.
	default:
		format := f.buildDefaultFormat()
		if v.CanInterface() {
			fmt.Fprintf(f.fs, format, v.Interface())
		} else {
			fmt.Fprintf(f.fs, format, v.String())
		}
	}
}

// Format satisfies the fmt.Formatter interface. See NewFormatter for usage
// details.
func (f *formatState) Format(fs fmt.State, verb rune) {
	f.fs = fs

	// Use standard formatting for verbs that are not v.
	if verb != 'v' {
		format := f.constructOrigFormat(verb)
		fmt.Fprintf(fs, format, f.value)
		return
	}

	if f.value == nil {
		if fs.Flag('#') {
			fs.Write(interfaceBytes)
		}
		fs.Write(nilAngleBytes)
		return
	}

	f.format(reflect.ValueOf(f.value))
}

// newFormatter is a helper function to consolidate the logic from the various
// public methods which take varying config states.
func newFormatter(cs *ConfigState, v interface{}) fmt.Formatter {
	fs := &formatState{value: v, cs: cs}
	fs.pointers = make(map[uintptr]int)
	return fs
}

/*
NewFormatter returns a custom formatter that satisfies the fmt.Formatter
interface.  As a result, it integrates cleanly with standard fmt package
printing functions.  The formatter is useful for inline printing of smaller data
types similar to the standard %v format specifier.

The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).

Typically this function shouldn't be called directly.  It is much easier to make
use of the custom formatter by calling one of the convenience functions such as
Printf, Println, or Fprintf.
*/
func NewFormatter(v interface{}) fmt.Formatter {
	return newFormatter(&Config, v)
}

+ f abb3ec05a83d6a4a9e82e57b860af6a0014eb89bc40f9d234b83cbf69cb132dc vendor/github.com/davecgh/go-spew/spew/spew.go
utf8file 149
/*
 * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package spew

import (
	"fmt"
	"io"
)

// Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the formatted string as a value that satisfies error.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Errorf(format, spew.NewFormatter(a), spew.NewFormatter(b))
func Errorf(format string, a ...interface{}) (err error) {
	return fmt.Errorf(format, convertArgs(a)...)
}

// Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprint(w, spew.NewFormatter(a), spew.NewFormatter(b))
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	return fmt.Fprint(w, convertArgs(a)...)
}

// Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprintf(w, format, spew.NewFormatter(a), spew.NewFormatter(b))
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
	return fmt.Fprintf(w, format, convertArgs(a)...)
}

// Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
// passed with a default Formatter interface returned by NewFormatter.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Fprintln(w, spew.NewFormatter(a), spew.NewFormatter(b))
func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
	return fmt.Fprintln(w, convertArgs(a)...)
}

// Print is a wrapper for fmt.Print that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Print(spew.NewFormatter(a), spew.NewFormatter(b))
func Print(a ...interface{}) (n int, err error) {
	return fmt.Print(convertArgs(a)...)
}

// Printf is a wrapper for fmt.Printf that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Printf(format, spew.NewFormatter(a), spew.NewFormatter(b))
func Printf(format string, a ...interface{}) (n int, err error) {
	return fmt.Printf(format, convertArgs(a)...)
}

// Println is a wrapper for fmt.Println that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the number of bytes written and any write error encountered.  See
// NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Println(spew.NewFormatter(a), spew.NewFormatter(b))
func Println(a ...interface{}) (n int, err error) {
	return fmt.Println(convertArgs(a)...)
}

// Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprint(spew.NewFormatter(a), spew.NewFormatter(b))
func Sprint(a ...interface{}) string {
	return fmt.Sprint(convertArgs(a)...)
}

// Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
// passed with a default Formatter interface returned by NewFormatter.  It
// returns the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprintf(format, spew.NewFormatter(a), spew.NewFormatter(b))
func Sprintf(format string, a ...interface{}) string {
	return fmt.Sprintf(format, convertArgs(a)...)
}

// Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
// were passed with a default Formatter interface returned by NewFormatter.  It
// returns the resulting string.  See NewFormatter for formatting details.
//
// This function is shorthand for the following syntax:
//
//	fmt.Sprintln(spew.NewFormatter(a), spew.NewFormatter(b))
func Sprintln(a ...interface{}) string {
	return fmt.Sprintln(convertArgs(a)...)
}

// convertArgs accepts a slice of arguments and returns a slice of the same
// length with each argument converted to a default spew Formatter interface.
func convertArgs(args []interface{}) (formatters []interface{}) {
	formatters = make([]interface{}, len(args))
	for index, arg := range args {
		formatters[index] = NewFormatter(arg)
	}
	return formatters
}

- f 37a29a29cf330257b9dcb093be7697ea966d8a8811d9d80cb3886351176dfc2d vendor/github.com/fatih/color/.travis.yml
- f b48c28aa4720c070e936675fe386d6512ba1d045b8a6044b301d7739699395b6 vendor/github.com/fatih/color/Gopkg.lock
- f 26876e110d2bac5a95c31965dc85f230a30cf202d012cba93b37c4042378a299 vendor/github.com/fatih/color/Gopkg.toml
- f 3ef1b3417bb6c37894318d27520cb30ab7a21593b448f973e057fb14b7fba4e2 vendor/github.com/fatih/color/README.md
+ f bf372701752f8029a9b9e237eff9f09004f902480637f06ebd4801b932353602 vendor/github.com/fatih/color/README.md
dmppatch 12
@@ -1,238 +1,503 @@
-# Color %5B!%5BGoDoc%5D(https://godoc.org/github.com/fatih/color?status.svg)%5D(https://godoc.org/github.com/fatih/color) %5B!%5BBuild Status%5D(https://img.shields.io/travis/fatih/color.svg?style=flat-square)%5D(https://travis-ci.org/fatih/color)%0A
+# Archived project. No maintenance. %0A
 %0A
+This project is not maintained anymore and is archived. Feel free to fork and%0Amake your own changes if needed. For more detail read my blog post: %5BTaking an indefinite sabbatical from my projects%5D(https://arslan.io/2018/10/09/taking-an-indefinite-sabbatical-from-my-projects/)%0A
 %0A
+Thanks to everyone for their valuable feedback and contributions.%0A%0A%0A# Color %5B!%5BGoDoc%5D(https://godoc.org/github.com/fatih/color?status.svg)%5D(https://godoc.org/github.com/fatih/color) %0A
 %0ACol
@@ -830,133 +830,8 @@
 %60%60%60%0A
-%0ANote that the %60vendor%60 folder is here for stability. Remove the folder if you%0Aalready have the dependencies in your GOPATH.%0A
 %0A## 
+ f c13ad20dd1ccdd163e424c1b5c6ca3681ed37c2a2800d2d25736b5f755b430ed vendor/github.com/fatih/color/go.mod
utf8file 9
module github.com/fatih/color

go 1.13

require (
	github.com/mattn/go-colorable v0.1.4
	github.com/mattn/go-isatty v0.0.11
)

+ f 833ff60d89478a0eaec8cde9e32ab51a30e2dca4b050928c126e50622bae4024 vendor/github.com/fatih/color/go.sum
utf8file 9
github.com/mattn/go-colorable v0.1.4 h1:snbPLB8fVfU9iwbbo30TPtbLRzwWu6aJS6Xh4eaaviA=
github.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.11 h1:FxPOTFNqGkuDUGi3H/qkUbQO4ZiBa2brKq5r0l8TGeM=
github.com/mattn/go-isatty v0.0.11/go.mod h1:PhnuNfih5lzO57/f3n+odYbM4JtupLOxQOAqxQCu2WE=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=

- f 668380ce15d6071ab8d56c218b48d39853607c81acdce5f521c2caeb8a162006 vendor/github.com/frankbraun/codechain/archive/archive.go
+ f 89a68266a49402da64f89ab021826a65d2403279cbd3853309f3b50e5e4def1c vendor/github.com/frankbraun/codechain/archive/archive.go
dmppatch 5
@@ -251,56 +251,52 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22gi
- f b92b46ee3df98710f160a306a4b266665cec807efce3318b9bf5c135d4900647 vendor/github.com/frankbraun/codechain/archive/createdist.go
+ f ffadde29ad8dd443ee91bd2f2bc2c1be9951e2a8ad16884d53816e002b41d17f vendor/github.com/frankbraun/codechain/archive/createdist.go
dmppatch 5
@@ -125,56 +125,52 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22gi
+ f 00e4811a15e326edcde37cccf08cbd2608786b3fce2b3dd6d9d3fda3414dd14e vendor/github.com/frankbraun/codechain/command/addkey.go
utf8file 72
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/log"
)

// AddKey implements the 'addkey' command.
func AddKey(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-w] pubkey signature [comment]\n", argv0)
		fmt.Fprintf(os.Stderr, "Add new signer to hashchain.\n")
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	w := fs.Int("w", 1, "Signature weight w")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *w < 1 {
		return fmt.Errorf("%s: option -w must be >= 1", argv0)
	}
	nArg := fs.NArg()
	if nArg != 2 && nArg != 3 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	pubkey := fs.Arg(0)
	pub, err := base64.Decode(pubkey, 32)
	if err != nil {
		return fmt.Errorf("cannot decode pubkey: %s", err)
	}
	signature := fs.Arg(1)
	sig, err := base64.Decode(signature, 64)
	if err != nil {
		return fmt.Errorf("cannot decode signature: %s", err)
	}
	var comment []byte
	if nArg == 3 {
		comment = []byte(fs.Arg(2))
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	var pubKey [32]byte
	copy(pubKey[:], pub)
	var signtr [64]byte
	copy(signtr[:], sig)
	line, err := c.AddKey(*w, pubKey, signtr, comment)
	if err != nil {
		return err
	}
	fmt.Println(line)
	return nil
}

+ f e09cebb45c368c79d3e7f11844f9eb71d29b5b5ad76b6010947083bd7c1f383f vendor/github.com/frankbraun/codechain/command/apply.go
utf8file 65
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/archive"
	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/log"
)

// Apply implements the 'apply' command.
func Apply(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Apply all patches with enough signatures to code tree.\n")
		fs.PrintDefaults()
	}
	filename := fs.String("f", "", "Distribution file")
	headStr := fs.String("head", "", "Check that the hash chain contains the given head")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	var head *[32]byte
	if *headStr != "" {
		h, err := hex.Decode(*headStr, 32)
		if err != nil {
			return err
		}
		var ha [32]byte
		copy(ha[:], h)
		head = &ha
	}
	if *filename != "" {
		err := archive.ApplyFile(def.HashchainFile, def.PatchDir, *filename, head)
		if err != nil {
			return err
		}
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	if err := c.Close(); err != nil {
		return err
	}
	return c.Apply(head)
}

+ f c9fda1ad7e6ff0678cb690016e41c3e8641cfbfd6910fa7b8c731ce4f0bdf21a vendor/github.com/frankbraun/codechain/command/cleanslate.go
utf8file 71
package command

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/terminal"
)

func cleanSlate() error {
	files, err := ioutil.ReadDir(".")
	if err != nil {
		return err
	}
outer:
	for _, fi := range files {
		if def.ExcludePaths != nil {
			canonical := filepath.ToSlash(fi.Name())
			for _, excludePath := range def.ExcludePaths {
				if excludePath == canonical {
					continue outer
				}
			}
		}
		if fi.IsDir() {
			fmt.Println(fi.Name() + "/")
		} else {
			fmt.Println(fi.Name())
		}
	}

	err = terminal.Confirm("delete all files and directories listed above?")
	if err != nil {
		return err
	}

	return file.RemoveAll(".", def.ExcludePaths)
}

// CleanSlate implements the 'cleanslate' command.
func CleanSlate(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Remove all files except the .codechain dir and special files from current dir.\n")
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	return cleanSlate()
}

+ f 714f8b400851cd539d0d272f8a9adb42a97041d6c815c1498983beb1e7bcdad6 vendor/github.com/frankbraun/codechain/command/command.go
utf8file 15
// Package command implements the Codechain commands.
package command

import (
	"path/filepath"

	"github.com/frankbraun/codechain/util/def"
)

var (
	treeDirRoot = filepath.Join(def.CodechainDir, "tree")
	treeDirA    = filepath.Join(treeDirRoot, "a")
	treeDirB    = filepath.Join(treeDirRoot, "b")
)

+ f 6dfc78ae5d896ff2bd70c7d3366624aa2720ef49aedb82300896ddcf7eca2196 vendor/github.com/frankbraun/codechain/command/createdist.go
utf8file 52
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/archive"
	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/log"
)

// CreateDist implements the 'createdist' command.
func CreateDist(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-f dist.tar.gz]\n", argv0)
		fmt.Fprintf(os.Stderr, "Create distribution file (for `codechain apply -f`).\n")
		fs.PrintDefaults()
	}
	filename := fs.String("f", "", "Distribution file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	if *filename == "" {
		*filename = fmt.Sprintf("%x.tar.gz", c.Head())
	}
	if err := archive.CreateDist(c, *filename); err != nil {
		return err
	}
	fmt.Println(*filename)
	return nil
}

+ f eaefde96169d1efab9293dfe6757167ead59d2d7736a944124542bed2798521a vendor/github.com/frankbraun/codechain/command/keyfile.go
utf8file 124
package command

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/frankbraun/codechain/keyfile"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/bzero"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/frankbraun/codechain/util/terminal"
)

func changePassphrase(filename string, sec, sig *[64]byte, comment []byte) error {
	pass, err := terminal.ReadPassphrase(syscall.Stdin, true)
	if err != nil {
		return err
	}
	defer bzero.Bytes(pass)
	tmpfile := filename + ".new"
	os.Remove(tmpfile) // ignore error
	// create new keyfile
	if err := keyfile.Create(tmpfile, pass, *sec, *sig, comment); err != nil {
		return err
	}
	// move temp. file in place
	return os.Rename(tmpfile, filename)
}

func listKeys(homeDir string) error {
	secretsDir := filepath.Join(homeDir, def.SecretsSubDir)
	files, err := ioutil.ReadDir(secretsDir)
	if err != nil {
		return err
	}
	for _, fi := range files {
		filename := filepath.Join(secretsDir, fi.Name())
		fmt.Println(filename)
		f, err := os.Open(filename)
		if err != nil {
			return err
		}
		line, err := bufio.NewReader(f).ReadString('\n')
		if err != nil {
			f.Close()
			return err
		}
		f.Close()
		fields := strings.SplitN(line, " ", 3)
		if len(fields) == 3 {
			fmt.Print(fields[2])
		}
		fmt.Println()
	}
	return nil
}

// KeyFile implements the 'keyfile' command.
func KeyFile(checkUpToDate, homeDir, argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s -s seckey.bin\n", argv0)
		fmt.Fprintf(os.Stderr, "Show pubkey, signature, and comment for encrypted secret key file.\n")
		fs.PrintDefaults()
	}
	change := fs.Bool("c", false, "Change passphrase")
	list := fs.Bool("l", false, "List keyfiles")
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *change && *list {
		return fmt.Errorf("%s: options -c and -l exclude each other", argv0)
	}
	if *secKey != "" && *list {
		return fmt.Errorf("%s: options -s and -l exclude each other", argv0)
	}
	if *secKey == "" && !*list {
		return fmt.Errorf("%s: option -s is mandatory", argv0)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate(checkUpToDate); err != nil {
		return err
	}
	if *list {
		return listKeys(homeDir)
	}
	sec, sig, comment, err := seckey.Read(*secKey)
	if err != nil {
		return err
	}
	if *change {
		fmt.Printf("%s read, please provide new ", *secKey)
		if err := changePassphrase(*secKey, sec, sig, comment); err != nil {
			return err
		}
		fmt.Println("passphrase changed")
	} else {
		fmt.Println("public key with signature and optional comment:")
		fmt.Printf("%s %s", base64.Encode(sec[32:]), base64.Encode(sig[:]))
		if len(comment) > 0 {
			fmt.Printf(" '%s'", string(comment))
		}
		fmt.Println("")
	}
	return nil
}

+ f 4cc48e5f8079214845fab36b1780707e73896191847305a996cedf44c07fad8e vendor/github.com/frankbraun/codechain/command/keygen.go
utf8file 119
package command

import (
	"crypto/ed25519"
	"crypto/rand"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"syscall"

	"github.com/frankbraun/codechain/keyfile"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/bzero"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/frankbraun/codechain/util/terminal"
)

// TestComment is a comment used for testing purposes. Do not set!
var TestComment string

// KeyGen implements the 'keygen' command.
func KeyGen(checkUpToDate, homeDir, argv0 string, args ...string) error {
	var (
		secretsDir string
		pass       []byte
		comment    []byte
		err        error
	)
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-s seckey.bin]\n", argv0)
		fmt.Fprintf(os.Stderr, "Generate new encrypted secret key file and show pubkey, signature, and comment.\n")
		fs.PrintDefaults()
	}
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate(checkUpToDate); err != nil {
		return err
	}
	if *secKey != "" {
		exists, err := file.Exists(*secKey)
		if err != nil {
			return err
		}
		if exists {
			return fmt.Errorf("file '%s' exists already", *secKey)
		}
	} else {
		secretsDir = filepath.Join(homeDir, def.SecretsSubDir)
		if err := os.MkdirAll(secretsDir, 0700); err != nil {
			return err
		}
	}
	if seckey.TestPass == "" {
		pass, err = terminal.ReadPassphrase(syscall.Stdin, true)
		if err != nil {
			return err
		}
		defer bzero.Bytes(pass)
	} else {
		pass = []byte(seckey.TestPass)
	}
	if TestComment == "" {
		fmt.Println("comment (e.g., John Doe <john@example.com>; can be empty; cannot be changed):")
		comment, err = terminal.ReadLine(os.Stdin)
		if err != nil {
			return err
		}
	} else {
		comment = []byte(TestComment)
	}
	pub, sec, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return err
	}
	sig := ed25519.Sign(sec, append(pub, comment...))
	pubEnc := base64.Encode(pub[:])
	var sk [64]byte
	copy(sk[:], sec)
	var signature [64]byte
	copy(signature[:], sig)
	if *secKey != "" {
		err := keyfile.Create(*secKey, pass, sk, signature, comment)
		if err != nil {
			return err
		}
	} else {
		filename := filepath.Join(secretsDir, pubEnc)
		err := keyfile.Create(filename, pass, sk, signature, comment)
		if err != nil {
			return err
		}
		fmt.Println("secret key file created:")
		fmt.Println(filename)
	}
	fmt.Println("public key with signature and optional comment:")
	fmt.Printf("%s %s", pubEnc, base64.Encode(sig))
	if len(comment) > 0 {
		fmt.Printf(" '%s'", string(comment))
	}
	fmt.Println("")
	return nil
}

+ f 1177dfff0cfdc09e4bc0b606b090e729fa557434f265fd94bdce33bcc67dc126 vendor/github.com/frankbraun/codechain/command/publish.go
utf8file 228
package command

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/patchfile"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/sync"
	"github.com/frankbraun/codechain/tree"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/git"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/homedir"
	"github.com/frankbraun/codechain/util/interrupt"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/frankbraun/codechain/util/terminal"
)

func publish(
	c *hashchain.HashChain, secKeyFile, message string,
	dryRun, useGit, yesPrompt bool,
	version int,
) error {
	var (
		secKey *[64]byte
		err    error
	)

	// get last published treehash
	treeHash := c.LastTreeHash()

	// make sure patch file doesn't exist for last tree hash
	patchFile := filepath.Join(def.PatchDir, treeHash)
	exists, err := file.Exists(patchFile)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("%s: patch file already exists", patchFile)
	}

	// calculate current treehash
	curHash, err := tree.Hash(".", def.ExcludePaths)
	if err != nil {
		return err
	}
	curHashStr := hex.Encode(curHash[:])
	log.Printf("current tree hash: %s", curHashStr)

	// make sure the tree is dirty
	if curHashStr == treeHash {
		return fmt.Errorf("tree not dirty, nothing to publish")
	}

	// load secret key
	if !dryRun {
		secKey, _, _, err = seckey.Load(c, homedir.Codechain(), secKeyFile)
		if err != nil {
			return err
		}
	}

	// bring .codechain/tree/a in sync with last published treehash
	log.Println("sync tree/a")
	treeHashes := c.TreeHashes()
	err = sync.Dir(treeDirA, treeHash, def.PatchDir, treeHashes, def.ExcludePaths, true)
	if err != nil {
		return err
	}
	log.Println("done")

	// bring .codechain/tree/b in sync with the tree hash to be published
	tmpHash, err := tree.Hash(treeDirB, def.ExcludePaths)
	if err != nil {
		return err
	}
	if !bytes.Equal(curHash[:], tmpHash[:]) {
		if err := os.RemoveAll(treeDirB); err != nil {
			return err
		}
		if err := file.CopyDirExclude(".", treeDirB, def.ExcludePaths); err != nil {
			return err
		}
	}

	if useGit && !yesPrompt {
		// display diff pager
		if err := git.DiffPager(treeDirA, treeDirB); err != nil {
			return err
		}
	} else {
		fmt.Println("the patch to publish is the diff between the following two directries:")
		fmt.Println(treeDirA)
		fmt.Println(treeDirB)
	}
	if dryRun {
		return nil
	}

	// confirm patch
	if yesPrompt {
		fmt.Println("patch published automatically (-y was used).")
	} else {
		if err := terminal.Confirm("publish patch?"); err != nil {
			return err
		}
	}

	// read comment
	var comment []byte
	if message != "" {
		comment = []byte(message)
	} else {
		fmt.Println("comment describing code change (can be empty; cannot be changed later):")
		comment, err = terminal.ReadLine(os.Stdin)
		if err != nil {
			return err
		}
	}

	// get and write patch
	f, err := os.OpenFile(patchFile, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0644)
	if err != nil {
		return err
	}
	err = patchfile.Diff(version, f, treeDirA, treeDirB, def.ExcludePaths)
	if err != nil {
		f.Close()
		os.Remove(f.Name())
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}
	log.Printf("%s: written\n", patchFile)

	// apply patch file to .codechain/tree/a to make sure it works
	treeHashes = append(treeHashes, curHashStr)
	err = sync.Dir(treeDirA, curHashStr, def.PatchDir, treeHashes, def.ExcludePaths, false)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: is faulty (this is a bug, please report it)\n",
			patchFile)
		return err
	}

	// sign patch and add to hash chain
	entry, err := c.Source(*curHash, *secKey, comment)
	if err != nil {
		return err
	}
	fmt.Println(entry)

	return nil
}

// Publish implements the 'publish' command.
func Publish(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-s seckey.bin]\n", argv0)
		fmt.Fprintf(os.Stderr, "Add signed changes in tree to .codechain ready for publication.\n")
		fs.PrintDefaults()
	}
	dryRun := fs.Bool("d", false, "Dry run, just show diff without signing anything")
	message := fs.String("m", "", "Use the given message as the comment describing the code change")
	useGit := fs.Bool("git", true, "Use git-diff to show diffs")
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	version := fs.Int("version", patchfile.Version, "Patchfile version to publish")
	yesPrompt := fs.Bool("y", false, "Automatic yes to prompts, use with care!")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *version < 1 || *version > patchfile.Version {
		return patchfile.ErrHeaderVersion
	}
	if !*dryRun {
		if err := seckey.Check(homedir.Codechain(), *secKey); err != nil {
			return err
		}
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	if err := os.MkdirAll(treeDirA, 0755); err != nil {
		return err
	}
	if err := os.MkdirAll(treeDirB, 0755); err != nil {
		return err
	}
	if err := os.MkdirAll(def.PatchDir, 0755); err != nil {
		return err
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	// add interrupt handler
	interrupt.AddInterruptHandler(func() {
		c.Close()
	})
	// run publish
	go func() {
		err := publish(c, *secKey, *message, *dryRun, *useGit, *yesPrompt, *version)
		if err != nil {
			interrupt.ShutdownChannel <- err
			return
		}
		interrupt.ShutdownChannel <- nil
	}()
	return <-interrupt.ShutdownChannel
}

+ f d3aea9df0b460895e1769d03f6129727ee47e18dd5ff120b8ff97ccfa4565b71 vendor/github.com/frankbraun/codechain/command/remkey.go
utf8file 56
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/log"
)

// RemKey implements the 'remkey' command.
func RemKey(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s pubkey\n", argv0)
		fmt.Fprintf(os.Stderr, "Remove existing signer from hashchain.\n")
		fs.PrintDefaults()
	}
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 1 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	pubkey := fs.Arg(0)
	pub, err := base64.Decode(pubkey, 32)
	if err != nil {
		return fmt.Errorf("cannot decode pubkey: %s", err)
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	var pubKey [32]byte
	copy(pubKey[:], pub)
	line, err := c.RemoveKey(pubKey)
	if err != nil {
		return err
	}
	fmt.Println(line)
	return nil
}

+ f 6e68f816a672fbba96c6e00198cad9c9b5140ef9306eccc67788efc85328e35a vendor/github.com/frankbraun/codechain/command/review.go
utf8file 282
package command

import (
	"errors"
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/sync"
	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/git"
	"github.com/frankbraun/codechain/util/homedir"
	"github.com/frankbraun/codechain/util/interrupt"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
	"github.com/frankbraun/codechain/util/terminal"
)

func showPatchInfo(
	c *hashchain.HashChain, i, idx int,
	treeHashes, treeComments []string,
	foundBarrier int,
) {
	pub, comment := c.SignerInfo(treeHashes[i])
	if foundBarrier > 0 {
		fmt.Printf("patch %d/%d\n", i-foundBarrier+1, idx-foundBarrier+1)
	} else { // after barrier
		fmt.Printf("patch %d/%d\n", i-idx, len(treeHashes)-idx-1)
	}
	if treeComments[i] != "" {
		fmt.Println(treeComments[i])
	}
	fmt.Printf("developer: %s\n", pub)
	if comment != "" {
		fmt.Println(comment)
	}
}

func procDiff(i int, treeHashes []string, useGit bool) error {
	// bring .codechain/tree/a in sync
	log.Println("bring .codechain/tree/a in sync")
	err := sync.Dir(treeDirA, treeHashes[i-1], def.PatchDir, treeHashes, def.ExcludePaths, true)
	if err != nil {
		return err
	}

	// bring .codechain/tree/b in sync
	log.Println("bring .codechain/tree/b in sync")
	err = sync.Dir(treeDirB, treeHashes[i], def.PatchDir, treeHashes, def.ExcludePaths, true)
	if err != nil {
		return err
	}

	if useGit {
		// display diff pager
		if err := git.DiffPager(treeDirA, treeDirB); err != nil {
			return err
		}
	} else {
		fmt.Println("review diff between the following two directries:")
		fmt.Println(treeDirA)
		fmt.Println(treeDirB)
	}
	return nil
}

func review(c *hashchain.HashChain, secKeyFile, treeHash string, detached, useGit bool) error {
	// load secret key
	log.Println("review(): load secret key")
	secKey, _, _, err := seckey.Load(c, homedir.Codechain(), secKeyFile)
	if err != nil {
		return err
	}
	log.Println("review(): loaded")

	// get last tree hashes
	_, idx := c.LastSignedTreeHash()
	treeHashes := c.TreeHashes()
	treeComments := c.TreeComments()
	if len(treeHashes) != len(treeComments) {
		return fmt.Errorf("invariant failed: len(treeHashes) == len(treeComments)")
	}

	// deal with explicit treehash
	if treeHash != "" {
		log.Printf("treehash=%s", treeHash)
		var i int
		for ; i < len(treeHashes); i++ {
			if treeHash == treeHashes[i] {
				log.Printf("treehash found at index %d", i)
				break
			}
		}
		if i == len(treeHashes) {
			return errors.New("cannot find treehash in hashchain")
		}
		if i <= idx {
			return errors.New("given treehash is already signed")
		}
		idx = i
	}

	if log.Std != nil {
		log.Println("treeHashes :")
		for _, h := range treeHashes {
			log.Println(h)
		}
		log.Println("treeComments:")
		for _, c := range treeComments {
			log.Println(c)
		}
	}

	// show changes in signers/sigctl
	var signed bool
	pubKey := base64.Encode(secKey[32:])
	infos, err := c.UnsignedInfo(pubKey, treeHash, true)
	if err != nil {
		return err
	}
	if len(infos) > 0 {
		fmt.Println("signer/sigctl changes:")
		for _, info := range infos {
			fmt.Println(info)
		}
		err := terminal.Confirm("confirm signer/sigctl changes?")
		if err != nil {
			return err
		}
		signed = true
	}

	// show commits which have been signed, but not by this signer
	barrier := c.SignerBarrier(pubKey)
	log.Printf("review(): barrier=%d\n", barrier)
	var foundBarrier int
outer:
	for i := 1; i <= idx; i++ {
		if c.SourceLine(treeHashes[i]) > barrier {
			if foundBarrier == 0 {
				foundBarrier = i
			}
			showPatchInfo(c, i, idx, treeHashes, treeComments, foundBarrier)
			err := terminal.Confirm("review already released patch (no continues)?")
			if err != nil {
				if err == terminal.ErrAbort {
					break outer
				}
				return err
			}
			if err := procDiff(i, treeHashes, useGit); err != nil {
				return err
			}
		}
	}

	for i := idx + 1; i < len(treeHashes); i++ {
		showPatchInfo(c, i, idx, treeHashes, treeComments, 0)
		if c.SourceLine(treeHashes[i]) > barrier {
			if err := terminal.Confirm("review patch (no aborts)?"); err != nil {
				return err
			}
			if err := procDiff(i, treeHashes, useGit); err != nil {
				return err
			}
			if err := terminal.Confirm("sign patch?"); err != nil {
				return err
			}
			signed = true
		} else {
			fmt.Println("skipping already signed patch")
		}
	}

	if !signed {
		err := terminal.Confirm("no new signer/sigctl changes or source publications to sign\n" +
			"sign anyway?")
		if err != nil {
			return err
		}
	}

	// sign patches and add to hash chain
	var linkHash [32]byte
	if treeHash != "" {
		linkHash = c.LinkHash(treeHash)
	} else {
		linkHash = c.Head()
	}
	entry, err := c.Signature(linkHash, *secKey, detached)
	if err != nil {
		return err
	}
	fmt.Println(entry)
	return nil
}

func addDetached(c *hashchain.HashChain, linkHash, pubKey, signature string) error {
	entry, err := c.DetachedSignature(linkHash, pubKey, signature)
	if err != nil {
		return err
	}
	fmt.Println(entry)
	return nil
}

// Review implements the 'review' command.
func Review(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [-s seckey.bin] [treehash]\n", argv0)
		fmt.Fprintf(os.Stderr, "       %s -a linkhash pubkey signature\n", argv0)
		fmt.Fprintf(os.Stderr, "Review code changes (all or up to treehash) and changes of signers and sigctl.\n")
		fs.PrintDefaults()
	}
	add := fs.Bool("a", false, "Add detached signature")
	detached := fs.Bool("d", false, "Create detached signature")
	useGit := fs.Bool("git", true, "Use git-diff to show diffs")
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if err := seckey.Check(homedir.Codechain(), *secKey); err != nil {
		return err
	}
	if *add {
		if fs.NArg() != 3 {
			fs.Usage()
			return flag.ErrHelp
		}
	} else {
		if fs.NArg() != 0 && fs.NArg() != 1 {
			fs.Usage()
			return flag.ErrHelp
		}
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	if err := os.MkdirAll(treeDirA, 0755); err != nil {
		return err
	}
	if err := os.MkdirAll(treeDirB, 0755); err != nil {
		return err
	}
	var treeHash string
	if fs.NArg() == 1 {
		treeHash = fs.Arg(0)
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	// add interrupt handler
	interrupt.AddInterruptHandler(func() {
		c.Close()
	})
	// run review
	go func() {
		var err error
		if *add {
			err = addDetached(c, fs.Arg(0), fs.Arg(1), fs.Arg(2))
		} else {
			err = review(c, *secKey, treeHash, *detached, *useGit)
		}
		if err != nil {
			interrupt.ShutdownChannel <- err
			return
		}
		interrupt.ShutdownChannel <- nil
	}()
	return <-interrupt.ShutdownChannel
}

+ f f01ee8a46e9453216257b32d5632512edddd1fdd3c32d1409e76f4cf481c689d vendor/github.com/frankbraun/codechain/command/sigctl.go
utf8file 55
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/log"
)

// SigCtl implements the 'sigctl' command.
func SigCtl(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s -m\n", argv0)
		fmt.Fprintf(os.Stderr, "Change signature control value.\n")
		fs.PrintDefaults()
	}
	m := fs.Int("m", -1, "Signature threshold M")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *m == -1 {
		return fmt.Errorf("%s: option -m is mandatory", argv0)
	}
	if *m < 1 {
		return fmt.Errorf("%s: option -m must be >= 1", argv0)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	line, err := c.SignatureControl(*m)
	if err != nil {
		return err
	}
	fmt.Println(line)
	return nil
}

+ f 4b022032521c2ae69a07755729a3d7a60659b29833aa45ad76e6916c9cb23df6 vendor/github.com/frankbraun/codechain/command/start.go
utf8file 64
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/log"
	"github.com/frankbraun/codechain/util/seckey"
)

// Start implements the 'start' command.
func Start(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s -s seckey.bin\n", argv0)
		fmt.Fprintf(os.Stderr, "Initialized new .codechain/hashchain in current directory.\n")
		fs.PrintDefaults()
	}
	secKey := fs.String("s", "", "Secret key file")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if *secKey == "" {
		return fmt.Errorf("%s: option -s is mandatory", argv0)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	if err := os.MkdirAll(def.CodechainDir, 0755); err != nil {
		return err
	}
	exists, err := file.Exists(def.HashchainFile)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("%s: file '%s' exists already", argv0, def.HashchainFile)
	}
	sec, _, comment, err := seckey.Read(*secKey)
	if err != nil {
		return err
	}
	c, entry, err := hashchain.Start(def.HashchainFile, *sec, comment)
	if err != nil {
		return err
	}
	defer c.Close()
	fmt.Println(entry)
	return nil
}

+ f 65120571e538085a205dec048e90e3f20610e610d51187941577ad4bcaff4e79 vendor/github.com/frankbraun/codechain/command/status.go
utf8file 130
package command

import (
	"flag"
	"fmt"
	"os"
	"sort"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/tree"
	"github.com/frankbraun/codechain/util"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/hex"
	"github.com/frankbraun/codechain/util/log"
)

func showSigner(c *hashchain.HashChain) {
	fmt.Printf("signers (%d-of-%d required):\n", c.M(), c.N())
	var signer []string
	for s := range c.Signer() {
		signer = append(signer, s)
	}
	sort.Strings(signer)
	for _, s := range signer {
		fmt.Printf("%d %s %s\n", c.SignerWeight(s), s, c.SignerComment(s))
	}
}

func showSignedReleases(c *hashchain.HashChain) {
	_, idx := c.LastSignedTreeHash()
	if idx == 0 {
		fmt.Println("no signed releases yet")
		return
	}
	treeHashes := c.TreeHashes()
	treeComments := c.TreeComments()
	fmt.Println("signed releases:")
	for i := 1; i <= idx; i++ {
		fmt.Printf("%s %s\n", treeHashes[i], treeComments[i])
	}
}

func showUnsigned(c *hashchain.HashChain) error {
	infos, err := c.UnsignedInfo("", "", false)
	if err != nil {
		return err
	}
	if len(infos) == 0 {
		fmt.Println("no unsigned entries")
		return nil
	}
	fmt.Println("unsigned entries:")
	for _, info := range infos {
		fmt.Println(info)
	}
	return nil
}

func showTreeStatus(c *hashchain.HashChain) error {
	treeHash, err := tree.Hash(".", def.ExcludePaths)
	if err != nil {
		return err
	}
	treeHashes := c.TreeHashes()
	if util.ContainsString(treeHashes, hex.Encode(treeHash[:])) {
		fmt.Printf("tree matches %x\n", treeHash[:])
	} else {
		fmt.Println("tree is dirty")
	}
	return nil
}

func status(c *hashchain.HashChain) error {
	showSignedReleases(c)
	fmt.Println()
	showSigner(c)
	fmt.Println()
	if err := showUnsigned(c); err != nil {
		return err
	}
	fmt.Println()
	fmt.Println("head:")
	fmt.Printf("%x\n", c.Head())
	fmt.Println()
	return showTreeStatus(c)
}

// Status implements the 'status' command.
func Status(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Show status of hashchain and tree.\n")
		fs.PrintDefaults()
	}
	deepVerify := fs.Bool("deep-verify", false, "Verify all patch files match hash chain entries")
	print := fs.Bool("p", false, "Print hashchain to stdout")
	verbose := fs.Bool("v", false, "Be verbose")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if *verbose {
		log.Std = log.NewStd(os.Stdout)
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	c, err := hashchain.ReadFile(def.HashchainFile)
	if err != nil {
		return err
	}
	defer c.Close()
	if *deepVerify {
		err := c.DeepVerify(treeDirA, def.PatchDir, def.ExcludePaths)
		if err != nil {
			return err
		}
	}
	if *print {
		c.Print()
		return nil
	}
	return status(c)
}

+ f 6b747d49c0d0866004d5309954da54f75374c19b6285197551a00b3dac69e5c7 vendor/github.com/frankbraun/codechain/command/treehash.go
utf8file 47
package command

import (
	"flag"
	"fmt"
	"os"

	"github.com/frankbraun/codechain/secpkg"
	"github.com/frankbraun/codechain/tree"
	"github.com/frankbraun/codechain/util/def"
)

// TreeHash implements the 'treehash' command.
func TreeHash(argv0 string, args ...string) error {
	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s\n", argv0)
		fmt.Fprintf(os.Stderr, "Show tree hash or tree list of current directory.\n")
		fs.PrintDefaults()
	}
	list := fs.Bool("l", false, "Print tree list instead of hash")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if fs.NArg() != 0 {
		fs.Usage()
		return flag.ErrHelp
	}
	if err := secpkg.UpToDate("codechain"); err != nil {
		return err
	}
	if *list {
		l, err := tree.ListBytes(".", def.ExcludePaths)
		if err != nil {
			return err
		}
		os.Stdout.Write(l)
	} else {
		hash, err := tree.Hash(".", def.ExcludePaths)
		if err != nil {
			return err
		}
		fmt.Printf("%x\n", hash[:])
	}
	return nil
}

- f dda2a29b5c538d398a54b3fd110ddeb6551ecf3aff2c352ceab523dc66586f91 vendor/github.com/frankbraun/codechain/hashchain/addkey.go
+ f dd7b5096496a18b388521c1751ffddeeed4d209963918c6830d28825d5bfa8d3 vendor/github.com/frankbraun/codechain/hashchain/addkey.go
dmppatch 5
@@ -116,59 +116,55 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22gi
- f 2251d8e88d3c2576929424a863efab2e19191fa181d0392d187bf9687db8854f vendor/github.com/frankbraun/codechain/hashchain/apply.go
+ f 490c0f619806f8211f2acfd1e79a5bea43984865255ab0257ec3d3e7f473d213 vendor/github.com/frankbraun/codechain/hashchain/apply.go
dmppatch 8
@@ -25,56 +25,8 @@
 t (%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
 %09%22gi
@@ -61,16 +61,60 @@
 n/sync%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 )%0A%0A// Ap
- f 39a09ab8be070ba7ac08108bcbde65bd6299f20e455ddad1d272dc0121318f35 vendor/github.com/frankbraun/codechain/hashchain/internal/state/state.go
+ f 8acee1c6921f99b111e78b1fa44a78a152ea5a1273b4ef2c332df1c8a09c895f vendor/github.com/frankbraun/codechain/hashchain/internal/state/state.go
dmppatch 8
@@ -93,59 +93,8 @@
 t%22%0A%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
 %09%22gi
@@ -169,16 +169,63 @@
 n/util%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22github
- f 1e5ec96cc5be6f8f473633db11c77b7158284478a8b11ac39f8d8a24e07181dc vendor/github.com/frankbraun/codechain/hashchain/remkey.go
+ f 8c5b974ef32d01d8779314d5dc8e06e2b44fe4786981f84a11472f34f262af4e vendor/github.com/frankbraun/codechain/hashchain/remkey.go
dmppatch 5
@@ -87,59 +87,55 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22gi
- f fa59471cfe4c5941a00c857b649385e0d1eb4f1c7ba913605ddd8f0e115d1545 vendor/github.com/frankbraun/codechain/hashchain/signature.go
+ f 9242211b462cd558ca940956095658c717454a3ae5a259fd9fff783cf599c98f vendor/github.com/frankbraun/codechain/hashchain/signature.go
dmppatch 5
@@ -105,59 +105,55 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22gi
- f f65f537d21edef2241f398f3fa5876bafe852d92603c7782220438682930aea6 vendor/github.com/frankbraun/codechain/hashchain/source.go
+ f b16f72b089c5b4f94b1685b48cd32b2b7aa56738fd1ff60a856989ff55eb3b86 vendor/github.com/frankbraun/codechain/hashchain/source.go
dmppatch 8
@@ -105,59 +105,8 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
 %09%22gi
@@ -141,16 +141,63 @@
 n/util%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22github
- f feb93e059b8109efabc9b9fddc3c21af29406ee576069fb57fcb78cb25d44c21 vendor/github.com/frankbraun/codechain/hashchain/start.go
+ f d903b17a42a9bc268a12ae80ec43ec46d5da10e98da54141ffbcdea7487ec9fd vendor/github.com/frankbraun/codechain/hashchain/start.go
dmppatch 5
@@ -132,59 +132,55 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22gi
- f c6d22aad166695cddc664223c9b99524f36e04b54cd320dc20175574ecb51e76 vendor/github.com/frankbraun/codechain/hashchain/verify.go
+ f 9727fc69e4ffd36812262e8e8d127770856bd02a794299509c5fb215ba6669a3 vendor/github.com/frankbraun/codechain/hashchain/verify.go
dmppatch 5
@@ -212,59 +212,55 @@
 pe%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09%22gi
- f a7b3276bbce38a5f71e40f1c0e4337b9336dbcd60886677c04ac1867da082f48 vendor/github.com/frankbraun/codechain/internal/ascii85/ascii85.go
- f ab8b97b5850dfeae3d85b1f80c988421d671c967a265b25d2db18b26b521b951 vendor/github.com/frankbraun/codechain/internal/base64/base64.go
- f 9e8f6ab25eda38ebba91bbe264ded311f7f608a9736a39cb6bd2c7f00dbafa9b vendor/github.com/frankbraun/codechain/internal/def/def.go
+ f ff55de1399ae24b4396595320857a341522353dca7010c702ddd37cd7173e7ec vendor/github.com/frankbraun/codechain/keyfile/errors.go
utf8file 9
package keyfile

import (
	"errors"
)

// ErrDecrypt is returned if the keyfile could not be decrypted (wrong passphrase).
var ErrDecrypt = errors.New("keyfile: cannot decrypt")

+ f 18aee69fda93215b1835110a0546ad76247015430d074eeec2f9b361f2a6f10c vendor/github.com/frankbraun/codechain/keyfile/keyfile.go
utf8file 128
// Package keyfile provides encrypted secret key storage.
package keyfile

import (
	"bytes"
	"crypto/rand"
	b64 "encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"

	"github.com/frankbraun/codechain/util/base64"
	"github.com/frankbraun/codechain/util/file"
	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/nacl/secretbox"
)

// Create keyfile (encrypted with passphrase) and store secretKey, signature,
// and optional comment it.
func Create(filename string, passphrase []byte, secretKey, signature [64]byte, comment []byte) error {
	var (
		salt  [32]byte
		nonce [24]byte
		key   [32]byte
	)
	exists, err := file.Exists(filename)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("file '%s' exists already", filename)
	}
	if _, err := io.ReadFull(rand.Reader, salt[:]); err != nil {
		return err
	}
	if _, err := io.ReadFull(rand.Reader, nonce[:]); err != nil {
		return err
	}
	derivedKey := argon2.IDKey(passphrase, salt[:], 1, 64*1024, 4, 32)
	copy(key[:], derivedKey)
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	msg := append(secretKey[:], signature[:]...)
	msg = append(msg, comment...)
	enc := secretbox.Seal(append(salt[:], nonce[:]...), msg, &nonce, &key)
	_, err = fmt.Fprintf(f, "%s %s", base64.Encode(secretKey[32:]),
		base64.Encode(signature[:]))
	if err != nil {
		return err
	}
	if comment != nil {
		_, err := fmt.Fprintf(f, " %s", comment)
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprintf(f, "\n%s\n", base64.Encode(enc))
	if err != nil {
		return err
	}
	return nil
}

// Read keyfile (encrypted with passphrase) and return secretKey, signature,
// and optional comment.
func Read(filename string, passphrase []byte) (*[64]byte, *[64]byte, []byte, error) {
	var (
		salt  [32]byte
		nonce [24]byte
		key   [32]byte
	)
	c, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, nil, nil, err
	}
	lines := bytes.SplitN(c, []byte("\n"), 2)
	line0 := strings.SplitN(string(lines[0]), " ", 3)
	line1 := string(bytes.TrimSpace(lines[1]))
	pub, err := base64.Decode(line0[0], 32)
	if err != nil {
		return nil, nil, nil, err
	}
	sig, err := base64.Decode(line0[1], 64)
	if err != nil {
		return nil, nil, nil, err
	}
	comment := line0[2]
	r, err := b64.RawURLEncoding.DecodeString(line1)
	if err != nil {
		return nil, nil, nil, err
	}
	expected := len(salt) + len(nonce) + 64 + 64 + secretbox.Overhead
	if len(r) < expected {
		return nil, nil, nil,
			fmt.Errorf("base64: wrong length %d (expecting at least %d): %s",
				2*len(r), 2*expected, line1)
	}
	copy(salt[:], r[:32])
	copy(nonce[:], r[32:56])
	enc := r[56:]
	derivedKey := argon2.IDKey(passphrase, salt[:], 1, 64*1024, 4, 32)
	copy(key[:], derivedKey)
	msg, verify := secretbox.Open(nil, enc, &nonce, &key)
	if !verify {
		return nil, nil, nil, ErrDecrypt
	}
	var sec [64]byte
	var decSig [64]byte
	copy(sec[:], msg[:64])
	copy(decSig[:], msg[64:128])
	decComment := msg[128:]
	if !bytes.Equal(sec[32:], pub) {
		return nil, nil, nil, fmt.Errorf("%s: public keys don't match", filename)
	}
	if !bytes.Equal(decSig[:], sig) {
		return nil, nil, nil, fmt.Errorf("%s: signatures don't match", filename)
	}
	if string(decComment) != comment {
		return nil, nil, nil, fmt.Errorf("%s: signatures don't match", filename)
	}
	return &sec, &decSig, decComment, nil
}

- f 886c42734b8f5671b7a39b8a2f0702b5468d4910923c9881b306bffe29b4fb89 vendor/github.com/frankbraun/codechain/patchfile/ascii85.go
+ f 6e9d6d1cea0d7f8dee0685ada54709055748a06c55e4a09c041a35f081d9b076 vendor/github.com/frankbraun/codechain/patchfile/ascii85.go
dmppatch 5
@@ -52,60 +52,56 @@
 l%22%0A%0A
-%09%22github.com/frankbraun/codechain/internal/ascii85%22%0A
+%09%22github.com/frankbraun/codechain/util/ascii85%22%0A
 )%0A%0A/
- f 113eae1265cf0f5939348f481d6fd36598fa8931fcc793fab7dd41b5aca3806f vendor/github.com/frankbraun/codechain/secpkg/checkupdate.go
+ f bd8b4826bf6783e157efa851502542a27bb90d6adaca71533cfec23896dccd5a vendor/github.com/frankbraun/codechain/secpkg/checkupdate.go
dmppatch 8
@@ -114,56 +114,8 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
 %09%22gi
@@ -150,16 +150,60 @@
 n/ssot%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22github
- f b6e7a1aaf2ba0538e81e0d6fd25ea8fbbb02c017709e7f9c28b7ca51d72fd300 vendor/github.com/frankbraun/codechain/secpkg/doc.go
+ f 8951ac10abd9cc06a9cfadde82d1d25b84e973f071edc6ceeabcea008b0b6de7 vendor/github.com/frankbraun/codechain/secpkg/doc.go
dmppatch 33
@@ -4864,101 +4864,225 @@
 e.%0A%0A
-  12. If not SKIP_BUILD, %60rm -rf ~/.config/secpkg/pkgs/NAME/build%60%0A
+  12. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local uninstall%60 in%0A      ~/.config/secpkg/pkgs/NAME/installed%0A%0A  13. If not SKIP_BUILD, %60rm -rf ~/.config/secpkg/pkgs/NAME/build%60%0A
 %0A
-  13. If not SKIP_BUILD,%0A
+  14. If not SKIP_BUILD,%0A
     
@@ -5160,78 +5160,78 @@
 d%60%0A%0A
-  14. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local%60 in%0A
+  15. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local%60 in%0A
     
@@ -5270,87 +5270,87 @@
 ld%0A%0A
-  15. If not SKIP_BUILD, call %60make prefix= ~/.config/secpkg/local install%60 in%0A
+  16. If not SKIP_BUILD, call %60make prefix= ~/.config/secpkg/local install%60 in%0A
     
@@ -5389,33 +5389,33 @@
 ld%0A%0A
-  16. If not SKIP_BUILD,%0A
+  17. If not SKIP_BUILD,%0A
     
@@ -5496,34 +5496,34 @@
 d%60%0A%0A
-  17. Update signed head:%0A
+  18. Update signed head:%0A
 %0A   
@@ -5723,58 +5723,58 @@
 ).%0A%0A
-  18. The software has been successfully updated.%0A
+  19. The software has been successfully updated.%0A
 %0AChe
- f aa84a62f41ed331b1fe6407b9f2d60845037eec1fe74b3c6dff386b4cd4c2964 vendor/github.com/frankbraun/codechain/secpkg/ensure.go
+ f 3f438af001efb679c3e8f3488383535f44faa5d27a5990ae7ac29d3269700e37 vendor/github.com/frankbraun/codechain/secpkg/ensure.go
dmppatch 5
@@ -127,56 +127,52 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22gi
- f 306384d40357e6a1dbb8ced5561cdc036e39a4e7226c675b553918127244ce3b vendor/github.com/frankbraun/codechain/secpkg/install.go
+ f 4efc32060ec9762930c6d9a97baa4bfb630abf5c9e42ef21dd8ec02514b8a38a vendor/github.com/frankbraun/codechain/secpkg/install.go
dmppatch 8
@@ -165,56 +165,8 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
 %09%22gi
@@ -201,16 +201,60 @@
 n/ssot%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22github
- f 53b356484d8959085191c1dab06aafc27097356c9799236028e58acdf45e362e vendor/github.com/frankbraun/codechain/secpkg/update.go
+ f 7caddb9d7485dd28c3bcd2dac666dcf211ee3f773b3f4ffa2e584ee13b9e6c81 vendor/github.com/frankbraun/codechain/secpkg/update.go
dmppatch 51
@@ -152,56 +152,8 @@
 in%22%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
 %09%22gi
@@ -188,16 +188,60 @@
 n/ssot%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22github
@@ -5295,77 +5295,484 @@
 %09%7D%0A%0A
-%09// 12. If not SKIP_BUILD, %60rm -rf ~/.config/secpkg/pkgs/NAME/build%60%0A
+%09// 12. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local uninstall%60 in%0A%09//     ~/.config/secpkg/pkgs/NAME/installed%0A%09installedDir := filepath.Join(pkgDir, %22installed%22)%0A%09localDir := filepath.Join(homedir.SecPkg(), %22local%22)%0A%09if !skipBuild %7B%0A%09%09if err := os.Chdir(installedDir); err != nil %7B%0A%09%09%09return false, err%0A%09%09%7D%0A%09%09if err := gnumake.Uninstall(localDir); err != nil %7B%0A%09%09%09return false, err%0A%09%09%7D%0A%09%7D%0A%0A%09// 13. If not SKIP_BUILD, %60rm -rf ~/.config/secpkg/pkgs/NAME/build%60%0A
 %09bui
@@ -5910,35 +5910,35 @@
 %09%7D%0A%0A
-%09// 13. If not SKIP_BUILD,%0A
+%09// 14. If not SKIP_BUILD,%0A
 %09// 
@@ -6120,80 +6120,80 @@
 %09%7D%0A%0A
-%09// 14. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local%60 in%0A
+%09// 16. If not SKIP_BUILD, call %60make prefix=~/.config/secpkg/local%60 in%0A
 %09// 
@@ -6233,62 +6233,8 @@
 ild%0A
-%09localDir := filepath.Join(homedir.SecPkg(), %22local%22)%0A
 %09if 
@@ -6422,89 +6422,89 @@
 %09%7D%0A%0A
-%09// 15. If not SKIP_BUILD, call %60make prefix= ~/.config/secpkg/local install%60 in%0A
+%09// 16. If not SKIP_BUILD, call %60make prefix= ~/.config/secpkg/local install%60 in%0A
 %09// 
@@ -6642,35 +6642,35 @@
 %09%7D%0A%0A
-%09// 16. If not SKIP_BUILD,%0A
+%09// 17. If not SKIP_BUILD,%0A
 %09// 
@@ -6769,61 +6769,8 @@
 d %7B%0A
-%09%09installedDir := filepath.Join(pkgDir, %22installed%22)%0A
 %09%09if
@@ -6936,36 +6936,36 @@
 %09%7D%0A%0A
-%09// 17. Update signed head:%0A
+%09// 18. Update signed head:%0A
 %09//%0A
@@ -7250,60 +7250,60 @@
 %09%7D%0A%0A
-%09// 18. The software has been successfully updated.%0A
+%09// 19. The software has been successfully updated.%0A
 %09if 
- f 9c34e65737b460fff42e98e1b322d07009fe92146cc8707a33d0b0d0df59a544 vendor/github.com/frankbraun/codechain/secpkg/uptodate.go
+ f 47cbb36c4573750c55ce850b4f814e1e8fc3da7a827b660eeae0a097cb62766d vendor/github.com/frankbraun/codechain/secpkg/uptodate.go
dmppatch 23
@@ -40,22 +40,57 @@
 mt%22%0A
+%09%22net%22%0A
 %09%22os%22%0A
+%09%22path/filepath%22%0A%09%22strings%22%0A
 %09%22time%22%0A
 )%0A%0A/
@@ -85,16 +85,65 @@
 %09%22time%22%0A
+%0A%09%22github.com/frankbraun/codechain/util/homedir%22%0A
 )%0A%0A// Up
@@ -608,62 +608,518 @@
 me)%0A
-%09%09%7D else %7B%0A%09%09%09return err%0A
+%09%09%09return nil%0A
 %09%09%7D%0A
-%09%7D else if needsUpdate %7B%0A
+%09%09return err%0A%09%7D%0A%09// determine path of currently running executable%0A%09path, err := os.Executable()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09localDir := filepath.Join(homedir.SecPkg(), %22local%22)%0A%09// issue warning if we don't actually run the installed executable%0A%09if !strings.HasPrefix(path, localDir) %7B%0A%09%09fmt.Fprintf(os.Stderr, %22WARNING: package '%25s' installed via %60secpkg install%60, but running different executable: %25s%5Cn%22,%0A%09%09%09name, path)%0A%09%7D%0A%09// now report update needs, if necessary%0A%09if needsUpdate %7B%0A
 %09%09re
@@ -1656,32 +1656,204 @@
 ); err != nil %7B%0A
+%09%09if err, ok := err.(net.Error); ok && err.Timeout() %7B%0A%09%09%09fmt.Fprintf(os.Stderr, %22WARNING: update check for package '%25s' timed out: %25s%5Cn%22,%0A%09%09%09%09name, err)%0A%09%09%09return nil%0A%09%09%7D%0A
 %09%09return err%0A%09%7D%0A
- f 9472cd5bbc3605a18fab51b95d6b40dae2041ba0b3291895b77bb2e1bf34ba72 vendor/github.com/frankbraun/codechain/ssot/doc.go
+ f 5184def0aaab6139d1f2b966cc0f48019510692cac8c017d5aebe9bb990b9d4d vendor/github.com/frankbraun/codechain/ssot/doc.go
dmppatch 60
@@ -1334,70 +1334,118 @@
 s.%0A%0A
-  3. Create a new .secpkg file which specifies the following:%0A
+  3. Test build (see TestBuild specification).%0A%0A  4. Create a new .secpkg file which specifies the following:%0A
 %0A   
@@ -1757,83 +1757,83 @@
 y.%0A%0A
-  4. Create the first signed head (see SignHead) for the current project's%0A
+  5. Create the first signed head (see SignHead) for the current project's%0A
     
@@ -1892,68 +1892,68 @@
 0.%0A%0A
-  5. Create the directory ~/.config/ssotpub/pkgs/NAME/dists%0A
+  6. Create the directory ~/.config/ssotpub/pkgs/NAME/dists%0A
     
@@ -2073,235 +2073,235 @@
 ).%0A%0A
-  6. Save the signed head to ~/.config/ssotpub/pkgs/NAME/signed_head%0A
+  7. Save the signed head to ~/.config/ssotpub/pkgs/NAME/signed_head%0A
 %0A
-  7. Print the distribution name: ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz%0A
+  8. Print the distribution name: ~/.config/secpkg/pkgs/NAME/dists/HEAD.tar.gz%0A
 %0A
-  8. Print DNS TXT records as defined by the .secpkg, the first signed head,%0A
+  9. Print DNS TXT records as defined by the .secpkg, the first signed head,%0A
     
@@ -3253,87 +3253,136 @@
 s.%0A%0A
-   6. If ROTATE is set, check if ~/.config/ssotput/pkgs/NAME/rotate_to exists.%0A
+   6. Test build (see TestBuild specification).%0A%0A   7. If ROTATE is set, check if ~/.config/ssotput/pkgs/NAME/rotate_to exists.%0A
     
@@ -3523,86 +3523,86 @@
 o.%0A%0A
-   7. Create a new signed head with current HEAD, the counter of the previous%0A
+   8. Create a new signed head with current HEAD, the counter of the previous%0A
     
@@ -4127,69 +4127,69 @@
 E.%0A%0A
-   8. If the HEAD changed, save the current distribution to:%0A
+   9. If the HEAD changed, save the current distribution to:%0A
     
@@ -4266,85 +4266,85 @@
 ).%0A%0A
-   9. If the HEAD changed, lookup the download URL and print where to upload%0A
+  10. If the HEAD changed, lookup the download URL and print where to upload%0A
     
@@ -4425,87 +4425,87 @@
 gz%0A%0A
-  10. Print DNS TXT record as defined by the .secpkg file and the signed head.%0A
+  12. Print DNS TXT record as defined by the .secpkg file and the signed head.%0A
     
@@ -4585,72 +4585,72 @@
 d.%0A%0A
-  11. If the HEAD changed, update the .secpkg file accordingly.%0A
+  13. If the HEAD changed, update the .secpkg file accordingly.%0A
 %0A  A
@@ -6625,16 +6625,684 @@
 nabled.%0A
+%0ATestBuild specification%0A%0ATo test the build of a secure package do the following:%0A%0A   1. Create temporary directory TMPDIR with %60build%60 and %60local%60 subdirectories.%0A%0A   2. %60mkdir TMPDIR/build/.codechain%60%0A%0A   3. %60cp .codechain/hashchain TMPDIR/build/.codechain%60%0A%0A   4. %60cp -r .codechain/patches TMPDIR/build/.codechain%60%0A%0A   5. %60cd TMPDIR/build%60%0A%0A   6. %60codechain apply%60%0A%0A   7. %60make prefix=TMPDIR/local%60%0A%0A   8. %60make prefix=TMPDIR/local install%60%0A%0A   9. Make sure TMPDIR/local contains at least one file.%0A%0A  10. %60make prefix=TMPDIR/local uninstall%60%0A%0A  11. Make sure TMPDIR/local contains no files (but empty directories are OK).%0A%0A  12. Delete temporary directory TMPDIR.%0A
 %0ARotate 
- f 5f57e53f3d059d207dabb2c27955f04455e96fca93a332c85caa7c904ed5d5fa vendor/github.com/frankbraun/codechain/ssot/rotateto.go
+ f 2b17a6a7145187b6f558fe26a48230500d53cce9c2123e612ec1c6f53c3e4f25 vendor/github.com/frankbraun/codechain/ssot/rotateto.go
dmppatch 5
@@ -75,59 +75,55 @@
 e%22%0A%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A
 %09uti
- f 814e1c80b9683bf5579ecbd8d65c02708275809c3bdf72f16452376e6838a150 vendor/github.com/frankbraun/codechain/ssot/ssot.go
+ f 0aa96e87534d6b3104fb56d1a34d3df6f58a891a0de01d22efcbcc6f4ff31c60 vendor/github.com/frankbraun/codechain/ssot/ssot.go
dmppatch 5
@@ -166,107 +166,99 @@
 or%22%0A
-%09%22github.com/frankbraun/codechain/internal/base64%22%0A%09%22github.com/frankbraun/codechain/internal/def%22%0A
+%09%22github.com/frankbraun/codechain/util/base64%22%0A%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22gi
- f 7e7a87eaadd06ad7f40c2bffa26afbceba711aa7cb14d633f670074f49759164 vendor/github.com/frankbraun/codechain/sync/sync.go
+ f 507579211e8560d08b9b5a47046785d338a67154d185e63735ba66629eb463f8 vendor/github.com/frankbraun/codechain/sync/sync.go
dmppatch 8
@@ -119,56 +119,8 @@
 h%22%0A%0A
-%09%22github.com/frankbraun/codechain/internal/def%22%0A
 %09%22gi
@@ -240,16 +240,60 @@
 n/util%22%0A
+%09%22github.com/frankbraun/codechain/util/def%22%0A
 %09%22github
+ f a7b3276bbce38a5f71e40f1c0e4337b9336dbcd60886677c04ac1867da082f48 vendor/github.com/frankbraun/codechain/util/ascii85/ascii85.go
utf8file 75
// Package ascii85 implements ascii85 encoding related utility functions.
package ascii85

import (
	"bytes"
	"encoding/ascii85"
	"io"
)

type newlineWriteCloser struct {
	buf         bytes.Buffer
	charsInLine int
	lines       int
}

func (n *newlineWriteCloser) Write(p []byte) (int, error) {
	startLen := len(p)
	for len(p)+n.charsInLine >= 80 {
		if _, err := n.buf.Write(p[:80-n.charsInLine]); err != nil {
			return 0, err
		}
		p = p[80-n.charsInLine:]
		if _, err := n.buf.WriteRune('\n'); err != nil {
			return 0, err
		}
		n.charsInLine = 0
		n.lines++
	}
	if len(p) > 0 {
		if _, err := n.buf.Write(p); err != nil {
			return 0, err
		}
		n.charsInLine = len(p)
	}
	return startLen, nil
}

func (n *newlineWriteCloser) Close() error {
	if n.charsInLine > 0 {
		if _, err := n.buf.WriteRune('\n'); err != nil {
			return err
		}
		n.charsInLine = 0
		n.lines++
	}
	return nil
}

// Encode src to ascii85 with a newline every 80 encoded characters and return
// the result and the number of encoded lines.
func Encode(src []byte) ([]byte, int, error) {
	var n newlineWriteCloser
	a := ascii85.NewEncoder(&n)
	if _, err := a.Write(src); err != nil {
		return nil, 0, err
	}
	if err := a.Close(); err != nil {
		return nil, 0, err
	}
	if err := n.Close(); err != nil {
		return nil, 0, err
	}
	return n.buf.Bytes(), n.lines, nil
}

// Decode ascii85 encoded src and return it.
func Decode(src []byte) ([]byte, error) {
	var dst bytes.Buffer
	dec := ascii85.NewDecoder(bytes.NewBuffer(src))
	if _, err := io.Copy(&dst, dec); err != nil {
		return nil, err
	}
	return dst.Bytes(), nil
}

+ f ab8b97b5850dfeae3d85b1f80c988421d671c967a265b25d2db18b26b521b951 vendor/github.com/frankbraun/codechain/util/base64/base64.go
utf8file 27
// Package base64 implements base64 encoding related utility functions.
package base64

import (
	"encoding/base64"
	"fmt"
)

// Encode returns the base64 encoding of src (URL encoding without padding).
func Encode(src []byte) string {
	return base64.RawURLEncoding.EncodeToString(src)
}

// Decode returns the bytes represented by the base64 string s
// (assuming that s is URL encoded without padding).
// Decode expects that the resulting byte slice has length l.
func Decode(s string, l int) ([]byte, error) {
	r, err := base64.RawURLEncoding.DecodeString(s)
	if err != nil {
		return nil, err
	}
	if len(r) != l {
		return nil, fmt.Errorf("base64: wrong length %d (expecting %d): %s", 2*len(r), 2*l, s)
	}
	return r, nil
}

+ f 59d979842375998d6c7ce90930544fe272f49613cc6ecf6193651bcb1bcf6092 vendor/github.com/frankbraun/codechain/util/bzero/bzero.go
utf8file 10
// Package bzero defines helper functions to zero sensitive memory.
package bzero

// Bytes sets all entries in the given byte slice buffer to zero.
func Bytes(buffer []byte) {
	for i := 0; i < len(buffer); i++ {
		buffer[i] = 0
	}
}

+ f 9e8f6ab25eda38ebba91bbe264ded311f7f608a9736a39cb6bd2c7f00dbafa9b vendor/github.com/frankbraun/codechain/util/def/def.go
utf8file 60
// Package def defines default values used in Codechain.
package def

import (
	"os"
	"path/filepath"
)

// DefaultCodechainDir is the default directory used for Codechain related files.
// Can be overwritten with the environment variable CODECHAIN_DIR.
const DefaultCodechainDir = ".codechain"

// CodechainDir is the directory used for Codechain releated files. If not set
// with the environment variable CODECHAIN_DIR, DefaultCodechainDir is used.
// If CODECHAIN_DIR is used, the environment variable CODECHAIN_EXCLUDE can be
// used to exclude a second Codechain directory from all Codechain commands.
var CodechainDir = DefaultCodechainDir

func init() {
	dir := os.Getenv("CODECHAIN_DIR")
	if dir != "" {
		CodechainDir = dir
		ExcludePaths = append(ExcludePaths, dir)
	}
	exclude := os.Getenv("CODECHAIN_EXCLUDE")
	if exclude != "" {
		ExcludePaths = append(ExcludePaths, exclude)
	}
	HashchainFile = filepath.Join(CodechainDir, "hashchain")
	PatchDir = filepath.Join(CodechainDir, "patches")
}

// SecretsSubDir is the default subdirectory of a tool's home directory used
// to store secret key files
const SecretsSubDir = "secrets"

// CodechainHeadName is the TXT entry used for Codechain's secpkg heads.
const CodechainHeadName = "_codechain-head."

// CodechainURLName is the TXT entry used for Codechain's secpkg URLs.
const CodechainURLName = "_codechain-url."

// CodechainTestName is the TXT entry used to test Dyn credentials.
const CodechainTestName = "_codechain-test."

// ExcludePaths is the default list of paths not considered by Codechain.
// Do not ever change this list! It will break existing Codechains.
var ExcludePaths = []string{
	DefaultCodechainDir,
	".git",
	".gitignore",
	".travis.yml",
}

// HashchainFile is the default name of the hashchain file.
var HashchainFile string

// PatchDir is the default name of the patch file directory.
var PatchDir string

+ f a4ca3e36717e0bab0bb823c27817b81ed1f102a5a1ceb02ded03203c1165faf7 vendor/github.com/frankbraun/codechain/util/git/git.go
utf8file 37
// Package git contains wrappers around some Git commands.
package git

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"syscall"
)

// DiffPager calls `git diff no-index` on the two directory trees rooted at a
// and b and shows the result on stdout, possibly using a pager.
func DiffPager(a, b string) error {
	cmd := exec.Command("git", "diff", "--no-index", a, b)
	cmd.Stdout = os.Stdout
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		if exiterr, ok := err.(*exec.ExitError); ok {
			if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {
				if status.ExitStatus() == 1 {
					return nil
				}
				// ignore SIGPIPE
				if status.Signaled() && status.Signal() == syscall.SIGPIPE {
					return nil
				}
			}
			return fmt.Errorf("%s: %s", exiterr, strings.TrimSpace(stderr.String()))
		}
		return err
	}
	return nil
}

- f ffa43fb0d14b329a000ad6d91326067fee30acaeeef7a41f0c6dd79a9b4cb91d vendor/github.com/frankbraun/codechain/util/homedir/homedir.go
+ f 515608b72ba20dca0e700a467b122b2fc190b0fd629904d29627a4dc803a1b3f vendor/github.com/frankbraun/codechain/util/homedir/homedir.go
dmppatch 20
@@ -227,38 +227,96 @@
 %0A)%0A%0A
-func get(app string) string %7B%0A
+// Get returns the home directory for the given app name.%0Afunc Get(app string) string %7B%0A
 %09env
@@ -638,33 +638,33 @@
 g %7B%0A
-%09return get(%22codechain%22)%0A
+%09return Get(%22codechain%22)%0A
 %7D%0A%0A/
@@ -740,30 +740,30 @@
 g %7B%0A
-%09return get(%22secpkg%22)%0A
+%09return Get(%22secpkg%22)%0A
 %7D%0A%0A/
@@ -842,29 +842,29 @@
 g %7B%0A
-%09return get(%22ssotpub%22)%0A
+%09return Get(%22ssotpub%22)%0A
 %7D%0A
+ f 62ddab91e68b1e49a4444ba433a7d8972b85e85442020faab1eae4d768bc33e8 vendor/github.com/frankbraun/codechain/util/interrupt/interrupt.go
utf8file 89
// Copyright (c) 2013-2016 The btcsuite developers
// Copyright (c) 2016 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

// Package interrupt allows to handle interrupts.
package interrupt

import (
	"fmt"
	"os"
	"os/signal"
)

// ShutdownChannel is used to signal that shutdown is in progress.
var ShutdownChannel = make(chan error)

// interruptChannel is used to receive SIGINT (Ctrl+C) signals.
var interruptChannel chan os.Signal

// addHandlerChannel is used to add an interrupt handler to the list of handlers
// to be invoked on SIGINT (Ctrl+C) signals.
var addHandlerChannel = make(chan func())

// mainInterruptHandler listens for SIGINT (Ctrl+C) signals on the
// interruptChannel and invokes the registered interruptCallbacks accordingly.
// It also listens for callback registration.  It must be run as a goroutine.
func mainInterruptHandler() {
	// interruptCallbacks is a list of callbacks to invoke when a
	// SIGINT (Ctrl+C) is received.
	var interruptCallbacks []func()

	// isShutdown is a flag which is used to indicate whether or not
	// the shutdown signal has already been received and hence any future
	// attempts to add a new interrupt handler should invoke them
	// immediately.
	var isShutdown bool

	for {
		select {
		case <-interruptChannel:
			// Ignore more than one shutdown signal.
			if isShutdown {
				fmt.Fprintln(os.Stderr, "Received SIGINT (Ctrl+C).  "+
					"Already shutting down...")
				continue
			}

			isShutdown = true
			fmt.Fprintln(os.Stderr, "Received SIGINT (Ctrl+C).  Shutting down...")

			// Run handlers in LIFO order.
			for i := range interruptCallbacks {
				idx := len(interruptCallbacks) - 1 - i
				callback := interruptCallbacks[idx]
				callback()
			}

			// Signal the main goroutine to shutdown.
			go func() {
				ShutdownChannel <- nil
			}()

		case handler := <-addHandlerChannel:
			// The shutdown signal has already been received, so
			// just invoke and new handlers immediately.
			if isShutdown {
				handler()
			}

			interruptCallbacks = append(interruptCallbacks, handler)
		}
	}
}

// AddInterruptHandler adds a handler to call when a SIGINT (Ctrl+C) is
// received.
func AddInterruptHandler(handler func()) {
	// Create the channel and start the main interrupt handler which invokes
	// all other callbacks and exits if not already done.
	if interruptChannel == nil {
		interruptChannel = make(chan os.Signal, 1)
		signal.Notify(interruptChannel, os.Interrupt)
		go mainInterruptHandler()
	}

	addHandlerChannel <- handler
}

+ f d10039c3ad61d8c5b8eb5a93c1250c4310f2565fcb0fb64b16e55deae1450308 vendor/github.com/frankbraun/codechain/util/seckey/seckey.go
utf8file 123
// Package seckey implements helper functions for secret key files.
package seckey

import (
	"crypto/ed25519"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"syscall"

	"github.com/frankbraun/codechain/hashchain"
	"github.com/frankbraun/codechain/keyfile"
	"github.com/frankbraun/codechain/util/bzero"
	"github.com/frankbraun/codechain/util/def"
	"github.com/frankbraun/codechain/util/file"
	"github.com/frankbraun/codechain/util/terminal"
)

// TestPass is a passphrase used for testing purposes. Do not set!
var TestPass string

// Check that the file seckey exists, if it is given.
// Otherwise make sure that at least the secrets subdirectory of homeDir
// exists.
func Check(homeDir, seckey string) error {
	if seckey != "" {
		exists, err := file.Exists(seckey)
		if err != nil {
			return err
		}
		if !exists {
			return fmt.Errorf("file '%s' doesn't exists", seckey)
		}
	} else {
		secretDir := filepath.Join(homeDir, def.SecretsSubDir)
		// make sure we have the secrets directory present
		exists, err := file.Exists(secretDir)
		if err != nil {
			return err
		}
		if !exists {
			return fmt.Errorf("directory '%s' doesn't exists: you have no secrets",
				homeDir)
		}
	}
	return nil
}

// Read reads the secret key from given filename.
// It reads the the passphrase from the terminal. If the wrong passphrase is
// given, the function reads the passphrase again.
func Read(filename string) (*[64]byte, *[64]byte, []byte, error) {
	exists, err := file.Exists(filename)
	if err != nil {
		return nil, nil, nil, err
	}
	if !exists {
		return nil, nil, nil, fmt.Errorf("keyfile '%s' does not exist", filename)
	}
	fmt.Printf("opening keyfile: %s\n", filename)
	var (
		pass    []byte
		sec     *[64]byte
		sig     *[64]byte
		comment []byte
	)
	for {
		if TestPass == "" {
			pass, err = terminal.ReadPassphrase(syscall.Stdin, false)
			if err != nil {
				return nil, nil, nil, err
			}
			defer bzero.Bytes(pass)
		} else {
			pass = []byte(TestPass)
		}
		sec, sig, comment, err = keyfile.Read(filename, pass)
		if err != nil {
			if TestPass == "" && err == keyfile.ErrDecrypt {
				fmt.Println("wrong passphrase, try again")
				continue
			}
			return nil, nil, nil, err
		}
		break
	}
	if !ed25519.Verify(sec[32:], append(sec[32:], comment...), sig[:]) {
		return nil, nil, nil, fmt.Errorf("signature does not verify")
	}
	return sec, sig, comment, nil
}

// Load loads secret from filename, if given.
// Otherwise it loads the secret corresponding to the signer in given hash
// chain and makes sure that only one such secret exists.
func Load(c *hashchain.HashChain, homeDir, filename string) (*[64]byte, *[64]byte, []byte, error) {
	if filename != "" {
		return Read(filename)
	}
	secretDir := filepath.Join(homeDir, def.SecretsSubDir)
	signer := c.Signer()
	files, err := ioutil.ReadDir(secretDir)
	if err != nil {
		return nil, nil, nil, err
	}
	var pubKey string
	for _, fi := range files {
		if signer[fi.Name()] {
			if pubKey == "" {
				pubKey = fi.Name()
			} else {
				return nil, nil, nil,
					fmt.Errorf("more than one matching keyfile found: you have too many secrets")
			}
		}
	}
	if pubKey == "" {
		return nil, nil, nil,
			fmt.Errorf("directory '%s' doesn't contain any matching secret keyfile", secretDir)
	}
	return Read(filepath.Join(secretDir, pubKey))
}

+ f ee6441e19763d7eb94e0abd27e632441013f81926f4d79fb13818bdaff9711a3 vendor/github.com/frankbraun/codechain/util/terminal/errors.go
utf8file 9
package terminal

import (
	"errors"
)

// ErrAbort is returned if a user answers 'n' to Confirm.
var ErrAbort = errors.New("aborted")

+ f 3958cdb0357e6708ff4b53e16aa7c618ea1ebe4942eecbf1b3252864aedfc7dc vendor/github.com/frankbraun/codechain/util/terminal/terminal.go
utf8file 129
// Package terminal provides utility function to read from terminals.
package terminal

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/frankbraun/codechain/util/bzero"
	"golang.org/x/crypto/ssh/terminal"
)

// ReadPassphrase reads a single line from fd without local echo and returns
// it (without trailing newline). When confirm is true it reads a second line
// and makes sure both passphrases match.
func ReadPassphrase(fd int, confirm bool) ([]byte, error) {
	var (
		pass   []byte
		pass2  []byte
		reader *bufio.Reader
		c      chan os.Signal
		stop   chan bool
		err    error
	)
	isTerminal := terminal.IsTerminal(fd)
	fmt.Printf("passphrase: ")
	if isTerminal {
		// Get terminal state to restore in case of interrupt.
		state, err := terminal.GetState(fd)
		if err != nil {
			return nil, err
		}
		// Create the necessary channels.
		c = make(chan os.Signal, 1)
		stop = make(chan bool, 1)
		// Register signal handler.
		signal.Notify(c, os.Interrupt)
		// Spawn goroutine to handle signal.
		go func() {
			select {
			case <-c:
				// Restore terminal and close goroutine.
				terminal.Restore(fd, state)
				fmt.Fprintln(os.Stderr, "cancelled")
				return
			case <-stop:
				return
			}
		}()
	}
	if isTerminal {
		pass, err = terminal.ReadPassword(fd)
		fmt.Println("")
		// Deregister signal handler.
		signal.Stop(c)
		// Stop signal handler goroutine to prevent goroutine leak.
		stop <- true
	} else {
		reader = bufio.NewReader(os.NewFile(uintptr(fd), "terminal"))
		pass, err = reader.ReadBytes('\n')
	}
	if err != nil {
		if err == io.EOF {
			return nil, errors.New("unable to read passphrase")
		}
		return nil, err
	}
	if len(pass) == 0 {
		return nil, errors.New("please provide a passphrase")
	}
	pass = bytes.TrimRight(pass, "\n")
	if confirm {
		fmt.Printf("confirm passphrase: ")
		if isTerminal {
			pass2, err = terminal.ReadPassword(syscall.Stdin)
			fmt.Println("")
		} else {
			pass2, err = reader.ReadBytes('\n')
		}
		if err != nil {
			return nil, err
		}
		defer bzero.Bytes(pass2)
		pass2 = bytes.TrimRight(pass2, "\n")
		if !bytes.Equal(pass, pass2) {
			return nil, errors.New("passphrases don't match")
		}
	}
	return pass, nil
}

// ReadLine reads a single line from r it and returns it (without trailing
// newline).
func ReadLine(r io.Reader) ([]byte, error) {
	str, err := bufio.NewReader(r).ReadBytes('\n')
	if err != nil {
		if err == io.EOF {
			return nil, errors.New("unable to read line")
		}
		return nil, err
	}
	return bytes.TrimSpace(str), nil
}

// Confirm asks the user to confirm the question with yes or no.
func Confirm(question string) error {
	for {
		fmt.Print(question + " [y/n]: ")
		answer, err := ReadLine(os.Stdin)
		if err != nil {
			return err
		}
		a := string(bytes.ToLower(answer))
		if strings.HasPrefix(a, "y") {
			return nil
		} else if strings.HasPrefix(a, "n") {
			return ErrAbort
		} else {
			fmt.Println("answer not recognized")
		}
	}
}

+ f 700be0003bc2c074dc1af5138554112cebaf57bd2aebe56151d81eef7c02e1ae vendor/golang.org/x/crypto/argon2/argon2.go
utf8file 286
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package argon2 implements the key derivation function Argon2.
// Argon2 was selected as the winner of the Password Hashing Competition and can
// be used to derive cryptographic keys from passwords.
//
// For a detailed specification of Argon2 see [1].
//
// If you aren't sure which function you need, use Argon2id (IDKey) and
// the parameter recommendations for your scenario.
//
//
// Argon2i
//
// Argon2i (implemented by Key) is the side-channel resistant version of Argon2.
// It uses data-independent memory access, which is preferred for password
// hashing and password-based key derivation. Argon2i requires more passes over
// memory than Argon2id to protect from trade-off attacks. The recommended
// parameters (taken from [2]) for non-interactive operations are time=3 and to
// use the maximum available memory.
//
//
// Argon2id
//
// Argon2id (implemented by IDKey) is a hybrid version of Argon2 combining
// Argon2i and Argon2d. It uses data-independent memory access for the first
// half of the first iteration over the memory and data-dependent memory access
// for the rest. Argon2id is side-channel resistant and provides better brute-
// force cost savings due to time-memory tradeoffs than Argon2i. The recommended
// parameters for non-interactive operations (taken from [2]) are time=1 and to
// use the maximum available memory.
//
// [1] https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf
// [2] https://tools.ietf.org/html/draft-irtf-cfrg-argon2-03#section-9.3
package argon2

import (
	"encoding/binary"
	"sync"

	"golang.org/x/crypto/blake2b"
)

// The Argon2 version implemented by this package.
const Version = 0x13

const (
	argon2d = iota
	argon2i
	argon2id
)

// Key derives a key from the password, salt, and cost parameters using Argon2i
// returning a byte slice of length keyLen that can be used as cryptographic
// key. The CPU cost and parallelism degree must be greater than zero.
//
// For example, you can get a derived key for e.g. AES-256 (which needs a
// 32-byte key) by doing:
//
//      key := argon2.Key([]byte("some password"), salt, 3, 32*1024, 4, 32)
//
// The draft RFC recommends[2] time=3, and memory=32*1024 is a sensible number.
// If using that amount of memory (32 MB) is not possible in some contexts then
// the time parameter can be increased to compensate.
//
// The time parameter specifies the number of passes over the memory and the
// memory parameter specifies the size of the memory in KiB. For example
// memory=32*1024 sets the memory cost to ~32 MB. The number of threads can be
// adjusted to the number of available CPUs. The cost parameters should be
// increased as memory latency and CPU parallelism increases. Remember to get a
// good random salt.
func Key(password, salt []byte, time, memory uint32, threads uint8, keyLen uint32) []byte {
	return deriveKey(argon2i, password, salt, nil, nil, time, memory, threads, keyLen)
}

// IDKey derives a key from the password, salt, and cost parameters using
// Argon2id returning a byte slice of length keyLen that can be used as
// cryptographic key. The CPU cost and parallelism degree must be greater than
// zero.
//
// For example, you can get a derived key for e.g. AES-256 (which needs a
// 32-byte key) by doing:
//
//      key := argon2.IDKey([]byte("some password"), salt, 1, 64*1024, 4, 32)
//
// The draft RFC recommends[2] time=1, and memory=64*1024 is a sensible number.
// If using that amount of memory (64 MB) is not possible in some contexts then
// the time parameter can be increased to compensate.
//
// The time parameter specifies the number of passes over the memory and the
// memory parameter specifies the size of the memory in KiB. For example
// memory=64*1024 sets the memory cost to ~64 MB. The number of threads can be
// adjusted to the numbers of available CPUs. The cost parameters should be
// increased as memory latency and CPU parallelism increases. Remember to get a
// good random salt.
func IDKey(password, salt []byte, time, memory uint32, threads uint8, keyLen uint32) []byte {
	return deriveKey(argon2id, password, salt, nil, nil, time, memory, threads, keyLen)
}

func deriveKey(mode int, password, salt, secret, data []byte, time, memory uint32, threads uint8, keyLen uint32) []byte {
	if time < 1 {
		panic("argon2: number of rounds too small")
	}
	if threads < 1 {
		panic("argon2: parallelism degree too low")
	}
	h0 := initHash(password, salt, secret, data, time, memory, uint32(threads), keyLen, mode)

	memory = memory / (syncPoints * uint32(threads)) * (syncPoints * uint32(threads))
	if memory < 2*syncPoints*uint32(threads) {
		memory = 2 * syncPoints * uint32(threads)
	}
	B := initBlocks(&h0, memory, uint32(threads))
	processBlocks(B, time, memory, uint32(threads), mode)
	return extractKey(B, memory, uint32(threads), keyLen)
}

const (
	blockLength = 128
	syncPoints  = 4
)

type block [blockLength]uint64

func initHash(password, salt, key, data []byte, time, memory, threads, keyLen uint32, mode int) [blake2b.Size + 8]byte {
	var (
		h0     [blake2b.Size + 8]byte
		params [24]byte
		tmp    [4]byte
	)

	b2, _ := blake2b.New512(nil)
	binary.LittleEndian.PutUint32(params[0:4], threads)
	binary.LittleEndian.PutUint32(params[4:8], keyLen)
	binary.LittleEndian.PutUint32(params[8:12], memory)
	binary.LittleEndian.PutUint32(params[12:16], time)
	binary.LittleEndian.PutUint32(params[16:20], uint32(Version))
	binary.LittleEndian.PutUint32(params[20:24], uint32(mode))
	b2.Write(params[:])
	binary.LittleEndian.PutUint32(tmp[:], uint32(len(password)))
	b2.Write(tmp[:])
	b2.Write(password)
	binary.LittleEndian.PutUint32(tmp[:], uint32(len(salt)))
	b2.Write(tmp[:])
	b2.Write(salt)
	binary.LittleEndian.PutUint32(tmp[:], uint32(len(key)))
	b2.Write(tmp[:])
	b2.Write(key)
	binary.LittleEndian.PutUint32(tmp[:], uint32(len(data)))
	b2.Write(tmp[:])
	b2.Write(data)
	b2.Sum(h0[:0])
	return h0
}

func initBlocks(h0 *[blake2b.Size + 8]byte, memory, threads uint32) []block {
	var block0 [1024]byte
	B := make([]block, memory)
	for lane := uint32(0); lane < threads; lane++ {
		j := lane * (memory / threads)
		binary.LittleEndian.PutUint32(h0[blake2b.Size+4:], lane)

		binary.LittleEndian.PutUint32(h0[blake2b.Size:], 0)
		blake2bHash(block0[:], h0[:])
		for i := range B[j+0] {
			B[j+0][i] = binary.LittleEndian.Uint64(block0[i*8:])
		}

		binary.LittleEndian.PutUint32(h0[blake2b.Size:], 1)
		blake2bHash(block0[:], h0[:])
		for i := range B[j+1] {
			B[j+1][i] = binary.LittleEndian.Uint64(block0[i*8:])
		}
	}
	return B
}

func processBlocks(B []block, time, memory, threads uint32, mode int) {
	lanes := memory / threads
	segments := lanes / syncPoints

	processSegment := func(n, slice, lane uint32, wg *sync.WaitGroup) {
		var addresses, in, zero block
		if mode == argon2i || (mode == argon2id && n == 0 && slice < syncPoints/2) {
			in[0] = uint64(n)
			in[1] = uint64(lane)
			in[2] = uint64(slice)
			in[3] = uint64(memory)
			in[4] = uint64(time)
			in[5] = uint64(mode)
		}

		index := uint32(0)
		if n == 0 && slice == 0 {
			index = 2 // we have already generated the first two blocks
			if mode == argon2i || mode == argon2id {
				in[6]++
				processBlock(&addresses, &in, &zero)
				processBlock(&addresses, &addresses, &zero)
			}
		}

		offset := lane*lanes + slice*segments + index
		var random uint64
		for index < segments {
			prev := offset - 1
			if index == 0 && slice == 0 {
				prev += lanes // last block in lane
			}
			if mode == argon2i || (mode == argon2id && n == 0 && slice < syncPoints/2) {
				if index%blockLength == 0 {
					in[6]++
					processBlock(&addresses, &in, &zero)
					processBlock(&addresses, &addresses, &zero)
				}
				random = addresses[index%blockLength]
			} else {
				random = B[prev][0]
			}
			newOffset := indexAlpha(random, lanes, segments, threads, n, slice, lane, index)
			processBlockXOR(&B[offset], &B[prev], &B[newOffset])
			index, offset = index+1, offset+1
		}
		wg.Done()
	}

	for n := uint32(0); n < time; n++ {
		for slice := uint32(0); slice < syncPoints; slice++ {
			var wg sync.WaitGroup
			for lane := uint32(0); lane < threads; lane++ {
				wg.Add(1)
				go processSegment(n, slice, lane, &wg)
			}
			wg.Wait()
		}
	}

}

func extractKey(B []block, memory, threads, keyLen uint32) []byte {
	lanes := memory / threads
	for lane := uint32(0); lane < threads-1; lane++ {
		for i, v := range B[(lane*lanes)+lanes-1] {
			B[memory-1][i] ^= v
		}
	}

	var block [1024]byte
	for i, v := range B[memory-1] {
		binary.LittleEndian.PutUint64(block[i*8:], v)
	}
	key := make([]byte, keyLen)
	blake2bHash(key, block[:])
	return key
}

func indexAlpha(rand uint64, lanes, segments, threads, n, slice, lane, index uint32) uint32 {
	refLane := uint32(rand>>32) % threads
	if n == 0 && slice == 0 {
		refLane = lane
	}
	m, s := 3*segments, ((slice+1)%syncPoints)*segments
	if lane == refLane {
		m += index
	}
	if n == 0 {
		m, s = slice*segments, 0
		if slice == 0 || lane == refLane {
			m += index
		}
	}
	if index == 0 || lane == refLane {
		m--
	}
	return phi(rand, uint64(m), uint64(s), refLane, lanes)
}

func phi(rand, m, s uint64, lane, lanes uint32) uint32 {
	p := rand & 0xFFFFFFFF
	p = (p * p) >> 32
	p = (p * m) >> 32
	return lane*lanes + uint32((s+m-(p+1))%uint64(lanes))
}

+ f 00b7ed36b3569e067ce4e34c92b44914e98a26f3666a2cf01b6785cc4b8201e6 vendor/golang.org/x/crypto/argon2/blake2b.go
utf8file 54
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package argon2

import (
	"encoding/binary"
	"hash"

	"golang.org/x/crypto/blake2b"
)

// blake2bHash computes an arbitrary long hash value of in
// and writes the hash to out.
func blake2bHash(out []byte, in []byte) {
	var b2 hash.Hash
	if n := len(out); n < blake2b.Size {
		b2, _ = blake2b.New(n, nil)
	} else {
		b2, _ = blake2b.New512(nil)
	}

	var buffer [blake2b.Size]byte
	binary.LittleEndian.PutUint32(buffer[:4], uint32(len(out)))
	b2.Write(buffer[:4])
	b2.Write(in)

	if len(out) <= blake2b.Size {
		b2.Sum(out[:0])
		return
	}

	outLen := len(out)
	b2.Sum(buffer[:0])
	b2.Reset()
	copy(out, buffer[:32])
	out = out[32:]
	for len(out) > blake2b.Size {
		b2.Write(buffer[:])
		b2.Sum(buffer[:0])
		copy(out, buffer[:32])
		out = out[32:]
		b2.Reset()
	}

	if outLen%blake2b.Size > 0 { // outLen > 64
		r := ((outLen + 31) / 32) - 2 // ⌈τ /32⌉-2
		b2, _ = blake2b.New(outLen-32*r, nil)
	}
	b2.Write(buffer[:])
	b2.Sum(out[:0])
}

+ f 6458d7553cd2a15e1ce8fee73395c0892e8fe3c7cfd73d0ea06c80550ec43db5 vendor/golang.org/x/crypto/argon2/blamka_amd64.go
utf8file 61
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!gccgo,!appengine

package argon2

import "golang.org/x/sys/cpu"

func init() {
	useSSE4 = cpu.X86.HasSSE41
}

//go:noescape
func mixBlocksSSE2(out, a, b, c *block)

//go:noescape
func xorBlocksSSE2(out, a, b, c *block)

//go:noescape
func blamkaSSE4(b *block)

func processBlockSSE(out, in1, in2 *block, xor bool) {
	var t block
	mixBlocksSSE2(&t, in1, in2, &t)
	if useSSE4 {
		blamkaSSE4(&t)
	} else {
		for i := 0; i < blockLength; i += 16 {
			blamkaGeneric(
				&t[i+0], &t[i+1], &t[i+2], &t[i+3],
				&t[i+4], &t[i+5], &t[i+6], &t[i+7],
				&t[i+8], &t[i+9], &t[i+10], &t[i+11],
				&t[i+12], &t[i+13], &t[i+14], &t[i+15],
			)
		}
		for i := 0; i < blockLength/8; i += 2 {
			blamkaGeneric(
				&t[i], &t[i+1], &t[16+i], &t[16+i+1],
				&t[32+i], &t[32+i+1], &t[48+i], &t[48+i+1],
				&t[64+i], &t[64+i+1], &t[80+i], &t[80+i+1],
				&t[96+i], &t[96+i+1], &t[112+i], &t[112+i+1],
			)
		}
	}
	if xor {
		xorBlocksSSE2(out, in1, in2, &t)
	} else {
		mixBlocksSSE2(out, in1, in2, &t)
	}
}

func processBlock(out, in1, in2 *block) {
	processBlockSSE(out, in1, in2, false)
}

func processBlockXOR(out, in1, in2 *block) {
	processBlockSSE(out, in1, in2, true)
}

+ f e2d93f5d399994c197bd0116b2e63e614374fe522ab04159cbafb99dd6f86dba vendor/golang.org/x/crypto/argon2/blamka_amd64.s
utf8file 244
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!gccgo,!appengine

#include "textflag.h"

DATA ·c40<>+0x00(SB)/8, $0x0201000706050403
DATA ·c40<>+0x08(SB)/8, $0x0a09080f0e0d0c0b
GLOBL ·c40<>(SB), (NOPTR+RODATA), $16

DATA ·c48<>+0x00(SB)/8, $0x0100070605040302
DATA ·c48<>+0x08(SB)/8, $0x09080f0e0d0c0b0a
GLOBL ·c48<>(SB), (NOPTR+RODATA), $16

#define SHUFFLE(v2, v3, v4, v5, v6, v7, t1, t2) \
	MOVO       v4, t1; \
	MOVO       v5, v4; \
	MOVO       t1, v5; \
	MOVO       v6, t1; \
	PUNPCKLQDQ v6, t2; \
	PUNPCKHQDQ v7, v6; \
	PUNPCKHQDQ t2, v6; \
	PUNPCKLQDQ v7, t2; \
	MOVO       t1, v7; \
	MOVO       v2, t1; \
	PUNPCKHQDQ t2, v7; \
	PUNPCKLQDQ v3, t2; \
	PUNPCKHQDQ t2, v2; \
	PUNPCKLQDQ t1, t2; \
	PUNPCKHQDQ t2, v3

#define SHUFFLE_INV(v2, v3, v4, v5, v6, v7, t1, t2) \
	MOVO       v4, t1; \
	MOVO       v5, v4; \
	MOVO       t1, v5; \
	MOVO       v2, t1; \
	PUNPCKLQDQ v2, t2; \
	PUNPCKHQDQ v3, v2; \
	PUNPCKHQDQ t2, v2; \
	PUNPCKLQDQ v3, t2; \
	MOVO       t1, v3; \
	MOVO       v6, t1; \
	PUNPCKHQDQ t2, v3; \
	PUNPCKLQDQ v7, t2; \
	PUNPCKHQDQ t2, v6; \
	PUNPCKLQDQ t1, t2; \
	PUNPCKHQDQ t2, v7

#define HALF_ROUND(v0, v1, v2, v3, v4, v5, v6, v7, t0, c40, c48) \
	MOVO    v0, t0;        \
	PMULULQ v2, t0;        \
	PADDQ   v2, v0;        \
	PADDQ   t0, v0;        \
	PADDQ   t0, v0;        \
	PXOR    v0, v6;        \
	PSHUFD  $0xB1, v6, v6; \
	MOVO    v4, t0;        \
	PMULULQ v6, t0;        \
	PADDQ   v6, v4;        \
	PADDQ   t0, v4;        \
	PADDQ   t0, v4;        \
	PXOR    v4, v2;        \
	PSHUFB  c40, v2;       \
	MOVO    v0, t0;        \
	PMULULQ v2, t0;        \
	PADDQ   v2, v0;        \
	PADDQ   t0, v0;        \
	PADDQ   t0, v0;        \
	PXOR    v0, v6;        \
	PSHUFB  c48, v6;       \
	MOVO    v4, t0;        \
	PMULULQ v6, t0;        \
	PADDQ   v6, v4;        \
	PADDQ   t0, v4;        \
	PADDQ   t0, v4;        \
	PXOR    v4, v2;        \
	MOVO    v2, t0;        \
	PADDQ   v2, t0;        \
	PSRLQ   $63, v2;       \
	PXOR    t0, v2;        \
	MOVO    v1, t0;        \
	PMULULQ v3, t0;        \
	PADDQ   v3, v1;        \
	PADDQ   t0, v1;        \
	PADDQ   t0, v1;        \
	PXOR    v1, v7;        \
	PSHUFD  $0xB1, v7, v7; \
	MOVO    v5, t0;        \
	PMULULQ v7, t0;        \
	PADDQ   v7, v5;        \
	PADDQ   t0, v5;        \
	PADDQ   t0, v5;        \
	PXOR    v5, v3;        \
	PSHUFB  c40, v3;       \
	MOVO    v1, t0;        \
	PMULULQ v3, t0;        \
	PADDQ   v3, v1;        \
	PADDQ   t0, v1;        \
	PADDQ   t0, v1;        \
	PXOR    v1, v7;        \
	PSHUFB  c48, v7;       \
	MOVO    v5, t0;        \
	PMULULQ v7, t0;        \
	PADDQ   v7, v5;        \
	PADDQ   t0, v5;        \
	PADDQ   t0, v5;        \
	PXOR    v5, v3;        \
	MOVO    v3, t0;        \
	PADDQ   v3, t0;        \
	PSRLQ   $63, v3;       \
	PXOR    t0, v3

#define LOAD_MSG_0(block, off) \
	MOVOU 8*(off+0)(block), X0;  \
	MOVOU 8*(off+2)(block), X1;  \
	MOVOU 8*(off+4)(block), X2;  \
	MOVOU 8*(off+6)(block), X3;  \
	MOVOU 8*(off+8)(block), X4;  \
	MOVOU 8*(off+10)(block), X5; \
	MOVOU 8*(off+12)(block), X6; \
	MOVOU 8*(off+14)(block), X7

#define STORE_MSG_0(block, off) \
	MOVOU X0, 8*(off+0)(block);  \
	MOVOU X1, 8*(off+2)(block);  \
	MOVOU X2, 8*(off+4)(block);  \
	MOVOU X3, 8*(off+6)(block);  \
	MOVOU X4, 8*(off+8)(block);  \
	MOVOU X5, 8*(off+10)(block); \
	MOVOU X6, 8*(off+12)(block); \
	MOVOU X7, 8*(off+14)(block)

#define LOAD_MSG_1(block, off) \
	MOVOU 8*off+0*8(block), X0;  \
	MOVOU 8*off+16*8(block), X1; \
	MOVOU 8*off+32*8(block), X2; \
	MOVOU 8*off+48*8(block), X3; \
	MOVOU 8*off+64*8(block), X4; \
	MOVOU 8*off+80*8(block), X5; \
	MOVOU 8*off+96*8(block), X6; \
	MOVOU 8*off+112*8(block), X7

#define STORE_MSG_1(block, off) \
	MOVOU X0, 8*off+0*8(block);  \
	MOVOU X1, 8*off+16*8(block); \
	MOVOU X2, 8*off+32*8(block); \
	MOVOU X3, 8*off+48*8(block); \
	MOVOU X4, 8*off+64*8(block); \
	MOVOU X5, 8*off+80*8(block); \
	MOVOU X6, 8*off+96*8(block); \
	MOVOU X7, 8*off+112*8(block)

#define BLAMKA_ROUND_0(block, off, t0, t1, c40, c48) \
	LOAD_MSG_0(block, off);                                   \
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, t0, c40, c48); \
	SHUFFLE(X2, X3, X4, X5, X6, X7, t0, t1);                  \
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, t0, c40, c48); \
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, t0, t1);              \
	STORE_MSG_0(block, off)

#define BLAMKA_ROUND_1(block, off, t0, t1, c40, c48) \
	LOAD_MSG_1(block, off);                                   \
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, t0, c40, c48); \
	SHUFFLE(X2, X3, X4, X5, X6, X7, t0, t1);                  \
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, t0, c40, c48); \
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, t0, t1);              \
	STORE_MSG_1(block, off)

// func blamkaSSE4(b *block)
TEXT ·blamkaSSE4(SB), 4, $0-8
	MOVQ b+0(FP), AX

	MOVOU ·c40<>(SB), X10
	MOVOU ·c48<>(SB), X11

	BLAMKA_ROUND_0(AX, 0, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 16, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 32, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 48, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 64, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 80, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 96, X8, X9, X10, X11)
	BLAMKA_ROUND_0(AX, 112, X8, X9, X10, X11)

	BLAMKA_ROUND_1(AX, 0, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 2, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 4, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 6, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 8, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 10, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 12, X8, X9, X10, X11)
	BLAMKA_ROUND_1(AX, 14, X8, X9, X10, X11)
	RET

// func mixBlocksSSE2(out, a, b, c *block)
TEXT ·mixBlocksSSE2(SB), 4, $0-32
	MOVQ out+0(FP), DX
	MOVQ a+8(FP), AX
	MOVQ b+16(FP), BX
	MOVQ a+24(FP), CX
	MOVQ $128, BP

loop:
	MOVOU 0(AX), X0
	MOVOU 0(BX), X1
	MOVOU 0(CX), X2
	PXOR  X1, X0
	PXOR  X2, X0
	MOVOU X0, 0(DX)
	ADDQ  $16, AX
	ADDQ  $16, BX
	ADDQ  $16, CX
	ADDQ  $16, DX
	SUBQ  $2, BP
	JA    loop
	RET

// func xorBlocksSSE2(out, a, b, c *block)
TEXT ·xorBlocksSSE2(SB), 4, $0-32
	MOVQ out+0(FP), DX
	MOVQ a+8(FP), AX
	MOVQ b+16(FP), BX
	MOVQ a+24(FP), CX
	MOVQ $128, BP

loop:
	MOVOU 0(AX), X0
	MOVOU 0(BX), X1
	MOVOU 0(CX), X2
	MOVOU 0(DX), X3
	PXOR  X1, X0
	PXOR  X2, X0
	PXOR  X3, X0
	MOVOU X0, 0(DX)
	ADDQ  $16, AX
	ADDQ  $16, BX
	ADDQ  $16, CX
	ADDQ  $16, DX
	SUBQ  $2, BP
	JA    loop
	RET

+ f 64fc08ec2dbd617cad784bb742d3533ee14254489f94dea41849aa6e00f6b5ca vendor/golang.org/x/crypto/argon2/blamka_generic.go
utf8file 164
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package argon2

var useSSE4 bool

func processBlockGeneric(out, in1, in2 *block, xor bool) {
	var t block
	for i := range t {
		t[i] = in1[i] ^ in2[i]
	}
	for i := 0; i < blockLength; i += 16 {
		blamkaGeneric(
			&t[i+0], &t[i+1], &t[i+2], &t[i+3],
			&t[i+4], &t[i+5], &t[i+6], &t[i+7],
			&t[i+8], &t[i+9], &t[i+10], &t[i+11],
			&t[i+12], &t[i+13], &t[i+14], &t[i+15],
		)
	}
	for i := 0; i < blockLength/8; i += 2 {
		blamkaGeneric(
			&t[i], &t[i+1], &t[16+i], &t[16+i+1],
			&t[32+i], &t[32+i+1], &t[48+i], &t[48+i+1],
			&t[64+i], &t[64+i+1], &t[80+i], &t[80+i+1],
			&t[96+i], &t[96+i+1], &t[112+i], &t[112+i+1],
		)
	}
	if xor {
		for i := range t {
			out[i] ^= in1[i] ^ in2[i] ^ t[i]
		}
	} else {
		for i := range t {
			out[i] = in1[i] ^ in2[i] ^ t[i]
		}
	}
}

func blamkaGeneric(t00, t01, t02, t03, t04, t05, t06, t07, t08, t09, t10, t11, t12, t13, t14, t15 *uint64) {
	v00, v01, v02, v03 := *t00, *t01, *t02, *t03
	v04, v05, v06, v07 := *t04, *t05, *t06, *t07
	v08, v09, v10, v11 := *t08, *t09, *t10, *t11
	v12, v13, v14, v15 := *t12, *t13, *t14, *t15

	v00 += v04 + 2*uint64(uint32(v00))*uint64(uint32(v04))
	v12 ^= v00
	v12 = v12>>32 | v12<<32
	v08 += v12 + 2*uint64(uint32(v08))*uint64(uint32(v12))
	v04 ^= v08
	v04 = v04>>24 | v04<<40

	v00 += v04 + 2*uint64(uint32(v00))*uint64(uint32(v04))
	v12 ^= v00
	v12 = v12>>16 | v12<<48
	v08 += v12 + 2*uint64(uint32(v08))*uint64(uint32(v12))
	v04 ^= v08
	v04 = v04>>63 | v04<<1

	v01 += v05 + 2*uint64(uint32(v01))*uint64(uint32(v05))
	v13 ^= v01
	v13 = v13>>32 | v13<<32
	v09 += v13 + 2*uint64(uint32(v09))*uint64(uint32(v13))
	v05 ^= v09
	v05 = v05>>24 | v05<<40

	v01 += v05 + 2*uint64(uint32(v01))*uint64(uint32(v05))
	v13 ^= v01
	v13 = v13>>16 | v13<<48
	v09 += v13 + 2*uint64(uint32(v09))*uint64(uint32(v13))
	v05 ^= v09
	v05 = v05>>63 | v05<<1

	v02 += v06 + 2*uint64(uint32(v02))*uint64(uint32(v06))
	v14 ^= v02
	v14 = v14>>32 | v14<<32
	v10 += v14 + 2*uint64(uint32(v10))*uint64(uint32(v14))
	v06 ^= v10
	v06 = v06>>24 | v06<<40

	v02 += v06 + 2*uint64(uint32(v02))*uint64(uint32(v06))
	v14 ^= v02
	v14 = v14>>16 | v14<<48
	v10 += v14 + 2*uint64(uint32(v10))*uint64(uint32(v14))
	v06 ^= v10
	v06 = v06>>63 | v06<<1

	v03 += v07 + 2*uint64(uint32(v03))*uint64(uint32(v07))
	v15 ^= v03
	v15 = v15>>32 | v15<<32
	v11 += v15 + 2*uint64(uint32(v11))*uint64(uint32(v15))
	v07 ^= v11
	v07 = v07>>24 | v07<<40

	v03 += v07 + 2*uint64(uint32(v03))*uint64(uint32(v07))
	v15 ^= v03
	v15 = v15>>16 | v15<<48
	v11 += v15 + 2*uint64(uint32(v11))*uint64(uint32(v15))
	v07 ^= v11
	v07 = v07>>63 | v07<<1

	v00 += v05 + 2*uint64(uint32(v00))*uint64(uint32(v05))
	v15 ^= v00
	v15 = v15>>32 | v15<<32
	v10 += v15 + 2*uint64(uint32(v10))*uint64(uint32(v15))
	v05 ^= v10
	v05 = v05>>24 | v05<<40

	v00 += v05 + 2*uint64(uint32(v00))*uint64(uint32(v05))
	v15 ^= v00
	v15 = v15>>16 | v15<<48
	v10 += v15 + 2*uint64(uint32(v10))*uint64(uint32(v15))
	v05 ^= v10
	v05 = v05>>63 | v05<<1

	v01 += v06 + 2*uint64(uint32(v01))*uint64(uint32(v06))
	v12 ^= v01
	v12 = v12>>32 | v12<<32
	v11 += v12 + 2*uint64(uint32(v11))*uint64(uint32(v12))
	v06 ^= v11
	v06 = v06>>24 | v06<<40

	v01 += v06 + 2*uint64(uint32(v01))*uint64(uint32(v06))
	v12 ^= v01
	v12 = v12>>16 | v12<<48
	v11 += v12 + 2*uint64(uint32(v11))*uint64(uint32(v12))
	v06 ^= v11
	v06 = v06>>63 | v06<<1

	v02 += v07 + 2*uint64(uint32(v02))*uint64(uint32(v07))
	v13 ^= v02
	v13 = v13>>32 | v13<<32
	v08 += v13 + 2*uint64(uint32(v08))*uint64(uint32(v13))
	v07 ^= v08
	v07 = v07>>24 | v07<<40

	v02 += v07 + 2*uint64(uint32(v02))*uint64(uint32(v07))
	v13 ^= v02
	v13 = v13>>16 | v13<<48
	v08 += v13 + 2*uint64(uint32(v08))*uint64(uint32(v13))
	v07 ^= v08
	v07 = v07>>63 | v07<<1

	v03 += v04 + 2*uint64(uint32(v03))*uint64(uint32(v04))
	v14 ^= v03
	v14 = v14>>32 | v14<<32
	v09 += v14 + 2*uint64(uint32(v09))*uint64(uint32(v14))
	v04 ^= v09
	v04 = v04>>24 | v04<<40

	v03 += v04 + 2*uint64(uint32(v03))*uint64(uint32(v04))
	v14 ^= v03
	v14 = v14>>16 | v14<<48
	v09 += v14 + 2*uint64(uint32(v09))*uint64(uint32(v14))
	v04 ^= v09
	v04 = v04>>63 | v04<<1

	*t00, *t01, *t02, *t03 = v00, v01, v02, v03
	*t04, *t05, *t06, *t07 = v04, v05, v06, v07
	*t08, *t09, *t10, *t11 = v08, v09, v10, v11
	*t12, *t13, *t14, *t15 = v12, v13, v14, v15
}

+ f 47ab762675bbcd17563c6a34ec5b839ea432ebafa98953f171c5329789774e6e vendor/golang.org/x/crypto/argon2/blamka_ref.go
utf8file 16
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !amd64 appengine gccgo

package argon2

func processBlock(out, in1, in2 *block) {
	processBlockGeneric(out, in1, in2, false)
}

func processBlockXOR(out, in1, in2 *block) {
	processBlockGeneric(out, in1, in2, true)
}

+ f de9b7859ddcbd6fa1b93bf186a6f19c8757c01cede2a1f7df2dcbf6990f763ac vendor/golang.org/x/crypto/blake2b/blake2b.go
utf8file 290
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package blake2b implements the BLAKE2b hash algorithm defined by RFC 7693
// and the extendable output function (XOF) BLAKE2Xb.
//
// For a detailed specification of BLAKE2b see https://blake2.net/blake2.pdf
// and for BLAKE2Xb see https://blake2.net/blake2x.pdf
//
// If you aren't sure which function you need, use BLAKE2b (Sum512 or New512).
// If you need a secret-key MAC (message authentication code), use the New512
// function with a non-nil key.
//
// BLAKE2X is a construction to compute hash values larger than 64 bytes. It
// can produce hash values between 0 and 4 GiB.
package blake2b

import (
	"encoding/binary"
	"errors"
	"hash"
)

const (
	// The blocksize of BLAKE2b in bytes.
	BlockSize = 128
	// The hash size of BLAKE2b-512 in bytes.
	Size = 64
	// The hash size of BLAKE2b-384 in bytes.
	Size384 = 48
	// The hash size of BLAKE2b-256 in bytes.
	Size256 = 32
)

var (
	useAVX2 bool
	useAVX  bool
	useSSE4 bool
)

var (
	errKeySize  = errors.New("blake2b: invalid key size")
	errHashSize = errors.New("blake2b: invalid hash size")
)

var iv = [8]uint64{
	0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
	0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179,
}

// Sum512 returns the BLAKE2b-512 checksum of the data.
func Sum512(data []byte) [Size]byte {
	var sum [Size]byte
	checkSum(&sum, Size, data)
	return sum
}

// Sum384 returns the BLAKE2b-384 checksum of the data.
func Sum384(data []byte) [Size384]byte {
	var sum [Size]byte
	var sum384 [Size384]byte
	checkSum(&sum, Size384, data)
	copy(sum384[:], sum[:Size384])
	return sum384
}

// Sum256 returns the BLAKE2b-256 checksum of the data.
func Sum256(data []byte) [Size256]byte {
	var sum [Size]byte
	var sum256 [Size256]byte
	checkSum(&sum, Size256, data)
	copy(sum256[:], sum[:Size256])
	return sum256
}

// New512 returns a new hash.Hash computing the BLAKE2b-512 checksum. A non-nil
// key turns the hash into a MAC. The key must be between zero and 64 bytes long.
func New512(key []byte) (hash.Hash, error) { return newDigest(Size, key) }

// New384 returns a new hash.Hash computing the BLAKE2b-384 checksum. A non-nil
// key turns the hash into a MAC. The key must be between zero and 64 bytes long.
func New384(key []byte) (hash.Hash, error) { return newDigest(Size384, key) }

// New256 returns a new hash.Hash computing the BLAKE2b-256 checksum. A non-nil
// key turns the hash into a MAC. The key must be between zero and 64 bytes long.
func New256(key []byte) (hash.Hash, error) { return newDigest(Size256, key) }

// New returns a new hash.Hash computing the BLAKE2b checksum with a custom length.
// A non-nil key turns the hash into a MAC. The key must be between zero and 64 bytes long.
// The hash size can be a value between 1 and 64 but it is highly recommended to use
// values equal or greater than:
// - 32 if BLAKE2b is used as a hash function (The key is zero bytes long).
// - 16 if BLAKE2b is used as a MAC function (The key is at least 16 bytes long).
// When the key is nil, the returned hash.Hash implements BinaryMarshaler
// and BinaryUnmarshaler for state (de)serialization as documented by hash.Hash.
func New(size int, key []byte) (hash.Hash, error) { return newDigest(size, key) }

func newDigest(hashSize int, key []byte) (*digest, error) {
	if hashSize < 1 || hashSize > Size {
		return nil, errHashSize
	}
	if len(key) > Size {
		return nil, errKeySize
	}
	d := &digest{
		size:   hashSize,
		keyLen: len(key),
	}
	copy(d.key[:], key)
	d.Reset()
	return d, nil
}

func checkSum(sum *[Size]byte, hashSize int, data []byte) {
	h := iv
	h[0] ^= uint64(hashSize) | (1 << 16) | (1 << 24)
	var c [2]uint64

	if length := len(data); length > BlockSize {
		n := length &^ (BlockSize - 1)
		if length == n {
			n -= BlockSize
		}
		hashBlocks(&h, &c, 0, data[:n])
		data = data[n:]
	}

	var block [BlockSize]byte
	offset := copy(block[:], data)
	remaining := uint64(BlockSize - offset)
	if c[0] < remaining {
		c[1]--
	}
	c[0] -= remaining

	hashBlocks(&h, &c, 0xFFFFFFFFFFFFFFFF, block[:])

	for i, v := range h[:(hashSize+7)/8] {
		binary.LittleEndian.PutUint64(sum[8*i:], v)
	}
}

type digest struct {
	h      [8]uint64
	c      [2]uint64
	size   int
	block  [BlockSize]byte
	offset int

	key    [BlockSize]byte
	keyLen int
}

const (
	magic         = "b2b"
	marshaledSize = len(magic) + 8*8 + 2*8 + 1 + BlockSize + 1
)

func (d *digest) MarshalBinary() ([]byte, error) {
	if d.keyLen != 0 {
		return nil, errors.New("crypto/blake2b: cannot marshal MACs")
	}
	b := make([]byte, 0, marshaledSize)
	b = append(b, magic...)
	for i := 0; i < 8; i++ {
		b = appendUint64(b, d.h[i])
	}
	b = appendUint64(b, d.c[0])
	b = appendUint64(b, d.c[1])
	// Maximum value for size is 64
	b = append(b, byte(d.size))
	b = append(b, d.block[:]...)
	b = append(b, byte(d.offset))
	return b, nil
}

func (d *digest) UnmarshalBinary(b []byte) error {
	if len(b) < len(magic) || string(b[:len(magic)]) != magic {
		return errors.New("crypto/blake2b: invalid hash state identifier")
	}
	if len(b) != marshaledSize {
		return errors.New("crypto/blake2b: invalid hash state size")
	}
	b = b[len(magic):]
	for i := 0; i < 8; i++ {
		b, d.h[i] = consumeUint64(b)
	}
	b, d.c[0] = consumeUint64(b)
	b, d.c[1] = consumeUint64(b)
	d.size = int(b[0])
	b = b[1:]
	copy(d.block[:], b[:BlockSize])
	b = b[BlockSize:]
	d.offset = int(b[0])
	return nil
}

func (d *digest) BlockSize() int { return BlockSize }

func (d *digest) Size() int { return d.size }

func (d *digest) Reset() {
	d.h = iv
	d.h[0] ^= uint64(d.size) | (uint64(d.keyLen) << 8) | (1 << 16) | (1 << 24)
	d.offset, d.c[0], d.c[1] = 0, 0, 0
	if d.keyLen > 0 {
		d.block = d.key
		d.offset = BlockSize
	}
}

func (d *digest) Write(p []byte) (n int, err error) {
	n = len(p)

	if d.offset > 0 {
		remaining := BlockSize - d.offset
		if n <= remaining {
			d.offset += copy(d.block[d.offset:], p)
			return
		}
		copy(d.block[d.offset:], p[:remaining])
		hashBlocks(&d.h, &d.c, 0, d.block[:])
		d.offset = 0
		p = p[remaining:]
	}

	if length := len(p); length > BlockSize {
		nn := length &^ (BlockSize - 1)
		if length == nn {
			nn -= BlockSize
		}
		hashBlocks(&d.h, &d.c, 0, p[:nn])
		p = p[nn:]
	}

	if len(p) > 0 {
		d.offset += copy(d.block[:], p)
	}

	return
}

func (d *digest) Sum(sum []byte) []byte {
	var hash [Size]byte
	d.finalize(&hash)
	return append(sum, hash[:d.size]...)
}

func (d *digest) finalize(hash *[Size]byte) {
	var block [BlockSize]byte
	copy(block[:], d.block[:d.offset])
	remaining := uint64(BlockSize - d.offset)

	c := d.c
	if c[0] < remaining {
		c[1]--
	}
	c[0] -= remaining

	h := d.h
	hashBlocks(&h, &c, 0xFFFFFFFFFFFFFFFF, block[:])

	for i, v := range h {
		binary.LittleEndian.PutUint64(hash[8*i:], v)
	}
}

func appendUint64(b []byte, x uint64) []byte {
	var a [8]byte
	binary.BigEndian.PutUint64(a[:], x)
	return append(b, a[:]...)
}

func appendUint32(b []byte, x uint32) []byte {
	var a [4]byte
	binary.BigEndian.PutUint32(a[:], x)
	return append(b, a[:]...)
}

func consumeUint64(b []byte) ([]byte, uint64) {
	x := binary.BigEndian.Uint64(b)
	return b[8:], x
}

func consumeUint32(b []byte) ([]byte, uint32) {
	x := binary.BigEndian.Uint32(b)
	return b[4:], x
}

+ f 8a67e28c7422ccbcf781b77147531433e087dbba01ad8a0e2bfd11b15744eb9f vendor/golang.org/x/crypto/blake2b/blake2bAVX2_amd64.go
utf8file 38
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.7,amd64,!gccgo,!appengine

package blake2b

import "golang.org/x/sys/cpu"

func init() {
	useAVX2 = cpu.X86.HasAVX2
	useAVX = cpu.X86.HasAVX
	useSSE4 = cpu.X86.HasSSE41
}

//go:noescape
func hashBlocksAVX2(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)

//go:noescape
func hashBlocksAVX(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)

//go:noescape
func hashBlocksSSE4(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)

func hashBlocks(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) {
	switch {
	case useAVX2:
		hashBlocksAVX2(h, c, flag, blocks)
	case useAVX:
		hashBlocksAVX(h, c, flag, blocks)
	case useSSE4:
		hashBlocksSSE4(h, c, flag, blocks)
	default:
		hashBlocksGeneric(h, c, flag, blocks)
	}
}

+ f f4effd199a5e3359139876c01cc2943db111407ac6421394926af2302af9bd3e vendor/golang.org/x/crypto/blake2b/blake2bAVX2_amd64.s
utf8file 751
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.7,amd64,!gccgo,!appengine

#include "textflag.h"

DATA ·AVX2_iv0<>+0x00(SB)/8, $0x6a09e667f3bcc908
DATA ·AVX2_iv0<>+0x08(SB)/8, $0xbb67ae8584caa73b
DATA ·AVX2_iv0<>+0x10(SB)/8, $0x3c6ef372fe94f82b
DATA ·AVX2_iv0<>+0x18(SB)/8, $0xa54ff53a5f1d36f1
GLOBL ·AVX2_iv0<>(SB), (NOPTR+RODATA), $32

DATA ·AVX2_iv1<>+0x00(SB)/8, $0x510e527fade682d1
DATA ·AVX2_iv1<>+0x08(SB)/8, $0x9b05688c2b3e6c1f
DATA ·AVX2_iv1<>+0x10(SB)/8, $0x1f83d9abfb41bd6b
DATA ·AVX2_iv1<>+0x18(SB)/8, $0x5be0cd19137e2179
GLOBL ·AVX2_iv1<>(SB), (NOPTR+RODATA), $32

DATA ·AVX2_c40<>+0x00(SB)/8, $0x0201000706050403
DATA ·AVX2_c40<>+0x08(SB)/8, $0x0a09080f0e0d0c0b
DATA ·AVX2_c40<>+0x10(SB)/8, $0x0201000706050403
DATA ·AVX2_c40<>+0x18(SB)/8, $0x0a09080f0e0d0c0b
GLOBL ·AVX2_c40<>(SB), (NOPTR+RODATA), $32

DATA ·AVX2_c48<>+0x00(SB)/8, $0x0100070605040302
DATA ·AVX2_c48<>+0x08(SB)/8, $0x09080f0e0d0c0b0a
DATA ·AVX2_c48<>+0x10(SB)/8, $0x0100070605040302
DATA ·AVX2_c48<>+0x18(SB)/8, $0x09080f0e0d0c0b0a
GLOBL ·AVX2_c48<>(SB), (NOPTR+RODATA), $32

DATA ·AVX_iv0<>+0x00(SB)/8, $0x6a09e667f3bcc908
DATA ·AVX_iv0<>+0x08(SB)/8, $0xbb67ae8584caa73b
GLOBL ·AVX_iv0<>(SB), (NOPTR+RODATA), $16

DATA ·AVX_iv1<>+0x00(SB)/8, $0x3c6ef372fe94f82b
DATA ·AVX_iv1<>+0x08(SB)/8, $0xa54ff53a5f1d36f1
GLOBL ·AVX_iv1<>(SB), (NOPTR+RODATA), $16

DATA ·AVX_iv2<>+0x00(SB)/8, $0x510e527fade682d1
DATA ·AVX_iv2<>+0x08(SB)/8, $0x9b05688c2b3e6c1f
GLOBL ·AVX_iv2<>(SB), (NOPTR+RODATA), $16

DATA ·AVX_iv3<>+0x00(SB)/8, $0x1f83d9abfb41bd6b
DATA ·AVX_iv3<>+0x08(SB)/8, $0x5be0cd19137e2179
GLOBL ·AVX_iv3<>(SB), (NOPTR+RODATA), $16

DATA ·AVX_c40<>+0x00(SB)/8, $0x0201000706050403
DATA ·AVX_c40<>+0x08(SB)/8, $0x0a09080f0e0d0c0b
GLOBL ·AVX_c40<>(SB), (NOPTR+RODATA), $16

DATA ·AVX_c48<>+0x00(SB)/8, $0x0100070605040302
DATA ·AVX_c48<>+0x08(SB)/8, $0x09080f0e0d0c0b0a
GLOBL ·AVX_c48<>(SB), (NOPTR+RODATA), $16

#define VPERMQ_0x39_Y1_Y1 BYTE $0xc4; BYTE $0xe3; BYTE $0xfd; BYTE $0x00; BYTE $0xc9; BYTE $0x39
#define VPERMQ_0x93_Y1_Y1 BYTE $0xc4; BYTE $0xe3; BYTE $0xfd; BYTE $0x00; BYTE $0xc9; BYTE $0x93
#define VPERMQ_0x4E_Y2_Y2 BYTE $0xc4; BYTE $0xe3; BYTE $0xfd; BYTE $0x00; BYTE $0xd2; BYTE $0x4e
#define VPERMQ_0x93_Y3_Y3 BYTE $0xc4; BYTE $0xe3; BYTE $0xfd; BYTE $0x00; BYTE $0xdb; BYTE $0x93
#define VPERMQ_0x39_Y3_Y3 BYTE $0xc4; BYTE $0xe3; BYTE $0xfd; BYTE $0x00; BYTE $0xdb; BYTE $0x39

#define ROUND_AVX2(m0, m1, m2, m3, t, c40, c48) \
	VPADDQ  m0, Y0, Y0;   \
	VPADDQ  Y1, Y0, Y0;   \
	VPXOR   Y0, Y3, Y3;   \
	VPSHUFD $-79, Y3, Y3; \
	VPADDQ  Y3, Y2, Y2;   \
	VPXOR   Y2, Y1, Y1;   \
	VPSHUFB c40, Y1, Y1;  \
	VPADDQ  m1, Y0, Y0;   \
	VPADDQ  Y1, Y0, Y0;   \
	VPXOR   Y0, Y3, Y3;   \
	VPSHUFB c48, Y3, Y3;  \
	VPADDQ  Y3, Y2, Y2;   \
	VPXOR   Y2, Y1, Y1;   \
	VPADDQ  Y1, Y1, t;    \
	VPSRLQ  $63, Y1, Y1;  \
	VPXOR   t, Y1, Y1;    \
	VPERMQ_0x39_Y1_Y1;    \
	VPERMQ_0x4E_Y2_Y2;    \
	VPERMQ_0x93_Y3_Y3;    \
	VPADDQ  m2, Y0, Y0;   \
	VPADDQ  Y1, Y0, Y0;   \
	VPXOR   Y0, Y3, Y3;   \
	VPSHUFD $-79, Y3, Y3; \
	VPADDQ  Y3, Y2, Y2;   \
	VPXOR   Y2, Y1, Y1;   \
	VPSHUFB c40, Y1, Y1;  \
	VPADDQ  m3, Y0, Y0;   \
	VPADDQ  Y1, Y0, Y0;   \
	VPXOR   Y0, Y3, Y3;   \
	VPSHUFB c48, Y3, Y3;  \
	VPADDQ  Y3, Y2, Y2;   \
	VPXOR   Y2, Y1, Y1;   \
	VPADDQ  Y1, Y1, t;    \
	VPSRLQ  $63, Y1, Y1;  \
	VPXOR   t, Y1, Y1;    \
	VPERMQ_0x39_Y3_Y3;    \
	VPERMQ_0x4E_Y2_Y2;    \
	VPERMQ_0x93_Y1_Y1

#define VMOVQ_SI_X11_0 BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x1E
#define VMOVQ_SI_X12_0 BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x26
#define VMOVQ_SI_X13_0 BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x2E
#define VMOVQ_SI_X14_0 BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x36
#define VMOVQ_SI_X15_0 BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x3E

#define VMOVQ_SI_X11(n) BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x5E; BYTE $n
#define VMOVQ_SI_X12(n) BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x66; BYTE $n
#define VMOVQ_SI_X13(n) BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x6E; BYTE $n
#define VMOVQ_SI_X14(n) BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x76; BYTE $n
#define VMOVQ_SI_X15(n) BYTE $0xC5; BYTE $0x7A; BYTE $0x7E; BYTE $0x7E; BYTE $n

#define VPINSRQ_1_SI_X11_0 BYTE $0xC4; BYTE $0x63; BYTE $0xA1; BYTE $0x22; BYTE $0x1E; BYTE $0x01
#define VPINSRQ_1_SI_X12_0 BYTE $0xC4; BYTE $0x63; BYTE $0x99; BYTE $0x22; BYTE $0x26; BYTE $0x01
#define VPINSRQ_1_SI_X13_0 BYTE $0xC4; BYTE $0x63; BYTE $0x91; BYTE $0x22; BYTE $0x2E; BYTE $0x01
#define VPINSRQ_1_SI_X14_0 BYTE $0xC4; BYTE $0x63; BYTE $0x89; BYTE $0x22; BYTE $0x36; BYTE $0x01
#define VPINSRQ_1_SI_X15_0 BYTE $0xC4; BYTE $0x63; BYTE $0x81; BYTE $0x22; BYTE $0x3E; BYTE $0x01

#define VPINSRQ_1_SI_X11(n) BYTE $0xC4; BYTE $0x63; BYTE $0xA1; BYTE $0x22; BYTE $0x5E; BYTE $n; BYTE $0x01
#define VPINSRQ_1_SI_X12(n) BYTE $0xC4; BYTE $0x63; BYTE $0x99; BYTE $0x22; BYTE $0x66; BYTE $n; BYTE $0x01
#define VPINSRQ_1_SI_X13(n) BYTE $0xC4; BYTE $0x63; BYTE $0x91; BYTE $0x22; BYTE $0x6E; BYTE $n; BYTE $0x01
#define VPINSRQ_1_SI_X14(n) BYTE $0xC4; BYTE $0x63; BYTE $0x89; BYTE $0x22; BYTE $0x76; BYTE $n; BYTE $0x01
#define VPINSRQ_1_SI_X15(n) BYTE $0xC4; BYTE $0x63; BYTE $0x81; BYTE $0x22; BYTE $0x7E; BYTE $n; BYTE $0x01

#define VMOVQ_R8_X15 BYTE $0xC4; BYTE $0x41; BYTE $0xF9; BYTE $0x6E; BYTE $0xF8
#define VPINSRQ_1_R9_X15 BYTE $0xC4; BYTE $0x43; BYTE $0x81; BYTE $0x22; BYTE $0xF9; BYTE $0x01

// load msg: Y12 = (i0, i1, i2, i3)
// i0, i1, i2, i3 must not be 0
#define LOAD_MSG_AVX2_Y12(i0, i1, i2, i3) \
	VMOVQ_SI_X12(i0*8);           \
	VMOVQ_SI_X11(i2*8);           \
	VPINSRQ_1_SI_X12(i1*8);       \
	VPINSRQ_1_SI_X11(i3*8);       \
	VINSERTI128 $1, X11, Y12, Y12

// load msg: Y13 = (i0, i1, i2, i3)
// i0, i1, i2, i3 must not be 0
#define LOAD_MSG_AVX2_Y13(i0, i1, i2, i3) \
	VMOVQ_SI_X13(i0*8);           \
	VMOVQ_SI_X11(i2*8);           \
	VPINSRQ_1_SI_X13(i1*8);       \
	VPINSRQ_1_SI_X11(i3*8);       \
	VINSERTI128 $1, X11, Y13, Y13

// load msg: Y14 = (i0, i1, i2, i3)
// i0, i1, i2, i3 must not be 0
#define LOAD_MSG_AVX2_Y14(i0, i1, i2, i3) \
	VMOVQ_SI_X14(i0*8);           \
	VMOVQ_SI_X11(i2*8);           \
	VPINSRQ_1_SI_X14(i1*8);       \
	VPINSRQ_1_SI_X11(i3*8);       \
	VINSERTI128 $1, X11, Y14, Y14

// load msg: Y15 = (i0, i1, i2, i3)
// i0, i1, i2, i3 must not be 0
#define LOAD_MSG_AVX2_Y15(i0, i1, i2, i3) \
	VMOVQ_SI_X15(i0*8);           \
	VMOVQ_SI_X11(i2*8);           \
	VPINSRQ_1_SI_X15(i1*8);       \
	VPINSRQ_1_SI_X11(i3*8);       \
	VINSERTI128 $1, X11, Y15, Y15

#define LOAD_MSG_AVX2_0_2_4_6_1_3_5_7_8_10_12_14_9_11_13_15() \
	VMOVQ_SI_X12_0;                   \
	VMOVQ_SI_X11(4*8);                \
	VPINSRQ_1_SI_X12(2*8);            \
	VPINSRQ_1_SI_X11(6*8);            \
	VINSERTI128 $1, X11, Y12, Y12;    \
	LOAD_MSG_AVX2_Y13(1, 3, 5, 7);    \
	LOAD_MSG_AVX2_Y14(8, 10, 12, 14); \
	LOAD_MSG_AVX2_Y15(9, 11, 13, 15)

#define LOAD_MSG_AVX2_14_4_9_13_10_8_15_6_1_0_11_5_12_2_7_3() \
	LOAD_MSG_AVX2_Y12(14, 4, 9, 13); \
	LOAD_MSG_AVX2_Y13(10, 8, 15, 6); \
	VMOVQ_SI_X11(11*8);              \
	VPSHUFD     $0x4E, 0*8(SI), X14; \
	VPINSRQ_1_SI_X11(5*8);           \
	VINSERTI128 $1, X11, Y14, Y14;   \
	LOAD_MSG_AVX2_Y15(12, 2, 7, 3)

#define LOAD_MSG_AVX2_11_12_5_15_8_0_2_13_10_3_7_9_14_6_1_4() \
	VMOVQ_SI_X11(5*8);              \
	VMOVDQU     11*8(SI), X12;      \
	VPINSRQ_1_SI_X11(15*8);         \
	VINSERTI128 $1, X11, Y12, Y12;  \
	VMOVQ_SI_X13(8*8);              \
	VMOVQ_SI_X11(2*8);              \
	VPINSRQ_1_SI_X13_0;             \
	VPINSRQ_1_SI_X11(13*8);         \
	VINSERTI128 $1, X11, Y13, Y13;  \
	LOAD_MSG_AVX2_Y14(10, 3, 7, 9); \
	LOAD_MSG_AVX2_Y15(14, 6, 1, 4)

#define LOAD_MSG_AVX2_7_3_13_11_9_1_12_14_2_5_4_15_6_10_0_8() \
	LOAD_MSG_AVX2_Y12(7, 3, 13, 11); \
	LOAD_MSG_AVX2_Y13(9, 1, 12, 14); \
	LOAD_MSG_AVX2_Y14(2, 5, 4, 15);  \
	VMOVQ_SI_X15(6*8);               \
	VMOVQ_SI_X11_0;                  \
	VPINSRQ_1_SI_X15(10*8);          \
	VPINSRQ_1_SI_X11(8*8);           \
	VINSERTI128 $1, X11, Y15, Y15

#define LOAD_MSG_AVX2_9_5_2_10_0_7_4_15_14_11_6_3_1_12_8_13() \
	LOAD_MSG_AVX2_Y12(9, 5, 2, 10);  \
	VMOVQ_SI_X13_0;                  \
	VMOVQ_SI_X11(4*8);               \
	VPINSRQ_1_SI_X13(7*8);           \
	VPINSRQ_1_SI_X11(15*8);          \
	VINSERTI128 $1, X11, Y13, Y13;   \
	LOAD_MSG_AVX2_Y14(14, 11, 6, 3); \
	LOAD_MSG_AVX2_Y15(1, 12, 8, 13)

#define LOAD_MSG_AVX2_2_6_0_8_12_10_11_3_4_7_15_1_13_5_14_9() \
	VMOVQ_SI_X12(2*8);                \
	VMOVQ_SI_X11_0;                   \
	VPINSRQ_1_SI_X12(6*8);            \
	VPINSRQ_1_SI_X11(8*8);            \
	VINSERTI128 $1, X11, Y12, Y12;    \
	LOAD_MSG_AVX2_Y13(12, 10, 11, 3); \
	LOAD_MSG_AVX2_Y14(4, 7, 15, 1);   \
	LOAD_MSG_AVX2_Y15(13, 5, 14, 9)

#define LOAD_MSG_AVX2_12_1_14_4_5_15_13_10_0_6_9_8_7_3_2_11() \
	LOAD_MSG_AVX2_Y12(12, 1, 14, 4);  \
	LOAD_MSG_AVX2_Y13(5, 15, 13, 10); \
	VMOVQ_SI_X14_0;                   \
	VPSHUFD     $0x4E, 8*8(SI), X11;  \
	VPINSRQ_1_SI_X14(6*8);            \
	VINSERTI128 $1, X11, Y14, Y14;    \
	LOAD_MSG_AVX2_Y15(7, 3, 2, 11)

#define LOAD_MSG_AVX2_13_7_12_3_11_14_1_9_5_15_8_2_0_4_6_10() \
	LOAD_MSG_AVX2_Y12(13, 7, 12, 3); \
	LOAD_MSG_AVX2_Y13(11, 14, 1, 9); \
	LOAD_MSG_AVX2_Y14(5, 15, 8, 2);  \
	VMOVQ_SI_X15_0;                  \
	VMOVQ_SI_X11(6*8);               \
	VPINSRQ_1_SI_X15(4*8);           \
	VPINSRQ_1_SI_X11(10*8);          \
	VINSERTI128 $1, X11, Y15, Y15

#define LOAD_MSG_AVX2_6_14_11_0_15_9_3_8_12_13_1_10_2_7_4_5() \
	VMOVQ_SI_X12(6*8);              \
	VMOVQ_SI_X11(11*8);             \
	VPINSRQ_1_SI_X12(14*8);         \
	VPINSRQ_1_SI_X11_0;             \
	VINSERTI128 $1, X11, Y12, Y12;  \
	LOAD_MSG_AVX2_Y13(15, 9, 3, 8); \
	VMOVQ_SI_X11(1*8);              \
	VMOVDQU     12*8(SI), X14;      \
	VPINSRQ_1_SI_X11(10*8);         \
	VINSERTI128 $1, X11, Y14, Y14;  \
	VMOVQ_SI_X15(2*8);              \
	VMOVDQU     4*8(SI), X11;       \
	VPINSRQ_1_SI_X15(7*8);          \
	VINSERTI128 $1, X11, Y15, Y15

#define LOAD_MSG_AVX2_10_8_7_1_2_4_6_5_15_9_3_13_11_14_12_0() \
	LOAD_MSG_AVX2_Y12(10, 8, 7, 1);  \
	VMOVQ_SI_X13(2*8);               \
	VPSHUFD     $0x4E, 5*8(SI), X11; \
	VPINSRQ_1_SI_X13(4*8);           \
	VINSERTI128 $1, X11, Y13, Y13;   \
	LOAD_MSG_AVX2_Y14(15, 9, 3, 13); \
	VMOVQ_SI_X15(11*8);              \
	VMOVQ_SI_X11(12*8);              \
	VPINSRQ_1_SI_X15(14*8);          \
	VPINSRQ_1_SI_X11_0;              \
	VINSERTI128 $1, X11, Y15, Y15

// func hashBlocksAVX2(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)
TEXT ·hashBlocksAVX2(SB), 4, $320-48 // frame size = 288 + 32 byte alignment
	MOVQ h+0(FP), AX
	MOVQ c+8(FP), BX
	MOVQ flag+16(FP), CX
	MOVQ blocks_base+24(FP), SI
	MOVQ blocks_len+32(FP), DI

	MOVQ SP, DX
	MOVQ SP, R9
	ADDQ $31, R9
	ANDQ $~31, R9
	MOVQ R9, SP

	MOVQ CX, 16(SP)
	XORQ CX, CX
	MOVQ CX, 24(SP)

	VMOVDQU ·AVX2_c40<>(SB), Y4
	VMOVDQU ·AVX2_c48<>(SB), Y5

	VMOVDQU 0(AX), Y8
	VMOVDQU 32(AX), Y9
	VMOVDQU ·AVX2_iv0<>(SB), Y6
	VMOVDQU ·AVX2_iv1<>(SB), Y7

	MOVQ 0(BX), R8
	MOVQ 8(BX), R9
	MOVQ R9, 8(SP)

loop:
	ADDQ $128, R8
	MOVQ R8, 0(SP)
	CMPQ R8, $128
	JGE  noinc
	INCQ R9
	MOVQ R9, 8(SP)

noinc:
	VMOVDQA Y8, Y0
	VMOVDQA Y9, Y1
	VMOVDQA Y6, Y2
	VPXOR   0(SP), Y7, Y3

	LOAD_MSG_AVX2_0_2_4_6_1_3_5_7_8_10_12_14_9_11_13_15()
	VMOVDQA Y12, 32(SP)
	VMOVDQA Y13, 64(SP)
	VMOVDQA Y14, 96(SP)
	VMOVDQA Y15, 128(SP)
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_14_4_9_13_10_8_15_6_1_0_11_5_12_2_7_3()
	VMOVDQA Y12, 160(SP)
	VMOVDQA Y13, 192(SP)
	VMOVDQA Y14, 224(SP)
	VMOVDQA Y15, 256(SP)

	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_11_12_5_15_8_0_2_13_10_3_7_9_14_6_1_4()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_7_3_13_11_9_1_12_14_2_5_4_15_6_10_0_8()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_9_5_2_10_0_7_4_15_14_11_6_3_1_12_8_13()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_2_6_0_8_12_10_11_3_4_7_15_1_13_5_14_9()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_12_1_14_4_5_15_13_10_0_6_9_8_7_3_2_11()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_13_7_12_3_11_14_1_9_5_15_8_2_0_4_6_10()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_6_14_11_0_15_9_3_8_12_13_1_10_2_7_4_5()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)
	LOAD_MSG_AVX2_10_8_7_1_2_4_6_5_15_9_3_13_11_14_12_0()
	ROUND_AVX2(Y12, Y13, Y14, Y15, Y10, Y4, Y5)

	ROUND_AVX2(32(SP), 64(SP), 96(SP), 128(SP), Y10, Y4, Y5)
	ROUND_AVX2(160(SP), 192(SP), 224(SP), 256(SP), Y10, Y4, Y5)

	VPXOR Y0, Y8, Y8
	VPXOR Y1, Y9, Y9
	VPXOR Y2, Y8, Y8
	VPXOR Y3, Y9, Y9

	LEAQ 128(SI), SI
	SUBQ $128, DI
	JNE  loop

	MOVQ R8, 0(BX)
	MOVQ R9, 8(BX)

	VMOVDQU Y8, 0(AX)
	VMOVDQU Y9, 32(AX)
	VZEROUPPER

	MOVQ DX, SP
	RET

#define VPUNPCKLQDQ_X2_X2_X15 BYTE $0xC5; BYTE $0x69; BYTE $0x6C; BYTE $0xFA
#define VPUNPCKLQDQ_X3_X3_X15 BYTE $0xC5; BYTE $0x61; BYTE $0x6C; BYTE $0xFB
#define VPUNPCKLQDQ_X7_X7_X15 BYTE $0xC5; BYTE $0x41; BYTE $0x6C; BYTE $0xFF
#define VPUNPCKLQDQ_X13_X13_X15 BYTE $0xC4; BYTE $0x41; BYTE $0x11; BYTE $0x6C; BYTE $0xFD
#define VPUNPCKLQDQ_X14_X14_X15 BYTE $0xC4; BYTE $0x41; BYTE $0x09; BYTE $0x6C; BYTE $0xFE

#define VPUNPCKHQDQ_X15_X2_X2 BYTE $0xC4; BYTE $0xC1; BYTE $0x69; BYTE $0x6D; BYTE $0xD7
#define VPUNPCKHQDQ_X15_X3_X3 BYTE $0xC4; BYTE $0xC1; BYTE $0x61; BYTE $0x6D; BYTE $0xDF
#define VPUNPCKHQDQ_X15_X6_X6 BYTE $0xC4; BYTE $0xC1; BYTE $0x49; BYTE $0x6D; BYTE $0xF7
#define VPUNPCKHQDQ_X15_X7_X7 BYTE $0xC4; BYTE $0xC1; BYTE $0x41; BYTE $0x6D; BYTE $0xFF
#define VPUNPCKHQDQ_X15_X3_X2 BYTE $0xC4; BYTE $0xC1; BYTE $0x61; BYTE $0x6D; BYTE $0xD7
#define VPUNPCKHQDQ_X15_X7_X6 BYTE $0xC4; BYTE $0xC1; BYTE $0x41; BYTE $0x6D; BYTE $0xF7
#define VPUNPCKHQDQ_X15_X13_X3 BYTE $0xC4; BYTE $0xC1; BYTE $0x11; BYTE $0x6D; BYTE $0xDF
#define VPUNPCKHQDQ_X15_X13_X7 BYTE $0xC4; BYTE $0xC1; BYTE $0x11; BYTE $0x6D; BYTE $0xFF

#define SHUFFLE_AVX() \
	VMOVDQA X6, X13;         \
	VMOVDQA X2, X14;         \
	VMOVDQA X4, X6;          \
	VPUNPCKLQDQ_X13_X13_X15; \
	VMOVDQA X5, X4;          \
	VMOVDQA X6, X5;          \
	VPUNPCKHQDQ_X15_X7_X6;   \
	VPUNPCKLQDQ_X7_X7_X15;   \
	VPUNPCKHQDQ_X15_X13_X7;  \
	VPUNPCKLQDQ_X3_X3_X15;   \
	VPUNPCKHQDQ_X15_X2_X2;   \
	VPUNPCKLQDQ_X14_X14_X15; \
	VPUNPCKHQDQ_X15_X3_X3;   \

#define SHUFFLE_AVX_INV() \
	VMOVDQA X2, X13;         \
	VMOVDQA X4, X14;         \
	VPUNPCKLQDQ_X2_X2_X15;   \
	VMOVDQA X5, X4;          \
	VPUNPCKHQDQ_X15_X3_X2;   \
	VMOVDQA X14, X5;         \
	VPUNPCKLQDQ_X3_X3_X15;   \
	VMOVDQA X6, X14;         \
	VPUNPCKHQDQ_X15_X13_X3;  \
	VPUNPCKLQDQ_X7_X7_X15;   \
	VPUNPCKHQDQ_X15_X6_X6;   \
	VPUNPCKLQDQ_X14_X14_X15; \
	VPUNPCKHQDQ_X15_X7_X7;   \

#define HALF_ROUND_AVX(v0, v1, v2, v3, v4, v5, v6, v7, m0, m1, m2, m3, t0, c40, c48) \
	VPADDQ  m0, v0, v0;   \
	VPADDQ  v2, v0, v0;   \
	VPADDQ  m1, v1, v1;   \
	VPADDQ  v3, v1, v1;   \
	VPXOR   v0, v6, v6;   \
	VPXOR   v1, v7, v7;   \
	VPSHUFD $-79, v6, v6; \
	VPSHUFD $-79, v7, v7; \
	VPADDQ  v6, v4, v4;   \
	VPADDQ  v7, v5, v5;   \
	VPXOR   v4, v2, v2;   \
	VPXOR   v5, v3, v3;   \
	VPSHUFB c40, v2, v2;  \
	VPSHUFB c40, v3, v3;  \
	VPADDQ  m2, v0, v0;   \
	VPADDQ  v2, v0, v0;   \
	VPADDQ  m3, v1, v1;   \
	VPADDQ  v3, v1, v1;   \
	VPXOR   v0, v6, v6;   \
	VPXOR   v1, v7, v7;   \
	VPSHUFB c48, v6, v6;  \
	VPSHUFB c48, v7, v7;  \
	VPADDQ  v6, v4, v4;   \
	VPADDQ  v7, v5, v5;   \
	VPXOR   v4, v2, v2;   \
	VPXOR   v5, v3, v3;   \
	VPADDQ  v2, v2, t0;   \
	VPSRLQ  $63, v2, v2;  \
	VPXOR   t0, v2, v2;   \
	VPADDQ  v3, v3, t0;   \
	VPSRLQ  $63, v3, v3;  \
	VPXOR   t0, v3, v3

// load msg: X12 = (i0, i1), X13 = (i2, i3), X14 = (i4, i5), X15 = (i6, i7)
// i0, i1, i2, i3, i4, i5, i6, i7 must not be 0
#define LOAD_MSG_AVX(i0, i1, i2, i3, i4, i5, i6, i7) \
	VMOVQ_SI_X12(i0*8);     \
	VMOVQ_SI_X13(i2*8);     \
	VMOVQ_SI_X14(i4*8);     \
	VMOVQ_SI_X15(i6*8);     \
	VPINSRQ_1_SI_X12(i1*8); \
	VPINSRQ_1_SI_X13(i3*8); \
	VPINSRQ_1_SI_X14(i5*8); \
	VPINSRQ_1_SI_X15(i7*8)

// load msg: X12 = (0, 2), X13 = (4, 6), X14 = (1, 3), X15 = (5, 7)
#define LOAD_MSG_AVX_0_2_4_6_1_3_5_7() \
	VMOVQ_SI_X12_0;        \
	VMOVQ_SI_X13(4*8);     \
	VMOVQ_SI_X14(1*8);     \
	VMOVQ_SI_X15(5*8);     \
	VPINSRQ_1_SI_X12(2*8); \
	VPINSRQ_1_SI_X13(6*8); \
	VPINSRQ_1_SI_X14(3*8); \
	VPINSRQ_1_SI_X15(7*8)

// load msg: X12 = (1, 0), X13 = (11, 5), X14 = (12, 2), X15 = (7, 3)
#define LOAD_MSG_AVX_1_0_11_5_12_2_7_3() \
	VPSHUFD $0x4E, 0*8(SI), X12; \
	VMOVQ_SI_X13(11*8);          \
	VMOVQ_SI_X14(12*8);          \
	VMOVQ_SI_X15(7*8);           \
	VPINSRQ_1_SI_X13(5*8);       \
	VPINSRQ_1_SI_X14(2*8);       \
	VPINSRQ_1_SI_X15(3*8)

// load msg: X12 = (11, 12), X13 = (5, 15), X14 = (8, 0), X15 = (2, 13)
#define LOAD_MSG_AVX_11_12_5_15_8_0_2_13() \
	VMOVDQU 11*8(SI), X12;  \
	VMOVQ_SI_X13(5*8);      \
	VMOVQ_SI_X14(8*8);      \
	VMOVQ_SI_X15(2*8);      \
	VPINSRQ_1_SI_X13(15*8); \
	VPINSRQ_1_SI_X14_0;     \
	VPINSRQ_1_SI_X15(13*8)

// load msg: X12 = (2, 5), X13 = (4, 15), X14 = (6, 10), X15 = (0, 8)
#define LOAD_MSG_AVX_2_5_4_15_6_10_0_8() \
	VMOVQ_SI_X12(2*8);      \
	VMOVQ_SI_X13(4*8);      \
	VMOVQ_SI_X14(6*8);      \
	VMOVQ_SI_X15_0;         \
	VPINSRQ_1_SI_X12(5*8);  \
	VPINSRQ_1_SI_X13(15*8); \
	VPINSRQ_1_SI_X14(10*8); \
	VPINSRQ_1_SI_X15(8*8)

// load msg: X12 = (9, 5), X13 = (2, 10), X14 = (0, 7), X15 = (4, 15)
#define LOAD_MSG_AVX_9_5_2_10_0_7_4_15() \
	VMOVQ_SI_X12(9*8);      \
	VMOVQ_SI_X13(2*8);      \
	VMOVQ_SI_X14_0;         \
	VMOVQ_SI_X15(4*8);      \
	VPINSRQ_1_SI_X12(5*8);  \
	VPINSRQ_1_SI_X13(10*8); \
	VPINSRQ_1_SI_X14(7*8);  \
	VPINSRQ_1_SI_X15(15*8)

// load msg: X12 = (2, 6), X13 = (0, 8), X14 = (12, 10), X15 = (11, 3)
#define LOAD_MSG_AVX_2_6_0_8_12_10_11_3() \
	VMOVQ_SI_X12(2*8);      \
	VMOVQ_SI_X13_0;         \
	VMOVQ_SI_X14(12*8);     \
	VMOVQ_SI_X15(11*8);     \
	VPINSRQ_1_SI_X12(6*8);  \
	VPINSRQ_1_SI_X13(8*8);  \
	VPINSRQ_1_SI_X14(10*8); \
	VPINSRQ_1_SI_X15(3*8)

// load msg: X12 = (0, 6), X13 = (9, 8), X14 = (7, 3), X15 = (2, 11)
#define LOAD_MSG_AVX_0_6_9_8_7_3_2_11() \
	MOVQ    0*8(SI), X12;        \
	VPSHUFD $0x4E, 8*8(SI), X13; \
	MOVQ    7*8(SI), X14;        \
	MOVQ    2*8(SI), X15;        \
	VPINSRQ_1_SI_X12(6*8);       \
	VPINSRQ_1_SI_X14(3*8);       \
	VPINSRQ_1_SI_X15(11*8)

// load msg: X12 = (6, 14), X13 = (11, 0), X14 = (15, 9), X15 = (3, 8)
#define LOAD_MSG_AVX_6_14_11_0_15_9_3_8() \
	MOVQ 6*8(SI), X12;      \
	MOVQ 11*8(SI), X13;     \
	MOVQ 15*8(SI), X14;     \
	MOVQ 3*8(SI), X15;      \
	VPINSRQ_1_SI_X12(14*8); \
	VPINSRQ_1_SI_X13_0;     \
	VPINSRQ_1_SI_X14(9*8);  \
	VPINSRQ_1_SI_X15(8*8)

// load msg: X12 = (5, 15), X13 = (8, 2), X14 = (0, 4), X15 = (6, 10)
#define LOAD_MSG_AVX_5_15_8_2_0_4_6_10() \
	MOVQ 5*8(SI), X12;      \
	MOVQ 8*8(SI), X13;      \
	MOVQ 0*8(SI), X14;      \
	MOVQ 6*8(SI), X15;      \
	VPINSRQ_1_SI_X12(15*8); \
	VPINSRQ_1_SI_X13(2*8);  \
	VPINSRQ_1_SI_X14(4*8);  \
	VPINSRQ_1_SI_X15(10*8)

// load msg: X12 = (12, 13), X13 = (1, 10), X14 = (2, 7), X15 = (4, 5)
#define LOAD_MSG_AVX_12_13_1_10_2_7_4_5() \
	VMOVDQU 12*8(SI), X12;  \
	MOVQ    1*8(SI), X13;   \
	MOVQ    2*8(SI), X14;   \
	VPINSRQ_1_SI_X13(10*8); \
	VPINSRQ_1_SI_X14(7*8);  \
	VMOVDQU 4*8(SI), X15

// load msg: X12 = (15, 9), X13 = (3, 13), X14 = (11, 14), X15 = (12, 0)
#define LOAD_MSG_AVX_15_9_3_13_11_14_12_0() \
	MOVQ 15*8(SI), X12;     \
	MOVQ 3*8(SI), X13;      \
	MOVQ 11*8(SI), X14;     \
	MOVQ 12*8(SI), X15;     \
	VPINSRQ_1_SI_X12(9*8);  \
	VPINSRQ_1_SI_X13(13*8); \
	VPINSRQ_1_SI_X14(14*8); \
	VPINSRQ_1_SI_X15_0

// func hashBlocksAVX(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)
TEXT ·hashBlocksAVX(SB), 4, $288-48 // frame size = 272 + 16 byte alignment
	MOVQ h+0(FP), AX
	MOVQ c+8(FP), BX
	MOVQ flag+16(FP), CX
	MOVQ blocks_base+24(FP), SI
	MOVQ blocks_len+32(FP), DI

	MOVQ SP, BP
	MOVQ SP, R9
	ADDQ $15, R9
	ANDQ $~15, R9
	MOVQ R9, SP

	VMOVDQU ·AVX_c40<>(SB), X0
	VMOVDQU ·AVX_c48<>(SB), X1
	VMOVDQA X0, X8
	VMOVDQA X1, X9

	VMOVDQU ·AVX_iv3<>(SB), X0
	VMOVDQA X0, 0(SP)
	XORQ    CX, 0(SP)          // 0(SP) = ·AVX_iv3 ^ (CX || 0)

	VMOVDQU 0(AX), X10
	VMOVDQU 16(AX), X11
	VMOVDQU 32(AX), X2
	VMOVDQU 48(AX), X3

	MOVQ 0(BX), R8
	MOVQ 8(BX), R9

loop:
	ADDQ $128, R8
	CMPQ R8, $128
	JGE  noinc
	INCQ R9

noinc:
	VMOVQ_R8_X15
	VPINSRQ_1_R9_X15

	VMOVDQA X10, X0
	VMOVDQA X11, X1
	VMOVDQU ·AVX_iv0<>(SB), X4
	VMOVDQU ·AVX_iv1<>(SB), X5
	VMOVDQU ·AVX_iv2<>(SB), X6

	VPXOR   X15, X6, X6
	VMOVDQA 0(SP), X7

	LOAD_MSG_AVX_0_2_4_6_1_3_5_7()
	VMOVDQA X12, 16(SP)
	VMOVDQA X13, 32(SP)
	VMOVDQA X14, 48(SP)
	VMOVDQA X15, 64(SP)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX(8, 10, 12, 14, 9, 11, 13, 15)
	VMOVDQA X12, 80(SP)
	VMOVDQA X13, 96(SP)
	VMOVDQA X14, 112(SP)
	VMOVDQA X15, 128(SP)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX(14, 4, 9, 13, 10, 8, 15, 6)
	VMOVDQA X12, 144(SP)
	VMOVDQA X13, 160(SP)
	VMOVDQA X14, 176(SP)
	VMOVDQA X15, 192(SP)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_1_0_11_5_12_2_7_3()
	VMOVDQA X12, 208(SP)
	VMOVDQA X13, 224(SP)
	VMOVDQA X14, 240(SP)
	VMOVDQA X15, 256(SP)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX_11_12_5_15_8_0_2_13()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX(10, 3, 7, 9, 14, 6, 1, 4)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX(7, 3, 13, 11, 9, 1, 12, 14)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_2_5_4_15_6_10_0_8()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX_9_5_2_10_0_7_4_15()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX(14, 11, 6, 3, 1, 12, 8, 13)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX_2_6_0_8_12_10_11_3()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX(4, 7, 15, 1, 13, 5, 14, 9)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX(12, 1, 14, 4, 5, 15, 13, 10)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_0_6_9_8_7_3_2_11()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX(13, 7, 12, 3, 11, 14, 1, 9)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_5_15_8_2_0_4_6_10()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX_6_14_11_0_15_9_3_8()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_12_13_1_10_2_7_4_5()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	LOAD_MSG_AVX(10, 8, 7, 1, 2, 4, 6, 5)
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX()
	LOAD_MSG_AVX_15_9_3_13_11_14_12_0()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, X12, X13, X14, X15, X15, X8, X9)
	SHUFFLE_AVX_INV()

	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, 16(SP), 32(SP), 48(SP), 64(SP), X15, X8, X9)
	SHUFFLE_AVX()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, 80(SP), 96(SP), 112(SP), 128(SP), X15, X8, X9)
	SHUFFLE_AVX_INV()

	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, 144(SP), 160(SP), 176(SP), 192(SP), X15, X8, X9)
	SHUFFLE_AVX()
	HALF_ROUND_AVX(X0, X1, X2, X3, X4, X5, X6, X7, 208(SP), 224(SP), 240(SP), 256(SP), X15, X8, X9)
	SHUFFLE_AVX_INV()

	VMOVDQU 32(AX), X14
	VMOVDQU 48(AX), X15
	VPXOR   X0, X10, X10
	VPXOR   X1, X11, X11
	VPXOR   X2, X14, X14
	VPXOR   X3, X15, X15
	VPXOR   X4, X10, X10
	VPXOR   X5, X11, X11
	VPXOR   X6, X14, X2
	VPXOR   X7, X15, X3
	VMOVDQU X2, 32(AX)
	VMOVDQU X3, 48(AX)

	LEAQ 128(SI), SI
	SUBQ $128, DI
	JNE  loop

	VMOVDQU X10, 0(AX)
	VMOVDQU X11, 16(AX)

	MOVQ R8, 0(BX)
	MOVQ R9, 8(BX)
	VZEROUPPER

	MOVQ BP, SP
	RET

+ f 4599bd632f894078cdb44fd250159d23ba08fbe7b43770cf3f1f56d93cb331a8 vendor/golang.org/x/crypto/blake2b/blake2b_amd64.go
utf8file 25
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !go1.7,amd64,!gccgo,!appengine

package blake2b

import "golang.org/x/sys/cpu"

func init() {
	useSSE4 = cpu.X86.HasSSE41
}

//go:noescape
func hashBlocksSSE4(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)

func hashBlocks(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) {
	if useSSE4 {
		hashBlocksSSE4(h, c, flag, blocks)
	} else {
		hashBlocksGeneric(h, c, flag, blocks)
	}
}

+ f 34a399fcc95e64715ecb829552490049dbfd064df33fb21d985b8002a1a5821f vendor/golang.org/x/crypto/blake2b/blake2b_amd64.s
utf8file 282
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!gccgo,!appengine

#include "textflag.h"

DATA ·iv0<>+0x00(SB)/8, $0x6a09e667f3bcc908
DATA ·iv0<>+0x08(SB)/8, $0xbb67ae8584caa73b
GLOBL ·iv0<>(SB), (NOPTR+RODATA), $16

DATA ·iv1<>+0x00(SB)/8, $0x3c6ef372fe94f82b
DATA ·iv1<>+0x08(SB)/8, $0xa54ff53a5f1d36f1
GLOBL ·iv1<>(SB), (NOPTR+RODATA), $16

DATA ·iv2<>+0x00(SB)/8, $0x510e527fade682d1
DATA ·iv2<>+0x08(SB)/8, $0x9b05688c2b3e6c1f
GLOBL ·iv2<>(SB), (NOPTR+RODATA), $16

DATA ·iv3<>+0x00(SB)/8, $0x1f83d9abfb41bd6b
DATA ·iv3<>+0x08(SB)/8, $0x5be0cd19137e2179
GLOBL ·iv3<>(SB), (NOPTR+RODATA), $16

DATA ·c40<>+0x00(SB)/8, $0x0201000706050403
DATA ·c40<>+0x08(SB)/8, $0x0a09080f0e0d0c0b
GLOBL ·c40<>(SB), (NOPTR+RODATA), $16

DATA ·c48<>+0x00(SB)/8, $0x0100070605040302
DATA ·c48<>+0x08(SB)/8, $0x09080f0e0d0c0b0a
GLOBL ·c48<>(SB), (NOPTR+RODATA), $16

#define SHUFFLE(v2, v3, v4, v5, v6, v7, t1, t2) \
	MOVO       v4, t1; \
	MOVO       v5, v4; \
	MOVO       t1, v5; \
	MOVO       v6, t1; \
	PUNPCKLQDQ v6, t2; \
	PUNPCKHQDQ v7, v6; \
	PUNPCKHQDQ t2, v6; \
	PUNPCKLQDQ v7, t2; \
	MOVO       t1, v7; \
	MOVO       v2, t1; \
	PUNPCKHQDQ t2, v7; \
	PUNPCKLQDQ v3, t2; \
	PUNPCKHQDQ t2, v2; \
	PUNPCKLQDQ t1, t2; \
	PUNPCKHQDQ t2, v3

#define SHUFFLE_INV(v2, v3, v4, v5, v6, v7, t1, t2) \
	MOVO       v4, t1; \
	MOVO       v5, v4; \
	MOVO       t1, v5; \
	MOVO       v2, t1; \
	PUNPCKLQDQ v2, t2; \
	PUNPCKHQDQ v3, v2; \
	PUNPCKHQDQ t2, v2; \
	PUNPCKLQDQ v3, t2; \
	MOVO       t1, v3; \
	MOVO       v6, t1; \
	PUNPCKHQDQ t2, v3; \
	PUNPCKLQDQ v7, t2; \
	PUNPCKHQDQ t2, v6; \
	PUNPCKLQDQ t1, t2; \
	PUNPCKHQDQ t2, v7

#define HALF_ROUND(v0, v1, v2, v3, v4, v5, v6, v7, m0, m1, m2, m3, t0, c40, c48) \
	PADDQ  m0, v0;        \
	PADDQ  m1, v1;        \
	PADDQ  v2, v0;        \
	PADDQ  v3, v1;        \
	PXOR   v0, v6;        \
	PXOR   v1, v7;        \
	PSHUFD $0xB1, v6, v6; \
	PSHUFD $0xB1, v7, v7; \
	PADDQ  v6, v4;        \
	PADDQ  v7, v5;        \
	PXOR   v4, v2;        \
	PXOR   v5, v3;        \
	PSHUFB c40, v2;       \
	PSHUFB c40, v3;       \
	PADDQ  m2, v0;        \
	PADDQ  m3, v1;        \
	PADDQ  v2, v0;        \
	PADDQ  v3, v1;        \
	PXOR   v0, v6;        \
	PXOR   v1, v7;        \
	PSHUFB c48, v6;       \
	PSHUFB c48, v7;       \
	PADDQ  v6, v4;        \
	PADDQ  v7, v5;        \
	PXOR   v4, v2;        \
	PXOR   v5, v3;        \
	MOVOU  v2, t0;        \
	PADDQ  v2, t0;        \
	PSRLQ  $63, v2;       \
	PXOR   t0, v2;        \
	MOVOU  v3, t0;        \
	PADDQ  v3, t0;        \
	PSRLQ  $63, v3;       \
	PXOR   t0, v3

#define LOAD_MSG(m0, m1, m2, m3, src, i0, i1, i2, i3, i4, i5, i6, i7) \
	MOVQ   i0*8(src), m0;     \
	PINSRQ $1, i1*8(src), m0; \
	MOVQ   i2*8(src), m1;     \
	PINSRQ $1, i3*8(src), m1; \
	MOVQ   i4*8(src), m2;     \
	PINSRQ $1, i5*8(src), m2; \
	MOVQ   i6*8(src), m3;     \
	PINSRQ $1, i7*8(src), m3

// func hashBlocksSSE4(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)
TEXT ·hashBlocksSSE4(SB), 4, $288-48 // frame size = 272 + 16 byte alignment
	MOVQ h+0(FP), AX
	MOVQ c+8(FP), BX
	MOVQ flag+16(FP), CX
	MOVQ blocks_base+24(FP), SI
	MOVQ blocks_len+32(FP), DI

	MOVQ SP, BP
	MOVQ SP, R9
	ADDQ $15, R9
	ANDQ $~15, R9
	MOVQ R9, SP

	MOVOU ·iv3<>(SB), X0
	MOVO  X0, 0(SP)
	XORQ  CX, 0(SP)     // 0(SP) = ·iv3 ^ (CX || 0)

	MOVOU ·c40<>(SB), X13
	MOVOU ·c48<>(SB), X14

	MOVOU 0(AX), X12
	MOVOU 16(AX), X15

	MOVQ 0(BX), R8
	MOVQ 8(BX), R9

loop:
	ADDQ $128, R8
	CMPQ R8, $128
	JGE  noinc
	INCQ R9

noinc:
	MOVQ R8, X8
	PINSRQ $1, R9, X8

	MOVO X12, X0
	MOVO X15, X1
	MOVOU 32(AX), X2
	MOVOU 48(AX), X3
	MOVOU ·iv0<>(SB), X4
	MOVOU ·iv1<>(SB), X5
	MOVOU ·iv2<>(SB), X6

	PXOR X8, X6
	MOVO 0(SP), X7

	LOAD_MSG(X8, X9, X10, X11, SI, 0, 2, 4, 6, 1, 3, 5, 7)
	MOVO X8, 16(SP)
	MOVO X9, 32(SP)
	MOVO X10, 48(SP)
	MOVO X11, 64(SP)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 8, 10, 12, 14, 9, 11, 13, 15)
	MOVO X8, 80(SP)
	MOVO X9, 96(SP)
	MOVO X10, 112(SP)
	MOVO X11, 128(SP)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 14, 4, 9, 13, 10, 8, 15, 6)
	MOVO X8, 144(SP)
	MOVO X9, 160(SP)
	MOVO X10, 176(SP)
	MOVO X11, 192(SP)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 1, 0, 11, 5, 12, 2, 7, 3)
	MOVO X8, 208(SP)
	MOVO X9, 224(SP)
	MOVO X10, 240(SP)
	MOVO X11, 256(SP)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 11, 12, 5, 15, 8, 0, 2, 13)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 10, 3, 7, 9, 14, 6, 1, 4)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 7, 3, 13, 11, 9, 1, 12, 14)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 2, 5, 4, 15, 6, 10, 0, 8)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 9, 5, 2, 10, 0, 7, 4, 15)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 14, 11, 6, 3, 1, 12, 8, 13)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 2, 6, 0, 8, 12, 10, 11, 3)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 4, 7, 15, 1, 13, 5, 14, 9)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 12, 1, 14, 4, 5, 15, 13, 10)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 0, 6, 9, 8, 7, 3, 2, 11)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 13, 7, 12, 3, 11, 14, 1, 9)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 5, 15, 8, 2, 0, 4, 6, 10)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 6, 14, 11, 0, 15, 9, 3, 8)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 12, 13, 1, 10, 2, 7, 4, 5)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	LOAD_MSG(X8, X9, X10, X11, SI, 10, 8, 7, 1, 2, 4, 6, 5)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	LOAD_MSG(X8, X9, X10, X11, SI, 15, 9, 3, 13, 11, 14, 12, 0)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, 16(SP), 32(SP), 48(SP), 64(SP), X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, 80(SP), 96(SP), 112(SP), 128(SP), X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, 144(SP), 160(SP), 176(SP), 192(SP), X11, X13, X14)
	SHUFFLE(X2, X3, X4, X5, X6, X7, X8, X9)
	HALF_ROUND(X0, X1, X2, X3, X4, X5, X6, X7, 208(SP), 224(SP), 240(SP), 256(SP), X11, X13, X14)
	SHUFFLE_INV(X2, X3, X4, X5, X6, X7, X8, X9)

	MOVOU 32(AX), X10
	MOVOU 48(AX), X11
	PXOR  X0, X12
	PXOR  X1, X15
	PXOR  X2, X10
	PXOR  X3, X11
	PXOR  X4, X12
	PXOR  X5, X15
	PXOR  X6, X10
	PXOR  X7, X11
	MOVOU X10, 32(AX)
	MOVOU X11, 48(AX)

	LEAQ 128(SI), SI
	SUBQ $128, DI
	JNE  loop

	MOVOU X12, 0(AX)
	MOVOU X15, 16(AX)

	MOVQ R8, 0(BX)
	MOVQ R9, 8(BX)

	MOVQ BP, SP
	RET

+ f 3ca806fe8939d7688d4dfa70003bef7ff55e66088176b6c6b794fb32fe02725f vendor/golang.org/x/crypto/blake2b/blake2b_generic.go
utf8file 183
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package blake2b

import (
	"encoding/binary"
	"math/bits"
)

// the precomputed values for BLAKE2b
// there are 12 16-byte arrays - one for each round
// the entries are calculated from the sigma constants.
var precomputed = [12][16]byte{
	{0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15},
	{14, 4, 9, 13, 10, 8, 15, 6, 1, 0, 11, 5, 12, 2, 7, 3},
	{11, 12, 5, 15, 8, 0, 2, 13, 10, 3, 7, 9, 14, 6, 1, 4},
	{7, 3, 13, 11, 9, 1, 12, 14, 2, 5, 4, 15, 6, 10, 0, 8},
	{9, 5, 2, 10, 0, 7, 4, 15, 14, 11, 6, 3, 1, 12, 8, 13},
	{2, 6, 0, 8, 12, 10, 11, 3, 4, 7, 15, 1, 13, 5, 14, 9},
	{12, 1, 14, 4, 5, 15, 13, 10, 0, 6, 9, 8, 7, 3, 2, 11},
	{13, 7, 12, 3, 11, 14, 1, 9, 5, 15, 8, 2, 0, 4, 6, 10},
	{6, 14, 11, 0, 15, 9, 3, 8, 12, 13, 1, 10, 2, 7, 4, 5},
	{10, 8, 7, 1, 2, 4, 6, 5, 15, 9, 3, 13, 11, 14, 12, 0},
	{0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15}, // equal to the first
	{14, 4, 9, 13, 10, 8, 15, 6, 1, 0, 11, 5, 12, 2, 7, 3}, // equal to the second
}

func hashBlocksGeneric(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) {
	var m [16]uint64
	c0, c1 := c[0], c[1]

	for i := 0; i < len(blocks); {
		c0 += BlockSize
		if c0 < BlockSize {
			c1++
		}

		v0, v1, v2, v3, v4, v5, v6, v7 := h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7]
		v8, v9, v10, v11, v12, v13, v14, v15 := iv[0], iv[1], iv[2], iv[3], iv[4], iv[5], iv[6], iv[7]
		v12 ^= c0
		v13 ^= c1
		v14 ^= flag

		for j := range m {
			m[j] = binary.LittleEndian.Uint64(blocks[i:])
			i += 8
		}

		for j := range precomputed {
			s := &(precomputed[j])

			v0 += m[s[0]]
			v0 += v4
			v12 ^= v0
			v12 = bits.RotateLeft64(v12, -32)
			v8 += v12
			v4 ^= v8
			v4 = bits.RotateLeft64(v4, -24)
			v1 += m[s[1]]
			v1 += v5
			v13 ^= v1
			v13 = bits.RotateLeft64(v13, -32)
			v9 += v13
			v5 ^= v9
			v5 = bits.RotateLeft64(v5, -24)
			v2 += m[s[2]]
			v2 += v6
			v14 ^= v2
			v14 = bits.RotateLeft64(v14, -32)
			v10 += v14
			v6 ^= v10
			v6 = bits.RotateLeft64(v6, -24)
			v3 += m[s[3]]
			v3 += v7
			v15 ^= v3
			v15 = bits.RotateLeft64(v15, -32)
			v11 += v15
			v7 ^= v11
			v7 = bits.RotateLeft64(v7, -24)

			v0 += m[s[4]]
			v0 += v4
			v12 ^= v0
			v12 = bits.RotateLeft64(v12, -16)
			v8 += v12
			v4 ^= v8
			v4 = bits.RotateLeft64(v4, -63)
			v1 += m[s[5]]
			v1 += v5
			v13 ^= v1
			v13 = bits.RotateLeft64(v13, -16)
			v9 += v13
			v5 ^= v9
			v5 = bits.RotateLeft64(v5, -63)
			v2 += m[s[6]]
			v2 += v6
			v14 ^= v2
			v14 = bits.RotateLeft64(v14, -16)
			v10 += v14
			v6 ^= v10
			v6 = bits.RotateLeft64(v6, -63)
			v3 += m[s[7]]
			v3 += v7
			v15 ^= v3
			v15 = bits.RotateLeft64(v15, -16)
			v11 += v15
			v7 ^= v11
			v7 = bits.RotateLeft64(v7, -63)

			v0 += m[s[8]]
			v0 += v5
			v15 ^= v0
			v15 = bits.RotateLeft64(v15, -32)
			v10 += v15
			v5 ^= v10
			v5 = bits.RotateLeft64(v5, -24)
			v1 += m[s[9]]
			v1 += v6
			v12 ^= v1
			v12 = bits.RotateLeft64(v12, -32)
			v11 += v12
			v6 ^= v11
			v6 = bits.RotateLeft64(v6, -24)
			v2 += m[s[10]]
			v2 += v7
			v13 ^= v2
			v13 = bits.RotateLeft64(v13, -32)
			v8 += v13
			v7 ^= v8
			v7 = bits.RotateLeft64(v7, -24)
			v3 += m[s[11]]
			v3 += v4
			v14 ^= v3
			v14 = bits.RotateLeft64(v14, -32)
			v9 += v14
			v4 ^= v9
			v4 = bits.RotateLeft64(v4, -24)

			v0 += m[s[12]]
			v0 += v5
			v15 ^= v0
			v15 = bits.RotateLeft64(v15, -16)
			v10 += v15
			v5 ^= v10
			v5 = bits.RotateLeft64(v5, -63)
			v1 += m[s[13]]
			v1 += v6
			v12 ^= v1
			v12 = bits.RotateLeft64(v12, -16)
			v11 += v12
			v6 ^= v11
			v6 = bits.RotateLeft64(v6, -63)
			v2 += m[s[14]]
			v2 += v7
			v13 ^= v2
			v13 = bits.RotateLeft64(v13, -16)
			v8 += v13
			v7 ^= v8
			v7 = bits.RotateLeft64(v7, -63)
			v3 += m[s[15]]
			v3 += v4
			v14 ^= v3
			v14 = bits.RotateLeft64(v14, -16)
			v9 += v14
			v4 ^= v9
			v4 = bits.RotateLeft64(v4, -63)

		}

		h[0] ^= v0 ^ v8
		h[1] ^= v1 ^ v9
		h[2] ^= v2 ^ v10
		h[3] ^= v3 ^ v11
		h[4] ^= v4 ^ v12
		h[5] ^= v5 ^ v13
		h[6] ^= v6 ^ v14
		h[7] ^= v7 ^ v15
	}
	c[0], c[1] = c0, c1
}

+ f 466ef421708bd9506caf421dda81449a6ee7118609175a5c233c4b0c5aa98fcc vendor/golang.org/x/crypto/blake2b/blake2b_ref.go
utf8file 12
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !amd64 appengine gccgo

package blake2b

func hashBlocks(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) {
	hashBlocksGeneric(h, c, flag, blocks)
}

+ f 0bbc2fbd298ee663cebf28716bd1946682e96abad982fc1a54e2396cb4ca596b vendor/golang.org/x/crypto/blake2b/blake2x.go
utf8file 178
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package blake2b

import (
	"encoding/binary"
	"errors"
	"io"
)

// XOF defines the interface to hash functions that
// support arbitrary-length output.
type XOF interface {
	// Write absorbs more data into the hash's state. It panics if called
	// after Read.
	io.Writer

	// Read reads more output from the hash. It returns io.EOF if the limit
	// has been reached.
	io.Reader

	// Clone returns a copy of the XOF in its current state.
	Clone() XOF

	// Reset resets the XOF to its initial state.
	Reset()
}

// OutputLengthUnknown can be used as the size argument to NewXOF to indicate
// the length of the output is not known in advance.
const OutputLengthUnknown = 0

// magicUnknownOutputLength is a magic value for the output size that indicates
// an unknown number of output bytes.
const magicUnknownOutputLength = (1 << 32) - 1

// maxOutputLength is the absolute maximum number of bytes to produce when the
// number of output bytes is unknown.
const maxOutputLength = (1 << 32) * 64

// NewXOF creates a new variable-output-length hash. The hash either produce a
// known number of bytes (1 <= size < 2**32-1), or an unknown number of bytes
// (size == OutputLengthUnknown). In the latter case, an absolute limit of
// 256GiB applies.
//
// A non-nil key turns the hash into a MAC. The key must between
// zero and 32 bytes long.
func NewXOF(size uint32, key []byte) (XOF, error) {
	if len(key) > Size {
		return nil, errKeySize
	}
	if size == magicUnknownOutputLength {
		// 2^32-1 indicates an unknown number of bytes and thus isn't a
		// valid length.
		return nil, errors.New("blake2b: XOF length too large")
	}
	if size == OutputLengthUnknown {
		size = magicUnknownOutputLength
	}
	x := &xof{
		d: digest{
			size:   Size,
			keyLen: len(key),
		},
		length: size,
	}
	copy(x.d.key[:], key)
	x.Reset()
	return x, nil
}

type xof struct {
	d                digest
	length           uint32
	remaining        uint64
	cfg, root, block [Size]byte
	offset           int
	nodeOffset       uint32
	readMode         bool
}

func (x *xof) Write(p []byte) (n int, err error) {
	if x.readMode {
		panic("blake2b: write to XOF after read")
	}
	return x.d.Write(p)
}

func (x *xof) Clone() XOF {
	clone := *x
	return &clone
}

func (x *xof) Reset() {
	x.cfg[0] = byte(Size)
	binary.LittleEndian.PutUint32(x.cfg[4:], uint32(Size)) // leaf length
	binary.LittleEndian.PutUint32(x.cfg[12:], x.length)    // XOF length
	x.cfg[17] = byte(Size)                                 // inner hash size

	x.d.Reset()
	x.d.h[1] ^= uint64(x.length) << 32

	x.remaining = uint64(x.length)
	if x.remaining == magicUnknownOutputLength {
		x.remaining = maxOutputLength
	}
	x.offset, x.nodeOffset = 0, 0
	x.readMode = false
}

func (x *xof) Read(p []byte) (n int, err error) {
	if !x.readMode {
		x.d.finalize(&x.root)
		x.readMode = true
	}

	if x.remaining == 0 {
		return 0, io.EOF
	}

	n = len(p)
	if uint64(n) > x.remaining {
		n = int(x.remaining)
		p = p[:n]
	}

	if x.offset > 0 {
		blockRemaining := Size - x.offset
		if n < blockRemaining {
			x.offset += copy(p, x.block[x.offset:])
			x.remaining -= uint64(n)
			return
		}
		copy(p, x.block[x.offset:])
		p = p[blockRemaining:]
		x.offset = 0
		x.remaining -= uint64(blockRemaining)
	}

	for len(p) >= Size {
		binary.LittleEndian.PutUint32(x.cfg[8:], x.nodeOffset)
		x.nodeOffset++

		x.d.initConfig(&x.cfg)
		x.d.Write(x.root[:])
		x.d.finalize(&x.block)

		copy(p, x.block[:])
		p = p[Size:]
		x.remaining -= uint64(Size)
	}

	if todo := len(p); todo > 0 {
		if x.remaining < uint64(Size) {
			x.cfg[0] = byte(x.remaining)
		}
		binary.LittleEndian.PutUint32(x.cfg[8:], x.nodeOffset)
		x.nodeOffset++

		x.d.initConfig(&x.cfg)
		x.d.Write(x.root[:])
		x.d.finalize(&x.block)

		x.offset = copy(p, x.block[:todo])
		x.remaining -= uint64(todo)
	}
	return
}

func (d *digest) initConfig(cfg *[Size]byte) {
	d.offset, d.c[0], d.c[1] = 0, 0, 0
	for i := range d.h {
		d.h[i] = iv[i] ^ binary.LittleEndian.Uint64(cfg[i*8:])
	}
}

+ f 3d4c355fdbdf646a375535fab5e28aae696e79e871c2b8431c93627dcbf9f2f0 vendor/golang.org/x/crypto/blake2b/register.go
utf8file 33
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.9

package blake2b

import (
	"crypto"
	"hash"
)

func init() {
	newHash256 := func() hash.Hash {
		h, _ := New256(nil)
		return h
	}
	newHash384 := func() hash.Hash {
		h, _ := New384(nil)
		return h
	}

	newHash512 := func() hash.Hash {
		h, _ := New512(nil)
		return h
	}

	crypto.RegisterHash(crypto.BLAKE2b_256, newHash256)
	crypto.RegisterHash(crypto.BLAKE2b_384, newHash384)
	crypto.RegisterHash(crypto.BLAKE2b_512, newHash512)
}

- f 6e2f856ee69f13adfc63d5560d88784187a74db7f7ca9f6982fca12f2f920b01 vendor/golang.org/x/crypto/poly1305/sum_arm.go
- f 5b9ffc769cfdd72110409301f4527e553eb9c404a924c4a1fae2715c8a501901 vendor/golang.org/x/crypto/poly1305/sum_arm.s
- f 550f4b12324dc7c8bf8370da1bdd53a773fdc2ed63378d4ce26e82110c300c42 vendor/golang.org/x/crypto/poly1305/sum_noasm.go
+ f fa91f5af33d6b891aa1c268dc79c2ed8d4576445073c7954657c919b67e1ae42 vendor/golang.org/x/crypto/poly1305/sum_noasm.go
dmppatch 5
@@ -157,81 +157,76 @@
 e.%0A%0A
-// +build s390x,!go1.11 !arm,!amd64,!s390x,!ppc64le gccgo appengine nacl%0A
+// +build s390x,!go1.11 !amd64,!s390x,!ppc64le gccgo appengine nacl%0A
 %0Apac
+ f 46f1008be1f21f8b3853431e8f058b99cba0fdba55109eebedf4d522b1ee5e70 vendor/golang.org/x/crypto/ssh/terminal/terminal.go
utf8file 971
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package terminal

import (
	"bytes"
	"io"
	"strconv"
	"sync"
	"unicode/utf8"
)

// EscapeCodes contains escape sequences that can be written to the terminal in
// order to achieve different styles of text.
type EscapeCodes struct {
	// Foreground colors
	Black, Red, Green, Yellow, Blue, Magenta, Cyan, White []byte

	// Reset all attributes
	Reset []byte
}

var vt100EscapeCodes = EscapeCodes{
	Black:   []byte{keyEscape, '[', '3', '0', 'm'},
	Red:     []byte{keyEscape, '[', '3', '1', 'm'},
	Green:   []byte{keyEscape, '[', '3', '2', 'm'},
	Yellow:  []byte{keyEscape, '[', '3', '3', 'm'},
	Blue:    []byte{keyEscape, '[', '3', '4', 'm'},
	Magenta: []byte{keyEscape, '[', '3', '5', 'm'},
	Cyan:    []byte{keyEscape, '[', '3', '6', 'm'},
	White:   []byte{keyEscape, '[', '3', '7', 'm'},

	Reset: []byte{keyEscape, '[', '0', 'm'},
}

// Terminal contains the state for running a VT100 terminal that is capable of
// reading lines of input.
type Terminal struct {
	// AutoCompleteCallback, if non-null, is called for each keypress with
	// the full input line and the current position of the cursor (in
	// bytes, as an index into |line|). If it returns ok=false, the key
	// press is processed normally. Otherwise it returns a replacement line
	// and the new cursor position.
	AutoCompleteCallback func(line string, pos int, key rune) (newLine string, newPos int, ok bool)

	// Escape contains a pointer to the escape codes for this terminal.
	// It's always a valid pointer, although the escape codes themselves
	// may be empty if the terminal doesn't support them.
	Escape *EscapeCodes

	// lock protects the terminal and the state in this object from
	// concurrent processing of a key press and a Write() call.
	lock sync.Mutex

	c      io.ReadWriter
	prompt []rune

	// line is the current line being entered.
	line []rune
	// pos is the logical position of the cursor in line
	pos int
	// echo is true if local echo is enabled
	echo bool
	// pasteActive is true iff there is a bracketed paste operation in
	// progress.
	pasteActive bool

	// cursorX contains the current X value of the cursor where the left
	// edge is 0. cursorY contains the row number where the first row of
	// the current line is 0.
	cursorX, cursorY int
	// maxLine is the greatest value of cursorY so far.
	maxLine int

	termWidth, termHeight int

	// outBuf contains the terminal data to be sent.
	outBuf []byte
	// remainder contains the remainder of any partial key sequences after
	// a read. It aliases into inBuf.
	remainder []byte
	inBuf     [256]byte

	// history contains previously entered commands so that they can be
	// accessed with the up and down keys.
	history stRingBuffer
	// historyIndex stores the currently accessed history entry, where zero
	// means the immediately previous entry.
	historyIndex int
	// When navigating up and down the history it's possible to return to
	// the incomplete, initial line. That value is stored in
	// historyPending.
	historyPending string
}

// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is
// a local terminal, that terminal must first have been put into raw mode.
// prompt is a string that is written at the start of each input line (i.e.
// "> ").
func NewTerminal(c io.ReadWriter, prompt string) *Terminal {
	return &Terminal{
		Escape:       &vt100EscapeCodes,
		c:            c,
		prompt:       []rune(prompt),
		termWidth:    80,
		termHeight:   24,
		echo:         true,
		historyIndex: -1,
	}
}

const (
	keyCtrlD     = 4
	keyCtrlU     = 21
	keyEnter     = '\r'
	keyEscape    = 27
	keyBackspace = 127
	keyUnknown   = 0xd800 /* UTF-16 surrogate area */ + iota
	keyUp
	keyDown
	keyLeft
	keyRight
	keyAltLeft
	keyAltRight
	keyHome
	keyEnd
	keyDeleteWord
	keyDeleteLine
	keyClearScreen
	keyPasteStart
	keyPasteEnd
)

var (
	crlf       = []byte{'\r', '\n'}
	pasteStart = []byte{keyEscape, '[', '2', '0', '0', '~'}
	pasteEnd   = []byte{keyEscape, '[', '2', '0', '1', '~'}
)

// bytesToKey tries to parse a key sequence from b. If successful, it returns
// the key and the remainder of the input. Otherwise it returns utf8.RuneError.
func bytesToKey(b []byte, pasteActive bool) (rune, []byte) {
	if len(b) == 0 {
		return utf8.RuneError, nil
	}

	if !pasteActive {
		switch b[0] {
		case 1: // ^A
			return keyHome, b[1:]
		case 5: // ^E
			return keyEnd, b[1:]
		case 8: // ^H
			return keyBackspace, b[1:]
		case 11: // ^K
			return keyDeleteLine, b[1:]
		case 12: // ^L
			return keyClearScreen, b[1:]
		case 23: // ^W
			return keyDeleteWord, b[1:]
		case 14: // ^N
			return keyDown, b[1:]
		case 16: // ^P
			return keyUp, b[1:]
		}
	}

	if b[0] != keyEscape {
		if !utf8.FullRune(b) {
			return utf8.RuneError, b
		}
		r, l := utf8.DecodeRune(b)
		return r, b[l:]
	}

	if !pasteActive && len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {
		switch b[2] {
		case 'A':
			return keyUp, b[3:]
		case 'B':
			return keyDown, b[3:]
		case 'C':
			return keyRight, b[3:]
		case 'D':
			return keyLeft, b[3:]
		case 'H':
			return keyHome, b[3:]
		case 'F':
			return keyEnd, b[3:]
		}
	}

	if !pasteActive && len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {
		switch b[5] {
		case 'C':
			return keyAltRight, b[6:]
		case 'D':
			return keyAltLeft, b[6:]
		}
	}

	if !pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteStart) {
		return keyPasteStart, b[6:]
	}

	if pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteEnd) {
		return keyPasteEnd, b[6:]
	}

	// If we get here then we have a key that we don't recognise, or a
	// partial sequence. It's not clear how one should find the end of a
	// sequence without knowing them all, but it seems that [a-zA-Z~] only
	// appears at the end of a sequence.
	for i, c := range b[0:] {
		if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '~' {
			return keyUnknown, b[i+1:]
		}
	}

	return utf8.RuneError, b
}

// queue appends data to the end of t.outBuf
func (t *Terminal) queue(data []rune) {
	t.outBuf = append(t.outBuf, []byte(string(data))...)
}

var eraseUnderCursor = []rune{' ', keyEscape, '[', 'D'}
var space = []rune{' '}

func isPrintable(key rune) bool {
	isInSurrogateArea := key >= 0xd800 && key <= 0xdbff
	return key >= 32 && !isInSurrogateArea
}

// moveCursorToPos appends data to t.outBuf which will move the cursor to the
// given, logical position in the text.
func (t *Terminal) moveCursorToPos(pos int) {
	if !t.echo {
		return
	}

	x := visualLength(t.prompt) + pos
	y := x / t.termWidth
	x = x % t.termWidth

	up := 0
	if y < t.cursorY {
		up = t.cursorY - y
	}

	down := 0
	if y > t.cursorY {
		down = y - t.cursorY
	}

	left := 0
	if x < t.cursorX {
		left = t.cursorX - x
	}

	right := 0
	if x > t.cursorX {
		right = x - t.cursorX
	}

	t.cursorX = x
	t.cursorY = y
	t.move(up, down, left, right)
}

func (t *Terminal) move(up, down, left, right int) {
	m := []rune{}

	// 1 unit up can be expressed as ^[[A or ^[A
	// 5 units up can be expressed as ^[[5A

	if up == 1 {
		m = append(m, keyEscape, '[', 'A')
	} else if up > 1 {
		m = append(m, keyEscape, '[')
		m = append(m, []rune(strconv.Itoa(up))...)
		m = append(m, 'A')
	}

	if down == 1 {
		m = append(m, keyEscape, '[', 'B')
	} else if down > 1 {
		m = append(m, keyEscape, '[')
		m = append(m, []rune(strconv.Itoa(down))...)
		m = append(m, 'B')
	}

	if right == 1 {
		m = append(m, keyEscape, '[', 'C')
	} else if right > 1 {
		m = append(m, keyEscape, '[')
		m = append(m, []rune(strconv.Itoa(right))...)
		m = append(m, 'C')
	}

	if left == 1 {
		m = append(m, keyEscape, '[', 'D')
	} else if left > 1 {
		m = append(m, keyEscape, '[')
		m = append(m, []rune(strconv.Itoa(left))...)
		m = append(m, 'D')
	}

	t.queue(m)
}

func (t *Terminal) clearLineToRight() {
	op := []rune{keyEscape, '[', 'K'}
	t.queue(op)
}

const maxLineLength = 4096

func (t *Terminal) setLine(newLine []rune, newPos int) {
	if t.echo {
		t.moveCursorToPos(0)
		t.writeLine(newLine)
		for i := len(newLine); i < len(t.line); i++ {
			t.writeLine(space)
		}
		t.moveCursorToPos(newPos)
	}
	t.line = newLine
	t.pos = newPos
}

func (t *Terminal) advanceCursor(places int) {
	t.cursorX += places
	t.cursorY += t.cursorX / t.termWidth
	if t.cursorY > t.maxLine {
		t.maxLine = t.cursorY
	}
	t.cursorX = t.cursorX % t.termWidth

	if places > 0 && t.cursorX == 0 {
		// Normally terminals will advance the current position
		// when writing a character. But that doesn't happen
		// for the last character in a line. However, when
		// writing a character (except a new line) that causes
		// a line wrap, the position will be advanced two
		// places.
		//
		// So, if we are stopping at the end of a line, we
		// need to write a newline so that our cursor can be
		// advanced to the next line.
		t.outBuf = append(t.outBuf, '\r', '\n')
	}
}

func (t *Terminal) eraseNPreviousChars(n int) {
	if n == 0 {
		return
	}

	if t.pos < n {
		n = t.pos
	}
	t.pos -= n
	t.moveCursorToPos(t.pos)

	copy(t.line[t.pos:], t.line[n+t.pos:])
	t.line = t.line[:len(t.line)-n]
	if t.echo {
		t.writeLine(t.line[t.pos:])
		for i := 0; i < n; i++ {
			t.queue(space)
		}
		t.advanceCursor(n)
		t.moveCursorToPos(t.pos)
	}
}

// countToLeftWord returns then number of characters from the cursor to the
// start of the previous word.
func (t *Terminal) countToLeftWord() int {
	if t.pos == 0 {
		return 0
	}

	pos := t.pos - 1
	for pos > 0 {
		if t.line[pos] != ' ' {
			break
		}
		pos--
	}
	for pos > 0 {
		if t.line[pos] == ' ' {
			pos++
			break
		}
		pos--
	}

	return t.pos - pos
}

// countToRightWord returns then number of characters from the cursor to the
// start of the next word.
func (t *Terminal) countToRightWord() int {
	pos := t.pos
	for pos < len(t.line) {
		if t.line[pos] == ' ' {
			break
		}
		pos++
	}
	for pos < len(t.line) {
		if t.line[pos] != ' ' {
			break
		}
		pos++
	}
	return pos - t.pos
}

// visualLength returns the number of visible glyphs in s.
func visualLength(runes []rune) int {
	inEscapeSeq := false
	length := 0

	for _, r := range runes {
		switch {
		case inEscapeSeq:
			if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') {
				inEscapeSeq = false
			}
		case r == '\x1b':
			inEscapeSeq = true
		default:
			length++
		}
	}

	return length
}

// handleKey processes the given key and, optionally, returns a line of text
// that the user has entered.
func (t *Terminal) handleKey(key rune) (line string, ok bool) {
	if t.pasteActive && key != keyEnter {
		t.addKeyToLine(key)
		return
	}

	switch key {
	case keyBackspace:
		if t.pos == 0 {
			return
		}
		t.eraseNPreviousChars(1)
	case keyAltLeft:
		// move left by a word.
		t.pos -= t.countToLeftWord()
		t.moveCursorToPos(t.pos)
	case keyAltRight:
		// move right by a word.
		t.pos += t.countToRightWord()
		t.moveCursorToPos(t.pos)
	case keyLeft:
		if t.pos == 0 {
			return
		}
		t.pos--
		t.moveCursorToPos(t.pos)
	case keyRight:
		if t.pos == len(t.line) {
			return
		}
		t.pos++
		t.moveCursorToPos(t.pos)
	case keyHome:
		if t.pos == 0 {
			return
		}
		t.pos = 0
		t.moveCursorToPos(t.pos)
	case keyEnd:
		if t.pos == len(t.line) {
			return
		}
		t.pos = len(t.line)
		t.moveCursorToPos(t.pos)
	case keyUp:
		entry, ok := t.history.NthPreviousEntry(t.historyIndex + 1)
		if !ok {
			return "", false
		}
		if t.historyIndex == -1 {
			t.historyPending = string(t.line)
		}
		t.historyIndex++
		runes := []rune(entry)
		t.setLine(runes, len(runes))
	case keyDown:
		switch t.historyIndex {
		case -1:
			return
		case 0:
			runes := []rune(t.historyPending)
			t.setLine(runes, len(runes))
			t.historyIndex--
		default:
			entry, ok := t.history.NthPreviousEntry(t.historyIndex - 1)
			if ok {
				t.historyIndex--
				runes := []rune(entry)
				t.setLine(runes, len(runes))
			}
		}
	case keyEnter:
		t.moveCursorToPos(len(t.line))
		t.queue([]rune("\r\n"))
		line = string(t.line)
		ok = true
		t.line = t.line[:0]
		t.pos = 0
		t.cursorX = 0
		t.cursorY = 0
		t.maxLine = 0
	case keyDeleteWord:
		// Delete zero or more spaces and then one or more characters.
		t.eraseNPreviousChars(t.countToLeftWord())
	case keyDeleteLine:
		// Delete everything from the current cursor position to the
		// end of line.
		for i := t.pos; i < len(t.line); i++ {
			t.queue(space)
			t.advanceCursor(1)
		}
		t.line = t.line[:t.pos]
		t.moveCursorToPos(t.pos)
	case keyCtrlD:
		// Erase the character under the current position.
		// The EOF case when the line is empty is handled in
		// readLine().
		if t.pos < len(t.line) {
			t.pos++
			t.eraseNPreviousChars(1)
		}
	case keyCtrlU:
		t.eraseNPreviousChars(t.pos)
	case keyClearScreen:
		// Erases the screen and moves the cursor to the home position.
		t.queue([]rune("\x1b[2J\x1b[H"))
		t.queue(t.prompt)
		t.cursorX, t.cursorY = 0, 0
		t.advanceCursor(visualLength(t.prompt))
		t.setLine(t.line, t.pos)
	default:
		if t.AutoCompleteCallback != nil {
			prefix := string(t.line[:t.pos])
			suffix := string(t.line[t.pos:])

			t.lock.Unlock()
			newLine, newPos, completeOk := t.AutoCompleteCallback(prefix+suffix, len(prefix), key)
			t.lock.Lock()

			if completeOk {
				t.setLine([]rune(newLine), utf8.RuneCount([]byte(newLine)[:newPos]))
				return
			}
		}
		if !isPrintable(key) {
			return
		}
		if len(t.line) == maxLineLength {
			return
		}
		t.addKeyToLine(key)
	}
	return
}

// addKeyToLine inserts the given key at the current position in the current
// line.
func (t *Terminal) addKeyToLine(key rune) {
	if len(t.line) == cap(t.line) {
		newLine := make([]rune, len(t.line), 2*(1+len(t.line)))
		copy(newLine, t.line)
		t.line = newLine
	}
	t.line = t.line[:len(t.line)+1]
	copy(t.line[t.pos+1:], t.line[t.pos:])
	t.line[t.pos] = key
	if t.echo {
		t.writeLine(t.line[t.pos:])
	}
	t.pos++
	t.moveCursorToPos(t.pos)
}

func (t *Terminal) writeLine(line []rune) {
	for len(line) != 0 {
		remainingOnLine := t.termWidth - t.cursorX
		todo := len(line)
		if todo > remainingOnLine {
			todo = remainingOnLine
		}
		t.queue(line[:todo])
		t.advanceCursor(visualLength(line[:todo]))
		line = line[todo:]
	}
}

// writeWithCRLF writes buf to w but replaces all occurrences of \n with \r\n.
func writeWithCRLF(w io.Writer, buf []byte) (n int, err error) {
	for len(buf) > 0 {
		i := bytes.IndexByte(buf, '\n')
		todo := len(buf)
		if i >= 0 {
			todo = i
		}

		var nn int
		nn, err = w.Write(buf[:todo])
		n += nn
		if err != nil {
			return n, err
		}
		buf = buf[todo:]

		if i >= 0 {
			if _, err = w.Write(crlf); err != nil {
				return n, err
			}
			n++
			buf = buf[1:]
		}
	}

	return n, nil
}

func (t *Terminal) Write(buf []byte) (n int, err error) {
	t.lock.Lock()
	defer t.lock.Unlock()

	if t.cursorX == 0 && t.cursorY == 0 {
		// This is the easy case: there's nothing on the screen that we
		// have to move out of the way.
		return writeWithCRLF(t.c, buf)
	}

	// We have a prompt and possibly user input on the screen. We
	// have to clear it first.
	t.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)
	t.cursorX = 0
	t.clearLineToRight()

	for t.cursorY > 0 {
		t.move(1 /* up */, 0, 0, 0)
		t.cursorY--
		t.clearLineToRight()
	}

	if _, err = t.c.Write(t.outBuf); err != nil {
		return
	}
	t.outBuf = t.outBuf[:0]

	if n, err = writeWithCRLF(t.c, buf); err != nil {
		return
	}

	t.writeLine(t.prompt)
	if t.echo {
		t.writeLine(t.line)
	}

	t.moveCursorToPos(t.pos)

	if _, err = t.c.Write(t.outBuf); err != nil {
		return
	}
	t.outBuf = t.outBuf[:0]
	return
}

// ReadPassword temporarily changes the prompt and reads a password, without
// echo, from the terminal.
func (t *Terminal) ReadPassword(prompt string) (line string, err error) {
	t.lock.Lock()
	defer t.lock.Unlock()

	oldPrompt := t.prompt
	t.prompt = []rune(prompt)
	t.echo = false

	line, err = t.readLine()

	t.prompt = oldPrompt
	t.echo = true

	return
}

// ReadLine returns a line of input from the terminal.
func (t *Terminal) ReadLine() (line string, err error) {
	t.lock.Lock()
	defer t.lock.Unlock()

	return t.readLine()
}

func (t *Terminal) readLine() (line string, err error) {
	// t.lock must be held at this point

	if t.cursorX == 0 && t.cursorY == 0 {
		t.writeLine(t.prompt)
		t.c.Write(t.outBuf)
		t.outBuf = t.outBuf[:0]
	}

	lineIsPasted := t.pasteActive

	for {
		rest := t.remainder
		lineOk := false
		for !lineOk {
			var key rune
			key, rest = bytesToKey(rest, t.pasteActive)
			if key == utf8.RuneError {
				break
			}
			if !t.pasteActive {
				if key == keyCtrlD {
					if len(t.line) == 0 {
						return "", io.EOF
					}
				}
				if key == keyPasteStart {
					t.pasteActive = true
					if len(t.line) == 0 {
						lineIsPasted = true
					}
					continue
				}
			} else if key == keyPasteEnd {
				t.pasteActive = false
				continue
			}
			if !t.pasteActive {
				lineIsPasted = false
			}
			line, lineOk = t.handleKey(key)
		}
		if len(rest) > 0 {
			n := copy(t.inBuf[:], rest)
			t.remainder = t.inBuf[:n]
		} else {
			t.remainder = nil
		}
		t.c.Write(t.outBuf)
		t.outBuf = t.outBuf[:0]
		if lineOk {
			if t.echo {
				t.historyIndex = -1
				t.history.Add(line)
			}
			if lineIsPasted {
				err = ErrPasteIndicator
			}
			return
		}

		// t.remainder is a slice at the beginning of t.inBuf
		// containing a partial key sequence
		readBuf := t.inBuf[len(t.remainder):]
		var n int

		t.lock.Unlock()
		n, err = t.c.Read(readBuf)
		t.lock.Lock()

		if err != nil {
			return
		}

		t.remainder = t.inBuf[:n+len(t.remainder)]
	}
}

// SetPrompt sets the prompt to be used when reading subsequent lines.
func (t *Terminal) SetPrompt(prompt string) {
	t.lock.Lock()
	defer t.lock.Unlock()

	t.prompt = []rune(prompt)
}

func (t *Terminal) clearAndRepaintLinePlusNPrevious(numPrevLines int) {
	// Move cursor to column zero at the start of the line.
	t.move(t.cursorY, 0, t.cursorX, 0)
	t.cursorX, t.cursorY = 0, 0
	t.clearLineToRight()
	for t.cursorY < numPrevLines {
		// Move down a line
		t.move(0, 1, 0, 0)
		t.cursorY++
		t.clearLineToRight()
	}
	// Move back to beginning.
	t.move(t.cursorY, 0, 0, 0)
	t.cursorX, t.cursorY = 0, 0

	t.queue(t.prompt)
	t.advanceCursor(visualLength(t.prompt))
	t.writeLine(t.line)
	t.moveCursorToPos(t.pos)
}

func (t *Terminal) SetSize(width, height int) error {
	t.lock.Lock()
	defer t.lock.Unlock()

	if width == 0 {
		width = 1
	}

	oldWidth := t.termWidth
	t.termWidth, t.termHeight = width, height

	switch {
	case width == oldWidth:
		// If the width didn't change then nothing else needs to be
		// done.
		return nil
	case len(t.line) == 0 && t.cursorX == 0 && t.cursorY == 0:
		// If there is nothing on current line and no prompt printed,
		// just do nothing
		return nil
	case width < oldWidth:
		// Some terminals (e.g. xterm) will truncate lines that were
		// too long when shinking. Others, (e.g. gnome-terminal) will
		// attempt to wrap them. For the former, repainting t.maxLine
		// works great, but that behaviour goes badly wrong in the case
		// of the latter because they have doubled every full line.

		// We assume that we are working on a terminal that wraps lines
		// and adjust the cursor position based on every previous line
		// wrapping and turning into two. This causes the prompt on
		// xterms to move upwards, which isn't great, but it avoids a
		// huge mess with gnome-terminal.
		if t.cursorX >= t.termWidth {
			t.cursorX = t.termWidth - 1
		}
		t.cursorY *= 2
		t.clearAndRepaintLinePlusNPrevious(t.maxLine * 2)
	case width > oldWidth:
		// If the terminal expands then our position calculations will
		// be wrong in the future because we think the cursor is
		// |t.pos| chars into the string, but there will be a gap at
		// the end of any wrapped line.
		//
		// But the position will actually be correct until we move, so
		// we can move back to the beginning and repaint everything.
		t.clearAndRepaintLinePlusNPrevious(t.maxLine)
	}

	_, err := t.c.Write(t.outBuf)
	t.outBuf = t.outBuf[:0]
	return err
}

type pasteIndicatorError struct{}

func (pasteIndicatorError) Error() string {
	return "terminal: ErrPasteIndicator not correctly handled"
}

// ErrPasteIndicator may be returned from ReadLine as the error, in addition
// to valid line data. It indicates that bracketed paste mode is enabled and
// that the returned line consists only of pasted data. Programs may wish to
// interpret pasted data more literally than typed data.
var ErrPasteIndicator = pasteIndicatorError{}

// SetBracketedPasteMode requests that the terminal bracket paste operations
// with markers. Not all terminals support this but, if it is supported, then
// enabling this mode will stop any autocomplete callback from running due to
// pastes. Additionally, any lines that are completely pasted will be returned
// from ReadLine with the error set to ErrPasteIndicator.
func (t *Terminal) SetBracketedPasteMode(on bool) {
	if on {
		io.WriteString(t.c, "\x1b[?2004h")
	} else {
		io.WriteString(t.c, "\x1b[?2004l")
	}
}

// stRingBuffer is a ring buffer of strings.
type stRingBuffer struct {
	// entries contains max elements.
	entries []string
	max     int
	// head contains the index of the element most recently added to the ring.
	head int
	// size contains the number of elements in the ring.
	size int
}

func (s *stRingBuffer) Add(a string) {
	if s.entries == nil {
		const defaultNumEntries = 100
		s.entries = make([]string, defaultNumEntries)
		s.max = defaultNumEntries
	}

	s.head = (s.head + 1) % s.max
	s.entries[s.head] = a
	if s.size < s.max {
		s.size++
	}
}

// NthPreviousEntry returns the value passed to the nth previous call to Add.
// If n is zero then the immediately prior value is returned, if one, then the
// next most recent, and so on. If such an element doesn't exist then ok is
// false.
func (s *stRingBuffer) NthPreviousEntry(n int) (value string, ok bool) {
	if n >= s.size {
		return "", false
	}
	index := s.head - n
	if index < 0 {
		index += s.max
	}
	return s.entries[index], true
}

// readPasswordLine reads from reader until it finds \n or io.EOF.
// The slice returned does not include the \n.
// readPasswordLine also ignores any \r it finds.
func readPasswordLine(reader io.Reader) ([]byte, error) {
	var buf [1]byte
	var ret []byte

	for {
		n, err := reader.Read(buf[:])
		if n > 0 {
			switch buf[0] {
			case '\b':
				if len(ret) > 0 {
					ret = ret[:len(ret)-1]
				}
			case '\n':
				return ret, nil
			case '\r':
				// remove \r from passwords on Windows
			default:
				ret = append(ret, buf[0])
			}
			continue
		}
		if err != nil {
			if err == io.EOF && len(ret) > 0 {
				return ret, nil
			}
			return ret, err
		}
	}
}

+ f 094cb1b8d27e65b81fa061543dbbfbe0e3edfda037909d3d59cf0ebc91407276 vendor/golang.org/x/crypto/ssh/terminal/util.go
utf8file 115
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix darwin dragonfly freebsd linux,!appengine netbsd openbsd

// Package terminal provides support functions for dealing with terminals, as
// commonly found on UNIX systems.
//
// Putting a terminal into raw mode is the most common requirement:
//
// 	oldState, err := terminal.MakeRaw(0)
// 	if err != nil {
// 	        panic(err)
// 	}
// 	defer terminal.Restore(0, oldState)
package terminal // import "golang.org/x/crypto/ssh/terminal"

import (
	"golang.org/x/sys/unix"
)

// State contains the state of a terminal.
type State struct {
	termios unix.Termios
}

// IsTerminal returns whether the given file descriptor is a terminal.
func IsTerminal(fd int) bool {
	_, err := unix.IoctlGetTermios(fd, ioctlReadTermios)
	return err == nil
}

// MakeRaw put the terminal connected to the given file descriptor into raw
// mode and returns the previous state of the terminal so that it can be
// restored.
func MakeRaw(fd int) (*State, error) {
	termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)
	if err != nil {
		return nil, err
	}

	oldState := State{termios: *termios}

	// This attempts to replicate the behaviour documented for cfmakeraw in
	// the termios(3) manpage.
	termios.Iflag &^= unix.IGNBRK | unix.BRKINT | unix.PARMRK | unix.ISTRIP | unix.INLCR | unix.IGNCR | unix.ICRNL | unix.IXON
	termios.Oflag &^= unix.OPOST
	termios.Lflag &^= unix.ECHO | unix.ECHONL | unix.ICANON | unix.ISIG | unix.IEXTEN
	termios.Cflag &^= unix.CSIZE | unix.PARENB
	termios.Cflag |= unix.CS8
	termios.Cc[unix.VMIN] = 1
	termios.Cc[unix.VTIME] = 0
	if err := unix.IoctlSetTermios(fd, ioctlWriteTermios, termios); err != nil {
		return nil, err
	}

	return &oldState, nil
}

// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
func GetState(fd int) (*State, error) {
	termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)
	if err != nil {
		return nil, err
	}

	return &State{termios: *termios}, nil
}

// Restore restores the terminal connected to the given file descriptor to a
// previous state.
func Restore(fd int, state *State) error {
	return unix.IoctlSetTermios(fd, ioctlWriteTermios, &state.termios)
}

// GetSize returns the dimensions of the given terminal.
func GetSize(fd int) (width, height int, err error) {
	ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)
	if err != nil {
		return -1, -1, err
	}
	return int(ws.Col), int(ws.Row), nil
}

// passwordReader is an io.Reader that reads from a specific file descriptor.
type passwordReader int

func (r passwordReader) Read(buf []byte) (int, error) {
	return unix.Read(int(r), buf)
}

// ReadPassword reads a line of input from a terminal without local echo.  This
// is commonly used for inputting passwords and other sensitive data. The slice
// returned does not include the \n.
func ReadPassword(fd int) ([]byte, error) {
	termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)
	if err != nil {
		return nil, err
	}

	newState := *termios
	newState.Lflag &^= unix.ECHO
	newState.Lflag |= unix.ICANON | unix.ISIG
	newState.Iflag |= unix.ICRNL
	if err := unix.IoctlSetTermios(fd, ioctlWriteTermios, &newState); err != nil {
		return nil, err
	}

	defer unix.IoctlSetTermios(fd, ioctlWriteTermios, termios)

	return readPasswordLine(passwordReader(fd))
}

+ f 605e3ae31bd0506b94b8df9669def27e30d6124e95a1c53b95ba68ab81a87627 vendor/golang.org/x/crypto/ssh/terminal/util_aix.go
utf8file 13
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix

package terminal

import "golang.org/x/sys/unix"

const ioctlReadTermios = unix.TCGETS
const ioctlWriteTermios = unix.TCSETS

+ f 294851ccb15e794141fe98ac60c6b5be849c58be2a55de0fd9e453291202a1a8 vendor/golang.org/x/crypto/ssh/terminal/util_bsd.go
utf8file 13
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build darwin dragonfly freebsd netbsd openbsd

package terminal

import "golang.org/x/sys/unix"

const ioctlReadTermios = unix.TIOCGETA
const ioctlWriteTermios = unix.TIOCSETA

+ f a0fd237264e2aa3a4709fc6216b7747c47eb2f4e6847671785044fa75e4ab5f4 vendor/golang.org/x/crypto/ssh/terminal/util_linux.go
utf8file 11
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package terminal

import "golang.org/x/sys/unix"

const ioctlReadTermios = unix.TCGETS
const ioctlWriteTermios = unix.TCSETS

+ f 86da7d8bf2b6df049e7c50ee3812f289b37b517ab6b6880675d55e46df721b6e vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
utf8file 59
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package terminal provides support functions for dealing with terminals, as
// commonly found on UNIX systems.
//
// Putting a terminal into raw mode is the most common requirement:
//
// 	oldState, err := terminal.MakeRaw(0)
// 	if err != nil {
// 	        panic(err)
// 	}
// 	defer terminal.Restore(0, oldState)
package terminal

import (
	"fmt"
	"runtime"
)

type State struct{}

// IsTerminal returns whether the given file descriptor is a terminal.
func IsTerminal(fd int) bool {
	return false
}

// MakeRaw put the terminal connected to the given file descriptor into raw
// mode and returns the previous state of the terminal so that it can be
// restored.
func MakeRaw(fd int) (*State, error) {
	return nil, fmt.Errorf("terminal: MakeRaw not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
}

// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
func GetState(fd int) (*State, error) {
	return nil, fmt.Errorf("terminal: GetState not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
}

// Restore restores the terminal connected to the given file descriptor to a
// previous state.
func Restore(fd int, state *State) error {
	return fmt.Errorf("terminal: Restore not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
}

// GetSize returns the dimensions of the given terminal.
func GetSize(fd int) (width, height int, err error) {
	return 0, 0, fmt.Errorf("terminal: GetSize not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
}

// ReadPassword reads a line of input from a terminal without local echo.  This
// is commonly used for inputting passwords and other sensitive data. The slice
// returned does not include the \n.
func ReadPassword(fd int) ([]byte, error) {
	return nil, fmt.Errorf("terminal: ReadPassword not implemented on %s/%s", runtime.GOOS, runtime.GOARCH)
}

+ f e92599b08c462aebf7336c7e2828bc8c6aae23240fb7714d3040b4d46a5fe001 vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
utf8file 125
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build solaris

package terminal // import "golang.org/x/crypto/ssh/terminal"

import (
	"golang.org/x/sys/unix"
	"io"
	"syscall"
)

// State contains the state of a terminal.
type State struct {
	termios unix.Termios
}

// IsTerminal returns whether the given file descriptor is a terminal.
func IsTerminal(fd int) bool {
	_, err := unix.IoctlGetTermio(fd, unix.TCGETA)
	return err == nil
}

// ReadPassword reads a line of input from a terminal without local echo.  This
// is commonly used for inputting passwords and other sensitive data. The slice
// returned does not include the \n.
func ReadPassword(fd int) ([]byte, error) {
	// see also: http://src.illumos.org/source/xref/illumos-gate/usr/src/lib/libast/common/uwin/getpass.c
	val, err := unix.IoctlGetTermios(fd, unix.TCGETS)
	if err != nil {
		return nil, err
	}
	oldState := *val

	newState := oldState
	newState.Lflag &^= syscall.ECHO
	newState.Lflag |= syscall.ICANON | syscall.ISIG
	newState.Iflag |= syscall.ICRNL
	err = unix.IoctlSetTermios(fd, unix.TCSETS, &newState)
	if err != nil {
		return nil, err
	}

	defer unix.IoctlSetTermios(fd, unix.TCSETS, &oldState)

	var buf [16]byte
	var ret []byte
	for {
		n, err := syscall.Read(fd, buf[:])
		if err != nil {
			return nil, err
		}
		if n == 0 {
			if len(ret) == 0 {
				return nil, io.EOF
			}
			break
		}
		if buf[n-1] == '\n' {
			n--
		}
		ret = append(ret, buf[:n]...)
		if n < len(buf) {
			break
		}
	}

	return ret, nil
}

// MakeRaw puts the terminal connected to the given file descriptor into raw
// mode and returns the previous state of the terminal so that it can be
// restored.
// see http://cr.illumos.org/~webrev/andy_js/1060/
func MakeRaw(fd int) (*State, error) {
	termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)
	if err != nil {
		return nil, err
	}

	oldState := State{termios: *termios}

	termios.Iflag &^= unix.IGNBRK | unix.BRKINT | unix.PARMRK | unix.ISTRIP | unix.INLCR | unix.IGNCR | unix.ICRNL | unix.IXON
	termios.Oflag &^= unix.OPOST
	termios.Lflag &^= unix.ECHO | unix.ECHONL | unix.ICANON | unix.ISIG | unix.IEXTEN
	termios.Cflag &^= unix.CSIZE | unix.PARENB
	termios.Cflag |= unix.CS8
	termios.Cc[unix.VMIN] = 1
	termios.Cc[unix.VTIME] = 0

	if err := unix.IoctlSetTermios(fd, unix.TCSETS, termios); err != nil {
		return nil, err
	}

	return &oldState, nil
}

// Restore restores the terminal connected to the given file descriptor to a
// previous state.
func Restore(fd int, oldState *State) error {
	return unix.IoctlSetTermios(fd, unix.TCSETS, &oldState.termios)
}

// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
func GetState(fd int) (*State, error) {
	termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)
	if err != nil {
		return nil, err
	}

	return &State{termios: *termios}, nil
}

// GetSize returns the dimensions of the given terminal.
func GetSize(fd int) (width, height int, err error) {
	ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)
	if err != nil {
		return 0, 0, err
	}
	return int(ws.Col), int(ws.Row), nil
}

+ f 4f8a2cbf4d9ba60cd2396910a3fd8f6bf9d08a455b0692ad8e7011355d9e1cec vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
utf8file 106
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows

// Package terminal provides support functions for dealing with terminals, as
// commonly found on UNIX systems.
//
// Putting a terminal into raw mode is the most common requirement:
//
// 	oldState, err := terminal.MakeRaw(0)
// 	if err != nil {
// 	        panic(err)
// 	}
// 	defer terminal.Restore(0, oldState)
package terminal

import (
	"os"

	"golang.org/x/sys/windows"
)

type State struct {
	mode uint32
}

// IsTerminal returns whether the given file descriptor is a terminal.
func IsTerminal(fd int) bool {
	var st uint32
	err := windows.GetConsoleMode(windows.Handle(fd), &st)
	return err == nil
}

// MakeRaw put the terminal connected to the given file descriptor into raw
// mode and returns the previous state of the terminal so that it can be
// restored.
func MakeRaw(fd int) (*State, error) {
	var st uint32
	if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil {
		return nil, err
	}
	raw := st &^ (windows.ENABLE_ECHO_INPUT | windows.ENABLE_PROCESSED_INPUT | windows.ENABLE_LINE_INPUT | windows.ENABLE_PROCESSED_OUTPUT)
	if err := windows.SetConsoleMode(windows.Handle(fd), raw); err != nil {
		return nil, err
	}
	return &State{st}, nil
}

// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
func GetState(fd int) (*State, error) {
	var st uint32
	if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil {
		return nil, err
	}
	return &State{st}, nil
}

// Restore restores the terminal connected to the given file descriptor to a
// previous state.
func Restore(fd int, state *State) error {
	return windows.SetConsoleMode(windows.Handle(fd), state.mode)
}

// GetSize returns the visible dimensions of the given terminal.
//
// These dimensions don't include any scrollback buffer height.
func GetSize(fd int) (width, height int, err error) {
	var info windows.ConsoleScreenBufferInfo
	if err := windows.GetConsoleScreenBufferInfo(windows.Handle(fd), &info); err != nil {
		return 0, 0, err
	}
	return int(info.Window.Right - info.Window.Left + 1), int(info.Window.Bottom - info.Window.Top + 1), nil
}

// ReadPassword reads a line of input from a terminal without local echo.  This
// is commonly used for inputting passwords and other sensitive data. The slice
// returned does not include the \n.
func ReadPassword(fd int) ([]byte, error) {
	var st uint32
	if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil {
		return nil, err
	}
	old := st

	st &^= (windows.ENABLE_ECHO_INPUT | windows.ENABLE_LINE_INPUT)
	st |= (windows.ENABLE_PROCESSED_OUTPUT | windows.ENABLE_PROCESSED_INPUT)
	if err := windows.SetConsoleMode(windows.Handle(fd), st); err != nil {
		return nil, err
	}

	defer windows.SetConsoleMode(windows.Handle(fd), old)

	var h windows.Handle
	p, _ := windows.GetCurrentProcess()
	if err := windows.DuplicateHandle(p, windows.Handle(fd), p, &h, 0, false, windows.DUPLICATE_SAME_ACCESS); err != nil {
		return nil, err
	}

	f := os.NewFile(uintptr(h), "stdin")
	defer f.Close()
	return readPasswordLine(f)
}

- f 334250a30969fe3c1b8db14c77a5293d911f1dfaa9e6c5bef8c6f03bed915988 vendor/golang.org/x/sys/unix/asm_linux_riscv64.s
+ f 13b17ae3c256fb84d2c66d68c9032aba04333e22bc1831cb64f1b3bc887686ad vendor/golang.org/x/sys/unix/asm_linux_riscv64.s
dmppatch 8
@@ -587,56 +587,8 @@
  A2%0A
-%09MOV%09$0, A3%0A%09MOV%09$0, A4%0A%09MOV%09$0, A5%0A%09MOV%09$0, A6%0A
 %09MOV
@@ -951,50 +951,8 @@
  A2%0A
-%09MOV%09ZERO, A3%0A%09MOV%09ZERO, A4%0A%09MOV%09ZERO, A5%0A
 %09MOV
- f 1dd8db8be9e32238295ddec575d5e2a977cde76bc6bc70a3ce3d6d293c37d956 vendor/golang.org/x/sys/unix/fcntl.go
+ f 17d765179cdd928346e0588df0f0bb8163e04a2cb1afe894f7dd265e443eb942 vendor/golang.org/x/sys/unix/fcntl.go
dmppatch 14
@@ -312,62 +312,62 @@
 nux%0A
-// systems by flock_linux_32bit.go to be SYS_FCNTL64.%0A
+// systems by fcntl_linux_32bit.go to be SYS_FCNTL64.%0A
 var 
@@ -406,223 +406,142 @@
 TL%0A%0A
-// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09valptr, _, errno := Syscall(fcntl64Syscall, fd, uintptr(cmd), uintptr(arg))%0A
+func fcntl(fd int, cmd, arg int) (int, error) %7B%0A%09valptr, _, errno := Syscall(fcntl64Syscall, uintptr(fd), uintptr(cmd), uintptr(arg))%0A
 %09var
@@ -610,16 +610,190 @@
 r), err%0A
+%7D%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09return fcntl(int(fd), cmd, arg)%0A
 %7D%0A%0A// Fc
- f c9d7ecf9318c066b2948d28ef7a6e1a6ab5fdd991acc59d17ebcec72e5ae90e2 vendor/golang.org/x/sys/unix/mkerrors.sh
+ f 434279e5a2e214c450fef5f9c428df1968a2ea4b9510958978a73d4a3304c8c1 vendor/golang.org/x/sys/unix/mkerrors.sh
dmppatch 8
@@ -4276,32 +4276,53 @@
  %3Csys/socket.h%3E%0A
+#include %3Csys/uio.h%3E%0A
 #include %3Csys/xa
@@ -13220,24 +13220,42 @@
  /%5EXDP_/ %7C%7C%0A
+%09%09$2 ~ /%5ERWF_/ %7C%7C%0A
 %09%09$2 ~ /%5E(HD
- f e9420758397d55a447cab5cdfad68b6e5f8384f33116b8ed2f7acc1419d1f97a vendor/golang.org/x/sys/unix/syscall_bsd.go
+ f a17f7d7e32b34fedab412a245f4b167a20640a68a6ff2874247e27bacfc79470 vendor/golang.org/x/sys/unix/syscall_bsd.go
dmppatch 8
@@ -12979,24 +12979,365 @@
 :n%5D, nil%0A%7D%0A%0A
+func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sys%09utimes
@@ -14895,68 +14895,8 @@
 )%0A%7D%0A
-%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A
 %0A//s
- f 72cb283c7ece258e92cfd92a6607e6432b8bedc9e537035c9d1359d7e98e5a92 vendor/golang.org/x/sys/unix/syscall_darwin.go
+ f 9d5edc113ff4a8303b99827516df8937e377497feba3d6ae68de10ffa3a737cb vendor/golang.org/x/sys/unix/syscall_darwin.go
dmppatch 8
@@ -4491,349 +4491,8 @@
 r)%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sy
@@ -9487,16 +9487,76 @@
 ped%0A */%0A
+%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A
 %0A//sys%09k
- f 0a2553402e0d97905e85868097519ff3d954e50921e2a46d62b65fc9c46798e2 vendor/golang.org/x/sys/unix/syscall_darwin_arm.1_11.go
+ f 71e569be580271e661729f5e22973655e92b30b95fac710228cd7ed0d2d1b783 vendor/golang.org/x/sys/unix/syscall_darwin_arm.1_11.go
dmppatch 5
@@ -157,37 +157,37 @@
 e.%0A%0A
-// +build darwin,386,!go1.12%0A
+// +build darwin,arm,!go1.12%0A
 %0Apac
- f f26fd5b0ca015d3df0fef99d25c966f1396046bd787a9950e887c8d0fb63dac8 vendor/golang.org/x/sys/unix/syscall_linux.go
+ f 27b14ae53f533d07b3d686e514e3eab87b81d9318270b7b3053fbf307a041b76 vendor/golang.org/x/sys/unix/syscall_linux.go
dmppatch 8
@@ -47256,67 +47256,8 @@
 or)%0A
-//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A
 //sy
@@ -52287,16 +52287,3219 @@
 S_WRITE%0A
+//sys%09readv(fd int, iovs %5B%5DIovec) (n int, err error) = SYS_READV%0A//sys%09writev(fd int, iovs %5B%5DIovec) (n int, err error) = SYS_WRITEV%0A//sys%09preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) = SYS_PREADV%0A//sys%09pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) = SYS_PWRITEV%0A//sys%09preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) = SYS_PREADV2%0A//sys%09pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) = SYS_PWRITEV2%0A%0Afunc bytes2iovec(bs %5B%5D%5B%5Dbyte) %5B%5DIovec %7B%0A%09iovecs := make(%5B%5DIovec, len(bs))%0A%09for i, b := range bs %7B%0A%09%09iovecs%5Bi%5D.SetLen(len(b))%0A%09%09if len(b) %3E 0 %7B%0A%09%09%09iovecs%5Bi%5D.Base = &b%5B0%5D%0A%09%09%7D else %7B%0A%09%09%09iovecs%5Bi%5D.Base = (*byte)(unsafe.Pointer(&_zero))%0A%09%09%7D%0A%09%7D%0A%09return iovecs%0A%7D%0A%0A// offs2lohi splits offs into its lower and upper unsigned long. On 64-bit%0A// systems, hi will always be 0. On 32-bit systems, offs will be split in half.%0A// preadv/pwritev chose this calling convention so they don't need to add a%0A// padding-register for alignment on ARM.%0Afunc offs2lohi(offs int64) (lo, hi uintptr) %7B%0A%09return uintptr(offs), uintptr(uint64(offs) %3E%3E SizeofLong)%0A%7D%0A%0Afunc Readv(fd int, iovs %5B%5D%5B%5Dbyte) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09n, err = readv(fd, iovecs)%0A%09readvRacedetect(iovecs, n, err)%0A%09return n, err%0A%7D%0A%0Afunc Preadv(fd int, iovs %5B%5D%5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09lo, hi := offs2lohi(offset)%0A%09n, err = preadv(fd, iovecs, lo, hi)%0A%09readvRacedetect(iovecs, n, err)%0A%09return n, err%0A%7D%0A%0Afunc Preadv2(fd int, iovs %5B%5D%5B%5Dbyte, offset int64, flags int) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09lo, hi := offs2lohi(offset)%0A%09n, err = preadv2(fd, iovecs, lo, hi, flags)%0A%09readvRacedetect(iovecs, n, err)%0A%09return n, err%0A%7D%0A%0Afunc readvRacedetect(iovecs %5B%5DIovec, n int, err error) %7B%0A%09if !raceenabled %7B%0A%09%09return%0A%09%7D%0A%09for i := 0; n %3E 0 && i %3C len(iovecs); i++ %7B%0A%09%09m := int(iovecs%5Bi%5D.Len)%0A%09%09if m %3E n %7B%0A%09%09%09m = n%0A%09%09%7D%0A%09%09n -= m%0A%09%09if m %3E 0 %7B%0A%09%09%09raceWriteRange(unsafe.Pointer(iovecs%5Bi%5D.Base), m)%0A%09%09%7D%0A%09%7D%0A%09if err == nil %7B%0A%09%09raceAcquire(unsafe.Pointer(&ioSync))%0A%09%7D%0A%7D%0A%0Afunc Writev(fd int, iovs %5B%5D%5B%5Dbyte) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09n, err = writev(fd, iovecs)%0A%09writevRacedetect(iovecs, n)%0A%09return n, err%0A%7D%0A%0Afunc Pwritev(fd int, iovs %5B%5D%5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09lo, hi := offs2lohi(offset)%0A%09n, err = pwritev(fd, iovecs, lo, hi)%0A%09writevRacedetect(iovecs, n)%0A%09return n, err%0A%7D%0A%0Afunc Pwritev2(fd int, iovs %5B%5D%5B%5Dbyte, offset int64, flags int) (n int, err error) %7B%0A%09iovecs := bytes2iovec(iovs)%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09lo, hi := offs2lohi(offset)%0A%09n, err = pwritev2(fd, iovecs, lo, hi, flags)%0A%09writevRacedetect(iovecs, n)%0A%09return n, err%0A%7D%0A%0Afunc writevRacedetect(iovecs %5B%5DIovec, n int) %7B%0A%09if !raceenabled %7B%0A%09%09return%0A%09%7D%0A%09for i := 0; n %3E 0 && i %3C len(iovecs); i++ %7B%0A%09%09m := int(iovecs%5Bi%5D.Len)%0A%09%09if m %3E n %7B%0A%09%09%09m = n%0A%09%09%7D%0A%09%09n -= m%0A%09%09if m %3E 0 %7B%0A%09%09%09raceReadRange(unsafe.Pointer(iovecs%5Bi%5D.Base), m)%0A%09%09%7D%0A%09%7D%0A%7D%0A
 %0A// mmap
- f a4f649f8465a364459d9eb6378d68f00690a2bdf4c8b5dc6a4c1c3be0394fdbf vendor/golang.org/x/sys/unix/syscall_netbsd.go
+ f 82f4e68a2c3e307543194f612d6b2565b7222cccb7039b7d3790c0761e3803e0 vendor/golang.org/x/sys/unix/syscall_netbsd.go
dmppatch 18
@@ -2734,349 +2734,8 @@
 %0A%7D%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 //sy
@@ -6307,32 +6307,84 @@
 nt) (err error)%0A
+//sys%09Dup3(from int, to int, flags int) (err error)%0A
 //sys%09Exit(code 
@@ -8339,76 +8339,87 @@
 or)%0A
-//sys%09Fstatvfs1(fd int, buf *Statvfs_t) (err error) = SYS_FSTATVFS1%0A
+//sys%09Fstatvfs1(fd int, buf *Statvfs_t, flags int) (err error) = SYS_FSTATVFS1%0A
 //sy
@@ -11261,79 +11261,90 @@
 or)%0A
-//sys%09Statvfs1(path string, buf *Statvfs_t) (err error) = SYS_STATVFS1%0A
+//sys%09Statvfs1(path string, buf *Statvfs_t, flags int) (err error) = SYS_STATVFS1%0A
 //sy
- f e444080d457451faa911d39141eb55b5b60740d9eb3f131d7beede6ddb665391 vendor/golang.org/x/sys/unix/syscall_openbsd.go
+ f 50f0353861bbc5a5f14d56afcdd5d03aa5bcd5d6cd3d40450bdec7f56b0c3671 vendor/golang.org/x/sys/unix/syscall_openbsd.go
dmppatch 12
@@ -1584,349 +1584,8 @@
 %0A%7D%0A%0A
-func SysctlClockinfo(name string) (*Clockinfo, error) %7B%0A%09mib, err := sysctlmib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09n := uintptr(SizeofClockinfo)%0A%09var ci Clockinfo%0A%09if err := sysctl(mib, (*byte)(unsafe.Pointer(&ci)), &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n != SizeofClockinfo %7B%0A%09%09return nil, EIO%0A%09%7D%0A%09return &ci, nil%0A%7D%0A%0A
 func
@@ -5802,24 +5802,76 @@
 (err error)%0A
+//sys%09Dup3(from int, to int, flags int) (err error)%0A
 //sys%09Exit(c
@@ -10698,17 +10698,8 @@
 cve%0A
-// fcntl%0A
 // f
- f 513a1f0b17682654af0bb2d0765a7b4e9de64fa28c4d9979de4d06e118580a93 vendor/golang.org/x/sys/unix/zerrors_linux_386.go
+ f ae6c25a4c6eff98dcb5dc16f1de64adccc561609af46841d93cea28fe2be5ede vendor/golang.org/x/sys/unix/zerrors_linux_386.go
dmppatch 4
@@ -106842,24 +106842,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f b5918b1ec74dc3b924ef96591fcc9c72fcf2805c6158e6917fb7c1cb65530d7d vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
+ f dd5042ed767d25d107dfc4a3c28fdf129ae5b2e93fbf61457c49f9e36313ab60 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
dmppatch 4
@@ -106901,24 +106901,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 0a24184cdb4000ad2ad454532d174973b98e7de289813d4e0f678661eccea193 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
+ f bc9b5bc230524a47fddb3a1e8cbba9d5313a8ec8e213f938aaf0b9eb60be4da2 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
dmppatch 4
@@ -107197,24 +107197,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f c7acfeaa1cb91344fcd7960c9054c41a72e740bf7cb7c9551abd1bded5fd64f1 vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
+ f af75b502f65941143cce954a717b1ffbe75574fef2cb82da8f6a4dd8c37e573f vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
dmppatch 4
@@ -106516,24 +106516,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 63a931f27073aaa1cee8122f5d960f8ab1603d02359a92c6ea1d6d48adf47ec6 vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
+ f a2ee6e10cb81d6db78846807c11cea68dbd4acca30ec536e4215e55a695686a9 vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
dmppatch 4
@@ -106973,24 +106973,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 11821d2042692c37d5399dcb39c7d09dc432d8f8728778871a998c6831d2e665 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
+ f 4d227188101c05e347ce318b39f57d66a198e42b41a81d803ed6b99f7096f272 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
dmppatch 4
@@ -106974,24 +106974,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f b4c3d1c88c486c1f4d7d2dafdec9ef5a52ba60ab34580db66410d395a869deea vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
+ f 3cd190237dacf26e5540bdf636f563f7d83f161b79d5719f0e46a0b3769d6ccf vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
dmppatch 4
@@ -106976,24 +106976,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f e1d7cf2baeaff14a9a853d0d2906cc4b036f7365442a134889dda951a60d5b6e vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
+ f 7922e9e1a41253656f369655bc60a249c462cd5d6fc353d8666b0899b6795e38 vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
dmppatch 4
@@ -106975,24 +106975,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f d435b4ce99e229aab633de543de052987d6c46c4d550873c18283e6f34b58285 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
+ f b9283eb5f8d89d35f28b667142eded8187db661cf0842b55ddf3f09497787bd1 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
dmppatch 4
@@ -109972,24 +109972,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 7a166a1be22252704c5a7c39733902af3c09de13b16a5f0395854673357a13b3 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
+ f bdc54cf60b690253020547f997b2f8588a025a508075c991f67c81c28dd4b127 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
dmppatch 4
@@ -109974,24 +109974,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 75e0b46890475500a059cf4a7339e6da3df6fc27da85d346e380f442ab183e88 vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
+ f c63b820cc5526bf7d3a73cf56b56bb046484c6b0fa9ba3b824c52b9bae3e85f3 vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
dmppatch 4
@@ -106213,24 +106213,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 27e283e3257b4dc08f279e67f3bb7d323a5c47889853e8c55fb9ebff2466f017 vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
+ f 7dc96d155cae01ccbdda258c732083983682a18b3d92525e3120c1ce5468bf2b vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
dmppatch 4
@@ -110074,24 +110074,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 521ca140adf995cd7c394e9b8801f2d49150ec0466ee5708a11600e37e3e17b8 vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
+ f 505a3bbc6b0f43896ad55a2698b3db8d14e6bbb07511595512e11878ba6529a2 vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
dmppatch 4
@@ -109753,24 +109753,383 @@
       = 0x1%0A
+%09RWF_APPEND                                  = 0x10%0A%09RWF_DSYNC                                   = 0x2%0A%09RWF_HIPRI                                   = 0x1%0A%09RWF_NOWAIT                                  = 0x8%0A%09RWF_SUPPORTED                               = 0x1f%0A%09RWF_SYNC                                    = 0x4%0A%09RWF_WRITE_LIFE_NOT_SET                      = 0x0%0A
 %09SCM_CREDENT
- f 20a5d8789baa4e32cb2e6d343ac59d904a5c60f0ee6e10c3830cefdf742fdaaf vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go
+ f 892032f2d8714dc94c3d49c186f0b9aa3f023dc1b0c2a1d6f4a03aad6dd1b9b8 vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go
dmppatch 8
@@ -6761,272 +6761,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -13687,32 +13687,296 @@
 tr(options), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A
 %09if e1 != 0 %7B%0A%09%09
- f 7f445820cd4f47f301d663fd0a5038f77dc3c1c112a1cf3289ebae30af750575 vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
+ f 148af198511198af0bd880ecd2212a8ca4aae59e991a727c5ac32c402105ab88 vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
dmppatch 8
@@ -10297,437 +10297,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -20711,32 +20711,461 @@
 System.B.dylib%22%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A
 %0A// THIS FILE IS
- f ffbf56591793b0e49160c8e0290e33a0dd6dc773d66e6e84cf1e2daf91b97435 vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s
+ f 05dcb1a9869d1e129219323a5781a8aa5345b02c655ba3484ab82123ba2129f2 vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s
dmppatch 12
@@ -1547,74 +1547,8 @@
 SB)%0A
-TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT
@@ -2911,32 +2911,98 @@
 setattrlist(SB)%0A
+TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT %C2%B7libc_kill
@@ -3725,24 +3725,106 @@
 _chroot(SB)%0A
+TEXT %C2%B7libc_clock_gettime_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_clock_gettime(SB)%0A
 TEXT %C2%B7libc_
- f abacd46e794c98234638db22b9dcd64e506621cf1a6874c6e5829a36c9aa75d1 vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go
+ f 8006f5f02ced15dc34784b710ff7f6bdd32a8ebfdb00a412dc58919985d1d53c vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go
dmppatch 8
@@ -6764,272 +6764,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -13690,32 +13690,296 @@
 tr(options), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A
 %09if e1 != 0 %7B%0A%09%09
- f 82504d6d610f7b9fe3e59ab15859c909c0928e54d0aa30236626bc0ff6bc54c4 vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
+ f 47287983986aeb609a6266ad2e74523b7e790536e8b7bcb0d00e3828caf4e68c vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
dmppatch 8
@@ -10298,437 +10298,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -20712,32 +20712,461 @@
 System.B.dylib%22%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A
 %0A// THIS FILE IS
- f c4a645792ab60cce36dad069f8bf239e29dc610a684791b03eb2906d33e16c04 vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s
+ f 6b9435cbec336637c016cdf7d8cf4fe0b3aa63f6691c81f1ef63de390efda1ae vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s
dmppatch 8
@@ -1549,74 +1549,8 @@
 SB)%0A
-TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT
@@ -2913,32 +2913,98 @@
 setattrlist(SB)%0A
+TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT %C2%B7libc_kill
- f 4647dc05353ccc3a6692774f239e45087ccc174557fed7a5c73d69292765d150 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go
+ f b62ba9fc634ca2ce81e7a7b9cea08a0b5f3428e51d0d8ccea6dc6874fdaa9ca8 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go
dmppatch 8
@@ -6761,272 +6761,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -13687,32 +13687,296 @@
 tr(options), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A
 %09if e1 != 0 %7B%0A%09%09
- f e260d74342e30592c986d16c0b1b2f2958b2387a50314f795796c79e2f70d1f0 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
+ f ea1082de104332cf0ad61f5f620cd71eb56178ade65c82c12c3fd9069ada74d4 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
dmppatch 8
@@ -10297,437 +10297,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -20711,32 +20711,461 @@
 System.B.dylib%22%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A
 %0A// THIS FILE IS
- f e937b57af7be3461a12d51461afd8d19658458a4dbb8dd151078639a9fc97af9 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s
+ f 08f842fe8b415a453f98799a01e93aebc2435c47008f47e3368fdb866c8e8db4 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s
dmppatch 12
@@ -1547,74 +1547,8 @@
 SB)%0A
-TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT
@@ -2911,32 +2911,98 @@
 setattrlist(SB)%0A
+TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT %C2%B7libc_kill
@@ -3111,24 +3111,92 @@
 c_ioctl(SB)%0A
+TEXT %C2%B7libc_sysctl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_sysctl(SB)%0A
 TEXT %C2%B7libc_
- f 137d46ae436a29d2e44088f0628864e42788ae9449466def6898cb35d032a550 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go
+ f a4553c9e39e00381a40aeeae467dfb08ae533f1ce555c3e3c07b88be6f529ac8 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go
dmppatch 8
@@ -6764,272 +6764,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -13690,32 +13690,296 @@
 tr(options), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A
 %09if e1 != 0 %7B%0A%09%09
- f 1ef2d5b9d96bbaf1c0033157307f9c3f5e1470576a87e4312ecb7ee8fc5b4ef3 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
+ f 7f91e9bdf8b787712de1a3686159fe46bf5432b7b0b5f3dd0242eeca49613295 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
dmppatch 8
@@ -10298,437 +10298,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -20712,32 +20712,461 @@
 System.B.dylib%22%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := syscall_syscall(funcPC(libc_fcntl_trampoline), uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc libc_fcntl_trampoline()%0A%0A//go:linkname libc_fcntl libc_fcntl%0A//go:cgo_import_dynamic libc_fcntl fcntl %22/usr/lib/libSystem.B.dylib%22%0A
 %0A// THIS FILE IS
- f 4282b7a03631881842dbec01f7976b3cbb676abfef3ad5a03688b73cc31d9e8e vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s
+ f 7102eb2f45584428ab535a58b3d86b73e1c40a0fd08c1d5d7604de05c12af448 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s
dmppatch 12
@@ -1549,74 +1549,8 @@
 SB)%0A
-TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT
@@ -2913,32 +2913,98 @@
 setattrlist(SB)%0A
+TEXT %C2%B7libc_fcntl_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_fcntl(SB)%0A
 TEXT %C2%B7libc_kill
@@ -3727,24 +3727,106 @@
 _chroot(SB)%0A
+TEXT %C2%B7libc_clock_gettime_trampoline(SB),NOSPLIT,$0-0%0A%09JMP%09libc_clock_gettime(SB)%0A
 TEXT %C2%B7libc_
- f 43bdb4001f9400adaa782aa05a95f06179ddad8f152ca37edf7690376d2fe7ff vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
+ f 455da5992bc495296dc52acd7b2adf5d9f9dabbb9bef8ff8cd0a04ebcbdc7a43 vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
dmppatch 4
@@ -7250,272 +7250,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
- f 94fd2da7460802d845d3b75bfd5771824bd01bdc08a127e9322c2edea0c2606e vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
+ f 16b1401ff869cec5f3afaa1da6dacc800e2696ae2731a1f39e15731de7713368 vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
dmppatch 4
@@ -7230,272 +7230,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
- f 2529a7956a46c7a3ede4572b30f24edeedcc7d7a35ebb06f5feeb6aab78d1e26 vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
+ f 3cfcbe2fc249a95a47dcb5cfe9fce7a4c850cc80ad35bc86fa6159b96166e934 vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
dmppatch 4
@@ -6723,272 +6723,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
- f 8e5c01cbe8d643332211ffca457c67091dda07856c953f85f2799f242ef5c3e3 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
+ f 799ef6d19b021a40a998a9183bcbce04b7e0636cb89a9ec486ea567e146afeca vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
dmppatch 4
@@ -6727,272 +6727,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
- f 62c7f3e5db77d2f3672f407decd60301131f3ad39228436c5242aa5acb86a403 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go
+ f e32e64770dbded2bec23d7fd860f9c33df8812759f9aa5cea3058e5ca0ebc6e3 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go
dmppatch 4
@@ -6726,272 +6726,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
- f 8a623340bc47ce3f636916cd799e51433cb446d58dedf7c90e1d0ba67ccdb9de vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
+ f a632da2baac9a14c0d99bb5afd37ac9d369ec939f0da51872f02aa87d7ad73f9 vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
dmppatch 8
@@ -16763,272 +16763,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -39036,32 +39036,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 74d3652d4617da24abe86cf2fe438b997047e8bd3e17b0e2fd005eb56670110d vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
+ f 016c9ea07508aefbe70070b5a6d49c259d091b654efc0a6cbe301aa30d8eab7d vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
dmppatch 8
@@ -16718,272 +16718,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38967,32 +38967,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 1023fa0208cbf31e5f838f3c5310594749e08388e1b288378c854b59b1dc5f5e vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
+ f 73ba1d7d77adb3532246805e155161813dca5d6e055afedb79cd105142f0918a vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
dmppatch 8
@@ -16768,272 +16768,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -39041,32 +39041,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 54e47404d56a3df5f644b47699a91e8f5049aa3eb30914b77058447ecec5a020 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
+ f 3eb9e796a57f758185640f56807843486bbf97c55e07d013e9cc6913cfda5887 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
dmppatch 8
@@ -16718,272 +16718,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38967,32 +38967,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 846effe106d302d4cb16936b55822daa365b2e3cf3e1642aaa737a5c3e8ca7a7 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
+ f 38a3b3b4f915c69fa431e0fc81528dd39202cc3adb8e01707b9515bb0f1c5e47 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
dmppatch 8
@@ -16772,272 +16772,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -39045,32 +39045,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 000bfbc129b307e93dc86577f882305374a58d369cc99d65c9789b7f47a0e93f vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
+ f 289e1446788dee25e11e2b852a8c341c20a4fb3898c497414c429ccb1401a9c1 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
dmppatch 8
@@ -16722,272 +16722,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38971,32 +38971,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f 486a4e8fed9b84d0dd690d8dd8e41f24c390dedc3aacd7e753bbfaaa304a4643 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
+ f a67e76c01a38d6ecfb761f80a519641414be835f902654f646e9a77894f87b5d vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
dmppatch 8
@@ -16726,272 +16726,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38975,32 +38975,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f bc6e6f0b5e2979267354944dfd0a0ffc7f20e6ff51dd873ea1ee6a7df9271302 vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
+ f 30d9dcf5d02235eb3558f7c95c0f3b57a5a08a70b51fe5ec8abd794297b404bc vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
dmppatch 8
@@ -16776,272 +16776,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -39049,32 +39049,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f c7a95a3a551bb4560d764b9913d74c0b21927d0a276c4d20e7e0fd0386e3d0ea vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
+ f 239307276f805e27d2f186b241fd3d62970d911902171203d0a7ca1d9280625d vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
dmppatch 8
@@ -16719,272 +16719,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38968,32 +38968,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f c71f500a0787bf26272faef32d923f481ebcb4c51ab75d20337f989e9f0c84c8 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
+ f 027ac04b7b26793c9896756161431e3294bacfbfa0f3711b10ac8a58d914e1d9 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
dmppatch 8
@@ -16723,272 +16723,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38972,32 +38972,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f d89b1f2a9ac3f52672ab3a12c264795163230afa9414481f72869add6ea4cdab vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
+ f f40513dc6947d9ed52251115e45d98ed770e02536aa11533ab34d6b46a871b8e vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
dmppatch 8
@@ -16724,272 +16724,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38973,32 +38973,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f b996a987ecadcaabee8617ea91fc4354f1a9d550d7a85cf3c0567593285d39c7 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
+ f c880ac2c855694d5c1cd6006ec23314bf88ccd32e15a30233e5bdefb1c321c52 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
dmppatch 8
@@ -16718,272 +16718,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38967,32 +38967,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f e40df74393208581edb4b47f1b47280c855334ea96c13825f2d387116569c1a8 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
+ f 20f81a9134c01cfed76b800274d6fc7be97dace75a75fb7cc6ea68ecbde603cc vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
dmppatch 8
@@ -16724,272 +16724,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -38973,32 +38973,2676 @@
 ), uintptr(np))%0A
+%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readv(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writev(fd int, iovs %5B%5DIovec) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc preadv2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pwritev2(fd int, iovs %5B%5DIovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(iovs) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&iovs%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))%0A
 %09n = int(r0)%0A%09if
- f d9d7a7220f84b7987f65fb423586df74cc73cea79233113ad35abd28561436a3 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
+ f d450e32217e9b0bda189d50bc70727f9f751d208e22b7d2e4ff5c68c2b65fb18 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
dmppatch 16
@@ -6726,272 +6726,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9044,516 +9044,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10377,24 +10377,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func Access(
@@ -13617,24 +13617,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 3ca5b35ff1bcdc66275692d79f1df89d4fe7ac5ba030059b498641d67a4c6862 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
+ f a2438e5186211dbe9f1b1f31069a9cc34f8868042549c3eb546c0a89e2cadf64 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
dmppatch 16
@@ -6727,272 +6727,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9045,516 +9045,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10378,24 +10378,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func Access(
@@ -13618,24 +13618,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f ca0f27baaea72b355e3192efa22bb5b1b98a379832c33512f6c125a40e80a63a vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
+ f 79efef2cfae2cdcf27d684c3c1735e7e55b98174fa32625506fdba4e7e718744 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
dmppatch 16
@@ -6731,272 +6731,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9049,516 +9049,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10382,24 +10382,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func Access(
@@ -13622,24 +13622,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f e37c0fa58998861367cbb83a691f83eeb83028ed8e3ab6b57c2fcf0493951097 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go
+ f 106801910bda1bebada81cd8d7cc238677e075582d0a602d344dbae846810193 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go
dmppatch 16
@@ -6727,272 +6727,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9045,516 +9045,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10378,24 +10378,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func Access(
@@ -13618,24 +13618,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 1a0d551c7ebd67c3dfb99af46995d0b6e31d5e1e6164dc80b1c0dc115fbd8c0b vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
+ f 68b51b54fb42997f71f20d8b8aebff6cbd692515845e1ae33cba2a120886d366 vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
dmppatch 16
@@ -6731,272 +6731,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9049,516 +9049,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10369,24 +10369,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func ppoll(f
@@ -13983,24 +13983,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f b5d6de50a13873db696964c93ef29933787b385b538cfdb30d4a2d06a39ce953 vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
+ f e763978e04f3f698889914adf8bced9752e9b440b2d35de46aa060d480706f06 vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
dmppatch 16
@@ -6732,272 +6732,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9050,516 +9050,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10370,24 +10370,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func ppoll(f
@@ -13984,24 +13984,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 90a9c093a8ff0582457465add5f7b3cb02fe32c2793d912dc61bb51184a0e187 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
+ f bdece0602510fbf7ece04918b07cce63c05fe56e632b172b519e1bf1baa04bf4 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
dmppatch 16
@@ -6736,272 +6736,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9054,516 +9054,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10374,24 +10374,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func ppoll(f
@@ -13988,24 +13988,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 498b27eda9c6be8bd5fba662052e3686f803ddb1bd9320f2a7759ab98c4631c3 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm64.go
+ f 5fbcac0eb6f64b4fd22e4321d8e4255205a593015ae18cc7af0341453345a169 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm64.go
dmppatch 16
@@ -6732,272 +6732,8 @@
 IT%0A%0A
-func fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -9050,516 +9050,8 @@
  0)%0A
-%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A
 %09if 
@@ -10370,24 +10370,532 @@
 O NOT EDIT%0A%0A
+func sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func ppoll(f
@@ -13984,24 +13984,267 @@
 ptr(to), 0)%0A
+%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(from int, to int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(from), uintptr(to), uintptr(flags))%0A
 %09if e1 != 0 
- f 9bbdd44eb528906e6dc3cb8910800818f7c183fe3dcdd291d4a4f08fb0b8722e vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
+ f b6ef64fb4cfbc468441118d9917a06f4c392d9c5f471d982102ade838a7c9a9b vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
dmppatch 3
@@ -6981,16 +6981,148 @@
 ine  %5B32%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz      int32%0A%09Tick    int32%0A%09Tickadj int32%0A%09Stathz  int32%0A%09Profhz  int32%0A%7D%0A
- f aa4933a20387bac9b0c6c3c9fb576e95f2732d3610cfec825e0bafbf96f9b9ae vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
+ f 710fef2659a13ae616f93403c8783036cb7ec8ae044657d83b041f6e150df224 vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
dmppatch 3
@@ -10814,16 +10814,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f f48937a5ee8b68bce8071cfac6491ea44f792d52d8e77ee9677430af48bee521 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
+ f b1ca09db4b1c8ac9ce82277a631e92b1d2d59e624b39923695baee75691c7729 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
dmppatch 3
@@ -10887,16 +10887,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f 6a0f2421552e3f9d2b73e9e135a36a9278ebd63d548a738e5fe93f6ddee71ebd vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
+ f 78fbbdb0c4a57038712d94adda0caf0682aec5bdad44e6cc6969e513ccb98f43 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
dmppatch 3
@@ -10585,16 +10585,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f 24ee41a86c7381b8b592b6366451abff2514158c474e66b327a86100701df96e vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go
+ f 449d1150523fd8ab37b215a836775857d2bb3bafaa51dcb31a90e0daa33c36bf vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go
dmppatch 3
@@ -10574,16 +10574,143 @@
 ne  %5B256%5Dbyte%0A%7D%0A
+%0Aconst SizeofClockinfo = 0x14%0A%0Atype Clockinfo struct %7B%0A%09Hz     int32%0A%09Tick   int32%0A%09Spare  int32%0A%09Stathz int32%0A%09Profhz int32%0A%7D%0A
- f bb14314f4b5eb782985f887d298103e9d9b10ac9b84acc1bab77378bf0e6ec73 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
+ f 89cbf006bc203700f58d857637794f5e234897bea1b57ed5fcd273985563248d vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
dmppatch 8
@@ -3031,24 +3031,135 @@
 e  int32%0A%7D%0A%0A
+type Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0A
 type Inet6Pk
@@ -3660,16 +3660,46 @@
   = 0xc%0A
+%09SizeofInet4Pktinfo     = 0xc%0A
 %09SizeofI
+ f 1ed908469d018fc34605124b47418422091f4aae525cd91561a9d94787934050 vendor/golang.org/x/sys/windows/aliases.go
utf8file 14
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows
// +build go1.9

package windows

import "syscall"

type Errno = syscall.Errno
type SysProcAttr = syscall.SysProcAttr

+ f 595152f59767c0ec1c7f9fe5798525a4aca11350791a43dc9fd940e8886cdbb3 vendor/golang.org/x/sys/windows/dll_windows.go
utf8file 387
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

import (
	"sync"
	"sync/atomic"
	"syscall"
	"unsafe"
)

// We need to use LoadLibrary and GetProcAddress from the Go runtime, because
// the these symbols are loaded by the system linker and are required to
// dynamically load additional symbols. Note that in the Go runtime, these
// return syscall.Handle and syscall.Errno, but these are the same, in fact,
// as windows.Handle and windows.Errno, and we intend to keep these the same.

//go:linkname syscall_loadlibrary syscall.loadlibrary
func syscall_loadlibrary(filename *uint16) (handle Handle, err Errno)

//go:linkname syscall_getprocaddress syscall.getprocaddress
func syscall_getprocaddress(handle Handle, procname *uint8) (proc uintptr, err Errno)

// DLLError describes reasons for DLL load failures.
type DLLError struct {
	Err     error
	ObjName string
	Msg     string
}

func (e *DLLError) Error() string { return e.Msg }

// A DLL implements access to a single DLL.
type DLL struct {
	Name   string
	Handle Handle
}

// LoadDLL loads DLL file into memory.
//
// Warning: using LoadDLL without an absolute path name is subject to
// DLL preloading attacks. To safely load a system DLL, use LazyDLL
// with System set to true, or use LoadLibraryEx directly.
func LoadDLL(name string) (dll *DLL, err error) {
	namep, err := UTF16PtrFromString(name)
	if err != nil {
		return nil, err
	}
	h, e := syscall_loadlibrary(namep)
	if e != 0 {
		return nil, &DLLError{
			Err:     e,
			ObjName: name,
			Msg:     "Failed to load " + name + ": " + e.Error(),
		}
	}
	d := &DLL{
		Name:   name,
		Handle: h,
	}
	return d, nil
}

// MustLoadDLL is like LoadDLL but panics if load operation failes.
func MustLoadDLL(name string) *DLL {
	d, e := LoadDLL(name)
	if e != nil {
		panic(e)
	}
	return d
}

// FindProc searches DLL d for procedure named name and returns *Proc
// if found. It returns an error if search fails.
func (d *DLL) FindProc(name string) (proc *Proc, err error) {
	namep, err := BytePtrFromString(name)
	if err != nil {
		return nil, err
	}
	a, e := syscall_getprocaddress(d.Handle, namep)
	if e != 0 {
		return nil, &DLLError{
			Err:     e,
			ObjName: name,
			Msg:     "Failed to find " + name + " procedure in " + d.Name + ": " + e.Error(),
		}
	}
	p := &Proc{
		Dll:  d,
		Name: name,
		addr: a,
	}
	return p, nil
}

// MustFindProc is like FindProc but panics if search fails.
func (d *DLL) MustFindProc(name string) *Proc {
	p, e := d.FindProc(name)
	if e != nil {
		panic(e)
	}
	return p
}

// Release unloads DLL d from memory.
func (d *DLL) Release() (err error) {
	return FreeLibrary(d.Handle)
}

// A Proc implements access to a procedure inside a DLL.
type Proc struct {
	Dll  *DLL
	Name string
	addr uintptr
}

// Addr returns the address of the procedure represented by p.
// The return value can be passed to Syscall to run the procedure.
func (p *Proc) Addr() uintptr {
	return p.addr
}

//go:uintptrescapes

// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
// are supplied.
//
// The returned error is always non-nil, constructed from the result of GetLastError.
// Callers must inspect the primary return value to decide whether an error occurred
// (according to the semantics of the specific function being called) before consulting
// the error. The error will be guaranteed to contain windows.Errno.
func (p *Proc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {
	switch len(a) {
	case 0:
		return syscall.Syscall(p.Addr(), uintptr(len(a)), 0, 0, 0)
	case 1:
		return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], 0, 0)
	case 2:
		return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], 0)
	case 3:
		return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], a[2])
	case 4:
		return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], 0, 0)
	case 5:
		return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], 0)
	case 6:
		return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5])
	case 7:
		return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], 0, 0)
	case 8:
		return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], 0)
	case 9:
		return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
	case 10:
		return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], 0, 0)
	case 11:
		return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], 0)
	case 12:
		return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])
	case 13:
		return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], 0, 0)
	case 14:
		return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], 0)
	case 15:
		return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14])
	default:
		panic("Call " + p.Name + " with too many arguments " + itoa(len(a)) + ".")
	}
}

// A LazyDLL implements access to a single DLL.
// It will delay the load of the DLL until the first
// call to its Handle method or to one of its
// LazyProc's Addr method.
type LazyDLL struct {
	Name string

	// System determines whether the DLL must be loaded from the
	// Windows System directory, bypassing the normal DLL search
	// path.
	System bool

	mu  sync.Mutex
	dll *DLL // non nil once DLL is loaded
}

// Load loads DLL file d.Name into memory. It returns an error if fails.
// Load will not try to load DLL, if it is already loaded into memory.
func (d *LazyDLL) Load() error {
	// Non-racy version of:
	// if d.dll != nil {
	if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll))) != nil {
		return nil
	}
	d.mu.Lock()
	defer d.mu.Unlock()
	if d.dll != nil {
		return nil
	}

	// kernel32.dll is special, since it's where LoadLibraryEx comes from.
	// The kernel already special-cases its name, so it's always
	// loaded from system32.
	var dll *DLL
	var err error
	if d.Name == "kernel32.dll" {
		dll, err = LoadDLL(d.Name)
	} else {
		dll, err = loadLibraryEx(d.Name, d.System)
	}
	if err != nil {
		return err
	}

	// Non-racy version of:
	// d.dll = dll
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll)), unsafe.Pointer(dll))
	return nil
}

// mustLoad is like Load but panics if search fails.
func (d *LazyDLL) mustLoad() {
	e := d.Load()
	if e != nil {
		panic(e)
	}
}

// Handle returns d's module handle.
func (d *LazyDLL) Handle() uintptr {
	d.mustLoad()
	return uintptr(d.dll.Handle)
}

// NewProc returns a LazyProc for accessing the named procedure in the DLL d.
func (d *LazyDLL) NewProc(name string) *LazyProc {
	return &LazyProc{l: d, Name: name}
}

// NewLazyDLL creates new LazyDLL associated with DLL file.
func NewLazyDLL(name string) *LazyDLL {
	return &LazyDLL{Name: name}
}

// NewLazySystemDLL is like NewLazyDLL, but will only
// search Windows System directory for the DLL if name is
// a base name (like "advapi32.dll").
func NewLazySystemDLL(name string) *LazyDLL {
	return &LazyDLL{Name: name, System: true}
}

// A LazyProc implements access to a procedure inside a LazyDLL.
// It delays the lookup until the Addr method is called.
type LazyProc struct {
	Name string

	mu   sync.Mutex
	l    *LazyDLL
	proc *Proc
}

// Find searches DLL for procedure named p.Name. It returns
// an error if search fails. Find will not search procedure,
// if it is already found and loaded into memory.
func (p *LazyProc) Find() error {
	// Non-racy version of:
	// if p.proc == nil {
	if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil {
		p.mu.Lock()
		defer p.mu.Unlock()
		if p.proc == nil {
			e := p.l.Load()
			if e != nil {
				return e
			}
			proc, e := p.l.dll.FindProc(p.Name)
			if e != nil {
				return e
			}
			// Non-racy version of:
			// p.proc = proc
			atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))
		}
	}
	return nil
}

// mustFind is like Find but panics if search fails.
func (p *LazyProc) mustFind() {
	e := p.Find()
	if e != nil {
		panic(e)
	}
}

// Addr returns the address of the procedure represented by p.
// The return value can be passed to Syscall to run the procedure.
// It will panic if the procedure cannot be found.
func (p *LazyProc) Addr() uintptr {
	p.mustFind()
	return p.proc.Addr()
}

//go:uintptrescapes

// Call executes procedure p with arguments a. It will panic, if more than 15 arguments
// are supplied. It will also panic if the procedure cannot be found.
//
// The returned error is always non-nil, constructed from the result of GetLastError.
// Callers must inspect the primary return value to decide whether an error occurred
// (according to the semantics of the specific function being called) before consulting
// the error. The error will be guaranteed to contain windows.Errno.
func (p *LazyProc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {
	p.mustFind()
	return p.proc.Call(a...)
}

var canDoSearchSystem32Once struct {
	sync.Once
	v bool
}

func initCanDoSearchSystem32() {
	// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
	// "Windows 7, Windows Server 2008 R2, Windows Vista, and Windows
	// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
	// systems that have KB2533623 installed. To determine whether the
	// flags are available, use GetProcAddress to get the address of the
	// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories
	// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*
	// flags can be used with LoadLibraryEx."
	canDoSearchSystem32Once.v = (modkernel32.NewProc("AddDllDirectory").Find() == nil)
}

func canDoSearchSystem32() bool {
	canDoSearchSystem32Once.Do(initCanDoSearchSystem32)
	return canDoSearchSystem32Once.v
}

func isBaseName(name string) bool {
	for _, c := range name {
		if c == ':' || c == '/' || c == '\\' {
			return false
		}
	}
	return true
}

// loadLibraryEx wraps the Windows LoadLibraryEx function.
//
// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx
//
// If name is not an absolute path, LoadLibraryEx searches for the DLL
// in a variety of automatic locations unless constrained by flags.
// See: https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx
func loadLibraryEx(name string, system bool) (*DLL, error) {
	loadDLL := name
	var flags uintptr
	if system {
		if canDoSearchSystem32() {
			const LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
			flags = LOAD_LIBRARY_SEARCH_SYSTEM32
		} else if isBaseName(name) {
			// WindowsXP or unpatched Windows machine
			// trying to load "foo.dll" out of the system
			// folder, but LoadLibraryEx doesn't support
			// that yet on their system, so emulate it.
			systemdir, err := GetSystemDirectory()
			if err != nil {
				return nil, err
			}
			loadDLL = systemdir + "\\" + name
		}
	}
	h, err := LoadLibraryEx(loadDLL, 0, flags)
	if err != nil {
		return nil, err
	}
	return &DLL{Name: name, Handle: h}, nil
}

type errString string

func (s errString) Error() string { return string(s) }

+ f 5975f1c94dad8747a68ec8f25132a881c75767037383d6ccf7f71482027df255 vendor/golang.org/x/sys/windows/empty.s
utf8file 9
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !go1.12

// This file is here to allow bodyless functions with go:linkname for Go 1.11
// and earlier (see https://golang.org/issue/23311).

+ f eba35571ac6a9dd1e2f663aafb4dc0315a01056f7d6eac2586cd89949ea82b2b vendor/golang.org/x/sys/windows/env_windows.go
utf8file 62
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Windows environment variables.

package windows

import (
	"syscall"
	"unicode/utf16"
	"unsafe"
)

func Getenv(key string) (value string, found bool) {
	return syscall.Getenv(key)
}

func Setenv(key, value string) error {
	return syscall.Setenv(key, value)
}

func Clearenv() {
	syscall.Clearenv()
}

func Environ() []string {
	return syscall.Environ()
}

// Returns a default environment associated with the token, rather than the current
// process. If inheritExisting is true, then this environment also inherits the
// environment of the current process.
func (token Token) Environ(inheritExisting bool) (env []string, err error) {
	var block *uint16
	err = CreateEnvironmentBlock(&block, token, inheritExisting)
	if err != nil {
		return nil, err
	}
	defer DestroyEnvironmentBlock(block)
	blockp := uintptr(unsafe.Pointer(block))
	for {
		entry := (*[(1 << 30) - 1]uint16)(unsafe.Pointer(blockp))[:]
		for i, v := range entry {
			if v == 0 {
				entry = entry[:i]
				break
			}
		}
		if len(entry) == 0 {
			break
		}
		env = append(env, string(utf16.Decode(entry)))
		blockp += 2 * (uintptr(len(entry)) + 1)
	}
	return env, nil
}

func Unsetenv(key string) error {
	return syscall.Unsetenv(key)
}

+ f 36e6102d274d20dbb5f740376453bb6ab13e02c86e2be706857a07a236b5682e vendor/golang.org/x/sys/windows/eventlog.go
utf8file 21
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows

package windows

const (
	EVENTLOG_SUCCESS          = 0
	EVENTLOG_ERROR_TYPE       = 1
	EVENTLOG_WARNING_TYPE     = 2
	EVENTLOG_INFORMATION_TYPE = 4
	EVENTLOG_AUDIT_SUCCESS    = 8
	EVENTLOG_AUDIT_FAILURE    = 16
)

//sys	RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) [failretval==0] = advapi32.RegisterEventSourceW
//sys	DeregisterEventSource(handle Handle) (err error) = advapi32.DeregisterEventSource
//sys	ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) = advapi32.ReportEventW

+ f fd58dc33d892badcfd5238722dbaa3b71b0d5e3ffa7a23b36015037530d56146 vendor/golang.org/x/sys/windows/exec_windows.go
utf8file 98
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Fork, exec, wait, etc.

package windows

// EscapeArg rewrites command line argument s as prescribed
// in http://msdn.microsoft.com/en-us/library/ms880421.
// This function returns "" (2 double quotes) if s is empty.
// Alternatively, these transformations are done:
// - every back slash (\) is doubled, but only if immediately
//   followed by double quote (");
// - every double quote (") is escaped by back slash (\);
// - finally, s is wrapped with double quotes (arg -> "arg"),
//   but only if there is space or tab inside s.
func EscapeArg(s string) string {
	if len(s) == 0 {
		return "\"\""
	}
	n := len(s)
	hasSpace := false
	for i := 0; i < len(s); i++ {
		switch s[i] {
		case '"', '\\':
			n++
		case ' ', '\t':
			hasSpace = true
		}
	}
	if hasSpace {
		n += 2
	}
	if n == len(s) {
		return s
	}

	qs := make([]byte, n)
	j := 0
	if hasSpace {
		qs[j] = '"'
		j++
	}
	slashes := 0
	for i := 0; i < len(s); i++ {
		switch s[i] {
		default:
			slashes = 0
			qs[j] = s[i]
		case '\\':
			slashes++
			qs[j] = s[i]
		case '"':
			for ; slashes > 0; slashes-- {
				qs[j] = '\\'
				j++
			}
			qs[j] = '\\'
			j++
			qs[j] = s[i]
		}
		j++
	}
	if hasSpace {
		for ; slashes > 0; slashes-- {
			qs[j] = '\\'
			j++
		}
		qs[j] = '"'
		j++
	}
	return string(qs[:j])
}

func CloseOnExec(fd Handle) {
	SetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)
}

// FullPath retrieves the full path of the specified file.
func FullPath(name string) (path string, err error) {
	p, err := UTF16PtrFromString(name)
	if err != nil {
		return "", err
	}
	n := uint32(100)
	for {
		buf := make([]uint16, n)
		n, err = GetFullPathName(p, uint32(len(buf)), &buf[0], nil)
		if err != nil {
			return "", err
		}
		if n <= uint32(len(buf)) {
			return UTF16ToString(buf[:n]), nil
		}
	}
}

+ f 218c056f2c289808308ecd2d6e0afd987c1c001e0e75410a4ef23470459681d9 vendor/golang.org/x/sys/windows/memory_windows.go
utf8file 27
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

const (
	MEM_COMMIT      = 0x00001000
	MEM_RESERVE     = 0x00002000
	MEM_DECOMMIT    = 0x00004000
	MEM_RELEASE     = 0x00008000
	MEM_RESET       = 0x00080000
	MEM_TOP_DOWN    = 0x00100000
	MEM_WRITE_WATCH = 0x00200000
	MEM_PHYSICAL    = 0x00400000
	MEM_RESET_UNDO  = 0x01000000
	MEM_LARGE_PAGES = 0x20000000

	PAGE_NOACCESS          = 0x01
	PAGE_READONLY          = 0x02
	PAGE_READWRITE         = 0x04
	PAGE_WRITECOPY         = 0x08
	PAGE_EXECUTE_READ      = 0x20
	PAGE_EXECUTE_READWRITE = 0x40
	PAGE_EXECUTE_WRITECOPY = 0x80
)

+ f 804b6eb1e92950f9581554dbc9ac86bd6e8ee9230d5cec1610c8990b2ec7cf0c vendor/golang.org/x/sys/windows/mkerrors.bash
utf8file 64
#!/bin/bash

# Copyright 2019 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

set -e
shopt -s nullglob

winerror="$(printf '%s\n' "/mnt/c/Program Files (x86)/Windows Kits/"/*/Include/*/shared/winerror.h | sort -Vr | head -n 1)"
[[ -n $winerror ]] || { echo "Unable to find winerror.h" >&2; exit 1; }

declare -A errors

{
	echo "// Code generated by 'mkerrors.bash'; DO NOT EDIT."
	echo
	echo "package windows"
	echo "import \"syscall\""
	echo "const ("

	while read -r line; do
		unset vtype
		if [[ $line =~ ^#define\ +([A-Z0-9_]+k?)\ +([A-Z0-9_]+\()?([A-Z][A-Z0-9_]+k?)\)? ]]; then
			key="${BASH_REMATCH[1]}"
			value="${BASH_REMATCH[3]}"
		elif [[ $line =~ ^#define\ +([A-Z0-9_]+k?)\ +([A-Z0-9_]+\()?((0x)?[0-9A-Fa-f]+)L?\)? ]]; then
			key="${BASH_REMATCH[1]}"
			value="${BASH_REMATCH[3]}"
			vtype="${BASH_REMATCH[2]}"
		elif [[ $line =~ ^#define\ +([A-Z0-9_]+k?)\ +\(\(([A-Z]+)\)((0x)?[0-9A-Fa-f]+)L?\) ]]; then
			key="${BASH_REMATCH[1]}"
			value="${BASH_REMATCH[3]}"
			vtype="${BASH_REMATCH[2]}"
		else
			continue
		fi
		[[ -n $key && -n $value ]] || continue
		[[ -z ${errors["$key"]} ]] || continue
		errors["$key"]="$value"
		if [[ -v vtype ]]; then
			if [[ $key == FACILITY_* || $key == NO_ERROR ]]; then
				vtype=""
			elif [[ $vtype == *HANDLE* || $vtype == *HRESULT* ]]; then
				vtype="Handle"
			else
				vtype="syscall.Errno"
			fi
			last_vtype="$vtype"
		else
			vtype=""
			if [[ $last_vtype == Handle && $value == NO_ERROR ]]; then
				value="S_OK"
			elif [[ $last_vtype == syscall.Errno && $value == NO_ERROR ]]; then
				value="ERROR_SUCCESS"
			fi
		fi

		echo "$key $vtype = $value"
	done < "$winerror"

	echo ")"
} | gofmt > "zerrors_windows.go"

+ f 3b7f6ac42ae1e73aa8d06d4f89f18b91916f153b030e9c01e15d41959b6b5fc6 vendor/golang.org/x/sys/windows/mkknownfolderids.bash
utf8file 28
#!/bin/bash

# Copyright 2019 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

set -e
shopt -s nullglob

knownfolders="$(printf '%s\n' "/mnt/c/Program Files (x86)/Windows Kits/"/*/Include/*/um/KnownFolders.h | sort -Vr | head -n 1)"
[[ -n $knownfolders ]] || { echo "Unable to find KnownFolders.h" >&2; exit 1; }

{
	echo "// Code generated by 'mkknownfolderids.bash'; DO NOT EDIT."
	echo
	echo "package windows"
	echo "type KNOWNFOLDERID GUID"
	echo "var ("
	while read -r line; do
		[[ $line =~ DEFINE_KNOWN_FOLDER\((FOLDERID_[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+),[\t\ ]*(0x[^,]+)\) ]] || continue
		printf "%s = &KNOWNFOLDERID{0x%08x, 0x%04x, 0x%04x, [8]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x}}\n" \
			"${BASH_REMATCH[1]}" $(( "${BASH_REMATCH[2]}" )) $(( "${BASH_REMATCH[3]}" )) $(( "${BASH_REMATCH[4]}" )) \
			$(( "${BASH_REMATCH[5]}" )) $(( "${BASH_REMATCH[6]}" )) $(( "${BASH_REMATCH[7]}" )) $(( "${BASH_REMATCH[8]}" )) \
			$(( "${BASH_REMATCH[9]}" )) $(( "${BASH_REMATCH[10]}" )) $(( "${BASH_REMATCH[11]}" )) $(( "${BASH_REMATCH[12]}" ))
	done < "$knownfolders"
	echo ")"
} | gofmt > "zknownfolderids_windows.go"

+ f 75e3e06901fe36bbfbbf63c7ae085cc90e2db6a0181042e852e4f31c31471574 vendor/golang.org/x/sys/windows/mksyscall.go
utf8file 10
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build generate

package windows

//go:generate go run golang.org/x/sys/windows/mkwinsyscall -output zsyscall_windows.go eventlog.go service.go syscall_windows.go security_windows.go

+ f 42c5afa9e5a630f46ed19d1f86ed902e0d6502413b42cf641d7ef703c0c2db6a vendor/golang.org/x/sys/windows/race.go
utf8file 31
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows,race

package windows

import (
	"runtime"
	"unsafe"
)

const raceenabled = true

func raceAcquire(addr unsafe.Pointer) {
	runtime.RaceAcquire(addr)
}

func raceReleaseMerge(addr unsafe.Pointer) {
	runtime.RaceReleaseMerge(addr)
}

func raceReadRange(addr unsafe.Pointer, len int) {
	runtime.RaceReadRange(addr, len)
}

func raceWriteRange(addr unsafe.Pointer, len int) {
	runtime.RaceWriteRange(addr, len)
}

+ f f483ad20eef4aedcabc598060fa414eab96f19e3391d1d65d9aec420d64ffd9d vendor/golang.org/x/sys/windows/race0.go
utf8file 26
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows,!race

package windows

import (
	"unsafe"
)

const raceenabled = false

func raceAcquire(addr unsafe.Pointer) {
}

func raceReleaseMerge(addr unsafe.Pointer) {
}

func raceReadRange(addr unsafe.Pointer, len int) {
}

func raceWriteRange(addr unsafe.Pointer, len int) {
}

+ f e9e980018532b2862301bfef193659485c2986304314e15188dc32a32bf4cbc2 vendor/golang.org/x/sys/windows/security_windows.go
utf8file 1397
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

import (
	"syscall"
	"unsafe"
)

const (
	NameUnknown          = 0
	NameFullyQualifiedDN = 1
	NameSamCompatible    = 2
	NameDisplay          = 3
	NameUniqueId         = 6
	NameCanonical        = 7
	NameUserPrincipal    = 8
	NameCanonicalEx      = 9
	NameServicePrincipal = 10
	NameDnsDomain        = 12
)

// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx
//sys	TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.TranslateNameW
//sys	GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.GetUserNameExW

// TranslateAccountName converts a directory service
// object name from one format to another.
func TranslateAccountName(username string, from, to uint32, initSize int) (string, error) {
	u, e := UTF16PtrFromString(username)
	if e != nil {
		return "", e
	}
	n := uint32(50)
	for {
		b := make([]uint16, n)
		e = TranslateName(u, from, to, &b[0], &n)
		if e == nil {
			return UTF16ToString(b[:n]), nil
		}
		if e != ERROR_INSUFFICIENT_BUFFER {
			return "", e
		}
		if n <= uint32(len(b)) {
			return "", e
		}
	}
}

const (
	// do not reorder
	NetSetupUnknownStatus = iota
	NetSetupUnjoined
	NetSetupWorkgroupName
	NetSetupDomainName
)

type UserInfo10 struct {
	Name       *uint16
	Comment    *uint16
	UsrComment *uint16
	FullName   *uint16
}

//sys	NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) = netapi32.NetUserGetInfo
//sys	NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) = netapi32.NetGetJoinInformation
//sys	NetApiBufferFree(buf *byte) (neterr error) = netapi32.NetApiBufferFree

const (
	// do not reorder
	SidTypeUser = 1 + iota
	SidTypeGroup
	SidTypeDomain
	SidTypeAlias
	SidTypeWellKnownGroup
	SidTypeDeletedAccount
	SidTypeInvalid
	SidTypeUnknown
	SidTypeComputer
	SidTypeLabel
)

type SidIdentifierAuthority struct {
	Value [6]byte
}

var (
	SECURITY_NULL_SID_AUTHORITY        = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 0}}
	SECURITY_WORLD_SID_AUTHORITY       = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 1}}
	SECURITY_LOCAL_SID_AUTHORITY       = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 2}}
	SECURITY_CREATOR_SID_AUTHORITY     = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 3}}
	SECURITY_NON_UNIQUE_AUTHORITY      = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 4}}
	SECURITY_NT_AUTHORITY              = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 5}}
	SECURITY_MANDATORY_LABEL_AUTHORITY = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 16}}
)

const (
	SECURITY_NULL_RID                   = 0
	SECURITY_WORLD_RID                  = 0
	SECURITY_LOCAL_RID                  = 0
	SECURITY_CREATOR_OWNER_RID          = 0
	SECURITY_CREATOR_GROUP_RID          = 1
	SECURITY_DIALUP_RID                 = 1
	SECURITY_NETWORK_RID                = 2
	SECURITY_BATCH_RID                  = 3
	SECURITY_INTERACTIVE_RID            = 4
	SECURITY_LOGON_IDS_RID              = 5
	SECURITY_SERVICE_RID                = 6
	SECURITY_LOCAL_SYSTEM_RID           = 18
	SECURITY_BUILTIN_DOMAIN_RID         = 32
	SECURITY_PRINCIPAL_SELF_RID         = 10
	SECURITY_CREATOR_OWNER_SERVER_RID   = 0x2
	SECURITY_CREATOR_GROUP_SERVER_RID   = 0x3
	SECURITY_LOGON_IDS_RID_COUNT        = 0x3
	SECURITY_ANONYMOUS_LOGON_RID        = 0x7
	SECURITY_PROXY_RID                  = 0x8
	SECURITY_ENTERPRISE_CONTROLLERS_RID = 0x9
	SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID
	SECURITY_AUTHENTICATED_USER_RID     = 0xb
	SECURITY_RESTRICTED_CODE_RID        = 0xc
	SECURITY_NT_NON_UNIQUE_RID          = 0x15
)

// Predefined domain-relative RIDs for local groups.
// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa379649(v=vs.85).aspx
const (
	DOMAIN_ALIAS_RID_ADMINS                         = 0x220
	DOMAIN_ALIAS_RID_USERS                          = 0x221
	DOMAIN_ALIAS_RID_GUESTS                         = 0x222
	DOMAIN_ALIAS_RID_POWER_USERS                    = 0x223
	DOMAIN_ALIAS_RID_ACCOUNT_OPS                    = 0x224
	DOMAIN_ALIAS_RID_SYSTEM_OPS                     = 0x225
	DOMAIN_ALIAS_RID_PRINT_OPS                      = 0x226
	DOMAIN_ALIAS_RID_BACKUP_OPS                     = 0x227
	DOMAIN_ALIAS_RID_REPLICATOR                     = 0x228
	DOMAIN_ALIAS_RID_RAS_SERVERS                    = 0x229
	DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               = 0x22a
	DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           = 0x22b
	DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      = 0x22c
	DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = 0x22d
	DOMAIN_ALIAS_RID_MONITORING_USERS               = 0x22e
	DOMAIN_ALIAS_RID_LOGGING_USERS                  = 0x22f
	DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            = 0x230
	DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             = 0x231
	DOMAIN_ALIAS_RID_DCOM_USERS                     = 0x232
	DOMAIN_ALIAS_RID_IUSERS                         = 0x238
	DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               = 0x239
	DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     = 0x23b
	DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = 0x23c
	DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        = 0x23d
	DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      = 0x23e
)

//sys	LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW
//sys	LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW
//sys	ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW
//sys	ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW
//sys	GetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid
//sys	CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) = advapi32.CopySid
//sys	AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) = advapi32.AllocateAndInitializeSid
//sys	createWellKnownSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID, sid *SID, sizeSid *uint32) (err error) = advapi32.CreateWellKnownSid
//sys	isWellKnownSid(sid *SID, sidType WELL_KNOWN_SID_TYPE) (isWellKnown bool) = advapi32.IsWellKnownSid
//sys	FreeSid(sid *SID) (err error) [failretval!=0] = advapi32.FreeSid
//sys	EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) = advapi32.EqualSid
//sys	getSidIdentifierAuthority(sid *SID) (authority *SidIdentifierAuthority) = advapi32.GetSidIdentifierAuthority
//sys	getSidSubAuthorityCount(sid *SID) (count *uint8) = advapi32.GetSidSubAuthorityCount
//sys	getSidSubAuthority(sid *SID, index uint32) (subAuthority *uint32) = advapi32.GetSidSubAuthority
//sys	isValidSid(sid *SID) (isValid bool) = advapi32.IsValidSid

// The security identifier (SID) structure is a variable-length
// structure used to uniquely identify users or groups.
type SID struct{}

// StringToSid converts a string-format security identifier
// SID into a valid, functional SID.
func StringToSid(s string) (*SID, error) {
	var sid *SID
	p, e := UTF16PtrFromString(s)
	if e != nil {
		return nil, e
	}
	e = ConvertStringSidToSid(p, &sid)
	if e != nil {
		return nil, e
	}
	defer LocalFree((Handle)(unsafe.Pointer(sid)))
	return sid.Copy()
}

// LookupSID retrieves a security identifier SID for the account
// and the name of the domain on which the account was found.
// System specify target computer to search.
func LookupSID(system, account string) (sid *SID, domain string, accType uint32, err error) {
	if len(account) == 0 {
		return nil, "", 0, syscall.EINVAL
	}
	acc, e := UTF16PtrFromString(account)
	if e != nil {
		return nil, "", 0, e
	}
	var sys *uint16
	if len(system) > 0 {
		sys, e = UTF16PtrFromString(system)
		if e != nil {
			return nil, "", 0, e
		}
	}
	n := uint32(50)
	dn := uint32(50)
	for {
		b := make([]byte, n)
		db := make([]uint16, dn)
		sid = (*SID)(unsafe.Pointer(&b[0]))
		e = LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)
		if e == nil {
			return sid, UTF16ToString(db), accType, nil
		}
		if e != ERROR_INSUFFICIENT_BUFFER {
			return nil, "", 0, e
		}
		if n <= uint32(len(b)) {
			return nil, "", 0, e
		}
	}
}

// String converts SID to a string format suitable for display, storage, or transmission.
func (sid *SID) String() string {
	var s *uint16
	e := ConvertSidToStringSid(sid, &s)
	if e != nil {
		return ""
	}
	defer LocalFree((Handle)(unsafe.Pointer(s)))
	return UTF16ToString((*[256]uint16)(unsafe.Pointer(s))[:])
}

// Len returns the length, in bytes, of a valid security identifier SID.
func (sid *SID) Len() int {
	return int(GetLengthSid(sid))
}

// Copy creates a duplicate of security identifier SID.
func (sid *SID) Copy() (*SID, error) {
	b := make([]byte, sid.Len())
	sid2 := (*SID)(unsafe.Pointer(&b[0]))
	e := CopySid(uint32(len(b)), sid2, sid)
	if e != nil {
		return nil, e
	}
	return sid2, nil
}

// IdentifierAuthority returns the identifier authority of the SID.
func (sid *SID) IdentifierAuthority() SidIdentifierAuthority {
	return *getSidIdentifierAuthority(sid)
}

// SubAuthorityCount returns the number of sub-authorities in the SID.
func (sid *SID) SubAuthorityCount() uint8 {
	return *getSidSubAuthorityCount(sid)
}

// SubAuthority returns the sub-authority of the SID as specified by
// the index, which must be less than sid.SubAuthorityCount().
func (sid *SID) SubAuthority(idx uint32) uint32 {
	if idx >= uint32(sid.SubAuthorityCount()) {
		panic("sub-authority index out of range")
	}
	return *getSidSubAuthority(sid, idx)
}

// IsValid returns whether the SID has a valid revision and length.
func (sid *SID) IsValid() bool {
	return isValidSid(sid)
}

// Equals compares two SIDs for equality.
func (sid *SID) Equals(sid2 *SID) bool {
	return EqualSid(sid, sid2)
}

// IsWellKnown determines whether the SID matches the well-known sidType.
func (sid *SID) IsWellKnown(sidType WELL_KNOWN_SID_TYPE) bool {
	return isWellKnownSid(sid, sidType)
}

// LookupAccount retrieves the name of the account for this SID
// and the name of the first domain on which this SID is found.
// System specify target computer to search for.
func (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) {
	var sys *uint16
	if len(system) > 0 {
		sys, err = UTF16PtrFromString(system)
		if err != nil {
			return "", "", 0, err
		}
	}
	n := uint32(50)
	dn := uint32(50)
	for {
		b := make([]uint16, n)
		db := make([]uint16, dn)
		e := LookupAccountSid(sys, sid, &b[0], &n, &db[0], &dn, &accType)
		if e == nil {
			return UTF16ToString(b), UTF16ToString(db), accType, nil
		}
		if e != ERROR_INSUFFICIENT_BUFFER {
			return "", "", 0, e
		}
		if n <= uint32(len(b)) {
			return "", "", 0, e
		}
	}
}

// Various types of pre-specified SIDs that can be synthesized and compared at runtime.
type WELL_KNOWN_SID_TYPE uint32

const (
	WinNullSid                                    = 0
	WinWorldSid                                   = 1
	WinLocalSid                                   = 2
	WinCreatorOwnerSid                            = 3
	WinCreatorGroupSid                            = 4
	WinCreatorOwnerServerSid                      = 5
	WinCreatorGroupServerSid                      = 6
	WinNtAuthoritySid                             = 7
	WinDialupSid                                  = 8
	WinNetworkSid                                 = 9
	WinBatchSid                                   = 10
	WinInteractiveSid                             = 11
	WinServiceSid                                 = 12
	WinAnonymousSid                               = 13
	WinProxySid                                   = 14
	WinEnterpriseControllersSid                   = 15
	WinSelfSid                                    = 16
	WinAuthenticatedUserSid                       = 17
	WinRestrictedCodeSid                          = 18
	WinTerminalServerSid                          = 19
	WinRemoteLogonIdSid                           = 20
	WinLogonIdsSid                                = 21
	WinLocalSystemSid                             = 22
	WinLocalServiceSid                            = 23
	WinNetworkServiceSid                          = 24
	WinBuiltinDomainSid                           = 25
	WinBuiltinAdministratorsSid                   = 26
	WinBuiltinUsersSid                            = 27
	WinBuiltinGuestsSid                           = 28
	WinBuiltinPowerUsersSid                       = 29
	WinBuiltinAccountOperatorsSid                 = 30
	WinBuiltinSystemOperatorsSid                  = 31
	WinBuiltinPrintOperatorsSid                   = 32
	WinBuiltinBackupOperatorsSid                  = 33
	WinBuiltinReplicatorSid                       = 34
	WinBuiltinPreWindows2000CompatibleAccessSid   = 35
	WinBuiltinRemoteDesktopUsersSid               = 36
	WinBuiltinNetworkConfigurationOperatorsSid    = 37
	WinAccountAdministratorSid                    = 38
	WinAccountGuestSid                            = 39
	WinAccountKrbtgtSid                           = 40
	WinAccountDomainAdminsSid                     = 41
	WinAccountDomainUsersSid                      = 42
	WinAccountDomainGuestsSid                     = 43
	WinAccountComputersSid                        = 44
	WinAccountControllersSid                      = 45
	WinAccountCertAdminsSid                       = 46
	WinAccountSchemaAdminsSid                     = 47
	WinAccountEnterpriseAdminsSid                 = 48
	WinAccountPolicyAdminsSid                     = 49
	WinAccountRasAndIasServersSid                 = 50
	WinNTLMAuthenticationSid                      = 51
	WinDigestAuthenticationSid                    = 52
	WinSChannelAuthenticationSid                  = 53
	WinThisOrganizationSid                        = 54
	WinOtherOrganizationSid                       = 55
	WinBuiltinIncomingForestTrustBuildersSid      = 56
	WinBuiltinPerfMonitoringUsersSid              = 57
	WinBuiltinPerfLoggingUsersSid                 = 58
	WinBuiltinAuthorizationAccessSid              = 59
	WinBuiltinTerminalServerLicenseServersSid     = 60
	WinBuiltinDCOMUsersSid                        = 61
	WinBuiltinIUsersSid                           = 62
	WinIUserSid                                   = 63
	WinBuiltinCryptoOperatorsSid                  = 64
	WinUntrustedLabelSid                          = 65
	WinLowLabelSid                                = 66
	WinMediumLabelSid                             = 67
	WinHighLabelSid                               = 68
	WinSystemLabelSid                             = 69
	WinWriteRestrictedCodeSid                     = 70
	WinCreatorOwnerRightsSid                      = 71
	WinCacheablePrincipalsGroupSid                = 72
	WinNonCacheablePrincipalsGroupSid             = 73
	WinEnterpriseReadonlyControllersSid           = 74
	WinAccountReadonlyControllersSid              = 75
	WinBuiltinEventLogReadersGroup                = 76
	WinNewEnterpriseReadonlyControllersSid        = 77
	WinBuiltinCertSvcDComAccessGroup              = 78
	WinMediumPlusLabelSid                         = 79
	WinLocalLogonSid                              = 80
	WinConsoleLogonSid                            = 81
	WinThisOrganizationCertificateSid             = 82
	WinApplicationPackageAuthoritySid             = 83
	WinBuiltinAnyPackageSid                       = 84
	WinCapabilityInternetClientSid                = 85
	WinCapabilityInternetClientServerSid          = 86
	WinCapabilityPrivateNetworkClientServerSid    = 87
	WinCapabilityPicturesLibrarySid               = 88
	WinCapabilityVideosLibrarySid                 = 89
	WinCapabilityMusicLibrarySid                  = 90
	WinCapabilityDocumentsLibrarySid              = 91
	WinCapabilitySharedUserCertificatesSid        = 92
	WinCapabilityEnterpriseAuthenticationSid      = 93
	WinCapabilityRemovableStorageSid              = 94
	WinBuiltinRDSRemoteAccessServersSid           = 95
	WinBuiltinRDSEndpointServersSid               = 96
	WinBuiltinRDSManagementServersSid             = 97
	WinUserModeDriversSid                         = 98
	WinBuiltinHyperVAdminsSid                     = 99
	WinAccountCloneableControllersSid             = 100
	WinBuiltinAccessControlAssistanceOperatorsSid = 101
	WinBuiltinRemoteManagementUsersSid            = 102
	WinAuthenticationAuthorityAssertedSid         = 103
	WinAuthenticationServiceAssertedSid           = 104
	WinLocalAccountSid                            = 105
	WinLocalAccountAndAdministratorSid            = 106
	WinAccountProtectedUsersSid                   = 107
	WinCapabilityAppointmentsSid                  = 108
	WinCapabilityContactsSid                      = 109
	WinAccountDefaultSystemManagedSid             = 110
	WinBuiltinDefaultSystemManagedGroupSid        = 111
	WinBuiltinStorageReplicaAdminsSid             = 112
	WinAccountKeyAdminsSid                        = 113
	WinAccountEnterpriseKeyAdminsSid              = 114
	WinAuthenticationKeyTrustSid                  = 115
	WinAuthenticationKeyPropertyMFASid            = 116
	WinAuthenticationKeyPropertyAttestationSid    = 117
	WinAuthenticationFreshKeyAuthSid              = 118
	WinBuiltinDeviceOwnersSid                     = 119
)

// Creates a SID for a well-known predefined alias, generally using the constants of the form
// Win*Sid, for the local machine.
func CreateWellKnownSid(sidType WELL_KNOWN_SID_TYPE) (*SID, error) {
	return CreateWellKnownDomainSid(sidType, nil)
}

// Creates a SID for a well-known predefined alias, generally using the constants of the form
// Win*Sid, for the domain specified by the domainSid parameter.
func CreateWellKnownDomainSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID) (*SID, error) {
	n := uint32(50)
	for {
		b := make([]byte, n)
		sid := (*SID)(unsafe.Pointer(&b[0]))
		err := createWellKnownSid(sidType, domainSid, sid, &n)
		if err == nil {
			return sid, nil
		}
		if err != ERROR_INSUFFICIENT_BUFFER {
			return nil, err
		}
		if n <= uint32(len(b)) {
			return nil, err
		}
	}
}

const (
	// do not reorder
	TOKEN_ASSIGN_PRIMARY = 1 << iota
	TOKEN_DUPLICATE
	TOKEN_IMPERSONATE
	TOKEN_QUERY
	TOKEN_QUERY_SOURCE
	TOKEN_ADJUST_PRIVILEGES
	TOKEN_ADJUST_GROUPS
	TOKEN_ADJUST_DEFAULT
	TOKEN_ADJUST_SESSIONID

	TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |
		TOKEN_ASSIGN_PRIMARY |
		TOKEN_DUPLICATE |
		TOKEN_IMPERSONATE |
		TOKEN_QUERY |
		TOKEN_QUERY_SOURCE |
		TOKEN_ADJUST_PRIVILEGES |
		TOKEN_ADJUST_GROUPS |
		TOKEN_ADJUST_DEFAULT |
		TOKEN_ADJUST_SESSIONID
	TOKEN_READ  = STANDARD_RIGHTS_READ | TOKEN_QUERY
	TOKEN_WRITE = STANDARD_RIGHTS_WRITE |
		TOKEN_ADJUST_PRIVILEGES |
		TOKEN_ADJUST_GROUPS |
		TOKEN_ADJUST_DEFAULT
	TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE
)

const (
	// do not reorder
	TokenUser = 1 + iota
	TokenGroups
	TokenPrivileges
	TokenOwner
	TokenPrimaryGroup
	TokenDefaultDacl
	TokenSource
	TokenType
	TokenImpersonationLevel
	TokenStatistics
	TokenRestrictedSids
	TokenSessionId
	TokenGroupsAndPrivileges
	TokenSessionReference
	TokenSandBoxInert
	TokenAuditPolicy
	TokenOrigin
	TokenElevationType
	TokenLinkedToken
	TokenElevation
	TokenHasRestrictions
	TokenAccessInformation
	TokenVirtualizationAllowed
	TokenVirtualizationEnabled
	TokenIntegrityLevel
	TokenUIAccess
	TokenMandatoryPolicy
	TokenLogonSid
	MaxTokenInfoClass
)

// Group attributes inside of Tokengroups.Groups[i].Attributes
const (
	SE_GROUP_MANDATORY          = 0x00000001
	SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
	SE_GROUP_ENABLED            = 0x00000004
	SE_GROUP_OWNER              = 0x00000008
	SE_GROUP_USE_FOR_DENY_ONLY  = 0x00000010
	SE_GROUP_INTEGRITY          = 0x00000020
	SE_GROUP_INTEGRITY_ENABLED  = 0x00000040
	SE_GROUP_LOGON_ID           = 0xC0000000
	SE_GROUP_RESOURCE           = 0x20000000
	SE_GROUP_VALID_ATTRIBUTES   = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED | SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY | SE_GROUP_LOGON_ID | SE_GROUP_RESOURCE | SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED
)

// Privilege attributes
const (
	SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
	SE_PRIVILEGE_ENABLED            = 0x00000002
	SE_PRIVILEGE_REMOVED            = 0x00000004
	SE_PRIVILEGE_USED_FOR_ACCESS    = 0x80000000
	SE_PRIVILEGE_VALID_ATTRIBUTES   = SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_REMOVED | SE_PRIVILEGE_USED_FOR_ACCESS
)

// Token types
const (
	TokenPrimary       = 1
	TokenImpersonation = 2
)

// Impersonation levels
const (
	SecurityAnonymous      = 0
	SecurityIdentification = 1
	SecurityImpersonation  = 2
	SecurityDelegation     = 3
)

type LUID struct {
	LowPart  uint32
	HighPart int32
}

type LUIDAndAttributes struct {
	Luid       LUID
	Attributes uint32
}

type SIDAndAttributes struct {
	Sid        *SID
	Attributes uint32
}

type Tokenuser struct {
	User SIDAndAttributes
}

type Tokenprimarygroup struct {
	PrimaryGroup *SID
}

type Tokengroups struct {
	GroupCount uint32
	Groups     [1]SIDAndAttributes // Use AllGroups() for iterating.
}

// AllGroups returns a slice that can be used to iterate over the groups in g.
func (g *Tokengroups) AllGroups() []SIDAndAttributes {
	return (*[(1 << 28) - 1]SIDAndAttributes)(unsafe.Pointer(&g.Groups[0]))[:g.GroupCount:g.GroupCount]
}

type Tokenprivileges struct {
	PrivilegeCount uint32
	Privileges     [1]LUIDAndAttributes // Use AllPrivileges() for iterating.
}

// AllPrivileges returns a slice that can be used to iterate over the privileges in p.
func (p *Tokenprivileges) AllPrivileges() []LUIDAndAttributes {
	return (*[(1 << 27) - 1]LUIDAndAttributes)(unsafe.Pointer(&p.Privileges[0]))[:p.PrivilegeCount:p.PrivilegeCount]
}

type Tokenmandatorylabel struct {
	Label SIDAndAttributes
}

func (tml *Tokenmandatorylabel) Size() uint32 {
	return uint32(unsafe.Sizeof(Tokenmandatorylabel{})) + GetLengthSid(tml.Label.Sid)
}

// Authorization Functions
//sys	checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) = advapi32.CheckTokenMembership
//sys	OpenProcessToken(process Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken
//sys	OpenThreadToken(thread Handle, access uint32, openAsSelf bool, token *Token) (err error) = advapi32.OpenThreadToken
//sys	ImpersonateSelf(impersonationlevel uint32) (err error) = advapi32.ImpersonateSelf
//sys	RevertToSelf() (err error) = advapi32.RevertToSelf
//sys	SetThreadToken(thread *Handle, token Token) (err error) = advapi32.SetThreadToken
//sys	LookupPrivilegeValue(systemname *uint16, name *uint16, luid *LUID) (err error) = advapi32.LookupPrivilegeValueW
//sys	AdjustTokenPrivileges(token Token, disableAllPrivileges bool, newstate *Tokenprivileges, buflen uint32, prevstate *Tokenprivileges, returnlen *uint32) (err error) = advapi32.AdjustTokenPrivileges
//sys	AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) = advapi32.AdjustTokenGroups
//sys	GetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation
//sys	SetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32) (err error) = advapi32.SetTokenInformation
//sys	DuplicateTokenEx(existingToken Token, desiredAccess uint32, tokenAttributes *SecurityAttributes, impersonationLevel uint32, tokenType uint32, newToken *Token) (err error) = advapi32.DuplicateTokenEx
//sys	GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW
//sys	getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetSystemDirectoryW
//sys	getWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetWindowsDirectoryW
//sys	getSystemWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetSystemWindowsDirectoryW

// An access token contains the security information for a logon session.
// The system creates an access token when a user logs on, and every
// process executed on behalf of the user has a copy of the token.
// The token identifies the user, the user's groups, and the user's
// privileges. The system uses the token to control access to securable
// objects and to control the ability of the user to perform various
// system-related operations on the local computer.
type Token Handle

// OpenCurrentProcessToken opens an access token associated with current
// process with TOKEN_QUERY access. It is a real token that needs to be closed.
//
// Deprecated: Explicitly call OpenProcessToken(CurrentProcess(), ...)
// with the desired access instead, or use GetCurrentProcessToken for a
// TOKEN_QUERY token.
func OpenCurrentProcessToken() (Token, error) {
	var token Token
	err := OpenProcessToken(CurrentProcess(), TOKEN_QUERY, &token)
	return token, err
}

// GetCurrentProcessToken returns the access token associated with
// the current process. It is a pseudo token that does not need
// to be closed.
func GetCurrentProcessToken() Token {
	return Token(^uintptr(4 - 1))
}

// GetCurrentThreadToken return the access token associated with
// the current thread. It is a pseudo token that does not need
// to be closed.
func GetCurrentThreadToken() Token {
	return Token(^uintptr(5 - 1))
}

// GetCurrentThreadEffectiveToken returns the effective access token
// associated with the current thread. It is a pseudo token that does
// not need to be closed.
func GetCurrentThreadEffectiveToken() Token {
	return Token(^uintptr(6 - 1))
}

// Close releases access to access token.
func (t Token) Close() error {
	return CloseHandle(Handle(t))
}

// getInfo retrieves a specified type of information about an access token.
func (t Token) getInfo(class uint32, initSize int) (unsafe.Pointer, error) {
	n := uint32(initSize)
	for {
		b := make([]byte, n)
		e := GetTokenInformation(t, class, &b[0], uint32(len(b)), &n)
		if e == nil {
			return unsafe.Pointer(&b[0]), nil
		}
		if e != ERROR_INSUFFICIENT_BUFFER {
			return nil, e
		}
		if n <= uint32(len(b)) {
			return nil, e
		}
	}
}

// GetTokenUser retrieves access token t user account information.
func (t Token) GetTokenUser() (*Tokenuser, error) {
	i, e := t.getInfo(TokenUser, 50)
	if e != nil {
		return nil, e
	}
	return (*Tokenuser)(i), nil
}

// GetTokenGroups retrieves group accounts associated with access token t.
func (t Token) GetTokenGroups() (*Tokengroups, error) {
	i, e := t.getInfo(TokenGroups, 50)
	if e != nil {
		return nil, e
	}
	return (*Tokengroups)(i), nil
}

// GetTokenPrimaryGroup retrieves access token t primary group information.
// A pointer to a SID structure representing a group that will become
// the primary group of any objects created by a process using this access token.
func (t Token) GetTokenPrimaryGroup() (*Tokenprimarygroup, error) {
	i, e := t.getInfo(TokenPrimaryGroup, 50)
	if e != nil {
		return nil, e
	}
	return (*Tokenprimarygroup)(i), nil
}

// GetUserProfileDirectory retrieves path to the
// root directory of the access token t user's profile.
func (t Token) GetUserProfileDirectory() (string, error) {
	n := uint32(100)
	for {
		b := make([]uint16, n)
		e := GetUserProfileDirectory(t, &b[0], &n)
		if e == nil {
			return UTF16ToString(b), nil
		}
		if e != ERROR_INSUFFICIENT_BUFFER {
			return "", e
		}
		if n <= uint32(len(b)) {
			return "", e
		}
	}
}

// IsElevated returns whether the current token is elevated from a UAC perspective.
func (token Token) IsElevated() bool {
	var isElevated uint32
	var outLen uint32
	err := GetTokenInformation(token, TokenElevation, (*byte)(unsafe.Pointer(&isElevated)), uint32(unsafe.Sizeof(isElevated)), &outLen)
	if err != nil {
		return false
	}
	return outLen == uint32(unsafe.Sizeof(isElevated)) && isElevated != 0
}

// GetLinkedToken returns the linked token, which may be an elevated UAC token.
func (token Token) GetLinkedToken() (Token, error) {
	var linkedToken Token
	var outLen uint32
	err := GetTokenInformation(token, TokenLinkedToken, (*byte)(unsafe.Pointer(&linkedToken)), uint32(unsafe.Sizeof(linkedToken)), &outLen)
	if err != nil {
		return Token(0), err
	}
	return linkedToken, nil
}

// GetSystemDirectory retrieves the path to current location of the system
// directory, which is typically, though not always, `C:\Windows\System32`.
func GetSystemDirectory() (string, error) {
	n := uint32(MAX_PATH)
	for {
		b := make([]uint16, n)
		l, e := getSystemDirectory(&b[0], n)
		if e != nil {
			return "", e
		}
		if l <= n {
			return UTF16ToString(b[:l]), nil
		}
		n = l
	}
}

// GetWindowsDirectory retrieves the path to current location of the Windows
// directory, which is typically, though not always, `C:\Windows`. This may
// be a private user directory in the case that the application is running
// under a terminal server.
func GetWindowsDirectory() (string, error) {
	n := uint32(MAX_PATH)
	for {
		b := make([]uint16, n)
		l, e := getWindowsDirectory(&b[0], n)
		if e != nil {
			return "", e
		}
		if l <= n {
			return UTF16ToString(b[:l]), nil
		}
		n = l
	}
}

// GetSystemWindowsDirectory retrieves the path to current location of the
// Windows directory, which is typically, though not always, `C:\Windows`.
func GetSystemWindowsDirectory() (string, error) {
	n := uint32(MAX_PATH)
	for {
		b := make([]uint16, n)
		l, e := getSystemWindowsDirectory(&b[0], n)
		if e != nil {
			return "", e
		}
		if l <= n {
			return UTF16ToString(b[:l]), nil
		}
		n = l
	}
}

// IsMember reports whether the access token t is a member of the provided SID.
func (t Token) IsMember(sid *SID) (bool, error) {
	var b int32
	if e := checkTokenMembership(t, sid, &b); e != nil {
		return false, e
	}
	return b != 0, nil
}

const (
	WTS_CONSOLE_CONNECT        = 0x1
	WTS_CONSOLE_DISCONNECT     = 0x2
	WTS_REMOTE_CONNECT         = 0x3
	WTS_REMOTE_DISCONNECT      = 0x4
	WTS_SESSION_LOGON          = 0x5
	WTS_SESSION_LOGOFF         = 0x6
	WTS_SESSION_LOCK           = 0x7
	WTS_SESSION_UNLOCK         = 0x8
	WTS_SESSION_REMOTE_CONTROL = 0x9
	WTS_SESSION_CREATE         = 0xa
	WTS_SESSION_TERMINATE      = 0xb
)

const (
	WTSActive       = 0
	WTSConnected    = 1
	WTSConnectQuery = 2
	WTSShadow       = 3
	WTSDisconnected = 4
	WTSIdle         = 5
	WTSListen       = 6
	WTSReset        = 7
	WTSDown         = 8
	WTSInit         = 9
)

type WTSSESSION_NOTIFICATION struct {
	Size      uint32
	SessionID uint32
}

type WTS_SESSION_INFO struct {
	SessionID         uint32
	WindowStationName *uint16
	State             uint32
}

//sys WTSQueryUserToken(session uint32, token *Token) (err error) = wtsapi32.WTSQueryUserToken
//sys WTSEnumerateSessions(handle Handle, reserved uint32, version uint32, sessions **WTS_SESSION_INFO, count *uint32) (err error) = wtsapi32.WTSEnumerateSessionsW
//sys WTSFreeMemory(ptr uintptr) = wtsapi32.WTSFreeMemory

type ACL struct {
	aclRevision byte
	sbz1        byte
	aclSize     uint16
	aceCount    uint16
	sbz2        uint16
}

type SECURITY_DESCRIPTOR struct {
	revision byte
	sbz1     byte
	control  SECURITY_DESCRIPTOR_CONTROL
	owner    *SID
	group    *SID
	sacl     *ACL
	dacl     *ACL
}

type SecurityAttributes struct {
	Length             uint32
	SecurityDescriptor *SECURITY_DESCRIPTOR
	InheritHandle      uint32
}

type SE_OBJECT_TYPE uint32

// Constants for type SE_OBJECT_TYPE
const (
	SE_UNKNOWN_OBJECT_TYPE     = 0
	SE_FILE_OBJECT             = 1
	SE_SERVICE                 = 2
	SE_PRINTER                 = 3
	SE_REGISTRY_KEY            = 4
	SE_LMSHARE                 = 5
	SE_KERNEL_OBJECT           = 6
	SE_WINDOW_OBJECT           = 7
	SE_DS_OBJECT               = 8
	SE_DS_OBJECT_ALL           = 9
	SE_PROVIDER_DEFINED_OBJECT = 10
	SE_WMIGUID_OBJECT          = 11
	SE_REGISTRY_WOW64_32KEY    = 12
	SE_REGISTRY_WOW64_64KEY    = 13
)

type SECURITY_INFORMATION uint32

// Constants for type SECURITY_INFORMATION
const (
	OWNER_SECURITY_INFORMATION            = 0x00000001
	GROUP_SECURITY_INFORMATION            = 0x00000002
	DACL_SECURITY_INFORMATION             = 0x00000004
	SACL_SECURITY_INFORMATION             = 0x00000008
	LABEL_SECURITY_INFORMATION            = 0x00000010
	ATTRIBUTE_SECURITY_INFORMATION        = 0x00000020
	SCOPE_SECURITY_INFORMATION            = 0x00000040
	BACKUP_SECURITY_INFORMATION           = 0x00010000
	PROTECTED_DACL_SECURITY_INFORMATION   = 0x80000000
	PROTECTED_SACL_SECURITY_INFORMATION   = 0x40000000
	UNPROTECTED_DACL_SECURITY_INFORMATION = 0x20000000
	UNPROTECTED_SACL_SECURITY_INFORMATION = 0x10000000
)

type SECURITY_DESCRIPTOR_CONTROL uint16

// Constants for type SECURITY_DESCRIPTOR_CONTROL
const (
	SE_OWNER_DEFAULTED       = 0x0001
	SE_GROUP_DEFAULTED       = 0x0002
	SE_DACL_PRESENT          = 0x0004
	SE_DACL_DEFAULTED        = 0x0008
	SE_SACL_PRESENT          = 0x0010
	SE_SACL_DEFAULTED        = 0x0020
	SE_DACL_AUTO_INHERIT_REQ = 0x0100
	SE_SACL_AUTO_INHERIT_REQ = 0x0200
	SE_DACL_AUTO_INHERITED   = 0x0400
	SE_SACL_AUTO_INHERITED   = 0x0800
	SE_DACL_PROTECTED        = 0x1000
	SE_SACL_PROTECTED        = 0x2000
	SE_RM_CONTROL_VALID      = 0x4000
	SE_SELF_RELATIVE         = 0x8000
)

type ACCESS_MASK uint32

// Constants for type ACCESS_MASK
const (
	DELETE                   = 0x00010000
	READ_CONTROL             = 0x00020000
	WRITE_DAC                = 0x00040000
	WRITE_OWNER              = 0x00080000
	SYNCHRONIZE              = 0x00100000
	STANDARD_RIGHTS_REQUIRED = 0x000F0000
	STANDARD_RIGHTS_READ     = READ_CONTROL
	STANDARD_RIGHTS_WRITE    = READ_CONTROL
	STANDARD_RIGHTS_EXECUTE  = READ_CONTROL
	STANDARD_RIGHTS_ALL      = 0x001F0000
	SPECIFIC_RIGHTS_ALL      = 0x0000FFFF
	ACCESS_SYSTEM_SECURITY   = 0x01000000
	MAXIMUM_ALLOWED          = 0x02000000
	GENERIC_READ             = 0x80000000
	GENERIC_WRITE            = 0x40000000
	GENERIC_EXECUTE          = 0x20000000
	GENERIC_ALL              = 0x10000000
)

type ACCESS_MODE uint32

// Constants for type ACCESS_MODE
const (
	NOT_USED_ACCESS   = 0
	GRANT_ACCESS      = 1
	SET_ACCESS        = 2
	DENY_ACCESS       = 3
	REVOKE_ACCESS     = 4
	SET_AUDIT_SUCCESS = 5
	SET_AUDIT_FAILURE = 6
)

// Constants for AceFlags and Inheritance fields
const (
	NO_INHERITANCE                     = 0x0
	SUB_OBJECTS_ONLY_INHERIT           = 0x1
	SUB_CONTAINERS_ONLY_INHERIT        = 0x2
	SUB_CONTAINERS_AND_OBJECTS_INHERIT = 0x3
	INHERIT_NO_PROPAGATE               = 0x4
	INHERIT_ONLY                       = 0x8
	INHERITED_ACCESS_ENTRY             = 0x10
	INHERITED_PARENT                   = 0x10000000
	INHERITED_GRANDPARENT              = 0x20000000
	OBJECT_INHERIT_ACE                 = 0x1
	CONTAINER_INHERIT_ACE              = 0x2
	NO_PROPAGATE_INHERIT_ACE           = 0x4
	INHERIT_ONLY_ACE                   = 0x8
	INHERITED_ACE                      = 0x10
	VALID_INHERIT_FLAGS                = 0x1F
)

type MULTIPLE_TRUSTEE_OPERATION uint32

// Constants for MULTIPLE_TRUSTEE_OPERATION
const (
	NO_MULTIPLE_TRUSTEE    = 0
	TRUSTEE_IS_IMPERSONATE = 1
)

type TRUSTEE_FORM uint32

// Constants for TRUSTEE_FORM
const (
	TRUSTEE_IS_SID              = 0
	TRUSTEE_IS_NAME             = 1
	TRUSTEE_BAD_FORM            = 2
	TRUSTEE_IS_OBJECTS_AND_SID  = 3
	TRUSTEE_IS_OBJECTS_AND_NAME = 4
)

type TRUSTEE_TYPE uint32

// Constants for TRUSTEE_TYPE
const (
	TRUSTEE_IS_UNKNOWN          = 0
	TRUSTEE_IS_USER             = 1
	TRUSTEE_IS_GROUP            = 2
	TRUSTEE_IS_DOMAIN           = 3
	TRUSTEE_IS_ALIAS            = 4
	TRUSTEE_IS_WELL_KNOWN_GROUP = 5
	TRUSTEE_IS_DELETED          = 6
	TRUSTEE_IS_INVALID          = 7
	TRUSTEE_IS_COMPUTER         = 8
)

// Constants for ObjectsPresent field
const (
	ACE_OBJECT_TYPE_PRESENT           = 0x1
	ACE_INHERITED_OBJECT_TYPE_PRESENT = 0x2
)

type EXPLICIT_ACCESS struct {
	AccessPermissions ACCESS_MASK
	AccessMode        ACCESS_MODE
	Inheritance       uint32
	Trustee           TRUSTEE
}

// This type is the union inside of TRUSTEE and must be created using one of the TrusteeValueFrom* functions.
type TrusteeValue uintptr

func TrusteeValueFromString(str string) TrusteeValue {
	return TrusteeValue(unsafe.Pointer(StringToUTF16Ptr(str)))
}
func TrusteeValueFromSID(sid *SID) TrusteeValue {
	return TrusteeValue(unsafe.Pointer(sid))
}
func TrusteeValueFromObjectsAndSid(objectsAndSid *OBJECTS_AND_SID) TrusteeValue {
	return TrusteeValue(unsafe.Pointer(objectsAndSid))
}
func TrusteeValueFromObjectsAndName(objectsAndName *OBJECTS_AND_NAME) TrusteeValue {
	return TrusteeValue(unsafe.Pointer(objectsAndName))
}

type TRUSTEE struct {
	MultipleTrustee          *TRUSTEE
	MultipleTrusteeOperation MULTIPLE_TRUSTEE_OPERATION
	TrusteeForm              TRUSTEE_FORM
	TrusteeType              TRUSTEE_TYPE
	TrusteeValue             TrusteeValue
}

type OBJECTS_AND_SID struct {
	ObjectsPresent          uint32
	ObjectTypeGuid          GUID
	InheritedObjectTypeGuid GUID
	Sid                     *SID
}

type OBJECTS_AND_NAME struct {
	ObjectsPresent          uint32
	ObjectType              SE_OBJECT_TYPE
	ObjectTypeName          *uint16
	InheritedObjectTypeName *uint16
	Name                    *uint16
}

//sys	getSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) = advapi32.GetSecurityInfo
//sys	SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) = advapi32.SetSecurityInfo
//sys	getNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) = advapi32.GetNamedSecurityInfoW
//sys	SetNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) = advapi32.SetNamedSecurityInfoW

//sys	buildSecurityDescriptor(owner *TRUSTEE, group *TRUSTEE, countAccessEntries uint32, accessEntries *EXPLICIT_ACCESS, countAuditEntries uint32, auditEntries *EXPLICIT_ACCESS, oldSecurityDescriptor *SECURITY_DESCRIPTOR, sizeNewSecurityDescriptor *uint32, newSecurityDescriptor **SECURITY_DESCRIPTOR) (ret error) = advapi32.BuildSecurityDescriptorW
//sys	initializeSecurityDescriptor(absoluteSD *SECURITY_DESCRIPTOR, revision uint32) (err error) = advapi32.InitializeSecurityDescriptor

//sys	getSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, control *SECURITY_DESCRIPTOR_CONTROL, revision *uint32) (err error) = advapi32.GetSecurityDescriptorControl
//sys	getSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent *bool, dacl **ACL, daclDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorDacl
//sys	getSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent *bool, sacl **ACL, saclDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorSacl
//sys	getSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner **SID, ownerDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorOwner
//sys	getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) = advapi32.GetSecurityDescriptorGroup
//sys	getSecurityDescriptorLength(sd *SECURITY_DESCRIPTOR) (len uint32) = advapi32.GetSecurityDescriptorLength
//sys	getSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) (ret error) [failretval!=0] = advapi32.GetSecurityDescriptorRMControl
//sys	isValidSecurityDescriptor(sd *SECURITY_DESCRIPTOR) (isValid bool) = advapi32.IsValidSecurityDescriptor

//sys	setSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, controlBitsOfInterest SECURITY_DESCRIPTOR_CONTROL, controlBitsToSet SECURITY_DESCRIPTOR_CONTROL) (err error) = advapi32.SetSecurityDescriptorControl
//sys	setSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent bool, dacl *ACL, daclDefaulted bool) (err error) = advapi32.SetSecurityDescriptorDacl
//sys	setSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent bool, sacl *ACL, saclDefaulted bool) (err error) = advapi32.SetSecurityDescriptorSacl
//sys	setSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner *SID, ownerDefaulted bool) (err error) = advapi32.SetSecurityDescriptorOwner
//sys	setSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group *SID, groupDefaulted bool) (err error) = advapi32.SetSecurityDescriptorGroup
//sys	setSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) = advapi32.SetSecurityDescriptorRMControl

//sys	convertStringSecurityDescriptorToSecurityDescriptor(str string, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) = advapi32.ConvertStringSecurityDescriptorToSecurityDescriptorW
//sys	convertSecurityDescriptorToStringSecurityDescriptor(sd *SECURITY_DESCRIPTOR, revision uint32, securityInformation SECURITY_INFORMATION, str **uint16, strLen *uint32) (err error) = advapi32.ConvertSecurityDescriptorToStringSecurityDescriptorW

//sys	makeAbsoluteSD(selfRelativeSD *SECURITY_DESCRIPTOR, absoluteSD *SECURITY_DESCRIPTOR, absoluteSDSize *uint32, dacl *ACL, daclSize *uint32, sacl *ACL, saclSize *uint32, owner *SID, ownerSize *uint32, group *SID, groupSize *uint32) (err error) = advapi32.MakeAbsoluteSD
//sys	makeSelfRelativeSD(absoluteSD *SECURITY_DESCRIPTOR, selfRelativeSD *SECURITY_DESCRIPTOR, selfRelativeSDSize *uint32) (err error) = advapi32.MakeSelfRelativeSD

//sys	setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) = advapi32.SetEntriesInAclW

// Control returns the security descriptor control bits.
func (sd *SECURITY_DESCRIPTOR) Control() (control SECURITY_DESCRIPTOR_CONTROL, revision uint32, err error) {
	err = getSecurityDescriptorControl(sd, &control, &revision)
	return
}

// SetControl sets the security descriptor control bits.
func (sd *SECURITY_DESCRIPTOR) SetControl(controlBitsOfInterest SECURITY_DESCRIPTOR_CONTROL, controlBitsToSet SECURITY_DESCRIPTOR_CONTROL) error {
	return setSecurityDescriptorControl(sd, controlBitsOfInterest, controlBitsToSet)
}

// RMControl returns the security descriptor resource manager control bits.
func (sd *SECURITY_DESCRIPTOR) RMControl() (control uint8, err error) {
	err = getSecurityDescriptorRMControl(sd, &control)
	return
}

// SetRMControl sets the security descriptor resource manager control bits.
func (sd *SECURITY_DESCRIPTOR) SetRMControl(rmControl uint8) {
	setSecurityDescriptorRMControl(sd, &rmControl)
}

// DACL returns the security descriptor DACL and whether it was defaulted. The dacl return value may be nil
// if a DACL exists but is an "empty DACL", meaning fully permissive. If the DACL does not exist, err returns
// ERROR_OBJECT_NOT_FOUND.
func (sd *SECURITY_DESCRIPTOR) DACL() (dacl *ACL, defaulted bool, err error) {
	var present bool
	err = getSecurityDescriptorDacl(sd, &present, &dacl, &defaulted)
	if !present {
		err = ERROR_OBJECT_NOT_FOUND
	}
	return
}

// SetDACL sets the absolute security descriptor DACL.
func (absoluteSD *SECURITY_DESCRIPTOR) SetDACL(dacl *ACL, present, defaulted bool) error {
	return setSecurityDescriptorDacl(absoluteSD, present, dacl, defaulted)
}

// SACL returns the security descriptor SACL and whether it was defaulted. The sacl return value may be nil
// if a SACL exists but is an "empty SACL", meaning fully permissive. If the SACL does not exist, err returns
// ERROR_OBJECT_NOT_FOUND.
func (sd *SECURITY_DESCRIPTOR) SACL() (sacl *ACL, defaulted bool, err error) {
	var present bool
	err = getSecurityDescriptorSacl(sd, &present, &sacl, &defaulted)
	if !present {
		err = ERROR_OBJECT_NOT_FOUND
	}
	return
}

// SetSACL sets the absolute security descriptor SACL.
func (absoluteSD *SECURITY_DESCRIPTOR) SetSACL(sacl *ACL, present, defaulted bool) error {
	return setSecurityDescriptorSacl(absoluteSD, present, sacl, defaulted)
}

// Owner returns the security descriptor owner and whether it was defaulted.
func (sd *SECURITY_DESCRIPTOR) Owner() (owner *SID, defaulted bool, err error) {
	err = getSecurityDescriptorOwner(sd, &owner, &defaulted)
	return
}

// SetOwner sets the absolute security descriptor owner.
func (absoluteSD *SECURITY_DESCRIPTOR) SetOwner(owner *SID, defaulted bool) error {
	return setSecurityDescriptorOwner(absoluteSD, owner, defaulted)
}

// Group returns the security descriptor group and whether it was defaulted.
func (sd *SECURITY_DESCRIPTOR) Group() (group *SID, defaulted bool, err error) {
	err = getSecurityDescriptorGroup(sd, &group, &defaulted)
	return
}

// SetGroup sets the absolute security descriptor owner.
func (absoluteSD *SECURITY_DESCRIPTOR) SetGroup(group *SID, defaulted bool) error {
	return setSecurityDescriptorGroup(absoluteSD, group, defaulted)
}

// Length returns the length of the security descriptor.
func (sd *SECURITY_DESCRIPTOR) Length() uint32 {
	return getSecurityDescriptorLength(sd)
}

// IsValid returns whether the security descriptor is valid.
func (sd *SECURITY_DESCRIPTOR) IsValid() bool {
	return isValidSecurityDescriptor(sd)
}

// String returns the SDDL form of the security descriptor, with a function signature that can be
// used with %v formatting directives.
func (sd *SECURITY_DESCRIPTOR) String() string {
	var sddl *uint16
	err := convertSecurityDescriptorToStringSecurityDescriptor(sd, 1, 0xff, &sddl, nil)
	if err != nil {
		return ""
	}
	defer LocalFree(Handle(unsafe.Pointer(sddl)))
	return UTF16ToString((*[(1 << 30) - 1]uint16)(unsafe.Pointer(sddl))[:])
}

// ToAbsolute converts a self-relative security descriptor into an absolute one.
func (selfRelativeSD *SECURITY_DESCRIPTOR) ToAbsolute() (absoluteSD *SECURITY_DESCRIPTOR, err error) {
	control, _, err := selfRelativeSD.Control()
	if err != nil {
		return
	}
	if control&SE_SELF_RELATIVE == 0 {
		err = ERROR_INVALID_PARAMETER
		return
	}
	var absoluteSDSize, daclSize, saclSize, ownerSize, groupSize uint32
	err = makeAbsoluteSD(selfRelativeSD, nil, &absoluteSDSize,
		nil, &daclSize, nil, &saclSize, nil, &ownerSize, nil, &groupSize)
	switch err {
	case ERROR_INSUFFICIENT_BUFFER:
	case nil:
		// makeAbsoluteSD is expected to fail, but it succeeds.
		return nil, ERROR_INTERNAL_ERROR
	default:
		return nil, err
	}
	if absoluteSDSize > 0 {
		absoluteSD = (*SECURITY_DESCRIPTOR)(unsafe.Pointer(&make([]byte, absoluteSDSize)[0]))
	}
	var (
		dacl  *ACL
		sacl  *ACL
		owner *SID
		group *SID
	)
	if daclSize > 0 {
		dacl = (*ACL)(unsafe.Pointer(&make([]byte, daclSize)[0]))
	}
	if saclSize > 0 {
		sacl = (*ACL)(unsafe.Pointer(&make([]byte, saclSize)[0]))
	}
	if ownerSize > 0 {
		owner = (*SID)(unsafe.Pointer(&make([]byte, ownerSize)[0]))
	}
	if groupSize > 0 {
		group = (*SID)(unsafe.Pointer(&make([]byte, groupSize)[0]))
	}
	err = makeAbsoluteSD(selfRelativeSD, absoluteSD, &absoluteSDSize,
		dacl, &daclSize, sacl, &saclSize, owner, &ownerSize, group, &groupSize)
	return
}

// ToSelfRelative converts an absolute security descriptor into a self-relative one.
func (absoluteSD *SECURITY_DESCRIPTOR) ToSelfRelative() (selfRelativeSD *SECURITY_DESCRIPTOR, err error) {
	control, _, err := absoluteSD.Control()
	if err != nil {
		return
	}
	if control&SE_SELF_RELATIVE != 0 {
		err = ERROR_INVALID_PARAMETER
		return
	}
	var selfRelativeSDSize uint32
	err = makeSelfRelativeSD(absoluteSD, nil, &selfRelativeSDSize)
	switch err {
	case ERROR_INSUFFICIENT_BUFFER:
	case nil:
		// makeSelfRelativeSD is expected to fail, but it succeeds.
		return nil, ERROR_INTERNAL_ERROR
	default:
		return nil, err
	}
	if selfRelativeSDSize > 0 {
		selfRelativeSD = (*SECURITY_DESCRIPTOR)(unsafe.Pointer(&make([]byte, selfRelativeSDSize)[0]))
	}
	err = makeSelfRelativeSD(absoluteSD, selfRelativeSD, &selfRelativeSDSize)
	return
}

func (selfRelativeSD *SECURITY_DESCRIPTOR) copySelfRelativeSecurityDescriptor() *SECURITY_DESCRIPTOR {
	sdBytes := make([]byte, selfRelativeSD.Length())
	copy(sdBytes, (*[(1 << 31) - 1]byte)(unsafe.Pointer(selfRelativeSD))[:len(sdBytes)])
	return (*SECURITY_DESCRIPTOR)(unsafe.Pointer(&sdBytes[0]))
}

// SecurityDescriptorFromString converts an SDDL string describing a security descriptor into a
// self-relative security descriptor object allocated on the Go heap.
func SecurityDescriptorFromString(sddl string) (sd *SECURITY_DESCRIPTOR, err error) {
	var winHeapSD *SECURITY_DESCRIPTOR
	err = convertStringSecurityDescriptorToSecurityDescriptor(sddl, 1, &winHeapSD, nil)
	if err != nil {
		return
	}
	defer LocalFree(Handle(unsafe.Pointer(winHeapSD)))
	return winHeapSD.copySelfRelativeSecurityDescriptor(), nil
}

// GetSecurityInfo queries the security information for a given handle and returns the self-relative security
// descriptor result on the Go heap.
func GetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION) (sd *SECURITY_DESCRIPTOR, err error) {
	var winHeapSD *SECURITY_DESCRIPTOR
	err = getSecurityInfo(handle, objectType, securityInformation, nil, nil, nil, nil, &winHeapSD)
	if err != nil {
		return
	}
	defer LocalFree(Handle(unsafe.Pointer(winHeapSD)))
	return winHeapSD.copySelfRelativeSecurityDescriptor(), nil
}

// GetNamedSecurityInfo queries the security information for a given named object and returns the self-relative security
// descriptor result on the Go heap.
func GetNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION) (sd *SECURITY_DESCRIPTOR, err error) {
	var winHeapSD *SECURITY_DESCRIPTOR
	err = getNamedSecurityInfo(objectName, objectType, securityInformation, nil, nil, nil, nil, &winHeapSD)
	if err != nil {
		return
	}
	defer LocalFree(Handle(unsafe.Pointer(winHeapSD)))
	return winHeapSD.copySelfRelativeSecurityDescriptor(), nil
}

// BuildSecurityDescriptor makes a new security descriptor using the input trustees, explicit access lists, and
// prior security descriptor to be merged, any of which can be nil, returning the self-relative security descriptor
// result on the Go heap.
func BuildSecurityDescriptor(owner *TRUSTEE, group *TRUSTEE, accessEntries []EXPLICIT_ACCESS, auditEntries []EXPLICIT_ACCESS, mergedSecurityDescriptor *SECURITY_DESCRIPTOR) (sd *SECURITY_DESCRIPTOR, err error) {
	var winHeapSD *SECURITY_DESCRIPTOR
	var winHeapSDSize uint32
	var firstAccessEntry *EXPLICIT_ACCESS
	if len(accessEntries) > 0 {
		firstAccessEntry = &accessEntries[0]
	}
	var firstAuditEntry *EXPLICIT_ACCESS
	if len(auditEntries) > 0 {
		firstAuditEntry = &auditEntries[0]
	}
	err = buildSecurityDescriptor(owner, group, uint32(len(accessEntries)), firstAccessEntry, uint32(len(auditEntries)), firstAuditEntry, mergedSecurityDescriptor, &winHeapSDSize, &winHeapSD)
	if err != nil {
		return
	}
	defer LocalFree(Handle(unsafe.Pointer(winHeapSD)))
	return winHeapSD.copySelfRelativeSecurityDescriptor(), nil
}

// NewSecurityDescriptor creates and initializes a new absolute security descriptor.
func NewSecurityDescriptor() (absoluteSD *SECURITY_DESCRIPTOR, err error) {
	absoluteSD = &SECURITY_DESCRIPTOR{}
	err = initializeSecurityDescriptor(absoluteSD, 1)
	return
}

// ACLFromEntries returns a new ACL on the Go heap containing a list of explicit entries as well as those of another ACL.
// Both explicitEntries and mergedACL are optional and can be nil.
func ACLFromEntries(explicitEntries []EXPLICIT_ACCESS, mergedACL *ACL) (acl *ACL, err error) {
	var firstExplicitEntry *EXPLICIT_ACCESS
	if len(explicitEntries) > 0 {
		firstExplicitEntry = &explicitEntries[0]
	}
	var winHeapACL *ACL
	err = setEntriesInAcl(uint32(len(explicitEntries)), firstExplicitEntry, mergedACL, &winHeapACL)
	if err != nil {
		return
	}
	defer LocalFree(Handle(unsafe.Pointer(winHeapACL)))
	aclBytes := make([]byte, winHeapACL.aclSize)
	copy(aclBytes, (*[(1 << 31) - 1]byte)(unsafe.Pointer(winHeapACL))[:len(aclBytes)])
	return (*ACL)(unsafe.Pointer(&aclBytes[0])), nil
}

+ f 8e709e6a28b4e52b784c10f8e761abe5d939988b3d8c138018bd55d49c7187ce vendor/golang.org/x/sys/windows/service.go
utf8file 230
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows

package windows

const (
	SC_MANAGER_CONNECT            = 1
	SC_MANAGER_CREATE_SERVICE     = 2
	SC_MANAGER_ENUMERATE_SERVICE  = 4
	SC_MANAGER_LOCK               = 8
	SC_MANAGER_QUERY_LOCK_STATUS  = 16
	SC_MANAGER_MODIFY_BOOT_CONFIG = 32
	SC_MANAGER_ALL_ACCESS         = 0xf003f
)

//sys	OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) [failretval==0] = advapi32.OpenSCManagerW

const (
	SERVICE_KERNEL_DRIVER       = 1
	SERVICE_FILE_SYSTEM_DRIVER  = 2
	SERVICE_ADAPTER             = 4
	SERVICE_RECOGNIZER_DRIVER   = 8
	SERVICE_WIN32_OWN_PROCESS   = 16
	SERVICE_WIN32_SHARE_PROCESS = 32
	SERVICE_WIN32               = SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS
	SERVICE_INTERACTIVE_PROCESS = 256
	SERVICE_DRIVER              = SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_RECOGNIZER_DRIVER
	SERVICE_TYPE_ALL            = SERVICE_WIN32 | SERVICE_ADAPTER | SERVICE_DRIVER | SERVICE_INTERACTIVE_PROCESS

	SERVICE_BOOT_START   = 0
	SERVICE_SYSTEM_START = 1
	SERVICE_AUTO_START   = 2
	SERVICE_DEMAND_START = 3
	SERVICE_DISABLED     = 4

	SERVICE_ERROR_IGNORE   = 0
	SERVICE_ERROR_NORMAL   = 1
	SERVICE_ERROR_SEVERE   = 2
	SERVICE_ERROR_CRITICAL = 3

	SC_STATUS_PROCESS_INFO = 0

	SC_ACTION_NONE        = 0
	SC_ACTION_RESTART     = 1
	SC_ACTION_REBOOT      = 2
	SC_ACTION_RUN_COMMAND = 3

	SERVICE_STOPPED          = 1
	SERVICE_START_PENDING    = 2
	SERVICE_STOP_PENDING     = 3
	SERVICE_RUNNING          = 4
	SERVICE_CONTINUE_PENDING = 5
	SERVICE_PAUSE_PENDING    = 6
	SERVICE_PAUSED           = 7
	SERVICE_NO_CHANGE        = 0xffffffff

	SERVICE_ACCEPT_STOP                  = 1
	SERVICE_ACCEPT_PAUSE_CONTINUE        = 2
	SERVICE_ACCEPT_SHUTDOWN              = 4
	SERVICE_ACCEPT_PARAMCHANGE           = 8
	SERVICE_ACCEPT_NETBINDCHANGE         = 16
	SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 32
	SERVICE_ACCEPT_POWEREVENT            = 64
	SERVICE_ACCEPT_SESSIONCHANGE         = 128

	SERVICE_CONTROL_STOP                  = 1
	SERVICE_CONTROL_PAUSE                 = 2
	SERVICE_CONTROL_CONTINUE              = 3
	SERVICE_CONTROL_INTERROGATE           = 4
	SERVICE_CONTROL_SHUTDOWN              = 5
	SERVICE_CONTROL_PARAMCHANGE           = 6
	SERVICE_CONTROL_NETBINDADD            = 7
	SERVICE_CONTROL_NETBINDREMOVE         = 8
	SERVICE_CONTROL_NETBINDENABLE         = 9
	SERVICE_CONTROL_NETBINDDISABLE        = 10
	SERVICE_CONTROL_DEVICEEVENT           = 11
	SERVICE_CONTROL_HARDWAREPROFILECHANGE = 12
	SERVICE_CONTROL_POWEREVENT            = 13
	SERVICE_CONTROL_SESSIONCHANGE         = 14

	SERVICE_ACTIVE    = 1
	SERVICE_INACTIVE  = 2
	SERVICE_STATE_ALL = 3

	SERVICE_QUERY_CONFIG         = 1
	SERVICE_CHANGE_CONFIG        = 2
	SERVICE_QUERY_STATUS         = 4
	SERVICE_ENUMERATE_DEPENDENTS = 8
	SERVICE_START                = 16
	SERVICE_STOP                 = 32
	SERVICE_PAUSE_CONTINUE       = 64
	SERVICE_INTERROGATE          = 128
	SERVICE_USER_DEFINED_CONTROL = 256
	SERVICE_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL

	SERVICE_RUNS_IN_SYSTEM_PROCESS = 1

	SERVICE_CONFIG_DESCRIPTION              = 1
	SERVICE_CONFIG_FAILURE_ACTIONS          = 2
	SERVICE_CONFIG_DELAYED_AUTO_START_INFO  = 3
	SERVICE_CONFIG_FAILURE_ACTIONS_FLAG     = 4
	SERVICE_CONFIG_SERVICE_SID_INFO         = 5
	SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 6
	SERVICE_CONFIG_PRESHUTDOWN_INFO         = 7
	SERVICE_CONFIG_TRIGGER_INFO             = 8
	SERVICE_CONFIG_PREFERRED_NODE           = 9
	SERVICE_CONFIG_LAUNCH_PROTECTED         = 12

	SERVICE_SID_TYPE_NONE         = 0
	SERVICE_SID_TYPE_UNRESTRICTED = 1
	SERVICE_SID_TYPE_RESTRICTED   = 2 | SERVICE_SID_TYPE_UNRESTRICTED

	SC_ENUM_PROCESS_INFO = 0

	SERVICE_NOTIFY_STATUS_CHANGE    = 2
	SERVICE_NOTIFY_STOPPED          = 0x00000001
	SERVICE_NOTIFY_START_PENDING    = 0x00000002
	SERVICE_NOTIFY_STOP_PENDING     = 0x00000004
	SERVICE_NOTIFY_RUNNING          = 0x00000008
	SERVICE_NOTIFY_CONTINUE_PENDING = 0x00000010
	SERVICE_NOTIFY_PAUSE_PENDING    = 0x00000020
	SERVICE_NOTIFY_PAUSED           = 0x00000040
	SERVICE_NOTIFY_CREATED          = 0x00000080
	SERVICE_NOTIFY_DELETED          = 0x00000100
	SERVICE_NOTIFY_DELETE_PENDING   = 0x00000200
)

type SERVICE_STATUS struct {
	ServiceType             uint32
	CurrentState            uint32
	ControlsAccepted        uint32
	Win32ExitCode           uint32
	ServiceSpecificExitCode uint32
	CheckPoint              uint32
	WaitHint                uint32
}

type SERVICE_TABLE_ENTRY struct {
	ServiceName *uint16
	ServiceProc uintptr
}

type QUERY_SERVICE_CONFIG struct {
	ServiceType      uint32
	StartType        uint32
	ErrorControl     uint32
	BinaryPathName   *uint16
	LoadOrderGroup   *uint16
	TagId            uint32
	Dependencies     *uint16
	ServiceStartName *uint16
	DisplayName      *uint16
}

type SERVICE_DESCRIPTION struct {
	Description *uint16
}

type SERVICE_DELAYED_AUTO_START_INFO struct {
	IsDelayedAutoStartUp uint32
}

type SERVICE_STATUS_PROCESS struct {
	ServiceType             uint32
	CurrentState            uint32
	ControlsAccepted        uint32
	Win32ExitCode           uint32
	ServiceSpecificExitCode uint32
	CheckPoint              uint32
	WaitHint                uint32
	ProcessId               uint32
	ServiceFlags            uint32
}

type ENUM_SERVICE_STATUS_PROCESS struct {
	ServiceName          *uint16
	DisplayName          *uint16
	ServiceStatusProcess SERVICE_STATUS_PROCESS
}

type SERVICE_NOTIFY struct {
	Version               uint32
	NotifyCallback        uintptr
	Context               uintptr
	NotificationStatus    uint32
	ServiceStatus         SERVICE_STATUS_PROCESS
	NotificationTriggered uint32
	ServiceNames          *uint16
}

type SERVICE_FAILURE_ACTIONS struct {
	ResetPeriod  uint32
	RebootMsg    *uint16
	Command      *uint16
	ActionsCount uint32
	Actions      *SC_ACTION
}

type SC_ACTION struct {
	Type  uint32
	Delay uint32
}

type QUERY_SERVICE_LOCK_STATUS struct {
	IsLocked     uint32
	LockOwner    *uint16
	LockDuration uint32
}

//sys	CloseServiceHandle(handle Handle) (err error) = advapi32.CloseServiceHandle
//sys	CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) [failretval==0] = advapi32.CreateServiceW
//sys	OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) [failretval==0] = advapi32.OpenServiceW
//sys	DeleteService(service Handle) (err error) = advapi32.DeleteService
//sys	StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) = advapi32.StartServiceW
//sys	QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) = advapi32.QueryServiceStatus
//sys	QueryServiceLockStatus(mgr Handle, lockStatus *QUERY_SERVICE_LOCK_STATUS, bufSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceLockStatusW
//sys	ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) = advapi32.ControlService
//sys	StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) = advapi32.StartServiceCtrlDispatcherW
//sys	SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) = advapi32.SetServiceStatus
//sys	ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) = advapi32.ChangeServiceConfigW
//sys	QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfigW
//sys	ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) = advapi32.ChangeServiceConfig2W
//sys	QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfig2W
//sys	EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) = advapi32.EnumServicesStatusExW
//sys	QueryServiceStatusEx(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceStatusEx
//sys	NotifyServiceStatusChange(service Handle, notifyMask uint32, notifier *SERVICE_NOTIFY) (ret error) = advapi32.NotifyServiceStatusChangeW

+ f a979ea38da92c56dc17baa7fce72bb82ac4353867d47c5240cee4404bf356875 vendor/golang.org/x/sys/windows/str.go
utf8file 23
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows

package windows

func itoa(val int) string { // do it here rather than with fmt to avoid dependency
	if val < 0 {
		return "-" + itoa(-val)
	}
	var buf [32]byte // big enough for int64
	i := len(buf) - 1
	for val >= 10 {
		buf[i] = byte(val%10 + '0')
		i--
		val /= 10
	}
	buf[i] = byte(val + '0')
	return string(buf[i:])
}

+ f 15bb620236c7bba4ff1edbda701444c99ea5111e9d0b133329f8199a30fd26ac vendor/golang.org/x/sys/windows/syscall.go
utf8file 75
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build windows

// Package windows contains an interface to the low-level operating system
// primitives. OS details vary depending on the underlying system, and
// by default, godoc will display the OS-specific documentation for the current
// system. If you want godoc to display syscall documentation for another
// system, set $GOOS and $GOARCH to the desired system. For example, if
// you want to view documentation for freebsd/arm on linux/amd64, set $GOOS
// to freebsd and $GOARCH to arm.
//
// The primary use of this package is inside other packages that provide a more
// portable interface to the system, such as "os", "time" and "net".  Use
// those packages rather than this one if you can.
//
// For details of the functions and data types in this package consult
// the manuals for the appropriate operating system.
//
// These calls return err == nil to indicate success; otherwise
// err represents an operating system error describing the failure and
// holds a value of type syscall.Errno.
package windows // import "golang.org/x/sys/windows"

import (
	"syscall"
)

// ByteSliceFromString returns a NUL-terminated slice of bytes
// containing the text of s. If s contains a NUL byte at any
// location, it returns (nil, syscall.EINVAL).
func ByteSliceFromString(s string) ([]byte, error) {
	for i := 0; i < len(s); i++ {
		if s[i] == 0 {
			return nil, syscall.EINVAL
		}
	}
	a := make([]byte, len(s)+1)
	copy(a, s)
	return a, nil
}

// BytePtrFromString returns a pointer to a NUL-terminated array of
// bytes containing the text of s. If s contains a NUL byte at any
// location, it returns (nil, syscall.EINVAL).
func BytePtrFromString(s string) (*byte, error) {
	a, err := ByteSliceFromString(s)
	if err != nil {
		return nil, err
	}
	return &a[0], nil
}

// Single-word zero for use when we need a valid pointer to 0 bytes.
// See mksyscall.pl.
var _zero uintptr

func (ts *Timespec) Unix() (sec int64, nsec int64) {
	return int64(ts.Sec), int64(ts.Nsec)
}

func (tv *Timeval) Unix() (sec int64, nsec int64) {
	return int64(tv.Sec), int64(tv.Usec) * 1000
}

func (ts *Timespec) Nano() int64 {
	return int64(ts.Sec)*1e9 + int64(ts.Nsec)
}

func (tv *Timeval) Nano() int64 {
	return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000
}

+ f 77034d5def261620a1bed478cb5fe6a766cf120ce955820af1e015b53a57d038 vendor/golang.org/x/sys/windows/syscall_windows.go
utf8file 1455
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Windows system calls.

package windows

import (
	errorspkg "errors"
	"sync"
	"syscall"
	"time"
	"unicode/utf16"
	"unsafe"
)

type Handle uintptr

const (
	InvalidHandle = ^Handle(0)

	// Flags for DefineDosDevice.
	DDD_EXACT_MATCH_ON_REMOVE = 0x00000004
	DDD_NO_BROADCAST_SYSTEM   = 0x00000008
	DDD_RAW_TARGET_PATH       = 0x00000001
	DDD_REMOVE_DEFINITION     = 0x00000002

	// Return values for GetDriveType.
	DRIVE_UNKNOWN     = 0
	DRIVE_NO_ROOT_DIR = 1
	DRIVE_REMOVABLE   = 2
	DRIVE_FIXED       = 3
	DRIVE_REMOTE      = 4
	DRIVE_CDROM       = 5
	DRIVE_RAMDISK     = 6

	// File system flags from GetVolumeInformation and GetVolumeInformationByHandle.
	FILE_CASE_SENSITIVE_SEARCH        = 0x00000001
	FILE_CASE_PRESERVED_NAMES         = 0x00000002
	FILE_FILE_COMPRESSION             = 0x00000010
	FILE_DAX_VOLUME                   = 0x20000000
	FILE_NAMED_STREAMS                = 0x00040000
	FILE_PERSISTENT_ACLS              = 0x00000008
	FILE_READ_ONLY_VOLUME             = 0x00080000
	FILE_SEQUENTIAL_WRITE_ONCE        = 0x00100000
	FILE_SUPPORTS_ENCRYPTION          = 0x00020000
	FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000
	FILE_SUPPORTS_HARD_LINKS          = 0x00400000
	FILE_SUPPORTS_OBJECT_IDS          = 0x00010000
	FILE_SUPPORTS_OPEN_BY_FILE_ID     = 0x01000000
	FILE_SUPPORTS_REPARSE_POINTS      = 0x00000080
	FILE_SUPPORTS_SPARSE_FILES        = 0x00000040
	FILE_SUPPORTS_TRANSACTIONS        = 0x00200000
	FILE_SUPPORTS_USN_JOURNAL         = 0x02000000
	FILE_UNICODE_ON_DISK              = 0x00000004
	FILE_VOLUME_IS_COMPRESSED         = 0x00008000
	FILE_VOLUME_QUOTAS                = 0x00000020

	// Flags for LockFileEx.
	LOCKFILE_FAIL_IMMEDIATELY = 0x00000001
	LOCKFILE_EXCLUSIVE_LOCK   = 0x00000002

	// Return values of SleepEx and other APC functions
	STATUS_USER_APC    = 0x000000C0
	WAIT_IO_COMPLETION = STATUS_USER_APC
)

// StringToUTF16 is deprecated. Use UTF16FromString instead.
// If s contains a NUL byte this function panics instead of
// returning an error.
func StringToUTF16(s string) []uint16 {
	a, err := UTF16FromString(s)
	if err != nil {
		panic("windows: string with NUL passed to StringToUTF16")
	}
	return a
}

// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
// s, with a terminating NUL added. If s contains a NUL byte at any
// location, it returns (nil, syscall.EINVAL).
func UTF16FromString(s string) ([]uint16, error) {
	for i := 0; i < len(s); i++ {
		if s[i] == 0 {
			return nil, syscall.EINVAL
		}
	}
	return utf16.Encode([]rune(s + "\x00")), nil
}

// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
// with a terminating NUL removed.
func UTF16ToString(s []uint16) string {
	for i, v := range s {
		if v == 0 {
			s = s[0:i]
			break
		}
	}
	return string(utf16.Decode(s))
}

// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.
// If s contains a NUL byte this function panics instead of
// returning an error.
func StringToUTF16Ptr(s string) *uint16 { return &StringToUTF16(s)[0] }

// UTF16PtrFromString returns pointer to the UTF-16 encoding of
// the UTF-8 string s, with a terminating NUL added. If s
// contains a NUL byte at any location, it returns (nil, syscall.EINVAL).
func UTF16PtrFromString(s string) (*uint16, error) {
	a, err := UTF16FromString(s)
	if err != nil {
		return nil, err
	}
	return &a[0], nil
}

func Getpagesize() int { return 4096 }

// NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.
// This is useful when interoperating with Windows code requiring callbacks.
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
func NewCallback(fn interface{}) uintptr {
	return syscall.NewCallback(fn)
}

// NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.
// This is useful when interoperating with Windows code requiring callbacks.
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
func NewCallbackCDecl(fn interface{}) uintptr {
	return syscall.NewCallbackCDecl(fn)
}

// windows api calls

//sys	GetLastError() (lasterr error)
//sys	LoadLibrary(libname string) (handle Handle, err error) = LoadLibraryW
//sys	LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW
//sys	FreeLibrary(handle Handle) (err error)
//sys	GetProcAddress(module Handle, procname string) (proc uintptr, err error)
//sys	GetModuleFileName(module Handle, filename *uint16, size uint32) (n uint32, err error) = kernel32.GetModuleFileNameW
//sys	GetModuleHandleEx(flags uint32, moduleName *uint16, module *Handle) (err error) = kernel32.GetModuleHandleExW
//sys	GetVersion() (ver uint32, err error)
//sys	FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) = FormatMessageW
//sys	ExitProcess(exitcode uint32)
//sys	IsWow64Process(handle Handle, isWow64 *bool) (err error) = IsWow64Process
//sys	CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile Handle) (handle Handle, err error) [failretval==InvalidHandle] = CreateFileW
//sys	ReadFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error)
//sys	WriteFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error)
//sys	GetOverlappedResult(handle Handle, overlapped *Overlapped, done *uint32, wait bool) (err error)
//sys	SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) [failretval==0xffffffff]
//sys	CloseHandle(handle Handle) (err error)
//sys	GetStdHandle(stdhandle uint32) (handle Handle, err error) [failretval==InvalidHandle]
//sys	SetStdHandle(stdhandle uint32, handle Handle) (err error)
//sys	findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstFileW
//sys	findNextFile1(handle Handle, data *win32finddata1) (err error) = FindNextFileW
//sys	FindClose(handle Handle) (err error)
//sys	GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error)
//sys	GetFileInformationByHandleEx(handle Handle, class uint32, outBuffer *byte, outBufferLen uint32) (err error)
//sys	GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) = GetCurrentDirectoryW
//sys	SetCurrentDirectory(path *uint16) (err error) = SetCurrentDirectoryW
//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW
//sys	RemoveDirectory(path *uint16) (err error) = RemoveDirectoryW
//sys	DeleteFile(path *uint16) (err error) = DeleteFileW
//sys	MoveFile(from *uint16, to *uint16) (err error) = MoveFileW
//sys	MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) = MoveFileExW
//sys	LockFileEx(file Handle, flags uint32, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error)
//sys	UnlockFileEx(file Handle, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error)
//sys	GetComputerName(buf *uint16, n *uint32) (err error) = GetComputerNameW
//sys	GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW
//sys	SetEndOfFile(handle Handle) (err error)
//sys	GetSystemTimeAsFileTime(time *Filetime)
//sys	GetSystemTimePreciseAsFileTime(time *Filetime)
//sys	GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) [failretval==0xffffffff]
//sys	CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error)
//sys	GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error)
//sys	PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error)
//sys	CancelIo(s Handle) (err error)
//sys	CancelIoEx(s Handle, o *Overlapped) (err error)
//sys	CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) = CreateProcessW
//sys	OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error)
//sys	ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) [failretval<=32] = shell32.ShellExecuteW
//sys	shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) = shell32.SHGetKnownFolderPath
//sys	TerminateProcess(handle Handle, exitcode uint32) (err error)
//sys	GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)
//sys	GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW
//sys	GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)
//sys	DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)
//sys	WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff]
//sys	waitForMultipleObjects(count uint32, handles uintptr, waitAll bool, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff] = WaitForMultipleObjects
//sys	GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) = GetTempPathW
//sys	CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)
//sys	GetFileType(filehandle Handle) (n uint32, err error)
//sys	CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW
//sys	CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext
//sys	CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) = advapi32.CryptGenRandom
//sys	GetEnvironmentStrings() (envs *uint16, err error) [failretval==nil] = kernel32.GetEnvironmentStringsW
//sys	FreeEnvironmentStrings(envs *uint16) (err error) = kernel32.FreeEnvironmentStringsW
//sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW
//sys	SetEnvironmentVariable(name *uint16, value *uint16) (err error) = kernel32.SetEnvironmentVariableW
//sys	CreateEnvironmentBlock(block **uint16, token Token, inheritExisting bool) (err error) = userenv.CreateEnvironmentBlock
//sys	DestroyEnvironmentBlock(block *uint16) (err error) = userenv.DestroyEnvironmentBlock
//sys	getTickCount64() (ms uint64) = kernel32.GetTickCount64
//sys	SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)
//sys	GetFileAttributes(name *uint16) (attrs uint32, err error) [failretval==INVALID_FILE_ATTRIBUTES] = kernel32.GetFileAttributesW
//sys	SetFileAttributes(name *uint16, attrs uint32) (err error) = kernel32.SetFileAttributesW
//sys	GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) = kernel32.GetFileAttributesExW
//sys	GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW
//sys	CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error) [failretval==nil] = shell32.CommandLineToArgvW
//sys	LocalFree(hmem Handle) (handle Handle, err error) [failretval!=0]
//sys	SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error)
//sys	FlushFileBuffers(handle Handle) (err error)
//sys	GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) = kernel32.GetFullPathNameW
//sys	GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) = kernel32.GetLongPathNameW
//sys	GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) = kernel32.GetShortPathNameW
//sys	CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) = kernel32.CreateFileMappingW
//sys	MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)
//sys	UnmapViewOfFile(addr uintptr) (err error)
//sys	FlushViewOfFile(addr uintptr, length uintptr) (err error)
//sys	VirtualLock(addr uintptr, length uintptr) (err error)
//sys	VirtualUnlock(addr uintptr, length uintptr) (err error)
//sys	VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) = kernel32.VirtualAlloc
//sys	VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) = kernel32.VirtualFree
//sys	VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) = kernel32.VirtualProtect
//sys	TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) = mswsock.TransmitFile
//sys	ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) = kernel32.ReadDirectoryChangesW
//sys	CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) = crypt32.CertOpenSystemStoreW
//sys   CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) [failretval==InvalidHandle] = crypt32.CertOpenStore
//sys	CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) [failretval==nil] = crypt32.CertEnumCertificatesInStore
//sys   CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) = crypt32.CertAddCertificateContextToStore
//sys	CertCloseStore(store Handle, flags uint32) (err error) = crypt32.CertCloseStore
//sys   CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) = crypt32.CertGetCertificateChain
//sys   CertFreeCertificateChain(ctx *CertChainContext) = crypt32.CertFreeCertificateChain
//sys   CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) [failretval==nil] = crypt32.CertCreateCertificateContext
//sys   CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext
//sys   CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy
//sys	RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW
//sys	RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey
//sys	RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegQueryInfoKeyW
//sys	RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegEnumKeyExW
//sys	RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) = advapi32.RegQueryValueExW
//sys	GetCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId
//sys	GetConsoleMode(console Handle, mode *uint32) (err error) = kernel32.GetConsoleMode
//sys	SetConsoleMode(console Handle, mode uint32) (err error) = kernel32.SetConsoleMode
//sys	GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) = kernel32.GetConsoleScreenBufferInfo
//sys	WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) = kernel32.WriteConsoleW
//sys	ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) = kernel32.ReadConsoleW
//sys	CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) [failretval==InvalidHandle] = kernel32.CreateToolhelp32Snapshot
//sys	Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32FirstW
//sys	Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW
//sys	Thread32First(snapshot Handle, threadEntry *ThreadEntry32) (err error)
//sys	Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error)
//sys	DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)
// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
//sys	CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) [failretval&0xff==0] = CreateHardLinkW
//sys	GetCurrentThreadId() (id uint32)
//sys	CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) = kernel32.CreateEventW
//sys	CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) = kernel32.CreateEventExW
//sys	OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenEventW
//sys	SetEvent(event Handle) (err error) = kernel32.SetEvent
//sys	ResetEvent(event Handle) (err error) = kernel32.ResetEvent
//sys	PulseEvent(event Handle) (err error) = kernel32.PulseEvent
//sys	CreateMutex(mutexAttrs *SecurityAttributes, initialOwner bool, name *uint16) (handle Handle, err error) = kernel32.CreateMutexW
//sys	CreateMutexEx(mutexAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) = kernel32.CreateMutexExW
//sys	OpenMutex(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenMutexW
//sys	ReleaseMutex(mutex Handle) (err error) = kernel32.ReleaseMutex
//sys	SleepEx(milliseconds uint32, alertable bool) (ret uint32) = kernel32.SleepEx
//sys	CreateJobObject(jobAttr *SecurityAttributes, name *uint16) (handle Handle, err error) = kernel32.CreateJobObjectW
//sys	AssignProcessToJobObject(job Handle, process Handle) (err error) = kernel32.AssignProcessToJobObject
//sys	TerminateJobObject(job Handle, exitCode uint32) (err error) = kernel32.TerminateJobObject
//sys	SetErrorMode(mode uint32) (ret uint32) = kernel32.SetErrorMode
//sys	ResumeThread(thread Handle) (ret uint32, err error) [failretval==0xffffffff] = kernel32.ResumeThread
//sys	SetPriorityClass(process Handle, priorityClass uint32) (err error) = kernel32.SetPriorityClass
//sys	GetPriorityClass(process Handle) (ret uint32, err error) = kernel32.GetPriorityClass
//sys	SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error)
//sys	GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error)
//sys	GetProcessId(process Handle) (id uint32, err error)
//sys	OpenThread(desiredAccess uint32, inheritHandle bool, threadId uint32) (handle Handle, err error)
//sys	SetProcessPriorityBoost(process Handle, disable bool) (err error) = kernel32.SetProcessPriorityBoost

// Volume Management Functions
//sys	DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) = DefineDosDeviceW
//sys	DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) = DeleteVolumeMountPointW
//sys	FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeW
//sys	FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstVolumeMountPointW
//sys	FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW
//sys	FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW
//sys	FindVolumeClose(findVolume Handle) (err error)
//sys	FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error)
//sys	GetDiskFreeSpaceEx(directoryName *uint16, freeBytesAvailableToCaller *uint64, totalNumberOfBytes *uint64, totalNumberOfFreeBytes *uint64) (err error) = GetDiskFreeSpaceExW
//sys	GetDriveType(rootPathName *uint16) (driveType uint32) = GetDriveTypeW
//sys	GetLogicalDrives() (drivesBitMask uint32, err error) [failretval==0]
//sys	GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) [failretval==0] = GetLogicalDriveStringsW
//sys	GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationW
//sys	GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationByHandleW
//sys	GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) = GetVolumeNameForVolumeMountPointW
//sys	GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) = GetVolumePathNameW
//sys	GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW
//sys	QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) [failretval==0] = QueryDosDeviceW
//sys	SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) = SetVolumeLabelW
//sys	SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW
//sys	MessageBox(hwnd Handle, text *uint16, caption *uint16, boxtype uint32) (ret int32, err error) [failretval==0] = user32.MessageBoxW
//sys	ExitWindowsEx(flags uint32, reason uint32) (err error) = user32.ExitWindowsEx
//sys	InitiateSystemShutdownEx(machineName *uint16, message *uint16, timeout uint32, forceAppsClosed bool, rebootAfterShutdown bool, reason uint32) (err error) = advapi32.InitiateSystemShutdownExW
//sys	SetProcessShutdownParameters(level uint32, flags uint32) (err error) = kernel32.SetProcessShutdownParameters
//sys	GetProcessShutdownParameters(level *uint32, flags *uint32) (err error) = kernel32.GetProcessShutdownParameters
//sys	clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) = ole32.CLSIDFromString
//sys	stringFromGUID2(rguid *GUID, lpsz *uint16, cchMax int32) (chars int32) = ole32.StringFromGUID2
//sys	coCreateGuid(pguid *GUID) (ret error) = ole32.CoCreateGuid
//sys	CoTaskMemFree(address unsafe.Pointer) = ole32.CoTaskMemFree
//sys	rtlGetVersion(info *OsVersionInfoEx) (ret error) = ntdll.RtlGetVersion
//sys	rtlGetNtVersionNumbers(majorVersion *uint32, minorVersion *uint32, buildNumber *uint32) = ntdll.RtlGetNtVersionNumbers
//sys	getProcessPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetProcessPreferredUILanguages
//sys	getThreadPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetThreadPreferredUILanguages
//sys	getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetUserPreferredUILanguages
//sys	getSystemPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) = kernel32.GetSystemPreferredUILanguages

// Process Status API (PSAPI)
//sys	EnumProcesses(processIds []uint32, bytesReturned *uint32) (err error) = psapi.EnumProcesses

// syscall interface implementation for other packages

// GetCurrentProcess returns the handle for the current process.
// It is a pseudo handle that does not need to be closed.
// The returned error is always nil.
//
// Deprecated: use CurrentProcess for the same Handle without the nil
// error.
func GetCurrentProcess() (Handle, error) {
	return CurrentProcess(), nil
}

// CurrentProcess returns the handle for the current process.
// It is a pseudo handle that does not need to be closed.
func CurrentProcess() Handle { return Handle(^uintptr(1 - 1)) }

// GetCurrentThread returns the handle for the current thread.
// It is a pseudo handle that does not need to be closed.
// The returned error is always nil.
//
// Deprecated: use CurrentThread for the same Handle without the nil
// error.
func GetCurrentThread() (Handle, error) {
	return CurrentThread(), nil
}

// CurrentThread returns the handle for the current thread.
// It is a pseudo handle that does not need to be closed.
func CurrentThread() Handle { return Handle(^uintptr(2 - 1)) }

// GetProcAddressByOrdinal retrieves the address of the exported
// function from module by ordinal.
func GetProcAddressByOrdinal(module Handle, ordinal uintptr) (proc uintptr, err error) {
	r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), ordinal, 0)
	proc = uintptr(r0)
	if proc == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Exit(code int) { ExitProcess(uint32(code)) }

func makeInheritSa() *SecurityAttributes {
	var sa SecurityAttributes
	sa.Length = uint32(unsafe.Sizeof(sa))
	sa.InheritHandle = 1
	return &sa
}

func Open(path string, mode int, perm uint32) (fd Handle, err error) {
	if len(path) == 0 {
		return InvalidHandle, ERROR_FILE_NOT_FOUND
	}
	pathp, err := UTF16PtrFromString(path)
	if err != nil {
		return InvalidHandle, err
	}
	var access uint32
	switch mode & (O_RDONLY | O_WRONLY | O_RDWR) {
	case O_RDONLY:
		access = GENERIC_READ
	case O_WRONLY:
		access = GENERIC_WRITE
	case O_RDWR:
		access = GENERIC_READ | GENERIC_WRITE
	}
	if mode&O_CREAT != 0 {
		access |= GENERIC_WRITE
	}
	if mode&O_APPEND != 0 {
		access &^= GENERIC_WRITE
		access |= FILE_APPEND_DATA
	}
	sharemode := uint32(FILE_SHARE_READ | FILE_SHARE_WRITE)
	var sa *SecurityAttributes
	if mode&O_CLOEXEC == 0 {
		sa = makeInheritSa()
	}
	var createmode uint32
	switch {
	case mode&(O_CREAT|O_EXCL) == (O_CREAT | O_EXCL):
		createmode = CREATE_NEW
	case mode&(O_CREAT|O_TRUNC) == (O_CREAT | O_TRUNC):
		createmode = CREATE_ALWAYS
	case mode&O_CREAT == O_CREAT:
		createmode = OPEN_ALWAYS
	case mode&O_TRUNC == O_TRUNC:
		createmode = TRUNCATE_EXISTING
	default:
		createmode = OPEN_EXISTING
	}
	var attrs uint32 = FILE_ATTRIBUTE_NORMAL
	if perm&S_IWRITE == 0 {
		attrs = FILE_ATTRIBUTE_READONLY
	}
	h, e := CreateFile(pathp, access, sharemode, sa, createmode, attrs, 0)
	return h, e
}

func Read(fd Handle, p []byte) (n int, err error) {
	var done uint32
	e := ReadFile(fd, p, &done, nil)
	if e != nil {
		if e == ERROR_BROKEN_PIPE {
			// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin
			return 0, nil
		}
		return 0, e
	}
	if raceenabled {
		if done > 0 {
			raceWriteRange(unsafe.Pointer(&p[0]), int(done))
		}
		raceAcquire(unsafe.Pointer(&ioSync))
	}
	return int(done), nil
}

func Write(fd Handle, p []byte) (n int, err error) {
	if raceenabled {
		raceReleaseMerge(unsafe.Pointer(&ioSync))
	}
	var done uint32
	e := WriteFile(fd, p, &done, nil)
	if e != nil {
		return 0, e
	}
	if raceenabled && done > 0 {
		raceReadRange(unsafe.Pointer(&p[0]), int(done))
	}
	return int(done), nil
}

var ioSync int64

func Seek(fd Handle, offset int64, whence int) (newoffset int64, err error) {
	var w uint32
	switch whence {
	case 0:
		w = FILE_BEGIN
	case 1:
		w = FILE_CURRENT
	case 2:
		w = FILE_END
	}
	hi := int32(offset >> 32)
	lo := int32(offset)
	// use GetFileType to check pipe, pipe can't do seek
	ft, _ := GetFileType(fd)
	if ft == FILE_TYPE_PIPE {
		return 0, syscall.EPIPE
	}
	rlo, e := SetFilePointer(fd, lo, &hi, w)
	if e != nil {
		return 0, e
	}
	return int64(hi)<<32 + int64(rlo), nil
}

func Close(fd Handle) (err error) {
	return CloseHandle(fd)
}

var (
	Stdin  = getStdHandle(STD_INPUT_HANDLE)
	Stdout = getStdHandle(STD_OUTPUT_HANDLE)
	Stderr = getStdHandle(STD_ERROR_HANDLE)
)

func getStdHandle(stdhandle uint32) (fd Handle) {
	r, _ := GetStdHandle(stdhandle)
	CloseOnExec(r)
	return r
}

const ImplementsGetwd = true

func Getwd() (wd string, err error) {
	b := make([]uint16, 300)
	n, e := GetCurrentDirectory(uint32(len(b)), &b[0])
	if e != nil {
		return "", e
	}
	return string(utf16.Decode(b[0:n])), nil
}

func Chdir(path string) (err error) {
	pathp, err := UTF16PtrFromString(path)
	if err != nil {
		return err
	}
	return SetCurrentDirectory(pathp)
}

func Mkdir(path string, mode uint32) (err error) {
	pathp, err := UTF16PtrFromString(path)
	if err != nil {
		return err
	}
	return CreateDirectory(pathp, nil)
}

func Rmdir(path string) (err error) {
	pathp, err := UTF16PtrFromString(path)
	if err != nil {
		return err
	}
	return RemoveDirectory(pathp)
}

func Unlink(path string) (err error) {
	pathp, err := UTF16PtrFromString(path)
	if err != nil {
		return err
	}
	return DeleteFile(pathp)
}

func Rename(oldpath, newpath string) (err error) {
	from, err := UTF16PtrFromString(oldpath)
	if err != nil {
		return err
	}
	to, err := UTF16PtrFromString(newpath)
	if err != nil {
		return err
	}
	return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)
}

func ComputerName() (name string, err error) {
	var n uint32 = MAX_COMPUTERNAME_LENGTH + 1
	b := make([]uint16, n)
	e := GetComputerName(&b[0], &n)
	if e != nil {
		return "", e
	}
	return string(utf16.Decode(b[0:n])), nil
}

func DurationSinceBoot() time.Duration {
	return time.Duration(getTickCount64()) * time.Millisecond
}

func Ftruncate(fd Handle, length int64) (err error) {
	curoffset, e := Seek(fd, 0, 1)
	if e != nil {
		return e
	}
	defer Seek(fd, curoffset, 0)
	_, e = Seek(fd, length, 0)
	if e != nil {
		return e
	}
	e = SetEndOfFile(fd)
	if e != nil {
		return e
	}
	return nil
}

func Gettimeofday(tv *Timeval) (err error) {
	var ft Filetime
	GetSystemTimeAsFileTime(&ft)
	*tv = NsecToTimeval(ft.Nanoseconds())
	return nil
}

func Pipe(p []Handle) (err error) {
	if len(p) != 2 {
		return syscall.EINVAL
	}
	var r, w Handle
	e := CreatePipe(&r, &w, makeInheritSa(), 0)
	if e != nil {
		return e
	}
	p[0] = r
	p[1] = w
	return nil
}

func Utimes(path string, tv []Timeval) (err error) {
	if len(tv) != 2 {
		return syscall.EINVAL
	}
	pathp, e := UTF16PtrFromString(path)
	if e != nil {
		return e
	}
	h, e := CreateFile(pathp,
		FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,
		OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
	if e != nil {
		return e
	}
	defer Close(h)
	a := NsecToFiletime(tv[0].Nanoseconds())
	w := NsecToFiletime(tv[1].Nanoseconds())
	return SetFileTime(h, nil, &a, &w)
}

func UtimesNano(path string, ts []Timespec) (err error) {
	if len(ts) != 2 {
		return syscall.EINVAL
	}
	pathp, e := UTF16PtrFromString(path)
	if e != nil {
		return e
	}
	h, e := CreateFile(pathp,
		FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,
		OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
	if e != nil {
		return e
	}
	defer Close(h)
	a := NsecToFiletime(TimespecToNsec(ts[0]))
	w := NsecToFiletime(TimespecToNsec(ts[1]))
	return SetFileTime(h, nil, &a, &w)
}

func Fsync(fd Handle) (err error) {
	return FlushFileBuffers(fd)
}

func Chmod(path string, mode uint32) (err error) {
	p, e := UTF16PtrFromString(path)
	if e != nil {
		return e
	}
	attrs, e := GetFileAttributes(p)
	if e != nil {
		return e
	}
	if mode&S_IWRITE != 0 {
		attrs &^= FILE_ATTRIBUTE_READONLY
	} else {
		attrs |= FILE_ATTRIBUTE_READONLY
	}
	return SetFileAttributes(p, attrs)
}

func LoadGetSystemTimePreciseAsFileTime() error {
	return procGetSystemTimePreciseAsFileTime.Find()
}

func LoadCancelIoEx() error {
	return procCancelIoEx.Find()
}

func LoadSetFileCompletionNotificationModes() error {
	return procSetFileCompletionNotificationModes.Find()
}

func WaitForMultipleObjects(handles []Handle, waitAll bool, waitMilliseconds uint32) (event uint32, err error) {
	// Every other win32 array API takes arguments as "pointer, count", except for this function. So we
	// can't declare it as a usual [] type, because mksyscall will use the opposite order. We therefore
	// trivially stub this ourselves.

	var handlePtr *Handle
	if len(handles) > 0 {
		handlePtr = &handles[0]
	}
	return waitForMultipleObjects(uint32(len(handles)), uintptr(unsafe.Pointer(handlePtr)), waitAll, waitMilliseconds)
}

// net api calls

const socket_error = uintptr(^uint32(0))

//sys	WSAStartup(verreq uint32, data *WSAData) (sockerr error) = ws2_32.WSAStartup
//sys	WSACleanup() (err error) [failretval==socket_error] = ws2_32.WSACleanup
//sys	WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) [failretval==socket_error] = ws2_32.WSAIoctl
//sys	socket(af int32, typ int32, protocol int32) (handle Handle, err error) [failretval==InvalidHandle] = ws2_32.socket
//sys	sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) [failretval==socket_error] = ws2_32.sendto
//sys	recvfrom(s Handle, buf []byte, flags int32, from *RawSockaddrAny, fromlen *int32) (n int32, err error) [failretval==-1] = ws2_32.recvfrom
//sys	Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) [failretval==socket_error] = ws2_32.setsockopt
//sys	Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockopt
//sys	bind(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.bind
//sys	connect(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.connect
//sys	getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockname
//sys	getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getpeername
//sys	listen(s Handle, backlog int32) (err error) [failretval==socket_error] = ws2_32.listen
//sys	shutdown(s Handle, how int32) (err error) [failretval==socket_error] = ws2_32.shutdown
//sys	Closesocket(s Handle) (err error) [failretval==socket_error] = ws2_32.closesocket
//sys	AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) = mswsock.AcceptEx
//sys	GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs
//sys	WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSARecv
//sys	WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSASend
//sys	WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32,  from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSARecvFrom
//sys	WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32,  overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSASendTo
//sys	GetHostByName(name string) (h *Hostent, err error) [failretval==nil] = ws2_32.gethostbyname
//sys	GetServByName(name string, proto string) (s *Servent, err error) [failretval==nil] = ws2_32.getservbyname
//sys	Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs
//sys	GetProtoByName(name string) (p *Protoent, err error) [failretval==nil] = ws2_32.getprotobyname
//sys	DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) = dnsapi.DnsQuery_W
//sys	DnsRecordListFree(rl *DNSRecord, freetype uint32) = dnsapi.DnsRecordListFree
//sys	DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) = dnsapi.DnsNameCompare_W
//sys	GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) = ws2_32.GetAddrInfoW
//sys	FreeAddrInfoW(addrinfo *AddrinfoW) = ws2_32.FreeAddrInfoW
//sys	GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry
//sys	GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) = iphlpapi.GetAdaptersInfo
//sys	SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes
//sys	WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) [failretval==-1] = ws2_32.WSAEnumProtocolsW
//sys	GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) = iphlpapi.GetAdaptersAddresses
//sys	GetACP() (acp uint32) = kernel32.GetACP
//sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar

// For testing: clients can set this flag to force
// creation of IPv6 sockets to return EAFNOSUPPORT.
var SocketDisableIPv6 bool

type RawSockaddrInet4 struct {
	Family uint16
	Port   uint16
	Addr   [4]byte /* in_addr */
	Zero   [8]uint8
}

type RawSockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte /* in6_addr */
	Scope_id uint32
}

type RawSockaddr struct {
	Family uint16
	Data   [14]int8
}

type RawSockaddrAny struct {
	Addr RawSockaddr
	Pad  [100]int8
}

type Sockaddr interface {
	sockaddr() (ptr unsafe.Pointer, len int32, err error) // lowercase; only we can define Sockaddrs
}

type SockaddrInet4 struct {
	Port int
	Addr [4]byte
	raw  RawSockaddrInet4
}

func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, int32, error) {
	if sa.Port < 0 || sa.Port > 0xFFFF {
		return nil, 0, syscall.EINVAL
	}
	sa.raw.Family = AF_INET
	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
	p[0] = byte(sa.Port >> 8)
	p[1] = byte(sa.Port)
	for i := 0; i < len(sa.Addr); i++ {
		sa.raw.Addr[i] = sa.Addr[i]
	}
	return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil
}

type SockaddrInet6 struct {
	Port   int
	ZoneId uint32
	Addr   [16]byte
	raw    RawSockaddrInet6
}

func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, int32, error) {
	if sa.Port < 0 || sa.Port > 0xFFFF {
		return nil, 0, syscall.EINVAL
	}
	sa.raw.Family = AF_INET6
	p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
	p[0] = byte(sa.Port >> 8)
	p[1] = byte(sa.Port)
	sa.raw.Scope_id = sa.ZoneId
	for i := 0; i < len(sa.Addr); i++ {
		sa.raw.Addr[i] = sa.Addr[i]
	}
	return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil
}

type RawSockaddrUnix struct {
	Family uint16
	Path   [UNIX_PATH_MAX]int8
}

type SockaddrUnix struct {
	Name string
	raw  RawSockaddrUnix
}

func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, int32, error) {
	name := sa.Name
	n := len(name)
	if n > len(sa.raw.Path) {
		return nil, 0, syscall.EINVAL
	}
	if n == len(sa.raw.Path) && name[0] != '@' {
		return nil, 0, syscall.EINVAL
	}
	sa.raw.Family = AF_UNIX
	for i := 0; i < n; i++ {
		sa.raw.Path[i] = int8(name[i])
	}
	// length is family (uint16), name, NUL.
	sl := int32(2)
	if n > 0 {
		sl += int32(n) + 1
	}
	if sa.raw.Path[0] == '@' {
		sa.raw.Path[0] = 0
		// Don't count trailing NUL for abstract address.
		sl--
	}

	return unsafe.Pointer(&sa.raw), sl, nil
}

func (rsa *RawSockaddrAny) Sockaddr() (Sockaddr, error) {
	switch rsa.Addr.Family {
	case AF_UNIX:
		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
		sa := new(SockaddrUnix)
		if pp.Path[0] == 0 {
			// "Abstract" Unix domain socket.
			// Rewrite leading NUL as @ for textual display.
			// (This is the standard convention.)
			// Not friendly to overwrite in place,
			// but the callers below don't care.
			pp.Path[0] = '@'
		}

		// Assume path ends at NUL.
		// This is not technically the Linux semantics for
		// abstract Unix domain sockets--they are supposed
		// to be uninterpreted fixed-size binary blobs--but
		// everyone uses this convention.
		n := 0
		for n < len(pp.Path) && pp.Path[n] != 0 {
			n++
		}
		bytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))[0:n]
		sa.Name = string(bytes)
		return sa, nil

	case AF_INET:
		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
		sa := new(SockaddrInet4)
		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
		sa.Port = int(p[0])<<8 + int(p[1])
		for i := 0; i < len(sa.Addr); i++ {
			sa.Addr[i] = pp.Addr[i]
		}
		return sa, nil

	case AF_INET6:
		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
		sa := new(SockaddrInet6)
		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
		sa.Port = int(p[0])<<8 + int(p[1])
		sa.ZoneId = pp.Scope_id
		for i := 0; i < len(sa.Addr); i++ {
			sa.Addr[i] = pp.Addr[i]
		}
		return sa, nil
	}
	return nil, syscall.EAFNOSUPPORT
}

func Socket(domain, typ, proto int) (fd Handle, err error) {
	if domain == AF_INET6 && SocketDisableIPv6 {
		return InvalidHandle, syscall.EAFNOSUPPORT
	}
	return socket(int32(domain), int32(typ), int32(proto))
}

func SetsockoptInt(fd Handle, level, opt int, value int) (err error) {
	v := int32(value)
	return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&v)), int32(unsafe.Sizeof(v)))
}

func Bind(fd Handle, sa Sockaddr) (err error) {
	ptr, n, err := sa.sockaddr()
	if err != nil {
		return err
	}
	return bind(fd, ptr, n)
}

func Connect(fd Handle, sa Sockaddr) (err error) {
	ptr, n, err := sa.sockaddr()
	if err != nil {
		return err
	}
	return connect(fd, ptr, n)
}

func Getsockname(fd Handle) (sa Sockaddr, err error) {
	var rsa RawSockaddrAny
	l := int32(unsafe.Sizeof(rsa))
	if err = getsockname(fd, &rsa, &l); err != nil {
		return
	}
	return rsa.Sockaddr()
}

func Getpeername(fd Handle) (sa Sockaddr, err error) {
	var rsa RawSockaddrAny
	l := int32(unsafe.Sizeof(rsa))
	if err = getpeername(fd, &rsa, &l); err != nil {
		return
	}
	return rsa.Sockaddr()
}

func Listen(s Handle, n int) (err error) {
	return listen(s, int32(n))
}

func Shutdown(fd Handle, how int) (err error) {
	return shutdown(fd, int32(how))
}

func WSASendto(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to Sockaddr, overlapped *Overlapped, croutine *byte) (err error) {
	rsa, l, err := to.sockaddr()
	if err != nil {
		return err
	}
	return WSASendTo(s, bufs, bufcnt, sent, flags, (*RawSockaddrAny)(unsafe.Pointer(rsa)), l, overlapped, croutine)
}

func LoadGetAddrInfo() error {
	return procGetAddrInfoW.Find()
}

var connectExFunc struct {
	once sync.Once
	addr uintptr
	err  error
}

func LoadConnectEx() error {
	connectExFunc.once.Do(func() {
		var s Handle
		s, connectExFunc.err = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
		if connectExFunc.err != nil {
			return
		}
		defer CloseHandle(s)
		var n uint32
		connectExFunc.err = WSAIoctl(s,
			SIO_GET_EXTENSION_FUNCTION_POINTER,
			(*byte)(unsafe.Pointer(&WSAID_CONNECTEX)),
			uint32(unsafe.Sizeof(WSAID_CONNECTEX)),
			(*byte)(unsafe.Pointer(&connectExFunc.addr)),
			uint32(unsafe.Sizeof(connectExFunc.addr)),
			&n, nil, 0)
	})
	return connectExFunc.err
}

func connectEx(s Handle, name unsafe.Pointer, namelen int32, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall9(connectExFunc.addr, 7, uintptr(s), uintptr(name), uintptr(namelen), uintptr(unsafe.Pointer(sendBuf)), uintptr(sendDataLen), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ConnectEx(fd Handle, sa Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) error {
	err := LoadConnectEx()
	if err != nil {
		return errorspkg.New("failed to find ConnectEx: " + err.Error())
	}
	ptr, n, err := sa.sockaddr()
	if err != nil {
		return err
	}
	return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped)
}

var sendRecvMsgFunc struct {
	once     sync.Once
	sendAddr uintptr
	recvAddr uintptr
	err      error
}

func loadWSASendRecvMsg() error {
	sendRecvMsgFunc.once.Do(func() {
		var s Handle
		s, sendRecvMsgFunc.err = Socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
		if sendRecvMsgFunc.err != nil {
			return
		}
		defer CloseHandle(s)
		var n uint32
		sendRecvMsgFunc.err = WSAIoctl(s,
			SIO_GET_EXTENSION_FUNCTION_POINTER,
			(*byte)(unsafe.Pointer(&WSAID_WSARECVMSG)),
			uint32(unsafe.Sizeof(WSAID_WSARECVMSG)),
			(*byte)(unsafe.Pointer(&sendRecvMsgFunc.recvAddr)),
			uint32(unsafe.Sizeof(sendRecvMsgFunc.recvAddr)),
			&n, nil, 0)
		if sendRecvMsgFunc.err != nil {
			return
		}
		sendRecvMsgFunc.err = WSAIoctl(s,
			SIO_GET_EXTENSION_FUNCTION_POINTER,
			(*byte)(unsafe.Pointer(&WSAID_WSASENDMSG)),
			uint32(unsafe.Sizeof(WSAID_WSASENDMSG)),
			(*byte)(unsafe.Pointer(&sendRecvMsgFunc.sendAddr)),
			uint32(unsafe.Sizeof(sendRecvMsgFunc.sendAddr)),
			&n, nil, 0)
	})
	return sendRecvMsgFunc.err
}

func WSASendMsg(fd Handle, msg *WSAMsg, flags uint32, bytesSent *uint32, overlapped *Overlapped, croutine *byte) error {
	err := loadWSASendRecvMsg()
	if err != nil {
		return err
	}
	r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.sendAddr, 6, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(flags), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return err
}

func WSARecvMsg(fd Handle, msg *WSAMsg, bytesReceived *uint32, overlapped *Overlapped, croutine *byte) error {
	err := loadWSASendRecvMsg()
	if err != nil {
		return err
	}
	r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.recvAddr, 5, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(unsafe.Pointer(bytesReceived)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return err
}

// Invented structures to support what package os expects.
type Rusage struct {
	CreationTime Filetime
	ExitTime     Filetime
	KernelTime   Filetime
	UserTime     Filetime
}

type WaitStatus struct {
	ExitCode uint32
}

func (w WaitStatus) Exited() bool { return true }

func (w WaitStatus) ExitStatus() int { return int(w.ExitCode) }

func (w WaitStatus) Signal() Signal { return -1 }

func (w WaitStatus) CoreDump() bool { return false }

func (w WaitStatus) Stopped() bool { return false }

func (w WaitStatus) Continued() bool { return false }

func (w WaitStatus) StopSignal() Signal { return -1 }

func (w WaitStatus) Signaled() bool { return false }

func (w WaitStatus) TrapCause() int { return -1 }

// Timespec is an invented structure on Windows, but here for
// consistency with the corresponding package for other operating systems.
type Timespec struct {
	Sec  int64
	Nsec int64
}

func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }

func NsecToTimespec(nsec int64) (ts Timespec) {
	ts.Sec = nsec / 1e9
	ts.Nsec = nsec % 1e9
	return
}

// TODO(brainman): fix all needed for net

func Accept(fd Handle) (nfd Handle, sa Sockaddr, err error) { return 0, nil, syscall.EWINDOWS }

func Recvfrom(fd Handle, p []byte, flags int) (n int, from Sockaddr, err error) {
	var rsa RawSockaddrAny
	l := int32(unsafe.Sizeof(rsa))
	n32, err := recvfrom(fd, p, int32(flags), &rsa, &l)
	n = int(n32)
	if err != nil {
		return
	}
	from, err = rsa.Sockaddr()
	return
}

func Sendto(fd Handle, p []byte, flags int, to Sockaddr) (err error) {
	ptr, l, err := to.sockaddr()
	if err != nil {
		return err
	}
	return sendto(fd, p, int32(flags), ptr, l)
}

func SetsockoptTimeval(fd Handle, level, opt int, tv *Timeval) (err error) { return syscall.EWINDOWS }

// The Linger struct is wrong but we only noticed after Go 1.
// sysLinger is the real system call structure.

// BUG(brainman): The definition of Linger is not appropriate for direct use
// with Setsockopt and Getsockopt.
// Use SetsockoptLinger instead.

type Linger struct {
	Onoff  int32
	Linger int32
}

type sysLinger struct {
	Onoff  uint16
	Linger uint16
}

type IPMreq struct {
	Multiaddr [4]byte /* in_addr */
	Interface [4]byte /* in_addr */
}

type IPv6Mreq struct {
	Multiaddr [16]byte /* in6_addr */
	Interface uint32
}

func GetsockoptInt(fd Handle, level, opt int) (int, error) { return -1, syscall.EWINDOWS }

func SetsockoptLinger(fd Handle, level, opt int, l *Linger) (err error) {
	sys := sysLinger{Onoff: uint16(l.Onoff), Linger: uint16(l.Linger)}
	return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&sys)), int32(unsafe.Sizeof(sys)))
}

func SetsockoptInet4Addr(fd Handle, level, opt int, value [4]byte) (err error) {
	return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&value[0])), 4)
}
func SetsockoptIPMreq(fd Handle, level, opt int, mreq *IPMreq) (err error) {
	return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(mreq)), int32(unsafe.Sizeof(*mreq)))
}
func SetsockoptIPv6Mreq(fd Handle, level, opt int, mreq *IPv6Mreq) (err error) {
	return syscall.EWINDOWS
}

func Getpid() (pid int) { return int(GetCurrentProcessId()) }

func FindFirstFile(name *uint16, data *Win32finddata) (handle Handle, err error) {
	// NOTE(rsc): The Win32finddata struct is wrong for the system call:
	// the two paths are each one uint16 short. Use the correct struct,
	// a win32finddata1, and then copy the results out.
	// There is no loss of expressivity here, because the final
	// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.
	// For Go 1.1, we might avoid the allocation of win32finddata1 here
	// by adding a final Bug [2]uint16 field to the struct and then
	// adjusting the fields in the result directly.
	var data1 win32finddata1
	handle, err = findFirstFile1(name, &data1)
	if err == nil {
		copyFindData(data, &data1)
	}
	return
}

func FindNextFile(handle Handle, data *Win32finddata) (err error) {
	var data1 win32finddata1
	err = findNextFile1(handle, &data1)
	if err == nil {
		copyFindData(data, &data1)
	}
	return
}

func getProcessEntry(pid int) (*ProcessEntry32, error) {
	snapshot, err := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
	if err != nil {
		return nil, err
	}
	defer CloseHandle(snapshot)
	var procEntry ProcessEntry32
	procEntry.Size = uint32(unsafe.Sizeof(procEntry))
	if err = Process32First(snapshot, &procEntry); err != nil {
		return nil, err
	}
	for {
		if procEntry.ProcessID == uint32(pid) {
			return &procEntry, nil
		}
		err = Process32Next(snapshot, &procEntry)
		if err != nil {
			return nil, err
		}
	}
}

func Getppid() (ppid int) {
	pe, err := getProcessEntry(Getpid())
	if err != nil {
		return -1
	}
	return int(pe.ParentProcessID)
}

// TODO(brainman): fix all needed for os
func Fchdir(fd Handle) (err error)             { return syscall.EWINDOWS }
func Link(oldpath, newpath string) (err error) { return syscall.EWINDOWS }
func Symlink(path, link string) (err error)    { return syscall.EWINDOWS }

func Fchmod(fd Handle, mode uint32) (err error)        { return syscall.EWINDOWS }
func Chown(path string, uid int, gid int) (err error)  { return syscall.EWINDOWS }
func Lchown(path string, uid int, gid int) (err error) { return syscall.EWINDOWS }
func Fchown(fd Handle, uid int, gid int) (err error)   { return syscall.EWINDOWS }

func Getuid() (uid int)                  { return -1 }
func Geteuid() (euid int)                { return -1 }
func Getgid() (gid int)                  { return -1 }
func Getegid() (egid int)                { return -1 }
func Getgroups() (gids []int, err error) { return nil, syscall.EWINDOWS }

type Signal int

func (s Signal) Signal() {}

func (s Signal) String() string {
	if 0 <= s && int(s) < len(signals) {
		str := signals[s]
		if str != "" {
			return str
		}
	}
	return "signal " + itoa(int(s))
}

func LoadCreateSymbolicLink() error {
	return procCreateSymbolicLinkW.Find()
}

// Readlink returns the destination of the named symbolic link.
func Readlink(path string, buf []byte) (n int, err error) {
	fd, err := CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nil, OPEN_EXISTING,
		FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS, 0)
	if err != nil {
		return -1, err
	}
	defer CloseHandle(fd)

	rdbbuf := make([]byte, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)
	var bytesReturned uint32
	err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nil, 0, &rdbbuf[0], uint32(len(rdbbuf)), &bytesReturned, nil)
	if err != nil {
		return -1, err
	}

	rdb := (*reparseDataBuffer)(unsafe.Pointer(&rdbbuf[0]))
	var s string
	switch rdb.ReparseTag {
	case IO_REPARSE_TAG_SYMLINK:
		data := (*symbolicLinkReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))
		p := (*[0xffff]uint16)(unsafe.Pointer(&data.PathBuffer[0]))
		s = UTF16ToString(p[data.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2])
	case IO_REPARSE_TAG_MOUNT_POINT:
		data := (*mountPointReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))
		p := (*[0xffff]uint16)(unsafe.Pointer(&data.PathBuffer[0]))
		s = UTF16ToString(p[data.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2])
	default:
		// the path is not a symlink or junction but another type of reparse
		// point
		return -1, syscall.ENOENT
	}
	n = copy(buf, []byte(s))

	return n, nil
}

// GUIDFromString parses a string in the form of
// "{XXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" into a GUID.
func GUIDFromString(str string) (GUID, error) {
	guid := GUID{}
	str16, err := syscall.UTF16PtrFromString(str)
	if err != nil {
		return guid, err
	}
	err = clsidFromString(str16, &guid)
	if err != nil {
		return guid, err
	}
	return guid, nil
}

// GenerateGUID creates a new random GUID.
func GenerateGUID() (GUID, error) {
	guid := GUID{}
	err := coCreateGuid(&guid)
	if err != nil {
		return guid, err
	}
	return guid, nil
}

// String returns the canonical string form of the GUID,
// in the form of "{XXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}".
func (guid GUID) String() string {
	var str [100]uint16
	chars := stringFromGUID2(&guid, &str[0], int32(len(str)))
	if chars <= 1 {
		return ""
	}
	return string(utf16.Decode(str[:chars-1]))
}

// KnownFolderPath returns a well-known folder path for the current user, specified by one of
// the FOLDERID_ constants, and chosen and optionally created based on a KF_ flag.
func KnownFolderPath(folderID *KNOWNFOLDERID, flags uint32) (string, error) {
	return Token(0).KnownFolderPath(folderID, flags)
}

// KnownFolderPath returns a well-known folder path for the user token, specified by one of
// the FOLDERID_ constants, and chosen and optionally created based on a KF_ flag.
func (t Token) KnownFolderPath(folderID *KNOWNFOLDERID, flags uint32) (string, error) {
	var p *uint16
	err := shGetKnownFolderPath(folderID, flags, t, &p)
	if err != nil {
		return "", err
	}
	defer CoTaskMemFree(unsafe.Pointer(p))
	return UTF16ToString((*[(1 << 30) - 1]uint16)(unsafe.Pointer(p))[:]), nil
}

// RtlGetVersion returns the version of the underlying operating system, ignoring
// manifest semantics but is affected by the application compatibility layer.
func RtlGetVersion() *OsVersionInfoEx {
	info := &OsVersionInfoEx{}
	info.osVersionInfoSize = uint32(unsafe.Sizeof(*info))
	// According to documentation, this function always succeeds.
	// The function doesn't even check the validity of the
	// osVersionInfoSize member. Disassembling ntdll.dll indicates
	// that the documentation is indeed correct about that.
	_ = rtlGetVersion(info)
	return info
}

// RtlGetNtVersionNumbers returns the version of the underlying operating system,
// ignoring manifest semantics and the application compatibility layer.
func RtlGetNtVersionNumbers() (majorVersion, minorVersion, buildNumber uint32) {
	rtlGetNtVersionNumbers(&majorVersion, &minorVersion, &buildNumber)
	buildNumber &= 0xffff
	return
}

// GetProcessPreferredUILanguages retrieves the process preferred UI languages.
func GetProcessPreferredUILanguages(flags uint32) ([]string, error) {
	return getUILanguages(flags, getProcessPreferredUILanguages)
}

// GetThreadPreferredUILanguages retrieves the thread preferred UI languages for the current thread.
func GetThreadPreferredUILanguages(flags uint32) ([]string, error) {
	return getUILanguages(flags, getThreadPreferredUILanguages)
}

// GetUserPreferredUILanguages retrieves information about the user preferred UI languages.
func GetUserPreferredUILanguages(flags uint32) ([]string, error) {
	return getUILanguages(flags, getUserPreferredUILanguages)
}

// GetSystemPreferredUILanguages retrieves the system preferred UI languages.
func GetSystemPreferredUILanguages(flags uint32) ([]string, error) {
	return getUILanguages(flags, getSystemPreferredUILanguages)
}

func getUILanguages(flags uint32, f func(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) error) ([]string, error) {
	size := uint32(128)
	for {
		var numLanguages uint32
		buf := make([]uint16, size)
		err := f(flags, &numLanguages, &buf[0], &size)
		if err == ERROR_INSUFFICIENT_BUFFER {
			continue
		}
		if err != nil {
			return nil, err
		}
		buf = buf[:size]
		if numLanguages == 0 || len(buf) == 0 { // GetProcessPreferredUILanguages may return numLanguages==0 with "\0\0"
			return []string{}, nil
		}
		if buf[len(buf)-1] == 0 {
			buf = buf[:len(buf)-1] // remove terminating null
		}
		languages := make([]string, 0, numLanguages)
		from := 0
		for i, c := range buf {
			if c == 0 {
				languages = append(languages, string(utf16.Decode(buf[from:i])))
				from = i + 1
			}
		}
		return languages, nil
	}
}

+ f bff74f7724a7485d92a01b57c72d843398e76ba8151813a8a3f82a50605f04d0 vendor/golang.org/x/sys/windows/types_windows.go
utf8file 1787
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

import (
	"net"
	"syscall"
	"unsafe"
)

const (
	// Invented values to support what package os expects.
	O_RDONLY   = 0x00000
	O_WRONLY   = 0x00001
	O_RDWR     = 0x00002
	O_CREAT    = 0x00040
	O_EXCL     = 0x00080
	O_NOCTTY   = 0x00100
	O_TRUNC    = 0x00200
	O_NONBLOCK = 0x00800
	O_APPEND   = 0x00400
	O_SYNC     = 0x01000
	O_ASYNC    = 0x02000
	O_CLOEXEC  = 0x80000
)

const (
	// More invented values for signals
	SIGHUP  = Signal(0x1)
	SIGINT  = Signal(0x2)
	SIGQUIT = Signal(0x3)
	SIGILL  = Signal(0x4)
	SIGTRAP = Signal(0x5)
	SIGABRT = Signal(0x6)
	SIGBUS  = Signal(0x7)
	SIGFPE  = Signal(0x8)
	SIGKILL = Signal(0x9)
	SIGSEGV = Signal(0xb)
	SIGPIPE = Signal(0xd)
	SIGALRM = Signal(0xe)
	SIGTERM = Signal(0xf)
)

var signals = [...]string{
	1:  "hangup",
	2:  "interrupt",
	3:  "quit",
	4:  "illegal instruction",
	5:  "trace/breakpoint trap",
	6:  "aborted",
	7:  "bus error",
	8:  "floating point exception",
	9:  "killed",
	10: "user defined signal 1",
	11: "segmentation fault",
	12: "user defined signal 2",
	13: "broken pipe",
	14: "alarm clock",
	15: "terminated",
}

const (
	FILE_LIST_DIRECTORY   = 0x00000001
	FILE_APPEND_DATA      = 0x00000004
	FILE_WRITE_ATTRIBUTES = 0x00000100

	FILE_SHARE_READ   = 0x00000001
	FILE_SHARE_WRITE  = 0x00000002
	FILE_SHARE_DELETE = 0x00000004

	FILE_ATTRIBUTE_READONLY              = 0x00000001
	FILE_ATTRIBUTE_HIDDEN                = 0x00000002
	FILE_ATTRIBUTE_SYSTEM                = 0x00000004
	FILE_ATTRIBUTE_DIRECTORY             = 0x00000010
	FILE_ATTRIBUTE_ARCHIVE               = 0x00000020
	FILE_ATTRIBUTE_DEVICE                = 0x00000040
	FILE_ATTRIBUTE_NORMAL                = 0x00000080
	FILE_ATTRIBUTE_TEMPORARY             = 0x00000100
	FILE_ATTRIBUTE_SPARSE_FILE           = 0x00000200
	FILE_ATTRIBUTE_REPARSE_POINT         = 0x00000400
	FILE_ATTRIBUTE_COMPRESSED            = 0x00000800
	FILE_ATTRIBUTE_OFFLINE               = 0x00001000
	FILE_ATTRIBUTE_NOT_CONTENT_INDEXED   = 0x00002000
	FILE_ATTRIBUTE_ENCRYPTED             = 0x00004000
	FILE_ATTRIBUTE_INTEGRITY_STREAM      = 0x00008000
	FILE_ATTRIBUTE_VIRTUAL               = 0x00010000
	FILE_ATTRIBUTE_NO_SCRUB_DATA         = 0x00020000
	FILE_ATTRIBUTE_RECALL_ON_OPEN        = 0x00040000
	FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x00400000

	INVALID_FILE_ATTRIBUTES = 0xffffffff

	CREATE_NEW        = 1
	CREATE_ALWAYS     = 2
	OPEN_EXISTING     = 3
	OPEN_ALWAYS       = 4
	TRUNCATE_EXISTING = 5

	FILE_FLAG_OPEN_REQUIRING_OPLOCK = 0x00040000
	FILE_FLAG_FIRST_PIPE_INSTANCE   = 0x00080000
	FILE_FLAG_OPEN_NO_RECALL        = 0x00100000
	FILE_FLAG_OPEN_REPARSE_POINT    = 0x00200000
	FILE_FLAG_SESSION_AWARE         = 0x00800000
	FILE_FLAG_POSIX_SEMANTICS       = 0x01000000
	FILE_FLAG_BACKUP_SEMANTICS      = 0x02000000
	FILE_FLAG_DELETE_ON_CLOSE       = 0x04000000
	FILE_FLAG_SEQUENTIAL_SCAN       = 0x08000000
	FILE_FLAG_RANDOM_ACCESS         = 0x10000000
	FILE_FLAG_NO_BUFFERING          = 0x20000000
	FILE_FLAG_OVERLAPPED            = 0x40000000
	FILE_FLAG_WRITE_THROUGH         = 0x80000000

	HANDLE_FLAG_INHERIT    = 0x00000001
	STARTF_USESTDHANDLES   = 0x00000100
	STARTF_USESHOWWINDOW   = 0x00000001
	DUPLICATE_CLOSE_SOURCE = 0x00000001
	DUPLICATE_SAME_ACCESS  = 0x00000002

	STD_INPUT_HANDLE  = -10 & (1<<32 - 1)
	STD_OUTPUT_HANDLE = -11 & (1<<32 - 1)
	STD_ERROR_HANDLE  = -12 & (1<<32 - 1)

	FILE_BEGIN   = 0
	FILE_CURRENT = 1
	FILE_END     = 2

	LANG_ENGLISH       = 0x09
	SUBLANG_ENGLISH_US = 0x01

	FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
	FORMAT_MESSAGE_IGNORE_INSERTS  = 512
	FORMAT_MESSAGE_FROM_STRING     = 1024
	FORMAT_MESSAGE_FROM_HMODULE    = 2048
	FORMAT_MESSAGE_FROM_SYSTEM     = 4096
	FORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192
	FORMAT_MESSAGE_MAX_WIDTH_MASK  = 255

	MAX_PATH      = 260
	MAX_LONG_PATH = 32768

	MAX_COMPUTERNAME_LENGTH = 15

	TIME_ZONE_ID_UNKNOWN  = 0
	TIME_ZONE_ID_STANDARD = 1

	TIME_ZONE_ID_DAYLIGHT = 2
	IGNORE                = 0
	INFINITE              = 0xffffffff

	WAIT_ABANDONED = 0x00000080
	WAIT_OBJECT_0  = 0x00000000
	WAIT_FAILED    = 0xFFFFFFFF

	// Access rights for process.
	PROCESS_CREATE_PROCESS            = 0x0080
	PROCESS_CREATE_THREAD             = 0x0002
	PROCESS_DUP_HANDLE                = 0x0040
	PROCESS_QUERY_INFORMATION         = 0x0400
	PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
	PROCESS_SET_INFORMATION           = 0x0200
	PROCESS_SET_QUOTA                 = 0x0100
	PROCESS_SUSPEND_RESUME            = 0x0800
	PROCESS_TERMINATE                 = 0x0001
	PROCESS_VM_OPERATION              = 0x0008
	PROCESS_VM_READ                   = 0x0010
	PROCESS_VM_WRITE                  = 0x0020

	// Access rights for thread.
	THREAD_DIRECT_IMPERSONATION      = 0x0200
	THREAD_GET_CONTEXT               = 0x0008
	THREAD_IMPERSONATE               = 0x0100
	THREAD_QUERY_INFORMATION         = 0x0040
	THREAD_QUERY_LIMITED_INFORMATION = 0x0800
	THREAD_SET_CONTEXT               = 0x0010
	THREAD_SET_INFORMATION           = 0x0020
	THREAD_SET_LIMITED_INFORMATION   = 0x0400
	THREAD_SET_THREAD_TOKEN          = 0x0080
	THREAD_SUSPEND_RESUME            = 0x0002
	THREAD_TERMINATE                 = 0x0001

	FILE_MAP_COPY    = 0x01
	FILE_MAP_WRITE   = 0x02
	FILE_MAP_READ    = 0x04
	FILE_MAP_EXECUTE = 0x20

	CTRL_C_EVENT        = 0
	CTRL_BREAK_EVENT    = 1
	CTRL_CLOSE_EVENT    = 2
	CTRL_LOGOFF_EVENT   = 5
	CTRL_SHUTDOWN_EVENT = 6

	// Windows reserves errors >= 1<<29 for application use.
	APPLICATION_ERROR = 1 << 29
)

const (
	// Process creation flags.
	CREATE_BREAKAWAY_FROM_JOB        = 0x01000000
	CREATE_DEFAULT_ERROR_MODE        = 0x04000000
	CREATE_NEW_CONSOLE               = 0x00000010
	CREATE_NEW_PROCESS_GROUP         = 0x00000200
	CREATE_NO_WINDOW                 = 0x08000000
	CREATE_PROTECTED_PROCESS         = 0x00040000
	CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
	CREATE_SEPARATE_WOW_VDM          = 0x00000800
	CREATE_SHARED_WOW_VDM            = 0x00001000
	CREATE_SUSPENDED                 = 0x00000004
	CREATE_UNICODE_ENVIRONMENT       = 0x00000400
	DEBUG_ONLY_THIS_PROCESS          = 0x00000002
	DEBUG_PROCESS                    = 0x00000001
	DETACHED_PROCESS                 = 0x00000008
	EXTENDED_STARTUPINFO_PRESENT     = 0x00080000
	INHERIT_PARENT_AFFINITY          = 0x00010000
)

const (
	// flags for CreateToolhelp32Snapshot
	TH32CS_SNAPHEAPLIST = 0x01
	TH32CS_SNAPPROCESS  = 0x02
	TH32CS_SNAPTHREAD   = 0x04
	TH32CS_SNAPMODULE   = 0x08
	TH32CS_SNAPMODULE32 = 0x10
	TH32CS_SNAPALL      = TH32CS_SNAPHEAPLIST | TH32CS_SNAPMODULE | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD
	TH32CS_INHERIT      = 0x80000000
)

const (
	// filters for ReadDirectoryChangesW
	FILE_NOTIFY_CHANGE_FILE_NAME   = 0x001
	FILE_NOTIFY_CHANGE_DIR_NAME    = 0x002
	FILE_NOTIFY_CHANGE_ATTRIBUTES  = 0x004
	FILE_NOTIFY_CHANGE_SIZE        = 0x008
	FILE_NOTIFY_CHANGE_LAST_WRITE  = 0x010
	FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x020
	FILE_NOTIFY_CHANGE_CREATION    = 0x040
	FILE_NOTIFY_CHANGE_SECURITY    = 0x100
)

const (
	// do not reorder
	FILE_ACTION_ADDED = iota + 1
	FILE_ACTION_REMOVED
	FILE_ACTION_MODIFIED
	FILE_ACTION_RENAMED_OLD_NAME
	FILE_ACTION_RENAMED_NEW_NAME
)

const (
	// wincrypt.h
	PROV_RSA_FULL                    = 1
	PROV_RSA_SIG                     = 2
	PROV_DSS                         = 3
	PROV_FORTEZZA                    = 4
	PROV_MS_EXCHANGE                 = 5
	PROV_SSL                         = 6
	PROV_RSA_SCHANNEL                = 12
	PROV_DSS_DH                      = 13
	PROV_EC_ECDSA_SIG                = 14
	PROV_EC_ECNRA_SIG                = 15
	PROV_EC_ECDSA_FULL               = 16
	PROV_EC_ECNRA_FULL               = 17
	PROV_DH_SCHANNEL                 = 18
	PROV_SPYRUS_LYNKS                = 20
	PROV_RNG                         = 21
	PROV_INTEL_SEC                   = 22
	PROV_REPLACE_OWF                 = 23
	PROV_RSA_AES                     = 24
	CRYPT_VERIFYCONTEXT              = 0xF0000000
	CRYPT_NEWKEYSET                  = 0x00000008
	CRYPT_DELETEKEYSET               = 0x00000010
	CRYPT_MACHINE_KEYSET             = 0x00000020
	CRYPT_SILENT                     = 0x00000040
	CRYPT_DEFAULT_CONTAINER_OPTIONAL = 0x00000080

	USAGE_MATCH_TYPE_AND = 0
	USAGE_MATCH_TYPE_OR  = 1

	/* msgAndCertEncodingType values for CertOpenStore function */
	X509_ASN_ENCODING   = 0x00000001
	PKCS_7_ASN_ENCODING = 0x00010000

	/* storeProvider values for CertOpenStore function */
	CERT_STORE_PROV_MSG               = 1
	CERT_STORE_PROV_MEMORY            = 2
	CERT_STORE_PROV_FILE              = 3
	CERT_STORE_PROV_REG               = 4
	CERT_STORE_PROV_PKCS7             = 5
	CERT_STORE_PROV_SERIALIZED        = 6
	CERT_STORE_PROV_FILENAME_A        = 7
	CERT_STORE_PROV_FILENAME_W        = 8
	CERT_STORE_PROV_FILENAME          = CERT_STORE_PROV_FILENAME_W
	CERT_STORE_PROV_SYSTEM_A          = 9
	CERT_STORE_PROV_SYSTEM_W          = 10
	CERT_STORE_PROV_SYSTEM            = CERT_STORE_PROV_SYSTEM_W
	CERT_STORE_PROV_COLLECTION        = 11
	CERT_STORE_PROV_SYSTEM_REGISTRY_A = 12
	CERT_STORE_PROV_SYSTEM_REGISTRY_W = 13
	CERT_STORE_PROV_SYSTEM_REGISTRY   = CERT_STORE_PROV_SYSTEM_REGISTRY_W
	CERT_STORE_PROV_PHYSICAL_W        = 14
	CERT_STORE_PROV_PHYSICAL          = CERT_STORE_PROV_PHYSICAL_W
	CERT_STORE_PROV_SMART_CARD_W      = 15
	CERT_STORE_PROV_SMART_CARD        = CERT_STORE_PROV_SMART_CARD_W
	CERT_STORE_PROV_LDAP_W            = 16
	CERT_STORE_PROV_LDAP              = CERT_STORE_PROV_LDAP_W
	CERT_STORE_PROV_PKCS12            = 17

	/* store characteristics (low WORD of flag) for CertOpenStore function */
	CERT_STORE_NO_CRYPT_RELEASE_FLAG            = 0x00000001
	CERT_STORE_SET_LOCALIZED_NAME_FLAG          = 0x00000002
	CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 0x00000004
	CERT_STORE_DELETE_FLAG                      = 0x00000010
	CERT_STORE_UNSAFE_PHYSICAL_FLAG             = 0x00000020
	CERT_STORE_SHARE_STORE_FLAG                 = 0x00000040
	CERT_STORE_SHARE_CONTEXT_FLAG               = 0x00000080
	CERT_STORE_MANIFOLD_FLAG                    = 0x00000100
	CERT_STORE_ENUM_ARCHIVED_FLAG               = 0x00000200
	CERT_STORE_UPDATE_KEYID_FLAG                = 0x00000400
	CERT_STORE_BACKUP_RESTORE_FLAG              = 0x00000800
	CERT_STORE_MAXIMUM_ALLOWED_FLAG             = 0x00001000
	CERT_STORE_CREATE_NEW_FLAG                  = 0x00002000
	CERT_STORE_OPEN_EXISTING_FLAG               = 0x00004000
	CERT_STORE_READONLY_FLAG                    = 0x00008000

	/* store locations (high WORD of flag) for CertOpenStore function */
	CERT_SYSTEM_STORE_CURRENT_USER               = 0x00010000
	CERT_SYSTEM_STORE_LOCAL_MACHINE              = 0x00020000
	CERT_SYSTEM_STORE_CURRENT_SERVICE            = 0x00040000
	CERT_SYSTEM_STORE_SERVICES                   = 0x00050000
	CERT_SYSTEM_STORE_USERS                      = 0x00060000
	CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY  = 0x00070000
	CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY = 0x00080000
	CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE   = 0x00090000
	CERT_SYSTEM_STORE_UNPROTECTED_FLAG           = 0x40000000
	CERT_SYSTEM_STORE_RELOCATE_FLAG              = 0x80000000

	/* Miscellaneous high-WORD flags for CertOpenStore function */
	CERT_REGISTRY_STORE_REMOTE_FLAG      = 0x00010000
	CERT_REGISTRY_STORE_SERIALIZED_FLAG  = 0x00020000
	CERT_REGISTRY_STORE_ROAMING_FLAG     = 0x00040000
	CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = 0x00080000
	CERT_REGISTRY_STORE_LM_GPT_FLAG      = 0x01000000
	CERT_REGISTRY_STORE_CLIENT_GPT_FLAG  = 0x80000000
	CERT_FILE_STORE_COMMIT_ENABLE_FLAG   = 0x00010000
	CERT_LDAP_STORE_SIGN_FLAG            = 0x00010000
	CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG  = 0x00020000
	CERT_LDAP_STORE_OPENED_FLAG          = 0x00040000
	CERT_LDAP_STORE_UNBIND_FLAG          = 0x00080000

	/* addDisposition values for CertAddCertificateContextToStore function */
	CERT_STORE_ADD_NEW                                 = 1
	CERT_STORE_ADD_USE_EXISTING                        = 2
	CERT_STORE_ADD_REPLACE_EXISTING                    = 3
	CERT_STORE_ADD_ALWAYS                              = 4
	CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5
	CERT_STORE_ADD_NEWER                               = 6
	CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES            = 7

	/* ErrorStatus values for CertTrustStatus struct */
	CERT_TRUST_NO_ERROR                          = 0x00000000
	CERT_TRUST_IS_NOT_TIME_VALID                 = 0x00000001
	CERT_TRUST_IS_REVOKED                        = 0x00000004
	CERT_TRUST_IS_NOT_SIGNATURE_VALID            = 0x00000008
	CERT_TRUST_IS_NOT_VALID_FOR_USAGE            = 0x00000010
	CERT_TRUST_IS_UNTRUSTED_ROOT                 = 0x00000020
	CERT_TRUST_REVOCATION_STATUS_UNKNOWN         = 0x00000040
	CERT_TRUST_IS_CYCLIC                         = 0x00000080
	CERT_TRUST_INVALID_EXTENSION                 = 0x00000100
	CERT_TRUST_INVALID_POLICY_CONSTRAINTS        = 0x00000200
	CERT_TRUST_INVALID_BASIC_CONSTRAINTS         = 0x00000400
	CERT_TRUST_INVALID_NAME_CONSTRAINTS          = 0x00000800
	CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 0x00001000
	CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT   = 0x00002000
	CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x00004000
	CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT      = 0x00008000
	CERT_TRUST_IS_PARTIAL_CHAIN                  = 0x00010000
	CERT_TRUST_CTL_IS_NOT_TIME_VALID             = 0x00020000
	CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID        = 0x00040000
	CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE        = 0x00080000
	CERT_TRUST_HAS_WEAK_SIGNATURE                = 0x00100000
	CERT_TRUST_IS_OFFLINE_REVOCATION             = 0x01000000
	CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY          = 0x02000000
	CERT_TRUST_IS_EXPLICIT_DISTRUST              = 0x04000000
	CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT    = 0x08000000

	/* InfoStatus values for CertTrustStatus struct */
	CERT_TRUST_HAS_EXACT_MATCH_ISSUER        = 0x00000001
	CERT_TRUST_HAS_KEY_MATCH_ISSUER          = 0x00000002
	CERT_TRUST_HAS_NAME_MATCH_ISSUER         = 0x00000004
	CERT_TRUST_IS_SELF_SIGNED                = 0x00000008
	CERT_TRUST_HAS_PREFERRED_ISSUER          = 0x00000100
	CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY     = 0x00000400
	CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS    = 0x00000400
	CERT_TRUST_IS_PEER_TRUSTED               = 0x00000800
	CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED     = 0x00001000
	CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = 0x00002000
	CERT_TRUST_IS_CA_TRUSTED                 = 0x00004000
	CERT_TRUST_IS_COMPLEX_CHAIN              = 0x00010000

	/* policyOID values for CertVerifyCertificateChainPolicy function */
	CERT_CHAIN_POLICY_BASE              = 1
	CERT_CHAIN_POLICY_AUTHENTICODE      = 2
	CERT_CHAIN_POLICY_AUTHENTICODE_TS   = 3
	CERT_CHAIN_POLICY_SSL               = 4
	CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = 5
	CERT_CHAIN_POLICY_NT_AUTH           = 6
	CERT_CHAIN_POLICY_MICROSOFT_ROOT    = 7
	CERT_CHAIN_POLICY_EV                = 8
	CERT_CHAIN_POLICY_SSL_F12           = 9

	/* AuthType values for SSLExtraCertChainPolicyPara struct */
	AUTHTYPE_CLIENT = 1
	AUTHTYPE_SERVER = 2

	/* Checks values for SSLExtraCertChainPolicyPara struct */
	SECURITY_FLAG_IGNORE_REVOCATION        = 0x00000080
	SECURITY_FLAG_IGNORE_UNKNOWN_CA        = 0x00000100
	SECURITY_FLAG_IGNORE_WRONG_USAGE       = 0x00000200
	SECURITY_FLAG_IGNORE_CERT_CN_INVALID   = 0x00001000
	SECURITY_FLAG_IGNORE_CERT_DATE_INVALID = 0x00002000
)

const (
	// flags for SetErrorMode
	SEM_FAILCRITICALERRORS     = 0x0001
	SEM_NOALIGNMENTFAULTEXCEPT = 0x0004
	SEM_NOGPFAULTERRORBOX      = 0x0002
	SEM_NOOPENFILEERRORBOX     = 0x8000
)

const (
	// Priority class.
	ABOVE_NORMAL_PRIORITY_CLASS   = 0x00008000
	BELOW_NORMAL_PRIORITY_CLASS   = 0x00004000
	HIGH_PRIORITY_CLASS           = 0x00000080
	IDLE_PRIORITY_CLASS           = 0x00000040
	NORMAL_PRIORITY_CLASS         = 0x00000020
	PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000
	PROCESS_MODE_BACKGROUND_END   = 0x00200000
	REALTIME_PRIORITY_CLASS       = 0x00000100
)

var (
	OID_PKIX_KP_SERVER_AUTH = []byte("1.3.6.1.5.5.7.3.1\x00")
	OID_SERVER_GATED_CRYPTO = []byte("1.3.6.1.4.1.311.10.3.3\x00")
	OID_SGC_NETSCAPE        = []byte("2.16.840.1.113730.4.1\x00")
)

// Pointer represents a pointer to an arbitrary Windows type.
//
// Pointer-typed fields may point to one of many different types. It's
// up to the caller to provide a pointer to the appropriate type, cast
// to Pointer. The caller must obey the unsafe.Pointer rules while
// doing so.
type Pointer *struct{}

// Invented values to support what package os expects.
type Timeval struct {
	Sec  int32
	Usec int32
}

func (tv *Timeval) Nanoseconds() int64 {
	return (int64(tv.Sec)*1e6 + int64(tv.Usec)) * 1e3
}

func NsecToTimeval(nsec int64) (tv Timeval) {
	tv.Sec = int32(nsec / 1e9)
	tv.Usec = int32(nsec % 1e9 / 1e3)
	return
}

type Overlapped struct {
	Internal     uintptr
	InternalHigh uintptr
	Offset       uint32
	OffsetHigh   uint32
	HEvent       Handle
}

type FileNotifyInformation struct {
	NextEntryOffset uint32
	Action          uint32
	FileNameLength  uint32
	FileName        uint16
}

type Filetime struct {
	LowDateTime  uint32
	HighDateTime uint32
}

// Nanoseconds returns Filetime ft in nanoseconds
// since Epoch (00:00:00 UTC, January 1, 1970).
func (ft *Filetime) Nanoseconds() int64 {
	// 100-nanosecond intervals since January 1, 1601
	nsec := int64(ft.HighDateTime)<<32 + int64(ft.LowDateTime)
	// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)
	nsec -= 116444736000000000
	// convert into nanoseconds
	nsec *= 100
	return nsec
}

func NsecToFiletime(nsec int64) (ft Filetime) {
	// convert into 100-nanosecond
	nsec /= 100
	// change starting time to January 1, 1601
	nsec += 116444736000000000
	// split into high / low
	ft.LowDateTime = uint32(nsec & 0xffffffff)
	ft.HighDateTime = uint32(nsec >> 32 & 0xffffffff)
	return ft
}

type Win32finddata struct {
	FileAttributes    uint32
	CreationTime      Filetime
	LastAccessTime    Filetime
	LastWriteTime     Filetime
	FileSizeHigh      uint32
	FileSizeLow       uint32
	Reserved0         uint32
	Reserved1         uint32
	FileName          [MAX_PATH - 1]uint16
	AlternateFileName [13]uint16
}

// This is the actual system call structure.
// Win32finddata is what we committed to in Go 1.
type win32finddata1 struct {
	FileAttributes    uint32
	CreationTime      Filetime
	LastAccessTime    Filetime
	LastWriteTime     Filetime
	FileSizeHigh      uint32
	FileSizeLow       uint32
	Reserved0         uint32
	Reserved1         uint32
	FileName          [MAX_PATH]uint16
	AlternateFileName [14]uint16
}

func copyFindData(dst *Win32finddata, src *win32finddata1) {
	dst.FileAttributes = src.FileAttributes
	dst.CreationTime = src.CreationTime
	dst.LastAccessTime = src.LastAccessTime
	dst.LastWriteTime = src.LastWriteTime
	dst.FileSizeHigh = src.FileSizeHigh
	dst.FileSizeLow = src.FileSizeLow
	dst.Reserved0 = src.Reserved0
	dst.Reserved1 = src.Reserved1

	// The src is 1 element bigger than dst, but it must be NUL.
	copy(dst.FileName[:], src.FileName[:])
	copy(dst.AlternateFileName[:], src.AlternateFileName[:])
}

type ByHandleFileInformation struct {
	FileAttributes     uint32
	CreationTime       Filetime
	LastAccessTime     Filetime
	LastWriteTime      Filetime
	VolumeSerialNumber uint32
	FileSizeHigh       uint32
	FileSizeLow        uint32
	NumberOfLinks      uint32
	FileIndexHigh      uint32
	FileIndexLow       uint32
}

const (
	GetFileExInfoStandard = 0
	GetFileExMaxInfoLevel = 1
)

type Win32FileAttributeData struct {
	FileAttributes uint32
	CreationTime   Filetime
	LastAccessTime Filetime
	LastWriteTime  Filetime
	FileSizeHigh   uint32
	FileSizeLow    uint32
}

// ShowWindow constants
const (
	// winuser.h
	SW_HIDE            = 0
	SW_NORMAL          = 1
	SW_SHOWNORMAL      = 1
	SW_SHOWMINIMIZED   = 2
	SW_SHOWMAXIMIZED   = 3
	SW_MAXIMIZE        = 3
	SW_SHOWNOACTIVATE  = 4
	SW_SHOW            = 5
	SW_MINIMIZE        = 6
	SW_SHOWMINNOACTIVE = 7
	SW_SHOWNA          = 8
	SW_RESTORE         = 9
	SW_SHOWDEFAULT     = 10
	SW_FORCEMINIMIZE   = 11
)

type StartupInfo struct {
	Cb            uint32
	_             *uint16
	Desktop       *uint16
	Title         *uint16
	X             uint32
	Y             uint32
	XSize         uint32
	YSize         uint32
	XCountChars   uint32
	YCountChars   uint32
	FillAttribute uint32
	Flags         uint32
	ShowWindow    uint16
	_             uint16
	_             *byte
	StdInput      Handle
	StdOutput     Handle
	StdErr        Handle
}

type ProcessInformation struct {
	Process   Handle
	Thread    Handle
	ProcessId uint32
	ThreadId  uint32
}

type ProcessEntry32 struct {
	Size            uint32
	Usage           uint32
	ProcessID       uint32
	DefaultHeapID   uintptr
	ModuleID        uint32
	Threads         uint32
	ParentProcessID uint32
	PriClassBase    int32
	Flags           uint32
	ExeFile         [MAX_PATH]uint16
}

type ThreadEntry32 struct {
	Size           uint32
	Usage          uint32
	ThreadID       uint32
	OwnerProcessID uint32
	BasePri        int32
	DeltaPri       int32
	Flags          uint32
}

type Systemtime struct {
	Year         uint16
	Month        uint16
	DayOfWeek    uint16
	Day          uint16
	Hour         uint16
	Minute       uint16
	Second       uint16
	Milliseconds uint16
}

type Timezoneinformation struct {
	Bias         int32
	StandardName [32]uint16
	StandardDate Systemtime
	StandardBias int32
	DaylightName [32]uint16
	DaylightDate Systemtime
	DaylightBias int32
}

// Socket related.

const (
	AF_UNSPEC  = 0
	AF_UNIX    = 1
	AF_INET    = 2
	AF_NETBIOS = 17
	AF_INET6   = 23
	AF_IRDA    = 26
	AF_BTH     = 32

	SOCK_STREAM    = 1
	SOCK_DGRAM     = 2
	SOCK_RAW       = 3
	SOCK_RDM       = 4
	SOCK_SEQPACKET = 5

	IPPROTO_IP      = 0
	IPPROTO_ICMP    = 1
	IPPROTO_IGMP    = 2
	BTHPROTO_RFCOMM = 3
	IPPROTO_TCP     = 6
	IPPROTO_UDP     = 17
	IPPROTO_IPV6    = 41
	IPPROTO_ICMPV6  = 58
	IPPROTO_RM      = 113

	SOL_SOCKET                = 0xffff
	SO_REUSEADDR              = 4
	SO_KEEPALIVE              = 8
	SO_DONTROUTE              = 16
	SO_BROADCAST              = 32
	SO_LINGER                 = 128
	SO_RCVBUF                 = 0x1002
	SO_RCVTIMEO               = 0x1006
	SO_SNDBUF                 = 0x1001
	SO_UPDATE_ACCEPT_CONTEXT  = 0x700b
	SO_UPDATE_CONNECT_CONTEXT = 0x7010

	IOC_OUT                            = 0x40000000
	IOC_IN                             = 0x80000000
	IOC_VENDOR                         = 0x18000000
	IOC_INOUT                          = IOC_IN | IOC_OUT
	IOC_WS2                            = 0x08000000
	SIO_GET_EXTENSION_FUNCTION_POINTER = IOC_INOUT | IOC_WS2 | 6
	SIO_KEEPALIVE_VALS                 = IOC_IN | IOC_VENDOR | 4
	SIO_UDP_CONNRESET                  = IOC_IN | IOC_VENDOR | 12

	// cf. http://support.microsoft.com/default.aspx?scid=kb;en-us;257460

	IP_TOS             = 0x3
	IP_TTL             = 0x4
	IP_MULTICAST_IF    = 0x9
	IP_MULTICAST_TTL   = 0xa
	IP_MULTICAST_LOOP  = 0xb
	IP_ADD_MEMBERSHIP  = 0xc
	IP_DROP_MEMBERSHIP = 0xd

	IPV6_V6ONLY         = 0x1b
	IPV6_UNICAST_HOPS   = 0x4
	IPV6_MULTICAST_IF   = 0x9
	IPV6_MULTICAST_HOPS = 0xa
	IPV6_MULTICAST_LOOP = 0xb
	IPV6_JOIN_GROUP     = 0xc
	IPV6_LEAVE_GROUP    = 0xd

	MSG_OOB       = 0x1
	MSG_PEEK      = 0x2
	MSG_DONTROUTE = 0x4
	MSG_WAITALL   = 0x8

	MSG_TRUNC  = 0x0100
	MSG_CTRUNC = 0x0200
	MSG_BCAST  = 0x0400
	MSG_MCAST  = 0x0800

	SOMAXCONN = 0x7fffffff

	TCP_NODELAY = 1

	SHUT_RD   = 0
	SHUT_WR   = 1
	SHUT_RDWR = 2

	WSADESCRIPTION_LEN = 256
	WSASYS_STATUS_LEN  = 128
)

type WSABuf struct {
	Len uint32
	Buf *byte
}

type WSAMsg struct {
	Name        *syscall.RawSockaddrAny
	Namelen     int32
	Buffers     *WSABuf
	BufferCount uint32
	Control     WSABuf
	Flags       uint32
}

// Invented values to support what package os expects.
const (
	S_IFMT   = 0x1f000
	S_IFIFO  = 0x1000
	S_IFCHR  = 0x2000
	S_IFDIR  = 0x4000
	S_IFBLK  = 0x6000
	S_IFREG  = 0x8000
	S_IFLNK  = 0xa000
	S_IFSOCK = 0xc000
	S_ISUID  = 0x800
	S_ISGID  = 0x400
	S_ISVTX  = 0x200
	S_IRUSR  = 0x100
	S_IWRITE = 0x80
	S_IWUSR  = 0x80
	S_IXUSR  = 0x40
)

const (
	FILE_TYPE_CHAR    = 0x0002
	FILE_TYPE_DISK    = 0x0001
	FILE_TYPE_PIPE    = 0x0003
	FILE_TYPE_REMOTE  = 0x8000
	FILE_TYPE_UNKNOWN = 0x0000
)

type Hostent struct {
	Name     *byte
	Aliases  **byte
	AddrType uint16
	Length   uint16
	AddrList **byte
}

type Protoent struct {
	Name    *byte
	Aliases **byte
	Proto   uint16
}

const (
	DNS_TYPE_A       = 0x0001
	DNS_TYPE_NS      = 0x0002
	DNS_TYPE_MD      = 0x0003
	DNS_TYPE_MF      = 0x0004
	DNS_TYPE_CNAME   = 0x0005
	DNS_TYPE_SOA     = 0x0006
	DNS_TYPE_MB      = 0x0007
	DNS_TYPE_MG      = 0x0008
	DNS_TYPE_MR      = 0x0009
	DNS_TYPE_NULL    = 0x000a
	DNS_TYPE_WKS     = 0x000b
	DNS_TYPE_PTR     = 0x000c
	DNS_TYPE_HINFO   = 0x000d
	DNS_TYPE_MINFO   = 0x000e
	DNS_TYPE_MX      = 0x000f
	DNS_TYPE_TEXT    = 0x0010
	DNS_TYPE_RP      = 0x0011
	DNS_TYPE_AFSDB   = 0x0012
	DNS_TYPE_X25     = 0x0013
	DNS_TYPE_ISDN    = 0x0014
	DNS_TYPE_RT      = 0x0015
	DNS_TYPE_NSAP    = 0x0016
	DNS_TYPE_NSAPPTR = 0x0017
	DNS_TYPE_SIG     = 0x0018
	DNS_TYPE_KEY     = 0x0019
	DNS_TYPE_PX      = 0x001a
	DNS_TYPE_GPOS    = 0x001b
	DNS_TYPE_AAAA    = 0x001c
	DNS_TYPE_LOC     = 0x001d
	DNS_TYPE_NXT     = 0x001e
	DNS_TYPE_EID     = 0x001f
	DNS_TYPE_NIMLOC  = 0x0020
	DNS_TYPE_SRV     = 0x0021
	DNS_TYPE_ATMA    = 0x0022
	DNS_TYPE_NAPTR   = 0x0023
	DNS_TYPE_KX      = 0x0024
	DNS_TYPE_CERT    = 0x0025
	DNS_TYPE_A6      = 0x0026
	DNS_TYPE_DNAME   = 0x0027
	DNS_TYPE_SINK    = 0x0028
	DNS_TYPE_OPT     = 0x0029
	DNS_TYPE_DS      = 0x002B
	DNS_TYPE_RRSIG   = 0x002E
	DNS_TYPE_NSEC    = 0x002F
	DNS_TYPE_DNSKEY  = 0x0030
	DNS_TYPE_DHCID   = 0x0031
	DNS_TYPE_UINFO   = 0x0064
	DNS_TYPE_UID     = 0x0065
	DNS_TYPE_GID     = 0x0066
	DNS_TYPE_UNSPEC  = 0x0067
	DNS_TYPE_ADDRS   = 0x00f8
	DNS_TYPE_TKEY    = 0x00f9
	DNS_TYPE_TSIG    = 0x00fa
	DNS_TYPE_IXFR    = 0x00fb
	DNS_TYPE_AXFR    = 0x00fc
	DNS_TYPE_MAILB   = 0x00fd
	DNS_TYPE_MAILA   = 0x00fe
	DNS_TYPE_ALL     = 0x00ff
	DNS_TYPE_ANY     = 0x00ff
	DNS_TYPE_WINS    = 0xff01
	DNS_TYPE_WINSR   = 0xff02
	DNS_TYPE_NBSTAT  = 0xff01
)

const (
	// flags inside DNSRecord.Dw
	DnsSectionQuestion   = 0x0000
	DnsSectionAnswer     = 0x0001
	DnsSectionAuthority  = 0x0002
	DnsSectionAdditional = 0x0003
)

type DNSSRVData struct {
	Target   *uint16
	Priority uint16
	Weight   uint16
	Port     uint16
	Pad      uint16
}

type DNSPTRData struct {
	Host *uint16
}

type DNSMXData struct {
	NameExchange *uint16
	Preference   uint16
	Pad          uint16
}

type DNSTXTData struct {
	StringCount uint16
	StringArray [1]*uint16
}

type DNSRecord struct {
	Next     *DNSRecord
	Name     *uint16
	Type     uint16
	Length   uint16
	Dw       uint32
	Ttl      uint32
	Reserved uint32
	Data     [40]byte
}

const (
	TF_DISCONNECT         = 1
	TF_REUSE_SOCKET       = 2
	TF_WRITE_BEHIND       = 4
	TF_USE_DEFAULT_WORKER = 0
	TF_USE_SYSTEM_THREAD  = 16
	TF_USE_KERNEL_APC     = 32
)

type TransmitFileBuffers struct {
	Head       uintptr
	HeadLength uint32
	Tail       uintptr
	TailLength uint32
}

const (
	IFF_UP           = 1
	IFF_BROADCAST    = 2
	IFF_LOOPBACK     = 4
	IFF_POINTTOPOINT = 8
	IFF_MULTICAST    = 16
)

const SIO_GET_INTERFACE_LIST = 0x4004747F

// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.
// will be fixed to change variable type as suitable.

type SockaddrGen [24]byte

type InterfaceInfo struct {
	Flags            uint32
	Address          SockaddrGen
	BroadcastAddress SockaddrGen
	Netmask          SockaddrGen
}

type IpAddressString struct {
	String [16]byte
}

type IpMaskString IpAddressString

type IpAddrString struct {
	Next      *IpAddrString
	IpAddress IpAddressString
	IpMask    IpMaskString
	Context   uint32
}

const MAX_ADAPTER_NAME_LENGTH = 256
const MAX_ADAPTER_DESCRIPTION_LENGTH = 128
const MAX_ADAPTER_ADDRESS_LENGTH = 8

type IpAdapterInfo struct {
	Next                *IpAdapterInfo
	ComboIndex          uint32
	AdapterName         [MAX_ADAPTER_NAME_LENGTH + 4]byte
	Description         [MAX_ADAPTER_DESCRIPTION_LENGTH + 4]byte
	AddressLength       uint32
	Address             [MAX_ADAPTER_ADDRESS_LENGTH]byte
	Index               uint32
	Type                uint32
	DhcpEnabled         uint32
	CurrentIpAddress    *IpAddrString
	IpAddressList       IpAddrString
	GatewayList         IpAddrString
	DhcpServer          IpAddrString
	HaveWins            bool
	PrimaryWinsServer   IpAddrString
	SecondaryWinsServer IpAddrString
	LeaseObtained       int64
	LeaseExpires        int64
}

const MAXLEN_PHYSADDR = 8
const MAX_INTERFACE_NAME_LEN = 256
const MAXLEN_IFDESCR = 256

type MibIfRow struct {
	Name            [MAX_INTERFACE_NAME_LEN]uint16
	Index           uint32
	Type            uint32
	Mtu             uint32
	Speed           uint32
	PhysAddrLen     uint32
	PhysAddr        [MAXLEN_PHYSADDR]byte
	AdminStatus     uint32
	OperStatus      uint32
	LastChange      uint32
	InOctets        uint32
	InUcastPkts     uint32
	InNUcastPkts    uint32
	InDiscards      uint32
	InErrors        uint32
	InUnknownProtos uint32
	OutOctets       uint32
	OutUcastPkts    uint32
	OutNUcastPkts   uint32
	OutDiscards     uint32
	OutErrors       uint32
	OutQLen         uint32
	DescrLen        uint32
	Descr           [MAXLEN_IFDESCR]byte
}

type CertInfo struct {
	// Not implemented
}

type CertContext struct {
	EncodingType uint32
	EncodedCert  *byte
	Length       uint32
	CertInfo     *CertInfo
	Store        Handle
}

type CertChainContext struct {
	Size                       uint32
	TrustStatus                CertTrustStatus
	ChainCount                 uint32
	Chains                     **CertSimpleChain
	LowerQualityChainCount     uint32
	LowerQualityChains         **CertChainContext
	HasRevocationFreshnessTime uint32
	RevocationFreshnessTime    uint32
}

type CertTrustListInfo struct {
	// Not implemented
}

type CertSimpleChain struct {
	Size                       uint32
	TrustStatus                CertTrustStatus
	NumElements                uint32
	Elements                   **CertChainElement
	TrustListInfo              *CertTrustListInfo
	HasRevocationFreshnessTime uint32
	RevocationFreshnessTime    uint32
}

type CertChainElement struct {
	Size              uint32
	CertContext       *CertContext
	TrustStatus       CertTrustStatus
	RevocationInfo    *CertRevocationInfo
	IssuanceUsage     *CertEnhKeyUsage
	ApplicationUsage  *CertEnhKeyUsage
	ExtendedErrorInfo *uint16
}

type CertRevocationCrlInfo struct {
	// Not implemented
}

type CertRevocationInfo struct {
	Size             uint32
	RevocationResult uint32
	RevocationOid    *byte
	OidSpecificInfo  Pointer
	HasFreshnessTime uint32
	FreshnessTime    uint32
	CrlInfo          *CertRevocationCrlInfo
}

type CertTrustStatus struct {
	ErrorStatus uint32
	InfoStatus  uint32
}

type CertUsageMatch struct {
	Type  uint32
	Usage CertEnhKeyUsage
}

type CertEnhKeyUsage struct {
	Length           uint32
	UsageIdentifiers **byte
}

type CertChainPara struct {
	Size                         uint32
	RequestedUsage               CertUsageMatch
	RequstedIssuancePolicy       CertUsageMatch
	URLRetrievalTimeout          uint32
	CheckRevocationFreshnessTime uint32
	RevocationFreshnessTime      uint32
	CacheResync                  *Filetime
}

type CertChainPolicyPara struct {
	Size            uint32
	Flags           uint32
	ExtraPolicyPara Pointer
}

type SSLExtraCertChainPolicyPara struct {
	Size       uint32
	AuthType   uint32
	Checks     uint32
	ServerName *uint16
}

type CertChainPolicyStatus struct {
	Size              uint32
	Error             uint32
	ChainIndex        uint32
	ElementIndex      uint32
	ExtraPolicyStatus Pointer
}

const (
	// do not reorder
	HKEY_CLASSES_ROOT = 0x80000000 + iota
	HKEY_CURRENT_USER
	HKEY_LOCAL_MACHINE
	HKEY_USERS
	HKEY_PERFORMANCE_DATA
	HKEY_CURRENT_CONFIG
	HKEY_DYN_DATA

	KEY_QUERY_VALUE        = 1
	KEY_SET_VALUE          = 2
	KEY_CREATE_SUB_KEY     = 4
	KEY_ENUMERATE_SUB_KEYS = 8
	KEY_NOTIFY             = 16
	KEY_CREATE_LINK        = 32
	KEY_WRITE              = 0x20006
	KEY_EXECUTE            = 0x20019
	KEY_READ               = 0x20019
	KEY_WOW64_64KEY        = 0x0100
	KEY_WOW64_32KEY        = 0x0200
	KEY_ALL_ACCESS         = 0xf003f
)

const (
	// do not reorder
	REG_NONE = iota
	REG_SZ
	REG_EXPAND_SZ
	REG_BINARY
	REG_DWORD_LITTLE_ENDIAN
	REG_DWORD_BIG_ENDIAN
	REG_LINK
	REG_MULTI_SZ
	REG_RESOURCE_LIST
	REG_FULL_RESOURCE_DESCRIPTOR
	REG_RESOURCE_REQUIREMENTS_LIST
	REG_QWORD_LITTLE_ENDIAN
	REG_DWORD = REG_DWORD_LITTLE_ENDIAN
	REG_QWORD = REG_QWORD_LITTLE_ENDIAN
)

const (
	EVENT_MODIFY_STATE = 0x0002
	EVENT_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3

	MUTANT_QUERY_STATE = 0x0001
	MUTANT_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | MUTANT_QUERY_STATE

	SEMAPHORE_MODIFY_STATE = 0x0002
	SEMAPHORE_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3

	TIMER_QUERY_STATE  = 0x0001
	TIMER_MODIFY_STATE = 0x0002
	TIMER_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | TIMER_QUERY_STATE | TIMER_MODIFY_STATE

	MUTEX_MODIFY_STATE = MUTANT_QUERY_STATE
	MUTEX_ALL_ACCESS   = MUTANT_ALL_ACCESS

	CREATE_EVENT_MANUAL_RESET  = 0x1
	CREATE_EVENT_INITIAL_SET   = 0x2
	CREATE_MUTEX_INITIAL_OWNER = 0x1
)

type AddrinfoW struct {
	Flags     int32
	Family    int32
	Socktype  int32
	Protocol  int32
	Addrlen   uintptr
	Canonname *uint16
	Addr      uintptr
	Next      *AddrinfoW
}

const (
	AI_PASSIVE     = 1
	AI_CANONNAME   = 2
	AI_NUMERICHOST = 4
)

type GUID struct {
	Data1 uint32
	Data2 uint16
	Data3 uint16
	Data4 [8]byte
}

var WSAID_CONNECTEX = GUID{
	0x25a207b9,
	0xddf3,
	0x4660,
	[8]byte{0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e},
}

var WSAID_WSASENDMSG = GUID{
	0xa441e712,
	0x754f,
	0x43ca,
	[8]byte{0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d},
}

var WSAID_WSARECVMSG = GUID{
	0xf689d7c8,
	0x6f1f,
	0x436b,
	[8]byte{0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22},
}

const (
	FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1
	FILE_SKIP_SET_EVENT_ON_HANDLE        = 2
)

const (
	WSAPROTOCOL_LEN    = 255
	MAX_PROTOCOL_CHAIN = 7
	BASE_PROTOCOL      = 1
	LAYERED_PROTOCOL   = 0

	XP1_CONNECTIONLESS           = 0x00000001
	XP1_GUARANTEED_DELIVERY      = 0x00000002
	XP1_GUARANTEED_ORDER         = 0x00000004
	XP1_MESSAGE_ORIENTED         = 0x00000008
	XP1_PSEUDO_STREAM            = 0x00000010
	XP1_GRACEFUL_CLOSE           = 0x00000020
	XP1_EXPEDITED_DATA           = 0x00000040
	XP1_CONNECT_DATA             = 0x00000080
	XP1_DISCONNECT_DATA          = 0x00000100
	XP1_SUPPORT_BROADCAST        = 0x00000200
	XP1_SUPPORT_MULTIPOINT       = 0x00000400
	XP1_MULTIPOINT_CONTROL_PLANE = 0x00000800
	XP1_MULTIPOINT_DATA_PLANE    = 0x00001000
	XP1_QOS_SUPPORTED            = 0x00002000
	XP1_UNI_SEND                 = 0x00008000
	XP1_UNI_RECV                 = 0x00010000
	XP1_IFS_HANDLES              = 0x00020000
	XP1_PARTIAL_MESSAGE          = 0x00040000
	XP1_SAN_SUPPORT_SDP          = 0x00080000

	PFL_MULTIPLE_PROTO_ENTRIES  = 0x00000001
	PFL_RECOMMENDED_PROTO_ENTRY = 0x00000002
	PFL_HIDDEN                  = 0x00000004
	PFL_MATCHES_PROTOCOL_ZERO   = 0x00000008
	PFL_NETWORKDIRECT_PROVIDER  = 0x00000010
)

type WSAProtocolInfo struct {
	ServiceFlags1     uint32
	ServiceFlags2     uint32
	ServiceFlags3     uint32
	ServiceFlags4     uint32
	ProviderFlags     uint32
	ProviderId        GUID
	CatalogEntryId    uint32
	ProtocolChain     WSAProtocolChain
	Version           int32
	AddressFamily     int32
	MaxSockAddr       int32
	MinSockAddr       int32
	SocketType        int32
	Protocol          int32
	ProtocolMaxOffset int32
	NetworkByteOrder  int32
	SecurityScheme    int32
	MessageSize       uint32
	ProviderReserved  uint32
	ProtocolName      [WSAPROTOCOL_LEN + 1]uint16
}

type WSAProtocolChain struct {
	ChainLen     int32
	ChainEntries [MAX_PROTOCOL_CHAIN]uint32
}

type TCPKeepalive struct {
	OnOff    uint32
	Time     uint32
	Interval uint32
}

type symbolicLinkReparseBuffer struct {
	SubstituteNameOffset uint16
	SubstituteNameLength uint16
	PrintNameOffset      uint16
	PrintNameLength      uint16
	Flags                uint32
	PathBuffer           [1]uint16
}

type mountPointReparseBuffer struct {
	SubstituteNameOffset uint16
	SubstituteNameLength uint16
	PrintNameOffset      uint16
	PrintNameLength      uint16
	PathBuffer           [1]uint16
}

type reparseDataBuffer struct {
	ReparseTag        uint32
	ReparseDataLength uint16
	Reserved          uint16

	// GenericReparseBuffer
	reparseBuffer byte
}

const (
	FSCTL_GET_REPARSE_POINT          = 0x900A8
	MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024
	IO_REPARSE_TAG_MOUNT_POINT       = 0xA0000003
	IO_REPARSE_TAG_SYMLINK           = 0xA000000C
	SYMBOLIC_LINK_FLAG_DIRECTORY     = 0x1
)

const (
	ComputerNameNetBIOS                   = 0
	ComputerNameDnsHostname               = 1
	ComputerNameDnsDomain                 = 2
	ComputerNameDnsFullyQualified         = 3
	ComputerNamePhysicalNetBIOS           = 4
	ComputerNamePhysicalDnsHostname       = 5
	ComputerNamePhysicalDnsDomain         = 6
	ComputerNamePhysicalDnsFullyQualified = 7
	ComputerNameMax                       = 8
)

// For MessageBox()
const (
	MB_OK                   = 0x00000000
	MB_OKCANCEL             = 0x00000001
	MB_ABORTRETRYIGNORE     = 0x00000002
	MB_YESNOCANCEL          = 0x00000003
	MB_YESNO                = 0x00000004
	MB_RETRYCANCEL          = 0x00000005
	MB_CANCELTRYCONTINUE    = 0x00000006
	MB_ICONHAND             = 0x00000010
	MB_ICONQUESTION         = 0x00000020
	MB_ICONEXCLAMATION      = 0x00000030
	MB_ICONASTERISK         = 0x00000040
	MB_USERICON             = 0x00000080
	MB_ICONWARNING          = MB_ICONEXCLAMATION
	MB_ICONERROR            = MB_ICONHAND
	MB_ICONINFORMATION      = MB_ICONASTERISK
	MB_ICONSTOP             = MB_ICONHAND
	MB_DEFBUTTON1           = 0x00000000
	MB_DEFBUTTON2           = 0x00000100
	MB_DEFBUTTON3           = 0x00000200
	MB_DEFBUTTON4           = 0x00000300
	MB_APPLMODAL            = 0x00000000
	MB_SYSTEMMODAL          = 0x00001000
	MB_TASKMODAL            = 0x00002000
	MB_HELP                 = 0x00004000
	MB_NOFOCUS              = 0x00008000
	MB_SETFOREGROUND        = 0x00010000
	MB_DEFAULT_DESKTOP_ONLY = 0x00020000
	MB_TOPMOST              = 0x00040000
	MB_RIGHT                = 0x00080000
	MB_RTLREADING           = 0x00100000
	MB_SERVICE_NOTIFICATION = 0x00200000
)

const (
	MOVEFILE_REPLACE_EXISTING      = 0x1
	MOVEFILE_COPY_ALLOWED          = 0x2
	MOVEFILE_DELAY_UNTIL_REBOOT    = 0x4
	MOVEFILE_WRITE_THROUGH         = 0x8
	MOVEFILE_CREATE_HARDLINK       = 0x10
	MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x20
)

const GAA_FLAG_INCLUDE_PREFIX = 0x00000010

const (
	IF_TYPE_OTHER              = 1
	IF_TYPE_ETHERNET_CSMACD    = 6
	IF_TYPE_ISO88025_TOKENRING = 9
	IF_TYPE_PPP                = 23
	IF_TYPE_SOFTWARE_LOOPBACK  = 24
	IF_TYPE_ATM                = 37
	IF_TYPE_IEEE80211          = 71
	IF_TYPE_TUNNEL             = 131
	IF_TYPE_IEEE1394           = 144
)

type SocketAddress struct {
	Sockaddr       *syscall.RawSockaddrAny
	SockaddrLength int32
}

// IP returns an IPv4 or IPv6 address, or nil if the underlying SocketAddress is neither.
func (addr *SocketAddress) IP() net.IP {
	if uintptr(addr.SockaddrLength) >= unsafe.Sizeof(RawSockaddrInet4{}) && addr.Sockaddr.Addr.Family == AF_INET {
		return (*RawSockaddrInet4)(unsafe.Pointer(addr.Sockaddr)).Addr[:]
	} else if uintptr(addr.SockaddrLength) >= unsafe.Sizeof(RawSockaddrInet6{}) && addr.Sockaddr.Addr.Family == AF_INET6 {
		return (*RawSockaddrInet6)(unsafe.Pointer(addr.Sockaddr)).Addr[:]
	}
	return nil
}

type IpAdapterUnicastAddress struct {
	Length             uint32
	Flags              uint32
	Next               *IpAdapterUnicastAddress
	Address            SocketAddress
	PrefixOrigin       int32
	SuffixOrigin       int32
	DadState           int32
	ValidLifetime      uint32
	PreferredLifetime  uint32
	LeaseLifetime      uint32
	OnLinkPrefixLength uint8
}

type IpAdapterAnycastAddress struct {
	Length  uint32
	Flags   uint32
	Next    *IpAdapterAnycastAddress
	Address SocketAddress
}

type IpAdapterMulticastAddress struct {
	Length  uint32
	Flags   uint32
	Next    *IpAdapterMulticastAddress
	Address SocketAddress
}

type IpAdapterDnsServerAdapter struct {
	Length   uint32
	Reserved uint32
	Next     *IpAdapterDnsServerAdapter
	Address  SocketAddress
}

type IpAdapterPrefix struct {
	Length       uint32
	Flags        uint32
	Next         *IpAdapterPrefix
	Address      SocketAddress
	PrefixLength uint32
}

type IpAdapterAddresses struct {
	Length                uint32
	IfIndex               uint32
	Next                  *IpAdapterAddresses
	AdapterName           *byte
	FirstUnicastAddress   *IpAdapterUnicastAddress
	FirstAnycastAddress   *IpAdapterAnycastAddress
	FirstMulticastAddress *IpAdapterMulticastAddress
	FirstDnsServerAddress *IpAdapterDnsServerAdapter
	DnsSuffix             *uint16
	Description           *uint16
	FriendlyName          *uint16
	PhysicalAddress       [syscall.MAX_ADAPTER_ADDRESS_LENGTH]byte
	PhysicalAddressLength uint32
	Flags                 uint32
	Mtu                   uint32
	IfType                uint32
	OperStatus            uint32
	Ipv6IfIndex           uint32
	ZoneIndices           [16]uint32
	FirstPrefix           *IpAdapterPrefix
	/* more fields might be present here. */
}

const (
	IfOperStatusUp             = 1
	IfOperStatusDown           = 2
	IfOperStatusTesting        = 3
	IfOperStatusUnknown        = 4
	IfOperStatusDormant        = 5
	IfOperStatusNotPresent     = 6
	IfOperStatusLowerLayerDown = 7
)

// Console related constants used for the mode parameter to SetConsoleMode. See
// https://docs.microsoft.com/en-us/windows/console/setconsolemode for details.

const (
	ENABLE_PROCESSED_INPUT        = 0x1
	ENABLE_LINE_INPUT             = 0x2
	ENABLE_ECHO_INPUT             = 0x4
	ENABLE_WINDOW_INPUT           = 0x8
	ENABLE_MOUSE_INPUT            = 0x10
	ENABLE_INSERT_MODE            = 0x20
	ENABLE_QUICK_EDIT_MODE        = 0x40
	ENABLE_EXTENDED_FLAGS         = 0x80
	ENABLE_AUTO_POSITION          = 0x100
	ENABLE_VIRTUAL_TERMINAL_INPUT = 0x200

	ENABLE_PROCESSED_OUTPUT            = 0x1
	ENABLE_WRAP_AT_EOL_OUTPUT          = 0x2
	ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x4
	DISABLE_NEWLINE_AUTO_RETURN        = 0x8
	ENABLE_LVB_GRID_WORLDWIDE          = 0x10
)

type Coord struct {
	X int16
	Y int16
}

type SmallRect struct {
	Left   int16
	Top    int16
	Right  int16
	Bottom int16
}

// Used with GetConsoleScreenBuffer to retrieve information about a console
// screen buffer. See
// https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str
// for details.

type ConsoleScreenBufferInfo struct {
	Size              Coord
	CursorPosition    Coord
	Attributes        uint16
	Window            SmallRect
	MaximumWindowSize Coord
}

const UNIX_PATH_MAX = 108 // defined in afunix.h

const (
	// flags for JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags
	JOB_OBJECT_LIMIT_ACTIVE_PROCESS             = 0x00000008
	JOB_OBJECT_LIMIT_AFFINITY                   = 0x00000010
	JOB_OBJECT_LIMIT_BREAKAWAY_OK               = 0x00000800
	JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
	JOB_OBJECT_LIMIT_JOB_MEMORY                 = 0x00000200
	JOB_OBJECT_LIMIT_JOB_TIME                   = 0x00000004
	JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          = 0x00002000
	JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          = 0x00000040
	JOB_OBJECT_LIMIT_PRIORITY_CLASS             = 0x00000020
	JOB_OBJECT_LIMIT_PROCESS_MEMORY             = 0x00000100
	JOB_OBJECT_LIMIT_PROCESS_TIME               = 0x00000002
	JOB_OBJECT_LIMIT_SCHEDULING_CLASS           = 0x00000080
	JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        = 0x00001000
	JOB_OBJECT_LIMIT_SUBSET_AFFINITY            = 0x00004000
	JOB_OBJECT_LIMIT_WORKINGSET                 = 0x00000001
)

type JOBOBJECT_BASIC_LIMIT_INFORMATION struct {
	PerProcessUserTimeLimit int64
	PerJobUserTimeLimit     int64
	LimitFlags              uint32
	MinimumWorkingSetSize   uintptr
	MaximumWorkingSetSize   uintptr
	ActiveProcessLimit      uint32
	Affinity                uintptr
	PriorityClass           uint32
	SchedulingClass         uint32
}

type IO_COUNTERS struct {
	ReadOperationCount  uint64
	WriteOperationCount uint64
	OtherOperationCount uint64
	ReadTransferCount   uint64
	WriteTransferCount  uint64
	OtherTransferCount  uint64
}

type JOBOBJECT_EXTENDED_LIMIT_INFORMATION struct {
	BasicLimitInformation JOBOBJECT_BASIC_LIMIT_INFORMATION
	IoInfo                IO_COUNTERS
	ProcessMemoryLimit    uintptr
	JobMemoryLimit        uintptr
	PeakProcessMemoryUsed uintptr
	PeakJobMemoryUsed     uintptr
}

const (
	// UIRestrictionsClass
	JOB_OBJECT_UILIMIT_DESKTOP          = 0x00000040
	JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 0x00000010
	JOB_OBJECT_UILIMIT_EXITWINDOWS      = 0x00000080
	JOB_OBJECT_UILIMIT_GLOBALATOMS      = 0x00000020
	JOB_OBJECT_UILIMIT_HANDLES          = 0x00000001
	JOB_OBJECT_UILIMIT_READCLIPBOARD    = 0x00000002
	JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
	JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 0x00000004
)

type JOBOBJECT_BASIC_UI_RESTRICTIONS struct {
	UIRestrictionsClass uint32
}

const (
	// JobObjectInformationClass
	JobObjectAssociateCompletionPortInformation = 7
	JobObjectBasicLimitInformation              = 2
	JobObjectBasicUIRestrictions                = 4
	JobObjectCpuRateControlInformation          = 15
	JobObjectEndOfJobTimeInformation            = 6
	JobObjectExtendedLimitInformation           = 9
	JobObjectGroupInformation                   = 11
	JobObjectGroupInformationEx                 = 14
	JobObjectLimitViolationInformation2         = 35
	JobObjectNetRateControlInformation          = 32
	JobObjectNotificationLimitInformation       = 12
	JobObjectNotificationLimitInformation2      = 34
	JobObjectSecurityLimitInformation           = 5
)

const (
	KF_FLAG_DEFAULT                          = 0x00000000
	KF_FLAG_FORCE_APP_DATA_REDIRECTION       = 0x00080000
	KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET = 0x00040000
	KF_FLAG_FORCE_PACKAGE_REDIRECTION        = 0x00020000
	KF_FLAG_NO_PACKAGE_REDIRECTION           = 0x00010000
	KF_FLAG_FORCE_APPCONTAINER_REDIRECTION   = 0x00020000
	KF_FLAG_NO_APPCONTAINER_REDIRECTION      = 0x00010000
	KF_FLAG_CREATE                           = 0x00008000
	KF_FLAG_DONT_VERIFY                      = 0x00004000
	KF_FLAG_DONT_UNEXPAND                    = 0x00002000
	KF_FLAG_NO_ALIAS                         = 0x00001000
	KF_FLAG_INIT                             = 0x00000800
	KF_FLAG_DEFAULT_PATH                     = 0x00000400
	KF_FLAG_NOT_PARENT_RELATIVE              = 0x00000200
	KF_FLAG_SIMPLE_IDLIST                    = 0x00000100
	KF_FLAG_ALIAS_ONLY                       = 0x80000000
)

type OsVersionInfoEx struct {
	osVersionInfoSize uint32
	MajorVersion      uint32
	MinorVersion      uint32
	BuildNumber       uint32
	PlatformId        uint32
	CsdVersion        [128]uint16
	ServicePackMajor  uint16
	ServicePackMinor  uint16
	SuiteMask         uint16
	ProductType       byte
	_                 byte
}

const (
	EWX_LOGOFF          = 0x00000000
	EWX_SHUTDOWN        = 0x00000001
	EWX_REBOOT          = 0x00000002
	EWX_FORCE           = 0x00000004
	EWX_POWEROFF        = 0x00000008
	EWX_FORCEIFHUNG     = 0x00000010
	EWX_QUICKRESOLVE    = 0x00000020
	EWX_RESTARTAPPS     = 0x00000040
	EWX_HYBRID_SHUTDOWN = 0x00400000
	EWX_BOOTOPTIONS     = 0x01000000

	SHTDN_REASON_FLAG_COMMENT_REQUIRED          = 0x01000000
	SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED = 0x02000000
	SHTDN_REASON_FLAG_CLEAN_UI                  = 0x04000000
	SHTDN_REASON_FLAG_DIRTY_UI                  = 0x08000000
	SHTDN_REASON_FLAG_USER_DEFINED              = 0x40000000
	SHTDN_REASON_FLAG_PLANNED                   = 0x80000000
	SHTDN_REASON_MAJOR_OTHER                    = 0x00000000
	SHTDN_REASON_MAJOR_NONE                     = 0x00000000
	SHTDN_REASON_MAJOR_HARDWARE                 = 0x00010000
	SHTDN_REASON_MAJOR_OPERATINGSYSTEM          = 0x00020000
	SHTDN_REASON_MAJOR_SOFTWARE                 = 0x00030000
	SHTDN_REASON_MAJOR_APPLICATION              = 0x00040000
	SHTDN_REASON_MAJOR_SYSTEM                   = 0x00050000
	SHTDN_REASON_MAJOR_POWER                    = 0x00060000
	SHTDN_REASON_MAJOR_LEGACY_API               = 0x00070000
	SHTDN_REASON_MINOR_OTHER                    = 0x00000000
	SHTDN_REASON_MINOR_NONE                     = 0x000000ff
	SHTDN_REASON_MINOR_MAINTENANCE              = 0x00000001
	SHTDN_REASON_MINOR_INSTALLATION             = 0x00000002
	SHTDN_REASON_MINOR_UPGRADE                  = 0x00000003
	SHTDN_REASON_MINOR_RECONFIG                 = 0x00000004
	SHTDN_REASON_MINOR_HUNG                     = 0x00000005
	SHTDN_REASON_MINOR_UNSTABLE                 = 0x00000006
	SHTDN_REASON_MINOR_DISK                     = 0x00000007
	SHTDN_REASON_MINOR_PROCESSOR                = 0x00000008
	SHTDN_REASON_MINOR_NETWORKCARD              = 0x00000009
	SHTDN_REASON_MINOR_POWER_SUPPLY             = 0x0000000a
	SHTDN_REASON_MINOR_CORDUNPLUGGED            = 0x0000000b
	SHTDN_REASON_MINOR_ENVIRONMENT              = 0x0000000c
	SHTDN_REASON_MINOR_HARDWARE_DRIVER          = 0x0000000d
	SHTDN_REASON_MINOR_OTHERDRIVER              = 0x0000000e
	SHTDN_REASON_MINOR_BLUESCREEN               = 0x0000000F
	SHTDN_REASON_MINOR_SERVICEPACK              = 0x00000010
	SHTDN_REASON_MINOR_HOTFIX                   = 0x00000011
	SHTDN_REASON_MINOR_SECURITYFIX              = 0x00000012
	SHTDN_REASON_MINOR_SECURITY                 = 0x00000013
	SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY     = 0x00000014
	SHTDN_REASON_MINOR_WMI                      = 0x00000015
	SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL    = 0x00000016
	SHTDN_REASON_MINOR_HOTFIX_UNINSTALL         = 0x00000017
	SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL    = 0x00000018
	SHTDN_REASON_MINOR_MMC                      = 0x00000019
	SHTDN_REASON_MINOR_SYSTEMRESTORE            = 0x0000001a
	SHTDN_REASON_MINOR_TERMSRV                  = 0x00000020
	SHTDN_REASON_MINOR_DC_PROMOTION             = 0x00000021
	SHTDN_REASON_MINOR_DC_DEMOTION              = 0x00000022
	SHTDN_REASON_UNKNOWN                        = SHTDN_REASON_MINOR_NONE
	SHTDN_REASON_LEGACY_API                     = SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED
	SHTDN_REASON_VALID_BIT_MASK                 = 0xc0ffffff

	SHUTDOWN_NORETRY = 0x1
)

// Flags used for GetModuleHandleEx
const (
	GET_MODULE_HANDLE_EX_FLAG_PIN                = 1
	GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 2
	GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS       = 4
)

// MUI function flag values
const (
	MUI_LANGUAGE_ID                    = 0x4
	MUI_LANGUAGE_NAME                  = 0x8
	MUI_MERGE_SYSTEM_FALLBACK          = 0x10
	MUI_MERGE_USER_FALLBACK            = 0x20
	MUI_UI_FALLBACK                    = MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK
	MUI_THREAD_LANGUAGES               = 0x40
	MUI_CONSOLE_FILTER                 = 0x100
	MUI_COMPLEX_SCRIPT_FILTER          = 0x200
	MUI_RESET_FILTERS                  = 0x001
	MUI_USER_PREFERRED_UI_LANGUAGES    = 0x10
	MUI_USE_INSTALLED_LANGUAGES        = 0x20
	MUI_USE_SEARCH_ALL_LANGUAGES       = 0x40
	MUI_LANG_NEUTRAL_PE_FILE           = 0x100
	MUI_NON_LANG_NEUTRAL_FILE          = 0x200
	MUI_MACHINE_LANGUAGE_SETTINGS      = 0x400
	MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL  = 0x001
	MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN = 0x002
	MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI  = 0x004
	MUI_QUERY_TYPE                     = 0x001
	MUI_QUERY_CHECKSUM                 = 0x002
	MUI_QUERY_LANGUAGE_NAME            = 0x004
	MUI_QUERY_RESOURCE_TYPES           = 0x008
	MUI_FILEINFO_VERSION               = 0x001

	MUI_FULL_LANGUAGE      = 0x01
	MUI_PARTIAL_LANGUAGE   = 0x02
	MUI_LIP_LANGUAGE       = 0x04
	MUI_LANGUAGE_INSTALLED = 0x20
	MUI_LANGUAGE_LICENSED  = 0x40
)

+ f fba7c3ffd3cdaf0d535ac67df50b1225827c6f04a75334cbb2384ed1c3515b69 vendor/golang.org/x/sys/windows/types_windows_386.go
utf8file 23
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

type WSAData struct {
	Version      uint16
	HighVersion  uint16
	Description  [WSADESCRIPTION_LEN + 1]byte
	SystemStatus [WSASYS_STATUS_LEN + 1]byte
	MaxSockets   uint16
	MaxUdpDg     uint16
	VendorInfo   *byte
}

type Servent struct {
	Name    *byte
	Aliases **byte
	Port    uint16
	Proto   *byte
}

+ f 6ebf889bcbd4ef923625462e1514af19ffdad94e7659f7dbab7506cba112b69b vendor/golang.org/x/sys/windows/types_windows_amd64.go
utf8file 23
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

type WSAData struct {
	Version      uint16
	HighVersion  uint16
	MaxSockets   uint16
	MaxUdpDg     uint16
	VendorInfo   *byte
	Description  [WSADESCRIPTION_LEN + 1]byte
	SystemStatus [WSASYS_STATUS_LEN + 1]byte
}

type Servent struct {
	Name    *byte
	Aliases **byte
	Proto   *byte
	Port    uint16
}

+ f 6ac145a95a50eb1ddbb6bd4313b3e506634266c5ce698a7fb189e3ca39f0c712 vendor/golang.org/x/sys/windows/types_windows_arm.go
utf8file 23
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package windows

type WSAData struct {
	Version      uint16
	HighVersion  uint16
	Description  [WSADESCRIPTION_LEN + 1]byte
	SystemStatus [WSASYS_STATUS_LEN + 1]byte
	MaxSockets   uint16
	MaxUdpDg     uint16
	VendorInfo   *byte
}

type Servent struct {
	Name    *byte
	Aliases **byte
	Port    uint16
	Proto   *byte
}

+ f 7e8a3410b5b555b95f5fe31a52c32aff856bbd8ec3980ede5eb6195aa1e428e8 vendor/golang.org/x/sys/windows/zerrors_windows.go
utf8file 6854
// Code generated by 'mkerrors.bash'; DO NOT EDIT.

package windows

import "syscall"

const (
	FACILITY_NULL                                                                           = 0
	FACILITY_RPC                                                                            = 1
	FACILITY_DISPATCH                                                                       = 2
	FACILITY_STORAGE                                                                        = 3
	FACILITY_ITF                                                                            = 4
	FACILITY_WIN32                                                                          = 7
	FACILITY_WINDOWS                                                                        = 8
	FACILITY_SSPI                                                                           = 9
	FACILITY_SECURITY                                                                       = 9
	FACILITY_CONTROL                                                                        = 10
	FACILITY_CERT                                                                           = 11
	FACILITY_INTERNET                                                                       = 12
	FACILITY_MEDIASERVER                                                                    = 13
	FACILITY_MSMQ                                                                           = 14
	FACILITY_SETUPAPI                                                                       = 15
	FACILITY_SCARD                                                                          = 16
	FACILITY_COMPLUS                                                                        = 17
	FACILITY_AAF                                                                            = 18
	FACILITY_URT                                                                            = 19
	FACILITY_ACS                                                                            = 20
	FACILITY_DPLAY                                                                          = 21
	FACILITY_UMI                                                                            = 22
	FACILITY_SXS                                                                            = 23
	FACILITY_WINDOWS_CE                                                                     = 24
	FACILITY_HTTP                                                                           = 25
	FACILITY_USERMODE_COMMONLOG                                                             = 26
	FACILITY_WER                                                                            = 27
	FACILITY_USERMODE_FILTER_MANAGER                                                        = 31
	FACILITY_BACKGROUNDCOPY                                                                 = 32
	FACILITY_CONFIGURATION                                                                  = 33
	FACILITY_WIA                                                                            = 33
	FACILITY_STATE_MANAGEMENT                                                               = 34
	FACILITY_METADIRECTORY                                                                  = 35
	FACILITY_WINDOWSUPDATE                                                                  = 36
	FACILITY_DIRECTORYSERVICE                                                               = 37
	FACILITY_GRAPHICS                                                                       = 38
	FACILITY_SHELL                                                                          = 39
	FACILITY_NAP                                                                            = 39
	FACILITY_TPM_SERVICES                                                                   = 40
	FACILITY_TPM_SOFTWARE                                                                   = 41
	FACILITY_UI                                                                             = 42
	FACILITY_XAML                                                                           = 43
	FACILITY_ACTION_QUEUE                                                                   = 44
	FACILITY_PLA                                                                            = 48
	FACILITY_WINDOWS_SETUP                                                                  = 48
	FACILITY_FVE                                                                            = 49
	FACILITY_FWP                                                                            = 50
	FACILITY_WINRM                                                                          = 51
	FACILITY_NDIS                                                                           = 52
	FACILITY_USERMODE_HYPERVISOR                                                            = 53
	FACILITY_CMI                                                                            = 54
	FACILITY_USERMODE_VIRTUALIZATION                                                        = 55
	FACILITY_USERMODE_VOLMGR                                                                = 56
	FACILITY_BCD                                                                            = 57
	FACILITY_USERMODE_VHD                                                                   = 58
	FACILITY_USERMODE_HNS                                                                   = 59
	FACILITY_SDIAG                                                                          = 60
	FACILITY_WEBSERVICES                                                                    = 61
	FACILITY_WINPE                                                                          = 61
	FACILITY_WPN                                                                            = 62
	FACILITY_WINDOWS_STORE                                                                  = 63
	FACILITY_INPUT                                                                          = 64
	FACILITY_EAP                                                                            = 66
	FACILITY_WINDOWS_DEFENDER                                                               = 80
	FACILITY_OPC                                                                            = 81
	FACILITY_XPS                                                                            = 82
	FACILITY_MBN                                                                            = 84
	FACILITY_POWERSHELL                                                                     = 84
	FACILITY_RAS                                                                            = 83
	FACILITY_P2P_INT                                                                        = 98
	FACILITY_P2P                                                                            = 99
	FACILITY_DAF                                                                            = 100
	FACILITY_BLUETOOTH_ATT                                                                  = 101
	FACILITY_AUDIO                                                                          = 102
	FACILITY_STATEREPOSITORY                                                                = 103
	FACILITY_VISUALCPP                                                                      = 109
	FACILITY_SCRIPT                                                                         = 112
	FACILITY_PARSE                                                                          = 113
	FACILITY_BLB                                                                            = 120
	FACILITY_BLB_CLI                                                                        = 121
	FACILITY_WSBAPP                                                                         = 122
	FACILITY_BLBUI                                                                          = 128
	FACILITY_USN                                                                            = 129
	FACILITY_USERMODE_VOLSNAP                                                               = 130
	FACILITY_TIERING                                                                        = 131
	FACILITY_WSB_ONLINE                                                                     = 133
	FACILITY_ONLINE_ID                                                                      = 134
	FACILITY_DEVICE_UPDATE_AGENT                                                            = 135
	FACILITY_DRVSERVICING                                                                   = 136
	FACILITY_DLS                                                                            = 153
	FACILITY_DELIVERY_OPTIMIZATION                                                          = 208
	FACILITY_USERMODE_SPACES                                                                = 231
	FACILITY_USER_MODE_SECURITY_CORE                                                        = 232
	FACILITY_USERMODE_LICENSING                                                             = 234
	FACILITY_SOS                                                                            = 160
	FACILITY_DEBUGGERS                                                                      = 176
	FACILITY_SPP                                                                            = 256
	FACILITY_RESTORE                                                                        = 256
	FACILITY_DMSERVER                                                                       = 256
	FACILITY_DEPLOYMENT_SERVICES_SERVER                                                     = 257
	FACILITY_DEPLOYMENT_SERVICES_IMAGING                                                    = 258
	FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT                                                 = 259
	FACILITY_DEPLOYMENT_SERVICES_UTIL                                                       = 260
	FACILITY_DEPLOYMENT_SERVICES_BINLSVC                                                    = 261
	FACILITY_DEPLOYMENT_SERVICES_PXE                                                        = 263
	FACILITY_DEPLOYMENT_SERVICES_TFTP                                                       = 264
	FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT                                       = 272
	FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING                                        = 278
	FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER                                           = 289
	FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT                                           = 290
	FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER                                           = 293
	FACILITY_LINGUISTIC_SERVICES                                                            = 305
	FACILITY_AUDIOSTREAMING                                                                 = 1094
	FACILITY_ACCELERATOR                                                                    = 1536
	FACILITY_WMAAECMA                                                                       = 1996
	FACILITY_DIRECTMUSIC                                                                    = 2168
	FACILITY_DIRECT3D10                                                                     = 2169
	FACILITY_DXGI                                                                           = 2170
	FACILITY_DXGI_DDI                                                                       = 2171
	FACILITY_DIRECT3D11                                                                     = 2172
	FACILITY_DIRECT3D11_DEBUG                                                               = 2173
	FACILITY_DIRECT3D12                                                                     = 2174
	FACILITY_DIRECT3D12_DEBUG                                                               = 2175
	FACILITY_LEAP                                                                           = 2184
	FACILITY_AUDCLNT                                                                        = 2185
	FACILITY_WINCODEC_DWRITE_DWM                                                            = 2200
	FACILITY_WINML                                                                          = 2192
	FACILITY_DIRECT2D                                                                       = 2201
	FACILITY_DEFRAG                                                                         = 2304
	FACILITY_USERMODE_SDBUS                                                                 = 2305
	FACILITY_JSCRIPT                                                                        = 2306
	FACILITY_PIDGENX                                                                        = 2561
	FACILITY_EAS                                                                            = 85
	FACILITY_WEB                                                                            = 885
	FACILITY_WEB_SOCKET                                                                     = 886
	FACILITY_MOBILE                                                                         = 1793
	FACILITY_SQLITE                                                                         = 1967
	FACILITY_UTC                                                                            = 1989
	FACILITY_WEP                                                                            = 2049
	FACILITY_SYNCENGINE                                                                     = 2050
	FACILITY_XBOX                                                                           = 2339
	FACILITY_PIX                                                                            = 2748
	ERROR_SUCCESS                                                             syscall.Errno = 0
	NO_ERROR                                                                                = 0
	SEC_E_OK                                                                  Handle        = 0x00000000
	ERROR_INVALID_FUNCTION                                                    syscall.Errno = 1
	ERROR_FILE_NOT_FOUND                                                      syscall.Errno = 2
	ERROR_PATH_NOT_FOUND                                                      syscall.Errno = 3
	ERROR_TOO_MANY_OPEN_FILES                                                 syscall.Errno = 4
	ERROR_ACCESS_DENIED                                                       syscall.Errno = 5
	ERROR_INVALID_HANDLE                                                      syscall.Errno = 6
	ERROR_ARENA_TRASHED                                                       syscall.Errno = 7
	ERROR_NOT_ENOUGH_MEMORY                                                   syscall.Errno = 8
	ERROR_INVALID_BLOCK                                                       syscall.Errno = 9
	ERROR_BAD_ENVIRONMENT                                                     syscall.Errno = 10
	ERROR_BAD_FORMAT                                                          syscall.Errno = 11
	ERROR_INVALID_ACCESS                                                      syscall.Errno = 12
	ERROR_INVALID_DATA                                                        syscall.Errno = 13
	ERROR_OUTOFMEMORY                                                         syscall.Errno = 14
	ERROR_INVALID_DRIVE                                                       syscall.Errno = 15
	ERROR_CURRENT_DIRECTORY                                                   syscall.Errno = 16
	ERROR_NOT_SAME_DEVICE                                                     syscall.Errno = 17
	ERROR_NO_MORE_FILES                                                       syscall.Errno = 18
	ERROR_WRITE_PROTECT                                                       syscall.Errno = 19
	ERROR_BAD_UNIT                                                            syscall.Errno = 20
	ERROR_NOT_READY                                                           syscall.Errno = 21
	ERROR_BAD_COMMAND                                                         syscall.Errno = 22
	ERROR_CRC                                                                 syscall.Errno = 23
	ERROR_BAD_LENGTH                                                          syscall.Errno = 24
	ERROR_SEEK                                                                syscall.Errno = 25
	ERROR_NOT_DOS_DISK                                                        syscall.Errno = 26
	ERROR_SECTOR_NOT_FOUND                                                    syscall.Errno = 27
	ERROR_OUT_OF_PAPER                                                        syscall.Errno = 28
	ERROR_WRITE_FAULT                                                         syscall.Errno = 29
	ERROR_READ_FAULT                                                          syscall.Errno = 30
	ERROR_GEN_FAILURE                                                         syscall.Errno = 31
	ERROR_SHARING_VIOLATION                                                   syscall.Errno = 32
	ERROR_LOCK_VIOLATION                                                      syscall.Errno = 33
	ERROR_WRONG_DISK                                                          syscall.Errno = 34
	ERROR_SHARING_BUFFER_EXCEEDED                                             syscall.Errno = 36
	ERROR_HANDLE_EOF                                                          syscall.Errno = 38
	ERROR_HANDLE_DISK_FULL                                                    syscall.Errno = 39
	ERROR_NOT_SUPPORTED                                                       syscall.Errno = 50
	ERROR_REM_NOT_LIST                                                        syscall.Errno = 51
	ERROR_DUP_NAME                                                            syscall.Errno = 52
	ERROR_BAD_NETPATH                                                         syscall.Errno = 53
	ERROR_NETWORK_BUSY                                                        syscall.Errno = 54
	ERROR_DEV_NOT_EXIST                                                       syscall.Errno = 55
	ERROR_TOO_MANY_CMDS                                                       syscall.Errno = 56
	ERROR_ADAP_HDW_ERR                                                        syscall.Errno = 57
	ERROR_BAD_NET_RESP                                                        syscall.Errno = 58
	ERROR_UNEXP_NET_ERR                                                       syscall.Errno = 59
	ERROR_BAD_REM_ADAP                                                        syscall.Errno = 60
	ERROR_PRINTQ_FULL                                                         syscall.Errno = 61
	ERROR_NO_SPOOL_SPACE                                                      syscall.Errno = 62
	ERROR_PRINT_CANCELLED                                                     syscall.Errno = 63
	ERROR_NETNAME_DELETED                                                     syscall.Errno = 64
	ERROR_NETWORK_ACCESS_DENIED                                               syscall.Errno = 65
	ERROR_BAD_DEV_TYPE                                                        syscall.Errno = 66
	ERROR_BAD_NET_NAME                                                        syscall.Errno = 67
	ERROR_TOO_MANY_NAMES                                                      syscall.Errno = 68
	ERROR_TOO_MANY_SESS                                                       syscall.Errno = 69
	ERROR_SHARING_PAUSED                                                      syscall.Errno = 70
	ERROR_REQ_NOT_ACCEP                                                       syscall.Errno = 71
	ERROR_REDIR_PAUSED                                                        syscall.Errno = 72
	ERROR_FILE_EXISTS                                                         syscall.Errno = 80
	ERROR_CANNOT_MAKE                                                         syscall.Errno = 82
	ERROR_FAIL_I24                                                            syscall.Errno = 83
	ERROR_OUT_OF_STRUCTURES                                                   syscall.Errno = 84
	ERROR_ALREADY_ASSIGNED                                                    syscall.Errno = 85
	ERROR_INVALID_PASSWORD                                                    syscall.Errno = 86
	ERROR_INVALID_PARAMETER                                                   syscall.Errno = 87
	ERROR_NET_WRITE_FAULT                                                     syscall.Errno = 88
	ERROR_NO_PROC_SLOTS                                                       syscall.Errno = 89
	ERROR_TOO_MANY_SEMAPHORES                                                 syscall.Errno = 100
	ERROR_EXCL_SEM_ALREADY_OWNED                                              syscall.Errno = 101
	ERROR_SEM_IS_SET                                                          syscall.Errno = 102
	ERROR_TOO_MANY_SEM_REQUESTS                                               syscall.Errno = 103
	ERROR_INVALID_AT_INTERRUPT_TIME                                           syscall.Errno = 104
	ERROR_SEM_OWNER_DIED                                                      syscall.Errno = 105
	ERROR_SEM_USER_LIMIT                                                      syscall.Errno = 106
	ERROR_DISK_CHANGE                                                         syscall.Errno = 107
	ERROR_DRIVE_LOCKED                                                        syscall.Errno = 108
	ERROR_BROKEN_PIPE                                                         syscall.Errno = 109
	ERROR_OPEN_FAILED                                                         syscall.Errno = 110
	ERROR_BUFFER_OVERFLOW                                                     syscall.Errno = 111
	ERROR_DISK_FULL                                                           syscall.Errno = 112
	ERROR_NO_MORE_SEARCH_HANDLES                                              syscall.Errno = 113
	ERROR_INVALID_TARGET_HANDLE                                               syscall.Errno = 114
	ERROR_INVALID_CATEGORY                                                    syscall.Errno = 117
	ERROR_INVALID_VERIFY_SWITCH                                               syscall.Errno = 118
	ERROR_BAD_DRIVER_LEVEL                                                    syscall.Errno = 119
	ERROR_CALL_NOT_IMPLEMENTED                                                syscall.Errno = 120
	ERROR_SEM_TIMEOUT                                                         syscall.Errno = 121
	ERROR_INSUFFICIENT_BUFFER                                                 syscall.Errno = 122
	ERROR_INVALID_NAME                                                        syscall.Errno = 123
	ERROR_INVALID_LEVEL                                                       syscall.Errno = 124
	ERROR_NO_VOLUME_LABEL                                                     syscall.Errno = 125
	ERROR_MOD_NOT_FOUND                                                       syscall.Errno = 126
	ERROR_PROC_NOT_FOUND                                                      syscall.Errno = 127
	ERROR_WAIT_NO_CHILDREN                                                    syscall.Errno = 128
	ERROR_CHILD_NOT_COMPLETE                                                  syscall.Errno = 129
	ERROR_DIRECT_ACCESS_HANDLE                                                syscall.Errno = 130
	ERROR_NEGATIVE_SEEK                                                       syscall.Errno = 131
	ERROR_SEEK_ON_DEVICE                                                      syscall.Errno = 132
	ERROR_IS_JOIN_TARGET                                                      syscall.Errno = 133
	ERROR_IS_JOINED                                                           syscall.Errno = 134
	ERROR_IS_SUBSTED                                                          syscall.Errno = 135
	ERROR_NOT_JOINED                                                          syscall.Errno = 136
	ERROR_NOT_SUBSTED                                                         syscall.Errno = 137
	ERROR_JOIN_TO_JOIN                                                        syscall.Errno = 138
	ERROR_SUBST_TO_SUBST                                                      syscall.Errno = 139
	ERROR_JOIN_TO_SUBST                                                       syscall.Errno = 140
	ERROR_SUBST_TO_JOIN                                                       syscall.Errno = 141
	ERROR_BUSY_DRIVE                                                          syscall.Errno = 142
	ERROR_SAME_DRIVE                                                          syscall.Errno = 143
	ERROR_DIR_NOT_ROOT                                                        syscall.Errno = 144
	ERROR_DIR_NOT_EMPTY                                                       syscall.Errno = 145
	ERROR_IS_SUBST_PATH                                                       syscall.Errno = 146
	ERROR_IS_JOIN_PATH                                                        syscall.Errno = 147
	ERROR_PATH_BUSY                                                           syscall.Errno = 148
	ERROR_IS_SUBST_TARGET                                                     syscall.Errno = 149
	ERROR_SYSTEM_TRACE                                                        syscall.Errno = 150
	ERROR_INVALID_EVENT_COUNT                                                 syscall.Errno = 151
	ERROR_TOO_MANY_MUXWAITERS                                                 syscall.Errno = 152
	ERROR_INVALID_LIST_FORMAT                                                 syscall.Errno = 153
	ERROR_LABEL_TOO_LONG                                                      syscall.Errno = 154
	ERROR_TOO_MANY_TCBS                                                       syscall.Errno = 155
	ERROR_SIGNAL_REFUSED                                                      syscall.Errno = 156
	ERROR_DISCARDED                                                           syscall.Errno = 157
	ERROR_NOT_LOCKED                                                          syscall.Errno = 158
	ERROR_BAD_THREADID_ADDR                                                   syscall.Errno = 159
	ERROR_BAD_ARGUMENTS                                                       syscall.Errno = 160
	ERROR_BAD_PATHNAME                                                        syscall.Errno = 161
	ERROR_SIGNAL_PENDING                                                      syscall.Errno = 162
	ERROR_MAX_THRDS_REACHED                                                   syscall.Errno = 164
	ERROR_LOCK_FAILED                                                         syscall.Errno = 167
	ERROR_BUSY                                                                syscall.Errno = 170
	ERROR_DEVICE_SUPPORT_IN_PROGRESS                                          syscall.Errno = 171
	ERROR_CANCEL_VIOLATION                                                    syscall.Errno = 173
	ERROR_ATOMIC_LOCKS_NOT_SUPPORTED                                          syscall.Errno = 174
	ERROR_INVALID_SEGMENT_NUMBER                                              syscall.Errno = 180
	ERROR_INVALID_ORDINAL                                                     syscall.Errno = 182
	ERROR_ALREADY_EXISTS                                                      syscall.Errno = 183
	ERROR_INVALID_FLAG_NUMBER                                                 syscall.Errno = 186
	ERROR_SEM_NOT_FOUND                                                       syscall.Errno = 187
	ERROR_INVALID_STARTING_CODESEG                                            syscall.Errno = 188
	ERROR_INVALID_STACKSEG                                                    syscall.Errno = 189
	ERROR_INVALID_MODULETYPE                                                  syscall.Errno = 190
	ERROR_INVALID_EXE_SIGNATURE                                               syscall.Errno = 191
	ERROR_EXE_MARKED_INVALID                                                  syscall.Errno = 192
	ERROR_BAD_EXE_FORMAT                                                      syscall.Errno = 193
	ERROR_ITERATED_DATA_EXCEEDS_64k                                           syscall.Errno = 194
	ERROR_INVALID_MINALLOCSIZE                                                syscall.Errno = 195
	ERROR_DYNLINK_FROM_INVALID_RING                                           syscall.Errno = 196
	ERROR_IOPL_NOT_ENABLED                                                    syscall.Errno = 197
	ERROR_INVALID_SEGDPL                                                      syscall.Errno = 198
	ERROR_AUTODATASEG_EXCEEDS_64k                                             syscall.Errno = 199
	ERROR_RING2SEG_MUST_BE_MOVABLE                                            syscall.Errno = 200
	ERROR_RELOC_CHAIN_XEEDS_SEGLIM                                            syscall.Errno = 201
	ERROR_INFLOOP_IN_RELOC_CHAIN                                              syscall.Errno = 202
	ERROR_ENVVAR_NOT_FOUND                                                    syscall.Errno = 203
	ERROR_NO_SIGNAL_SENT                                                      syscall.Errno = 205
	ERROR_FILENAME_EXCED_RANGE                                                syscall.Errno = 206
	ERROR_RING2_STACK_IN_USE                                                  syscall.Errno = 207
	ERROR_META_EXPANSION_TOO_LONG                                             syscall.Errno = 208
	ERROR_INVALID_SIGNAL_NUMBER                                               syscall.Errno = 209
	ERROR_THREAD_1_INACTIVE                                                   syscall.Errno = 210
	ERROR_LOCKED                                                              syscall.Errno = 212
	ERROR_TOO_MANY_MODULES                                                    syscall.Errno = 214
	ERROR_NESTING_NOT_ALLOWED                                                 syscall.Errno = 215
	ERROR_EXE_MACHINE_TYPE_MISMATCH                                           syscall.Errno = 216
	ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY                                     syscall.Errno = 217
	ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY                              syscall.Errno = 218
	ERROR_FILE_CHECKED_OUT                                                    syscall.Errno = 220
	ERROR_CHECKOUT_REQUIRED                                                   syscall.Errno = 221
	ERROR_BAD_FILE_TYPE                                                       syscall.Errno = 222
	ERROR_FILE_TOO_LARGE                                                      syscall.Errno = 223
	ERROR_FORMS_AUTH_REQUIRED                                                 syscall.Errno = 224
	ERROR_VIRUS_INFECTED                                                      syscall.Errno = 225
	ERROR_VIRUS_DELETED                                                       syscall.Errno = 226
	ERROR_PIPE_LOCAL                                                          syscall.Errno = 229
	ERROR_BAD_PIPE                                                            syscall.Errno = 230
	ERROR_PIPE_BUSY                                                           syscall.Errno = 231
	ERROR_NO_DATA                                                             syscall.Errno = 232
	ERROR_PIPE_NOT_CONNECTED                                                  syscall.Errno = 233
	ERROR_MORE_DATA                                                           syscall.Errno = 234
	ERROR_NO_WORK_DONE                                                        syscall.Errno = 235
	ERROR_VC_DISCONNECTED                                                     syscall.Errno = 240
	ERROR_INVALID_EA_NAME                                                     syscall.Errno = 254
	ERROR_EA_LIST_INCONSISTENT                                                syscall.Errno = 255
	WAIT_TIMEOUT                                                              syscall.Errno = 258
	ERROR_NO_MORE_ITEMS                                                       syscall.Errno = 259
	ERROR_CANNOT_COPY                                                         syscall.Errno = 266
	ERROR_DIRECTORY                                                           syscall.Errno = 267
	ERROR_EAS_DIDNT_FIT                                                       syscall.Errno = 275
	ERROR_EA_FILE_CORRUPT                                                     syscall.Errno = 276
	ERROR_EA_TABLE_FULL                                                       syscall.Errno = 277
	ERROR_INVALID_EA_HANDLE                                                   syscall.Errno = 278
	ERROR_EAS_NOT_SUPPORTED                                                   syscall.Errno = 282
	ERROR_NOT_OWNER                                                           syscall.Errno = 288
	ERROR_TOO_MANY_POSTS                                                      syscall.Errno = 298
	ERROR_PARTIAL_COPY                                                        syscall.Errno = 299
	ERROR_OPLOCK_NOT_GRANTED                                                  syscall.Errno = 300
	ERROR_INVALID_OPLOCK_PROTOCOL                                             syscall.Errno = 301
	ERROR_DISK_TOO_FRAGMENTED                                                 syscall.Errno = 302
	ERROR_DELETE_PENDING                                                      syscall.Errno = 303
	ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING                syscall.Errno = 304
	ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME                                   syscall.Errno = 305
	ERROR_SECURITY_STREAM_IS_INCONSISTENT                                     syscall.Errno = 306
	ERROR_INVALID_LOCK_RANGE                                                  syscall.Errno = 307
	ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT                                         syscall.Errno = 308
	ERROR_NOTIFICATION_GUID_ALREADY_DEFINED                                   syscall.Errno = 309
	ERROR_INVALID_EXCEPTION_HANDLER                                           syscall.Errno = 310
	ERROR_DUPLICATE_PRIVILEGES                                                syscall.Errno = 311
	ERROR_NO_RANGES_PROCESSED                                                 syscall.Errno = 312
	ERROR_NOT_ALLOWED_ON_SYSTEM_FILE                                          syscall.Errno = 313
	ERROR_DISK_RESOURCES_EXHAUSTED                                            syscall.Errno = 314
	ERROR_INVALID_TOKEN                                                       syscall.Errno = 315
	ERROR_DEVICE_FEATURE_NOT_SUPPORTED                                        syscall.Errno = 316
	ERROR_MR_MID_NOT_FOUND                                                    syscall.Errno = 317
	ERROR_SCOPE_NOT_FOUND                                                     syscall.Errno = 318
	ERROR_UNDEFINED_SCOPE                                                     syscall.Errno = 319
	ERROR_INVALID_CAP                                                         syscall.Errno = 320
	ERROR_DEVICE_UNREACHABLE                                                  syscall.Errno = 321
	ERROR_DEVICE_NO_RESOURCES                                                 syscall.Errno = 322
	ERROR_DATA_CHECKSUM_ERROR                                                 syscall.Errno = 323
	ERROR_INTERMIXED_KERNEL_EA_OPERATION                                      syscall.Errno = 324
	ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED                                       syscall.Errno = 326
	ERROR_OFFSET_ALIGNMENT_VIOLATION                                          syscall.Errno = 327
	ERROR_INVALID_FIELD_IN_PARAMETER_LIST                                     syscall.Errno = 328
	ERROR_OPERATION_IN_PROGRESS                                               syscall.Errno = 329
	ERROR_BAD_DEVICE_PATH                                                     syscall.Errno = 330
	ERROR_TOO_MANY_DESCRIPTORS                                                syscall.Errno = 331
	ERROR_SCRUB_DATA_DISABLED                                                 syscall.Errno = 332
	ERROR_NOT_REDUNDANT_STORAGE                                               syscall.Errno = 333
	ERROR_RESIDENT_FILE_NOT_SUPPORTED                                         syscall.Errno = 334
	ERROR_COMPRESSED_FILE_NOT_SUPPORTED                                       syscall.Errno = 335
	ERROR_DIRECTORY_NOT_SUPPORTED                                             syscall.Errno = 336
	ERROR_NOT_READ_FROM_COPY                                                  syscall.Errno = 337
	ERROR_FT_WRITE_FAILURE                                                    syscall.Errno = 338
	ERROR_FT_DI_SCAN_REQUIRED                                                 syscall.Errno = 339
	ERROR_INVALID_KERNEL_INFO_VERSION                                         syscall.Errno = 340
	ERROR_INVALID_PEP_INFO_VERSION                                            syscall.Errno = 341
	ERROR_OBJECT_NOT_EXTERNALLY_BACKED                                        syscall.Errno = 342
	ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN                                   syscall.Errno = 343
	ERROR_COMPRESSION_NOT_BENEFICIAL                                          syscall.Errno = 344
	ERROR_STORAGE_TOPOLOGY_ID_MISMATCH                                        syscall.Errno = 345
	ERROR_BLOCKED_BY_PARENTAL_CONTROLS                                        syscall.Errno = 346
	ERROR_BLOCK_TOO_MANY_REFERENCES                                           syscall.Errno = 347
	ERROR_MARKED_TO_DISALLOW_WRITES                                           syscall.Errno = 348
	ERROR_ENCLAVE_FAILURE                                                     syscall.Errno = 349
	ERROR_FAIL_NOACTION_REBOOT                                                syscall.Errno = 350
	ERROR_FAIL_SHUTDOWN                                                       syscall.Errno = 351
	ERROR_FAIL_RESTART                                                        syscall.Errno = 352
	ERROR_MAX_SESSIONS_REACHED                                                syscall.Errno = 353
	ERROR_NETWORK_ACCESS_DENIED_EDP                                           syscall.Errno = 354
	ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL                                   syscall.Errno = 355
	ERROR_EDP_POLICY_DENIES_OPERATION                                         syscall.Errno = 356
	ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED                                    syscall.Errno = 357
	ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT                               syscall.Errno = 358
	ERROR_DEVICE_IN_MAINTENANCE                                               syscall.Errno = 359
	ERROR_NOT_SUPPORTED_ON_DAX                                                syscall.Errno = 360
	ERROR_DAX_MAPPING_EXISTS                                                  syscall.Errno = 361
	ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING                                     syscall.Errno = 362
	ERROR_CLOUD_FILE_METADATA_CORRUPT                                         syscall.Errno = 363
	ERROR_CLOUD_FILE_METADATA_TOO_LARGE                                       syscall.Errno = 364
	ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE                                  syscall.Errno = 365
	ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH                          syscall.Errno = 366
	ERROR_CHILD_PROCESS_BLOCKED                                               syscall.Errno = 367
	ERROR_STORAGE_LOST_DATA_PERSISTENCE                                       syscall.Errno = 368
	ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE                              syscall.Errno = 369
	ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT                         syscall.Errno = 370
	ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY                                     syscall.Errno = 371
	ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN                         syscall.Errno = 372
	ERROR_GDI_HANDLE_LEAK                                                     syscall.Errno = 373
	ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS                                  syscall.Errno = 374
	ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED                           syscall.Errno = 375
	ERROR_NOT_A_CLOUD_FILE                                                    syscall.Errno = 376
	ERROR_CLOUD_FILE_NOT_IN_SYNC                                              syscall.Errno = 377
	ERROR_CLOUD_FILE_ALREADY_CONNECTED                                        syscall.Errno = 378
	ERROR_CLOUD_FILE_NOT_SUPPORTED                                            syscall.Errno = 379
	ERROR_CLOUD_FILE_INVALID_REQUEST                                          syscall.Errno = 380
	ERROR_CLOUD_FILE_READ_ONLY_VOLUME                                         syscall.Errno = 381
	ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY                                  syscall.Errno = 382
	ERROR_CLOUD_FILE_VALIDATION_FAILED                                        syscall.Errno = 383
	ERROR_SMB1_NOT_AVAILABLE                                                  syscall.Errno = 384
	ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION                        syscall.Errno = 385
	ERROR_CLOUD_FILE_AUTHENTICATION_FAILED                                    syscall.Errno = 386
	ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES                                   syscall.Errno = 387
	ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE                                      syscall.Errno = 388
	ERROR_CLOUD_FILE_UNSUCCESSFUL                                             syscall.Errno = 389
	ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT                                      syscall.Errno = 390
	ERROR_CLOUD_FILE_IN_USE                                                   syscall.Errno = 391
	ERROR_CLOUD_FILE_PINNED                                                   syscall.Errno = 392
	ERROR_CLOUD_FILE_REQUEST_ABORTED                                          syscall.Errno = 393
	ERROR_CLOUD_FILE_PROPERTY_CORRUPT                                         syscall.Errno = 394
	ERROR_CLOUD_FILE_ACCESS_DENIED                                            syscall.Errno = 395
	ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS                                   syscall.Errno = 396
	ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT                                   syscall.Errno = 397
	ERROR_CLOUD_FILE_REQUEST_CANCELED                                         syscall.Errno = 398
	ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED                                       syscall.Errno = 399
	ERROR_THREAD_MODE_ALREADY_BACKGROUND                                      syscall.Errno = 400
	ERROR_THREAD_MODE_NOT_BACKGROUND                                          syscall.Errno = 401
	ERROR_PROCESS_MODE_ALREADY_BACKGROUND                                     syscall.Errno = 402
	ERROR_PROCESS_MODE_NOT_BACKGROUND                                         syscall.Errno = 403
	ERROR_CLOUD_FILE_PROVIDER_TERMINATED                                      syscall.Errno = 404
	ERROR_NOT_A_CLOUD_SYNC_ROOT                                               syscall.Errno = 405
	ERROR_FILE_PROTECTED_UNDER_DPL                                            syscall.Errno = 406
	ERROR_VOLUME_NOT_CLUSTER_ALIGNED                                          syscall.Errno = 407
	ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND                              syscall.Errno = 408
	ERROR_APPX_FILE_NOT_ENCRYPTED                                             syscall.Errno = 409
	ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED                                  syscall.Errno = 410
	ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET                        syscall.Errno = 411
	ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE                         syscall.Errno = 412
	ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER                         syscall.Errno = 413
	ERROR_LINUX_SUBSYSTEM_NOT_PRESENT                                         syscall.Errno = 414
	ERROR_FT_READ_FAILURE                                                     syscall.Errno = 415
	ERROR_STORAGE_RESERVE_ID_INVALID                                          syscall.Errno = 416
	ERROR_STORAGE_RESERVE_DOES_NOT_EXIST                                      syscall.Errno = 417
	ERROR_STORAGE_RESERVE_ALREADY_EXISTS                                      syscall.Errno = 418
	ERROR_STORAGE_RESERVE_NOT_EMPTY                                           syscall.Errno = 419
	ERROR_NOT_A_DAX_VOLUME                                                    syscall.Errno = 420
	ERROR_NOT_DAX_MAPPABLE                                                    syscall.Errno = 421
	ERROR_TIME_CRITICAL_THREAD                                                syscall.Errno = 422
	ERROR_DPL_NOT_SUPPORTED_FOR_USER                                          syscall.Errno = 423
	ERROR_CASE_DIFFERING_NAMES_IN_DIR                                         syscall.Errno = 424
	ERROR_CAPAUTHZ_NOT_DEVUNLOCKED                                            syscall.Errno = 450
	ERROR_CAPAUTHZ_CHANGE_TYPE                                                syscall.Errno = 451
	ERROR_CAPAUTHZ_NOT_PROVISIONED                                            syscall.Errno = 452
	ERROR_CAPAUTHZ_NOT_AUTHORIZED                                             syscall.Errno = 453
	ERROR_CAPAUTHZ_NO_POLICY                                                  syscall.Errno = 454
	ERROR_CAPAUTHZ_DB_CORRUPTED                                               syscall.Errno = 455
	ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG                                       syscall.Errno = 456
	ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY                                        syscall.Errno = 457
	ERROR_CAPAUTHZ_SCCD_PARSE_ERROR                                           syscall.Errno = 458
	ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED                                     syscall.Errno = 459
	ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH                                   syscall.Errno = 460
	ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT                                     syscall.Errno = 480
	ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT                             syscall.Errno = 481
	ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT                           syscall.Errno = 482
	ERROR_DEVICE_HARDWARE_ERROR                                               syscall.Errno = 483
	ERROR_INVALID_ADDRESS                                                     syscall.Errno = 487
	ERROR_VRF_CFG_ENABLED                                                     syscall.Errno = 1183
	ERROR_PARTITION_TERMINATING                                               syscall.Errno = 1184
	ERROR_USER_PROFILE_LOAD                                                   syscall.Errno = 500
	ERROR_ARITHMETIC_OVERFLOW                                                 syscall.Errno = 534
	ERROR_PIPE_CONNECTED                                                      syscall.Errno = 535
	ERROR_PIPE_LISTENING                                                      syscall.Errno = 536
	ERROR_VERIFIER_STOP                                                       syscall.Errno = 537
	ERROR_ABIOS_ERROR                                                         syscall.Errno = 538
	ERROR_WX86_WARNING                                                        syscall.Errno = 539
	ERROR_WX86_ERROR                                                          syscall.Errno = 540
	ERROR_TIMER_NOT_CANCELED                                                  syscall.Errno = 541
	ERROR_UNWIND                                                              syscall.Errno = 542
	ERROR_BAD_STACK                                                           syscall.Errno = 543
	ERROR_INVALID_UNWIND_TARGET                                               syscall.Errno = 544
	ERROR_INVALID_PORT_ATTRIBUTES                                             syscall.Errno = 545
	ERROR_PORT_MESSAGE_TOO_LONG                                               syscall.Errno = 546
	ERROR_INVALID_QUOTA_LOWER                                                 syscall.Errno = 547
	ERROR_DEVICE_ALREADY_ATTACHED                                             syscall.Errno = 548
	ERROR_INSTRUCTION_MISALIGNMENT                                            syscall.Errno = 549
	ERROR_PROFILING_NOT_STARTED                                               syscall.Errno = 550
	ERROR_PROFILING_NOT_STOPPED                                               syscall.Errno = 551
	ERROR_COULD_NOT_INTERPRET                                                 syscall.Errno = 552
	ERROR_PROFILING_AT_LIMIT                                                  syscall.Errno = 553
	ERROR_CANT_WAIT                                                           syscall.Errno = 554
	ERROR_CANT_TERMINATE_SELF                                                 syscall.Errno = 555
	ERROR_UNEXPECTED_MM_CREATE_ERR                                            syscall.Errno = 556
	ERROR_UNEXPECTED_MM_MAP_ERROR                                             syscall.Errno = 557
	ERROR_UNEXPECTED_MM_EXTEND_ERR                                            syscall.Errno = 558
	ERROR_BAD_FUNCTION_TABLE                                                  syscall.Errno = 559
	ERROR_NO_GUID_TRANSLATION                                                 syscall.Errno = 560
	ERROR_INVALID_LDT_SIZE                                                    syscall.Errno = 561
	ERROR_INVALID_LDT_OFFSET                                                  syscall.Errno = 563
	ERROR_INVALID_LDT_DESCRIPTOR                                              syscall.Errno = 564
	ERROR_TOO_MANY_THREADS                                                    syscall.Errno = 565
	ERROR_THREAD_NOT_IN_PROCESS                                               syscall.Errno = 566
	ERROR_PAGEFILE_QUOTA_EXCEEDED                                             syscall.Errno = 567
	ERROR_LOGON_SERVER_CONFLICT                                               syscall.Errno = 568
	ERROR_SYNCHRONIZATION_REQUIRED                                            syscall.Errno = 569
	ERROR_NET_OPEN_FAILED                                                     syscall.Errno = 570
	ERROR_IO_PRIVILEGE_FAILED                                                 syscall.Errno = 571
	ERROR_CONTROL_C_EXIT                                                      syscall.Errno = 572
	ERROR_MISSING_SYSTEMFILE                                                  syscall.Errno = 573
	ERROR_UNHANDLED_EXCEPTION                                                 syscall.Errno = 574
	ERROR_APP_INIT_FAILURE                                                    syscall.Errno = 575
	ERROR_PAGEFILE_CREATE_FAILED                                              syscall.Errno = 576
	ERROR_INVALID_IMAGE_HASH                                                  syscall.Errno = 577
	ERROR_NO_PAGEFILE                                                         syscall.Errno = 578
	ERROR_ILLEGAL_FLOAT_CONTEXT                                               syscall.Errno = 579
	ERROR_NO_EVENT_PAIR                                                       syscall.Errno = 580
	ERROR_DOMAIN_CTRLR_CONFIG_ERROR                                           syscall.Errno = 581
	ERROR_ILLEGAL_CHARACTER                                                   syscall.Errno = 582
	ERROR_UNDEFINED_CHARACTER                                                 syscall.Errno = 583
	ERROR_FLOPPY_VOLUME                                                       syscall.Errno = 584
	ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT                                    syscall.Errno = 585
	ERROR_BACKUP_CONTROLLER                                                   syscall.Errno = 586
	ERROR_MUTANT_LIMIT_EXCEEDED                                               syscall.Errno = 587
	ERROR_FS_DRIVER_REQUIRED                                                  syscall.Errno = 588
	ERROR_CANNOT_LOAD_REGISTRY_FILE                                           syscall.Errno = 589
	ERROR_DEBUG_ATTACH_FAILED                                                 syscall.Errno = 590
	ERROR_SYSTEM_PROCESS_TERMINATED                                           syscall.Errno = 591
	ERROR_DATA_NOT_ACCEPTED                                                   syscall.Errno = 592
	ERROR_VDM_HARD_ERROR                                                      syscall.Errno = 593
	ERROR_DRIVER_CANCEL_TIMEOUT                                               syscall.Errno = 594
	ERROR_REPLY_MESSAGE_MISMATCH                                              syscall.Errno = 595
	ERROR_LOST_WRITEBEHIND_DATA                                               syscall.Errno = 596
	ERROR_CLIENT_SERVER_PARAMETERS_INVALID                                    syscall.Errno = 597
	ERROR_NOT_TINY_STREAM                                                     syscall.Errno = 598
	ERROR_STACK_OVERFLOW_READ                                                 syscall.Errno = 599
	ERROR_CONVERT_TO_LARGE                                                    syscall.Errno = 600
	ERROR_FOUND_OUT_OF_SCOPE                                                  syscall.Errno = 601
	ERROR_ALLOCATE_BUCKET                                                     syscall.Errno = 602
	ERROR_MARSHALL_OVERFLOW                                                   syscall.Errno = 603
	ERROR_INVALID_VARIANT                                                     syscall.Errno = 604
	ERROR_BAD_COMPRESSION_BUFFER                                              syscall.Errno = 605
	ERROR_AUDIT_FAILED                                                        syscall.Errno = 606
	ERROR_TIMER_RESOLUTION_NOT_SET                                            syscall.Errno = 607
	ERROR_INSUFFICIENT_LOGON_INFO                                             syscall.Errno = 608
	ERROR_BAD_DLL_ENTRYPOINT                                                  syscall.Errno = 609
	ERROR_BAD_SERVICE_ENTRYPOINT                                              syscall.Errno = 610
	ERROR_IP_ADDRESS_CONFLICT1                                                syscall.Errno = 611
	ERROR_IP_ADDRESS_CONFLICT2                                                syscall.Errno = 612
	ERROR_REGISTRY_QUOTA_LIMIT                                                syscall.Errno = 613
	ERROR_NO_CALLBACK_ACTIVE                                                  syscall.Errno = 614
	ERROR_PWD_TOO_SHORT                                                       syscall.Errno = 615
	ERROR_PWD_TOO_RECENT                                                      syscall.Errno = 616
	ERROR_PWD_HISTORY_CONFLICT                                                syscall.Errno = 617
	ERROR_UNSUPPORTED_COMPRESSION                                             syscall.Errno = 618
	ERROR_INVALID_HW_PROFILE                                                  syscall.Errno = 619
	ERROR_INVALID_PLUGPLAY_DEVICE_PATH                                        syscall.Errno = 620
	ERROR_QUOTA_LIST_INCONSISTENT                                             syscall.Errno = 621
	ERROR_EVALUATION_EXPIRATION                                               syscall.Errno = 622
	ERROR_ILLEGAL_DLL_RELOCATION                                              syscall.Errno = 623
	ERROR_DLL_INIT_FAILED_LOGOFF                                              syscall.Errno = 624
	ERROR_VALIDATE_CONTINUE                                                   syscall.Errno = 625
	ERROR_NO_MORE_MATCHES                                                     syscall.Errno = 626
	ERROR_RANGE_LIST_CONFLICT                                                 syscall.Errno = 627
	ERROR_SERVER_SID_MISMATCH                                                 syscall.Errno = 628
	ERROR_CANT_ENABLE_DENY_ONLY                                               syscall.Errno = 629
	ERROR_FLOAT_MULTIPLE_FAULTS                                               syscall.Errno = 630
	ERROR_FLOAT_MULTIPLE_TRAPS                                                syscall.Errno = 631
	ERROR_NOINTERFACE                                                         syscall.Errno = 632
	ERROR_DRIVER_FAILED_SLEEP                                                 syscall.Errno = 633
	ERROR_CORRUPT_SYSTEM_FILE                                                 syscall.Errno = 634
	ERROR_COMMITMENT_MINIMUM                                                  syscall.Errno = 635
	ERROR_PNP_RESTART_ENUMERATION                                             syscall.Errno = 636
	ERROR_SYSTEM_IMAGE_BAD_SIGNATURE                                          syscall.Errno = 637
	ERROR_PNP_REBOOT_REQUIRED                                                 syscall.Errno = 638
	ERROR_INSUFFICIENT_POWER                                                  syscall.Errno = 639
	ERROR_MULTIPLE_FAULT_VIOLATION                                            syscall.Errno = 640
	ERROR_SYSTEM_SHUTDOWN                                                     syscall.Errno = 641
	ERROR_PORT_NOT_SET                                                        syscall.Errno = 642
	ERROR_DS_VERSION_CHECK_FAILURE                                            syscall.Errno = 643
	ERROR_RANGE_NOT_FOUND                                                     syscall.Errno = 644
	ERROR_NOT_SAFE_MODE_DRIVER                                                syscall.Errno = 646
	ERROR_FAILED_DRIVER_ENTRY                                                 syscall.Errno = 647
	ERROR_DEVICE_ENUMERATION_ERROR                                            syscall.Errno = 648
	ERROR_MOUNT_POINT_NOT_RESOLVED                                            syscall.Errno = 649
	ERROR_INVALID_DEVICE_OBJECT_PARAMETER                                     syscall.Errno = 650
	ERROR_MCA_OCCURED                                                         syscall.Errno = 651
	ERROR_DRIVER_DATABASE_ERROR                                               syscall.Errno = 652
	ERROR_SYSTEM_HIVE_TOO_LARGE                                               syscall.Errno = 653
	ERROR_DRIVER_FAILED_PRIOR_UNLOAD                                          syscall.Errno = 654
	ERROR_VOLSNAP_PREPARE_HIBERNATE                                           syscall.Errno = 655
	ERROR_HIBERNATION_FAILURE                                                 syscall.Errno = 656
	ERROR_PWD_TOO_LONG                                                        syscall.Errno = 657
	ERROR_FILE_SYSTEM_LIMITATION                                              syscall.Errno = 665
	ERROR_ASSERTION_FAILURE                                                   syscall.Errno = 668
	ERROR_ACPI_ERROR                                                          syscall.Errno = 669
	ERROR_WOW_ASSERTION                                                       syscall.Errno = 670
	ERROR_PNP_BAD_MPS_TABLE                                                   syscall.Errno = 671
	ERROR_PNP_TRANSLATION_FAILED                                              syscall.Errno = 672
	ERROR_PNP_IRQ_TRANSLATION_FAILED                                          syscall.Errno = 673
	ERROR_PNP_INVALID_ID                                                      syscall.Errno = 674
	ERROR_WAKE_SYSTEM_DEBUGGER                                                syscall.Errno = 675
	ERROR_HANDLES_CLOSED                                                      syscall.Errno = 676
	ERROR_EXTRANEOUS_INFORMATION                                              syscall.Errno = 677
	ERROR_RXACT_COMMIT_NECESSARY                                              syscall.Errno = 678
	ERROR_MEDIA_CHECK                                                         syscall.Errno = 679
	ERROR_GUID_SUBSTITUTION_MADE                                              syscall.Errno = 680
	ERROR_STOPPED_ON_SYMLINK                                                  syscall.Errno = 681
	ERROR_LONGJUMP                                                            syscall.Errno = 682
	ERROR_PLUGPLAY_QUERY_VETOED                                               syscall.Errno = 683
	ERROR_UNWIND_CONSOLIDATE                                                  syscall.Errno = 684
	ERROR_REGISTRY_HIVE_RECOVERED                                             syscall.Errno = 685
	ERROR_DLL_MIGHT_BE_INSECURE                                               syscall.Errno = 686
	ERROR_DLL_MIGHT_BE_INCOMPATIBLE                                           syscall.Errno = 687
	ERROR_DBG_EXCEPTION_NOT_HANDLED                                           syscall.Errno = 688
	ERROR_DBG_REPLY_LATER                                                     syscall.Errno = 689
	ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE                                        syscall.Errno = 690
	ERROR_DBG_TERMINATE_THREAD                                                syscall.Errno = 691
	ERROR_DBG_TERMINATE_PROCESS                                               syscall.Errno = 692
	ERROR_DBG_CONTROL_C                                                       syscall.Errno = 693
	ERROR_DBG_PRINTEXCEPTION_C                                                syscall.Errno = 694
	ERROR_DBG_RIPEXCEPTION                                                    syscall.Errno = 695
	ERROR_DBG_CONTROL_BREAK                                                   syscall.Errno = 696
	ERROR_DBG_COMMAND_EXCEPTION                                               syscall.Errno = 697
	ERROR_OBJECT_NAME_EXISTS                                                  syscall.Errno = 698
	ERROR_THREAD_WAS_SUSPENDED                                                syscall.Errno = 699
	ERROR_IMAGE_NOT_AT_BASE                                                   syscall.Errno = 700
	ERROR_RXACT_STATE_CREATED                                                 syscall.Errno = 701
	ERROR_SEGMENT_NOTIFICATION                                                syscall.Errno = 702
	ERROR_BAD_CURRENT_DIRECTORY                                               syscall.Errno = 703
	ERROR_FT_READ_RECOVERY_FROM_BACKUP                                        syscall.Errno = 704
	ERROR_FT_WRITE_RECOVERY                                                   syscall.Errno = 705
	ERROR_IMAGE_MACHINE_TYPE_MISMATCH                                         syscall.Errno = 706
	ERROR_RECEIVE_PARTIAL                                                     syscall.Errno = 707
	ERROR_RECEIVE_EXPEDITED                                                   syscall.Errno = 708
	ERROR_RECEIVE_PARTIAL_EXPEDITED                                           syscall.Errno = 709
	ERROR_EVENT_DONE                                                          syscall.Errno = 710
	ERROR_EVENT_PENDING                                                       syscall.Errno = 711
	ERROR_CHECKING_FILE_SYSTEM                                                syscall.Errno = 712
	ERROR_FATAL_APP_EXIT                                                      syscall.Errno = 713
	ERROR_PREDEFINED_HANDLE                                                   syscall.Errno = 714
	ERROR_WAS_UNLOCKED                                                        syscall.Errno = 715
	ERROR_SERVICE_NOTIFICATION                                                syscall.Errno = 716
	ERROR_WAS_LOCKED                                                          syscall.Errno = 717
	ERROR_LOG_HARD_ERROR                                                      syscall.Errno = 718
	ERROR_ALREADY_WIN32                                                       syscall.Errno = 719
	ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE                                     syscall.Errno = 720
	ERROR_NO_YIELD_PERFORMED                                                  syscall.Errno = 721
	ERROR_TIMER_RESUME_IGNORED                                                syscall.Errno = 722
	ERROR_ARBITRATION_UNHANDLED                                               syscall.Errno = 723
	ERROR_CARDBUS_NOT_SUPPORTED                                               syscall.Errno = 724
	ERROR_MP_PROCESSOR_MISMATCH                                               syscall.Errno = 725
	ERROR_HIBERNATED                                                          syscall.Errno = 726
	ERROR_RESUME_HIBERNATION                                                  syscall.Errno = 727
	ERROR_FIRMWARE_UPDATED                                                    syscall.Errno = 728
	ERROR_DRIVERS_LEAKING_LOCKED_PAGES                                        syscall.Errno = 729
	ERROR_WAKE_SYSTEM                                                         syscall.Errno = 730
	ERROR_WAIT_1                                                              syscall.Errno = 731
	ERROR_WAIT_2                                                              syscall.Errno = 732
	ERROR_WAIT_3                                                              syscall.Errno = 733
	ERROR_WAIT_63                                                             syscall.Errno = 734
	ERROR_ABANDONED_WAIT_0                                                    syscall.Errno = 735
	ERROR_ABANDONED_WAIT_63                                                   syscall.Errno = 736
	ERROR_USER_APC                                                            syscall.Errno = 737
	ERROR_KERNEL_APC                                                          syscall.Errno = 738
	ERROR_ALERTED                                                             syscall.Errno = 739
	ERROR_ELEVATION_REQUIRED                                                  syscall.Errno = 740
	ERROR_REPARSE                                                             syscall.Errno = 741
	ERROR_OPLOCK_BREAK_IN_PROGRESS                                            syscall.Errno = 742
	ERROR_VOLUME_MOUNTED                                                      syscall.Errno = 743
	ERROR_RXACT_COMMITTED                                                     syscall.Errno = 744
	ERROR_NOTIFY_CLEANUP                                                      syscall.Errno = 745
	ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED                                    syscall.Errno = 746
	ERROR_PAGE_FAULT_TRANSITION                                               syscall.Errno = 747
	ERROR_PAGE_FAULT_DEMAND_ZERO                                              syscall.Errno = 748
	ERROR_PAGE_FAULT_COPY_ON_WRITE                                            syscall.Errno = 749
	ERROR_PAGE_FAULT_GUARD_PAGE                                               syscall.Errno = 750
	ERROR_PAGE_FAULT_PAGING_FILE                                              syscall.Errno = 751
	ERROR_CACHE_PAGE_LOCKED                                                   syscall.Errno = 752
	ERROR_CRASH_DUMP                                                          syscall.Errno = 753
	ERROR_BUFFER_ALL_ZEROS                                                    syscall.Errno = 754
	ERROR_REPARSE_OBJECT                                                      syscall.Errno = 755
	ERROR_RESOURCE_REQUIREMENTS_CHANGED                                       syscall.Errno = 756
	ERROR_TRANSLATION_COMPLETE                                                syscall.Errno = 757
	ERROR_NOTHING_TO_TERMINATE                                                syscall.Errno = 758
	ERROR_PROCESS_NOT_IN_JOB                                                  syscall.Errno = 759
	ERROR_PROCESS_IN_JOB                                                      syscall.Errno = 760
	ERROR_VOLSNAP_HIBERNATE_READY                                             syscall.Errno = 761
	ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY                                  syscall.Errno = 762
	ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED                                  syscall.Errno = 763
	ERROR_INTERRUPT_STILL_CONNECTED                                           syscall.Errno = 764
	ERROR_WAIT_FOR_OPLOCK                                                     syscall.Errno = 765
	ERROR_DBG_EXCEPTION_HANDLED                                               syscall.Errno = 766
	ERROR_DBG_CONTINUE                                                        syscall.Errno = 767
	ERROR_CALLBACK_POP_STACK                                                  syscall.Errno = 768
	ERROR_COMPRESSION_DISABLED                                                syscall.Errno = 769
	ERROR_CANTFETCHBACKWARDS                                                  syscall.Errno = 770
	ERROR_CANTSCROLLBACKWARDS                                                 syscall.Errno = 771
	ERROR_ROWSNOTRELEASED                                                     syscall.Errno = 772
	ERROR_BAD_ACCESSOR_FLAGS                                                  syscall.Errno = 773
	ERROR_ERRORS_ENCOUNTERED                                                  syscall.Errno = 774
	ERROR_NOT_CAPABLE                                                         syscall.Errno = 775
	ERROR_REQUEST_OUT_OF_SEQUENCE                                             syscall.Errno = 776
	ERROR_VERSION_PARSE_ERROR                                                 syscall.Errno = 777
	ERROR_BADSTARTPOSITION                                                    syscall.Errno = 778
	ERROR_MEMORY_HARDWARE                                                     syscall.Errno = 779
	ERROR_DISK_REPAIR_DISABLED                                                syscall.Errno = 780
	ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE             syscall.Errno = 781
	ERROR_SYSTEM_POWERSTATE_TRANSITION                                        syscall.Errno = 782
	ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION                                syscall.Errno = 783
	ERROR_MCA_EXCEPTION                                                       syscall.Errno = 784
	ERROR_ACCESS_AUDIT_BY_POLICY                                              syscall.Errno = 785
	ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY                               syscall.Errno = 786
	ERROR_ABANDON_HIBERFILE                                                   syscall.Errno = 787
	ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED                          syscall.Errno = 788
	ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR                          syscall.Errno = 789
	ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR                              syscall.Errno = 790
	ERROR_BAD_MCFG_TABLE                                                      syscall.Errno = 791
	ERROR_DISK_REPAIR_REDIRECTED                                              syscall.Errno = 792
	ERROR_DISK_REPAIR_UNSUCCESSFUL                                            syscall.Errno = 793
	ERROR_CORRUPT_LOG_OVERFULL                                                syscall.Errno = 794
	ERROR_CORRUPT_LOG_CORRUPTED                                               syscall.Errno = 795
	ERROR_CORRUPT_LOG_UNAVAILABLE                                             syscall.Errno = 796
	ERROR_CORRUPT_LOG_DELETED_FULL                                            syscall.Errno = 797
	ERROR_CORRUPT_LOG_CLEARED                                                 syscall.Errno = 798
	ERROR_ORPHAN_NAME_EXHAUSTED                                               syscall.Errno = 799
	ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE                                       syscall.Errno = 800
	ERROR_CANNOT_GRANT_REQUESTED_OPLOCK                                       syscall.Errno = 801
	ERROR_CANNOT_BREAK_OPLOCK                                                 syscall.Errno = 802
	ERROR_OPLOCK_HANDLE_CLOSED                                                syscall.Errno = 803
	ERROR_NO_ACE_CONDITION                                                    syscall.Errno = 804
	ERROR_INVALID_ACE_CONDITION                                               syscall.Errno = 805
	ERROR_FILE_HANDLE_REVOKED                                                 syscall.Errno = 806
	ERROR_IMAGE_AT_DIFFERENT_BASE                                             syscall.Errno = 807
	ERROR_ENCRYPTED_IO_NOT_POSSIBLE                                           syscall.Errno = 808
	ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS                              syscall.Errno = 809
	ERROR_QUOTA_ACTIVITY                                                      syscall.Errno = 810
	ERROR_HANDLE_REVOKED                                                      syscall.Errno = 811
	ERROR_CALLBACK_INVOKE_INLINE                                              syscall.Errno = 812
	ERROR_CPU_SET_INVALID                                                     syscall.Errno = 813
	ERROR_ENCLAVE_NOT_TERMINATED                                              syscall.Errno = 814
	ERROR_ENCLAVE_VIOLATION                                                   syscall.Errno = 815
	ERROR_EA_ACCESS_DENIED                                                    syscall.Errno = 994
	ERROR_OPERATION_ABORTED                                                   syscall.Errno = 995
	ERROR_IO_INCOMPLETE                                                       syscall.Errno = 996
	ERROR_IO_PENDING                                                          syscall.Errno = 997
	ERROR_NOACCESS                                                            syscall.Errno = 998
	ERROR_SWAPERROR                                                           syscall.Errno = 999
	ERROR_STACK_OVERFLOW                                                      syscall.Errno = 1001
	ERROR_INVALID_MESSAGE                                                     syscall.Errno = 1002
	ERROR_CAN_NOT_COMPLETE                                                    syscall.Errno = 1003
	ERROR_INVALID_FLAGS                                                       syscall.Errno = 1004
	ERROR_UNRECOGNIZED_VOLUME                                                 syscall.Errno = 1005
	ERROR_FILE_INVALID                                                        syscall.Errno = 1006
	ERROR_FULLSCREEN_MODE                                                     syscall.Errno = 1007
	ERROR_NO_TOKEN                                                            syscall.Errno = 1008
	ERROR_BADDB                                                               syscall.Errno = 1009
	ERROR_BADKEY                                                              syscall.Errno = 1010
	ERROR_CANTOPEN                                                            syscall.Errno = 1011
	ERROR_CANTREAD                                                            syscall.Errno = 1012
	ERROR_CANTWRITE                                                           syscall.Errno = 1013
	ERROR_REGISTRY_RECOVERED                                                  syscall.Errno = 1014
	ERROR_REGISTRY_CORRUPT                                                    syscall.Errno = 1015
	ERROR_REGISTRY_IO_FAILED                                                  syscall.Errno = 1016
	ERROR_NOT_REGISTRY_FILE                                                   syscall.Errno = 1017
	ERROR_KEY_DELETED                                                         syscall.Errno = 1018
	ERROR_NO_LOG_SPACE                                                        syscall.Errno = 1019
	ERROR_KEY_HAS_CHILDREN                                                    syscall.Errno = 1020
	ERROR_CHILD_MUST_BE_VOLATILE                                              syscall.Errno = 1021
	ERROR_NOTIFY_ENUM_DIR                                                     syscall.Errno = 1022
	ERROR_DEPENDENT_SERVICES_RUNNING                                          syscall.Errno = 1051
	ERROR_INVALID_SERVICE_CONTROL                                             syscall.Errno = 1052
	ERROR_SERVICE_REQUEST_TIMEOUT                                             syscall.Errno = 1053
	ERROR_SERVICE_NO_THREAD                                                   syscall.Errno = 1054
	ERROR_SERVICE_DATABASE_LOCKED                                             syscall.Errno = 1055
	ERROR_SERVICE_ALREADY_RUNNING                                             syscall.Errno = 1056
	ERROR_INVALID_SERVICE_ACCOUNT                                             syscall.Errno = 1057
	ERROR_SERVICE_DISABLED                                                    syscall.Errno = 1058
	ERROR_CIRCULAR_DEPENDENCY                                                 syscall.Errno = 1059
	ERROR_SERVICE_DOES_NOT_EXIST                                              syscall.Errno = 1060
	ERROR_SERVICE_CANNOT_ACCEPT_CTRL                                          syscall.Errno = 1061
	ERROR_SERVICE_NOT_ACTIVE                                                  syscall.Errno = 1062
	ERROR_FAILED_SERVICE_CONTROLLER_CONNECT                                   syscall.Errno = 1063
	ERROR_EXCEPTION_IN_SERVICE                                                syscall.Errno = 1064
	ERROR_DATABASE_DOES_NOT_EXIST                                             syscall.Errno = 1065
	ERROR_SERVICE_SPECIFIC_ERROR                                              syscall.Errno = 1066
	ERROR_PROCESS_ABORTED                                                     syscall.Errno = 1067
	ERROR_SERVICE_DEPENDENCY_FAIL                                             syscall.Errno = 1068
	ERROR_SERVICE_LOGON_FAILED                                                syscall.Errno = 1069
	ERROR_SERVICE_START_HANG                                                  syscall.Errno = 1070
	ERROR_INVALID_SERVICE_LOCK                                                syscall.Errno = 1071
	ERROR_SERVICE_MARKED_FOR_DELETE                                           syscall.Errno = 1072
	ERROR_SERVICE_EXISTS                                                      syscall.Errno = 1073
	ERROR_ALREADY_RUNNING_LKG                                                 syscall.Errno = 1074
	ERROR_SERVICE_DEPENDENCY_DELETED                                          syscall.Errno = 1075
	ERROR_BOOT_ALREADY_ACCEPTED                                               syscall.Errno = 1076
	ERROR_SERVICE_NEVER_STARTED                                               syscall.Errno = 1077
	ERROR_DUPLICATE_SERVICE_NAME                                              syscall.Errno = 1078
	ERROR_DIFFERENT_SERVICE_ACCOUNT                                           syscall.Errno = 1079
	ERROR_CANNOT_DETECT_DRIVER_FAILURE                                        syscall.Errno = 1080
	ERROR_CANNOT_DETECT_PROCESS_ABORT                                         syscall.Errno = 1081
	ERROR_NO_RECOVERY_PROGRAM                                                 syscall.Errno = 1082
	ERROR_SERVICE_NOT_IN_EXE                                                  syscall.Errno = 1083
	ERROR_NOT_SAFEBOOT_SERVICE                                                syscall.Errno = 1084
	ERROR_END_OF_MEDIA                                                        syscall.Errno = 1100
	ERROR_FILEMARK_DETECTED                                                   syscall.Errno = 1101
	ERROR_BEGINNING_OF_MEDIA                                                  syscall.Errno = 1102
	ERROR_SETMARK_DETECTED                                                    syscall.Errno = 1103
	ERROR_NO_DATA_DETECTED                                                    syscall.Errno = 1104
	ERROR_PARTITION_FAILURE                                                   syscall.Errno = 1105
	ERROR_INVALID_BLOCK_LENGTH                                                syscall.Errno = 1106
	ERROR_DEVICE_NOT_PARTITIONED                                              syscall.Errno = 1107
	ERROR_UNABLE_TO_LOCK_MEDIA                                                syscall.Errno = 1108
	ERROR_UNABLE_TO_UNLOAD_MEDIA                                              syscall.Errno = 1109
	ERROR_MEDIA_CHANGED                                                       syscall.Errno = 1110
	ERROR_BUS_RESET                                                           syscall.Errno = 1111
	ERROR_NO_MEDIA_IN_DRIVE                                                   syscall.Errno = 1112
	ERROR_NO_UNICODE_TRANSLATION                                              syscall.Errno = 1113
	ERROR_DLL_INIT_FAILED                                                     syscall.Errno = 1114
	ERROR_SHUTDOWN_IN_PROGRESS                                                syscall.Errno = 1115
	ERROR_NO_SHUTDOWN_IN_PROGRESS                                             syscall.Errno = 1116
	ERROR_IO_DEVICE                                                           syscall.Errno = 1117
	ERROR_SERIAL_NO_DEVICE                                                    syscall.Errno = 1118
	ERROR_IRQ_BUSY                                                            syscall.Errno = 1119
	ERROR_MORE_WRITES                                                         syscall.Errno = 1120
	ERROR_COUNTER_TIMEOUT                                                     syscall.Errno = 1121
	ERROR_FLOPPY_ID_MARK_NOT_FOUND                                            syscall.Errno = 1122
	ERROR_FLOPPY_WRONG_CYLINDER                                               syscall.Errno = 1123
	ERROR_FLOPPY_UNKNOWN_ERROR                                                syscall.Errno = 1124
	ERROR_FLOPPY_BAD_REGISTERS                                                syscall.Errno = 1125
	ERROR_DISK_RECALIBRATE_FAILED                                             syscall.Errno = 1126
	ERROR_DISK_OPERATION_FAILED                                               syscall.Errno = 1127
	ERROR_DISK_RESET_FAILED                                                   syscall.Errno = 1128
	ERROR_EOM_OVERFLOW                                                        syscall.Errno = 1129
	ERROR_NOT_ENOUGH_SERVER_MEMORY                                            syscall.Errno = 1130
	ERROR_POSSIBLE_DEADLOCK                                                   syscall.Errno = 1131
	ERROR_MAPPED_ALIGNMENT                                                    syscall.Errno = 1132
	ERROR_SET_POWER_STATE_VETOED                                              syscall.Errno = 1140
	ERROR_SET_POWER_STATE_FAILED                                              syscall.Errno = 1141
	ERROR_TOO_MANY_LINKS                                                      syscall.Errno = 1142
	ERROR_OLD_WIN_VERSION                                                     syscall.Errno = 1150
	ERROR_APP_WRONG_OS                                                        syscall.Errno = 1151
	ERROR_SINGLE_INSTANCE_APP                                                 syscall.Errno = 1152
	ERROR_RMODE_APP                                                           syscall.Errno = 1153
	ERROR_INVALID_DLL                                                         syscall.Errno = 1154
	ERROR_NO_ASSOCIATION                                                      syscall.Errno = 1155
	ERROR_DDE_FAIL                                                            syscall.Errno = 1156
	ERROR_DLL_NOT_FOUND                                                       syscall.Errno = 1157
	ERROR_NO_MORE_USER_HANDLES                                                syscall.Errno = 1158
	ERROR_MESSAGE_SYNC_ONLY                                                   syscall.Errno = 1159
	ERROR_SOURCE_ELEMENT_EMPTY                                                syscall.Errno = 1160
	ERROR_DESTINATION_ELEMENT_FULL                                            syscall.Errno = 1161
	ERROR_ILLEGAL_ELEMENT_ADDRESS                                             syscall.Errno = 1162
	ERROR_MAGAZINE_NOT_PRESENT                                                syscall.Errno = 1163
	ERROR_DEVICE_REINITIALIZATION_NEEDED                                      syscall.Errno = 1164
	ERROR_DEVICE_REQUIRES_CLEANING                                            syscall.Errno = 1165
	ERROR_DEVICE_DOOR_OPEN                                                    syscall.Errno = 1166
	ERROR_DEVICE_NOT_CONNECTED                                                syscall.Errno = 1167
	ERROR_NOT_FOUND                                                           syscall.Errno = 1168
	ERROR_NO_MATCH                                                            syscall.Errno = 1169
	ERROR_SET_NOT_FOUND                                                       syscall.Errno = 1170
	ERROR_POINT_NOT_FOUND                                                     syscall.Errno = 1171
	ERROR_NO_TRACKING_SERVICE                                                 syscall.Errno = 1172
	ERROR_NO_VOLUME_ID                                                        syscall.Errno = 1173
	ERROR_UNABLE_TO_REMOVE_REPLACED                                           syscall.Errno = 1175
	ERROR_UNABLE_TO_MOVE_REPLACEMENT                                          syscall.Errno = 1176
	ERROR_UNABLE_TO_MOVE_REPLACEMENT_2                                        syscall.Errno = 1177
	ERROR_JOURNAL_DELETE_IN_PROGRESS                                          syscall.Errno = 1178
	ERROR_JOURNAL_NOT_ACTIVE                                                  syscall.Errno = 1179
	ERROR_POTENTIAL_FILE_FOUND                                                syscall.Errno = 1180
	ERROR_JOURNAL_ENTRY_DELETED                                               syscall.Errno = 1181
	ERROR_SHUTDOWN_IS_SCHEDULED                                               syscall.Errno = 1190
	ERROR_SHUTDOWN_USERS_LOGGED_ON                                            syscall.Errno = 1191
	ERROR_BAD_DEVICE                                                          syscall.Errno = 1200
	ERROR_CONNECTION_UNAVAIL                                                  syscall.Errno = 1201
	ERROR_DEVICE_ALREADY_REMEMBERED                                           syscall.Errno = 1202
	ERROR_NO_NET_OR_BAD_PATH                                                  syscall.Errno = 1203
	ERROR_BAD_PROVIDER                                                        syscall.Errno = 1204
	ERROR_CANNOT_OPEN_PROFILE                                                 syscall.Errno = 1205
	ERROR_BAD_PROFILE                                                         syscall.Errno = 1206
	ERROR_NOT_CONTAINER                                                       syscall.Errno = 1207
	ERROR_EXTENDED_ERROR                                                      syscall.Errno = 1208
	ERROR_INVALID_GROUPNAME                                                   syscall.Errno = 1209
	ERROR_INVALID_COMPUTERNAME                                                syscall.Errno = 1210
	ERROR_INVALID_EVENTNAME                                                   syscall.Errno = 1211
	ERROR_INVALID_DOMAINNAME                                                  syscall.Errno = 1212
	ERROR_INVALID_SERVICENAME                                                 syscall.Errno = 1213
	ERROR_INVALID_NETNAME                                                     syscall.Errno = 1214
	ERROR_INVALID_SHARENAME                                                   syscall.Errno = 1215
	ERROR_INVALID_PASSWORDNAME                                                syscall.Errno = 1216
	ERROR_INVALID_MESSAGENAME                                                 syscall.Errno = 1217
	ERROR_INVALID_MESSAGEDEST                                                 syscall.Errno = 1218
	ERROR_SESSION_CREDENTIAL_CONFLICT                                         syscall.Errno = 1219
	ERROR_REMOTE_SESSION_LIMIT_EXCEEDED                                       syscall.Errno = 1220
	ERROR_DUP_DOMAINNAME                                                      syscall.Errno = 1221
	ERROR_NO_NETWORK                                                          syscall.Errno = 1222
	ERROR_CANCELLED                                                           syscall.Errno = 1223
	ERROR_USER_MAPPED_FILE                                                    syscall.Errno = 1224
	ERROR_CONNECTION_REFUSED                                                  syscall.Errno = 1225
	ERROR_GRACEFUL_DISCONNECT                                                 syscall.Errno = 1226
	ERROR_ADDRESS_ALREADY_ASSOCIATED                                          syscall.Errno = 1227
	ERROR_ADDRESS_NOT_ASSOCIATED                                              syscall.Errno = 1228
	ERROR_CONNECTION_INVALID                                                  syscall.Errno = 1229
	ERROR_CONNECTION_ACTIVE                                                   syscall.Errno = 1230
	ERROR_NETWORK_UNREACHABLE                                                 syscall.Errno = 1231
	ERROR_HOST_UNREACHABLE                                                    syscall.Errno = 1232
	ERROR_PROTOCOL_UNREACHABLE                                                syscall.Errno = 1233
	ERROR_PORT_UNREACHABLE                                                    syscall.Errno = 1234
	ERROR_REQUEST_ABORTED                                                     syscall.Errno = 1235
	ERROR_CONNECTION_ABORTED                                                  syscall.Errno = 1236
	ERROR_RETRY                                                               syscall.Errno = 1237
	ERROR_CONNECTION_COUNT_LIMIT                                              syscall.Errno = 1238
	ERROR_LOGIN_TIME_RESTRICTION                                              syscall.Errno = 1239
	ERROR_LOGIN_WKSTA_RESTRICTION                                             syscall.Errno = 1240
	ERROR_INCORRECT_ADDRESS                                                   syscall.Errno = 1241
	ERROR_ALREADY_REGISTERED                                                  syscall.Errno = 1242
	ERROR_SERVICE_NOT_FOUND                                                   syscall.Errno = 1243
	ERROR_NOT_AUTHENTICATED                                                   syscall.Errno = 1244
	ERROR_NOT_LOGGED_ON                                                       syscall.Errno = 1245
	ERROR_CONTINUE                                                            syscall.Errno = 1246
	ERROR_ALREADY_INITIALIZED                                                 syscall.Errno = 1247
	ERROR_NO_MORE_DEVICES                                                     syscall.Errno = 1248
	ERROR_NO_SUCH_SITE                                                        syscall.Errno = 1249
	ERROR_DOMAIN_CONTROLLER_EXISTS                                            syscall.Errno = 1250
	ERROR_ONLY_IF_CONNECTED                                                   syscall.Errno = 1251
	ERROR_OVERRIDE_NOCHANGES                                                  syscall.Errno = 1252
	ERROR_BAD_USER_PROFILE                                                    syscall.Errno = 1253
	ERROR_NOT_SUPPORTED_ON_SBS                                                syscall.Errno = 1254
	ERROR_SERVER_SHUTDOWN_IN_PROGRESS                                         syscall.Errno = 1255
	ERROR_HOST_DOWN                                                           syscall.Errno = 1256
	ERROR_NON_ACCOUNT_SID                                                     syscall.Errno = 1257
	ERROR_NON_DOMAIN_SID                                                      syscall.Errno = 1258
	ERROR_APPHELP_BLOCK                                                       syscall.Errno = 1259
	ERROR_ACCESS_DISABLED_BY_POLICY                                           syscall.Errno = 1260
	ERROR_REG_NAT_CONSUMPTION                                                 syscall.Errno = 1261
	ERROR_CSCSHARE_OFFLINE                                                    syscall.Errno = 1262
	ERROR_PKINIT_FAILURE                                                      syscall.Errno = 1263
	ERROR_SMARTCARD_SUBSYSTEM_FAILURE                                         syscall.Errno = 1264
	ERROR_DOWNGRADE_DETECTED                                                  syscall.Errno = 1265
	ERROR_MACHINE_LOCKED                                                      syscall.Errno = 1271
	ERROR_SMB_GUEST_LOGON_BLOCKED                                             syscall.Errno = 1272
	ERROR_CALLBACK_SUPPLIED_INVALID_DATA                                      syscall.Errno = 1273
	ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED                                    syscall.Errno = 1274
	ERROR_DRIVER_BLOCKED                                                      syscall.Errno = 1275
	ERROR_INVALID_IMPORT_OF_NON_DLL                                           syscall.Errno = 1276
	ERROR_ACCESS_DISABLED_WEBBLADE                                            syscall.Errno = 1277
	ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER                                     syscall.Errno = 1278
	ERROR_RECOVERY_FAILURE                                                    syscall.Errno = 1279
	ERROR_ALREADY_FIBER                                                       syscall.Errno = 1280
	ERROR_ALREADY_THREAD                                                      syscall.Errno = 1281
	ERROR_STACK_BUFFER_OVERRUN                                                syscall.Errno = 1282
	ERROR_PARAMETER_QUOTA_EXCEEDED                                            syscall.Errno = 1283
	ERROR_DEBUGGER_INACTIVE                                                   syscall.Errno = 1284
	ERROR_DELAY_LOAD_FAILED                                                   syscall.Errno = 1285
	ERROR_VDM_DISALLOWED                                                      syscall.Errno = 1286
	ERROR_UNIDENTIFIED_ERROR                                                  syscall.Errno = 1287
	ERROR_INVALID_CRUNTIME_PARAMETER                                          syscall.Errno = 1288
	ERROR_BEYOND_VDL                                                          syscall.Errno = 1289
	ERROR_INCOMPATIBLE_SERVICE_SID_TYPE                                       syscall.Errno = 1290
	ERROR_DRIVER_PROCESS_TERMINATED                                           syscall.Errno = 1291
	ERROR_IMPLEMENTATION_LIMIT                                                syscall.Errno = 1292
	ERROR_PROCESS_IS_PROTECTED                                                syscall.Errno = 1293
	ERROR_SERVICE_NOTIFY_CLIENT_LAGGING                                       syscall.Errno = 1294
	ERROR_DISK_QUOTA_EXCEEDED                                                 syscall.Errno = 1295
	ERROR_CONTENT_BLOCKED                                                     syscall.Errno = 1296
	ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE                                      syscall.Errno = 1297
	ERROR_APP_HANG                                                            syscall.Errno = 1298
	ERROR_INVALID_LABEL                                                       syscall.Errno = 1299
	ERROR_NOT_ALL_ASSIGNED                                                    syscall.Errno = 1300
	ERROR_SOME_NOT_MAPPED                                                     syscall.Errno = 1301
	ERROR_NO_QUOTAS_FOR_ACCOUNT                                               syscall.Errno = 1302
	ERROR_LOCAL_USER_SESSION_KEY                                              syscall.Errno = 1303
	ERROR_NULL_LM_PASSWORD                                                    syscall.Errno = 1304
	ERROR_UNKNOWN_REVISION                                                    syscall.Errno = 1305
	ERROR_REVISION_MISMATCH                                                   syscall.Errno = 1306
	ERROR_INVALID_OWNER                                                       syscall.Errno = 1307
	ERROR_INVALID_PRIMARY_GROUP                                               syscall.Errno = 1308
	ERROR_NO_IMPERSONATION_TOKEN                                              syscall.Errno = 1309
	ERROR_CANT_DISABLE_MANDATORY                                              syscall.Errno = 1310
	ERROR_NO_LOGON_SERVERS                                                    syscall.Errno = 1311
	ERROR_NO_SUCH_LOGON_SESSION                                               syscall.Errno = 1312
	ERROR_NO_SUCH_PRIVILEGE                                                   syscall.Errno = 1313
	ERROR_PRIVILEGE_NOT_HELD                                                  syscall.Errno = 1314
	ERROR_INVALID_ACCOUNT_NAME                                                syscall.Errno = 1315
	ERROR_USER_EXISTS                                                         syscall.Errno = 1316
	ERROR_NO_SUCH_USER                                                        syscall.Errno = 1317
	ERROR_GROUP_EXISTS                                                        syscall.Errno = 1318
	ERROR_NO_SUCH_GROUP                                                       syscall.Errno = 1319
	ERROR_MEMBER_IN_GROUP                                                     syscall.Errno = 1320
	ERROR_MEMBER_NOT_IN_GROUP                                                 syscall.Errno = 1321
	ERROR_LAST_ADMIN                                                          syscall.Errno = 1322
	ERROR_WRONG_PASSWORD                                                      syscall.Errno = 1323
	ERROR_ILL_FORMED_PASSWORD                                                 syscall.Errno = 1324
	ERROR_PASSWORD_RESTRICTION                                                syscall.Errno = 1325
	ERROR_LOGON_FAILURE                                                       syscall.Errno = 1326
	ERROR_ACCOUNT_RESTRICTION                                                 syscall.Errno = 1327
	ERROR_INVALID_LOGON_HOURS                                                 syscall.Errno = 1328
	ERROR_INVALID_WORKSTATION                                                 syscall.Errno = 1329
	ERROR_PASSWORD_EXPIRED                                                    syscall.Errno = 1330
	ERROR_ACCOUNT_DISABLED                                                    syscall.Errno = 1331
	ERROR_NONE_MAPPED                                                         syscall.Errno = 1332
	ERROR_TOO_MANY_LUIDS_REQUESTED                                            syscall.Errno = 1333
	ERROR_LUIDS_EXHAUSTED                                                     syscall.Errno = 1334
	ERROR_INVALID_SUB_AUTHORITY                                               syscall.Errno = 1335
	ERROR_INVALID_ACL                                                         syscall.Errno = 1336
	ERROR_INVALID_SID                                                         syscall.Errno = 1337
	ERROR_INVALID_SECURITY_DESCR                                              syscall.Errno = 1338
	ERROR_BAD_INHERITANCE_ACL                                                 syscall.Errno = 1340
	ERROR_SERVER_DISABLED                                                     syscall.Errno = 1341
	ERROR_SERVER_NOT_DISABLED                                                 syscall.Errno = 1342
	ERROR_INVALID_ID_AUTHORITY                                                syscall.Errno = 1343
	ERROR_ALLOTTED_SPACE_EXCEEDED                                             syscall.Errno = 1344
	ERROR_INVALID_GROUP_ATTRIBUTES                                            syscall.Errno = 1345
	ERROR_BAD_IMPERSONATION_LEVEL                                             syscall.Errno = 1346
	ERROR_CANT_OPEN_ANONYMOUS                                                 syscall.Errno = 1347
	ERROR_BAD_VALIDATION_CLASS                                                syscall.Errno = 1348
	ERROR_BAD_TOKEN_TYPE                                                      syscall.Errno = 1349
	ERROR_NO_SECURITY_ON_OBJECT                                               syscall.Errno = 1350
	ERROR_CANT_ACCESS_DOMAIN_INFO                                             syscall.Errno = 1351
	ERROR_INVALID_SERVER_STATE                                                syscall.Errno = 1352
	ERROR_INVALID_DOMAIN_STATE                                                syscall.Errno = 1353
	ERROR_INVALID_DOMAIN_ROLE                                                 syscall.Errno = 1354
	ERROR_NO_SUCH_DOMAIN                                                      syscall.Errno = 1355
	ERROR_DOMAIN_EXISTS                                                       syscall.Errno = 1356
	ERROR_DOMAIN_LIMIT_EXCEEDED                                               syscall.Errno = 1357
	ERROR_INTERNAL_DB_CORRUPTION                                              syscall.Errno = 1358
	ERROR_INTERNAL_ERROR                                                      syscall.Errno = 1359
	ERROR_GENERIC_NOT_MAPPED                                                  syscall.Errno = 1360
	ERROR_BAD_DESCRIPTOR_FORMAT                                               syscall.Errno = 1361
	ERROR_NOT_LOGON_PROCESS                                                   syscall.Errno = 1362
	ERROR_LOGON_SESSION_EXISTS                                                syscall.Errno = 1363
	ERROR_NO_SUCH_PACKAGE                                                     syscall.Errno = 1364
	ERROR_BAD_LOGON_SESSION_STATE                                             syscall.Errno = 1365
	ERROR_LOGON_SESSION_COLLISION                                             syscall.Errno = 1366
	ERROR_INVALID_LOGON_TYPE                                                  syscall.Errno = 1367
	ERROR_CANNOT_IMPERSONATE                                                  syscall.Errno = 1368
	ERROR_RXACT_INVALID_STATE                                                 syscall.Errno = 1369
	ERROR_RXACT_COMMIT_FAILURE                                                syscall.Errno = 1370
	ERROR_SPECIAL_ACCOUNT                                                     syscall.Errno = 1371
	ERROR_SPECIAL_GROUP                                                       syscall.Errno = 1372
	ERROR_SPECIAL_USER                                                        syscall.Errno = 1373
	ERROR_MEMBERS_PRIMARY_GROUP                                               syscall.Errno = 1374
	ERROR_TOKEN_ALREADY_IN_USE                                                syscall.Errno = 1375
	ERROR_NO_SUCH_ALIAS                                                       syscall.Errno = 1376
	ERROR_MEMBER_NOT_IN_ALIAS                                                 syscall.Errno = 1377
	ERROR_MEMBER_IN_ALIAS                                                     syscall.Errno = 1378
	ERROR_ALIAS_EXISTS                                                        syscall.Errno = 1379
	ERROR_LOGON_NOT_GRANTED                                                   syscall.Errno = 1380
	ERROR_TOO_MANY_SECRETS                                                    syscall.Errno = 1381
	ERROR_SECRET_TOO_LONG                                                     syscall.Errno = 1382
	ERROR_INTERNAL_DB_ERROR                                                   syscall.Errno = 1383
	ERROR_TOO_MANY_CONTEXT_IDS                                                syscall.Errno = 1384
	ERROR_LOGON_TYPE_NOT_GRANTED                                              syscall.Errno = 1385
	ERROR_NT_CROSS_ENCRYPTION_REQUIRED                                        syscall.Errno = 1386
	ERROR_NO_SUCH_MEMBER                                                      syscall.Errno = 1387
	ERROR_INVALID_MEMBER                                                      syscall.Errno = 1388
	ERROR_TOO_MANY_SIDS                                                       syscall.Errno = 1389
	ERROR_LM_CROSS_ENCRYPTION_REQUIRED                                        syscall.Errno = 1390
	ERROR_NO_INHERITANCE                                                      syscall.Errno = 1391
	ERROR_FILE_CORRUPT                                                        syscall.Errno = 1392
	ERROR_DISK_CORRUPT                                                        syscall.Errno = 1393
	ERROR_NO_USER_SESSION_KEY                                                 syscall.Errno = 1394
	ERROR_LICENSE_QUOTA_EXCEEDED                                              syscall.Errno = 1395
	ERROR_WRONG_TARGET_NAME                                                   syscall.Errno = 1396
	ERROR_MUTUAL_AUTH_FAILED                                                  syscall.Errno = 1397
	ERROR_TIME_SKEW                                                           syscall.Errno = 1398
	ERROR_CURRENT_DOMAIN_NOT_ALLOWED                                          syscall.Errno = 1399
	ERROR_INVALID_WINDOW_HANDLE                                               syscall.Errno = 1400
	ERROR_INVALID_MENU_HANDLE                                                 syscall.Errno = 1401
	ERROR_INVALID_CURSOR_HANDLE                                               syscall.Errno = 1402
	ERROR_INVALID_ACCEL_HANDLE                                                syscall.Errno = 1403
	ERROR_INVALID_HOOK_HANDLE                                                 syscall.Errno = 1404
	ERROR_INVALID_DWP_HANDLE                                                  syscall.Errno = 1405
	ERROR_TLW_WITH_WSCHILD                                                    syscall.Errno = 1406
	ERROR_CANNOT_FIND_WND_CLASS                                               syscall.Errno = 1407
	ERROR_WINDOW_OF_OTHER_THREAD                                              syscall.Errno = 1408
	ERROR_HOTKEY_ALREADY_REGISTERED                                           syscall.Errno = 1409
	ERROR_CLASS_ALREADY_EXISTS                                                syscall.Errno = 1410
	ERROR_CLASS_DOES_NOT_EXIST                                                syscall.Errno = 1411
	ERROR_CLASS_HAS_WINDOWS                                                   syscall.Errno = 1412
	ERROR_INVALID_INDEX                                                       syscall.Errno = 1413
	ERROR_INVALID_ICON_HANDLE                                                 syscall.Errno = 1414
	ERROR_PRIVATE_DIALOG_INDEX                                                syscall.Errno = 1415
	ERROR_LISTBOX_ID_NOT_FOUND                                                syscall.Errno = 1416
	ERROR_NO_WILDCARD_CHARACTERS                                              syscall.Errno = 1417
	ERROR_CLIPBOARD_NOT_OPEN                                                  syscall.Errno = 1418
	ERROR_HOTKEY_NOT_REGISTERED                                               syscall.Errno = 1419
	ERROR_WINDOW_NOT_DIALOG                                                   syscall.Errno = 1420
	ERROR_CONTROL_ID_NOT_FOUND                                                syscall.Errno = 1421
	ERROR_INVALID_COMBOBOX_MESSAGE                                            syscall.Errno = 1422
	ERROR_WINDOW_NOT_COMBOBOX                                                 syscall.Errno = 1423
	ERROR_INVALID_EDIT_HEIGHT                                                 syscall.Errno = 1424
	ERROR_DC_NOT_FOUND                                                        syscall.Errno = 1425
	ERROR_INVALID_HOOK_FILTER                                                 syscall.Errno = 1426
	ERROR_INVALID_FILTER_PROC                                                 syscall.Errno = 1427
	ERROR_HOOK_NEEDS_HMOD                                                     syscall.Errno = 1428
	ERROR_GLOBAL_ONLY_HOOK                                                    syscall.Errno = 1429
	ERROR_JOURNAL_HOOK_SET                                                    syscall.Errno = 1430
	ERROR_HOOK_NOT_INSTALLED                                                  syscall.Errno = 1431
	ERROR_INVALID_LB_MESSAGE                                                  syscall.Errno = 1432
	ERROR_SETCOUNT_ON_BAD_LB                                                  syscall.Errno = 1433
	ERROR_LB_WITHOUT_TABSTOPS                                                 syscall.Errno = 1434
	ERROR_DESTROY_OBJECT_OF_OTHER_THREAD                                      syscall.Errno = 1435
	ERROR_CHILD_WINDOW_MENU                                                   syscall.Errno = 1436
	ERROR_NO_SYSTEM_MENU                                                      syscall.Errno = 1437
	ERROR_INVALID_MSGBOX_STYLE                                                syscall.Errno = 1438
	ERROR_INVALID_SPI_VALUE                                                   syscall.Errno = 1439
	ERROR_SCREEN_ALREADY_LOCKED                                               syscall.Errno = 1440
	ERROR_HWNDS_HAVE_DIFF_PARENT                                              syscall.Errno = 1441
	ERROR_NOT_CHILD_WINDOW                                                    syscall.Errno = 1442
	ERROR_INVALID_GW_COMMAND                                                  syscall.Errno = 1443
	ERROR_INVALID_THREAD_ID                                                   syscall.Errno = 1444
	ERROR_NON_MDICHILD_WINDOW                                                 syscall.Errno = 1445
	ERROR_POPUP_ALREADY_ACTIVE                                                syscall.Errno = 1446
	ERROR_NO_SCROLLBARS                                                       syscall.Errno = 1447
	ERROR_INVALID_SCROLLBAR_RANGE                                             syscall.Errno = 1448
	ERROR_INVALID_SHOWWIN_COMMAND                                             syscall.Errno = 1449
	ERROR_NO_SYSTEM_RESOURCES                                                 syscall.Errno = 1450
	ERROR_NONPAGED_SYSTEM_RESOURCES                                           syscall.Errno = 1451
	ERROR_PAGED_SYSTEM_RESOURCES                                              syscall.Errno = 1452
	ERROR_WORKING_SET_QUOTA                                                   syscall.Errno = 1453
	ERROR_PAGEFILE_QUOTA                                                      syscall.Errno = 1454
	ERROR_COMMITMENT_LIMIT                                                    syscall.Errno = 1455
	ERROR_MENU_ITEM_NOT_FOUND                                                 syscall.Errno = 1456
	ERROR_INVALID_KEYBOARD_HANDLE                                             syscall.Errno = 1457
	ERROR_HOOK_TYPE_NOT_ALLOWED                                               syscall.Errno = 1458
	ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION                                  syscall.Errno = 1459
	ERROR_TIMEOUT                                                             syscall.Errno = 1460
	ERROR_INVALID_MONITOR_HANDLE                                              syscall.Errno = 1461
	ERROR_INCORRECT_SIZE                                                      syscall.Errno = 1462
	ERROR_SYMLINK_CLASS_DISABLED                                              syscall.Errno = 1463
	ERROR_SYMLINK_NOT_SUPPORTED                                               syscall.Errno = 1464
	ERROR_XML_PARSE_ERROR                                                     syscall.Errno = 1465
	ERROR_XMLDSIG_ERROR                                                       syscall.Errno = 1466
	ERROR_RESTART_APPLICATION                                                 syscall.Errno = 1467
	ERROR_WRONG_COMPARTMENT                                                   syscall.Errno = 1468
	ERROR_AUTHIP_FAILURE                                                      syscall.Errno = 1469
	ERROR_NO_NVRAM_RESOURCES                                                  syscall.Errno = 1470
	ERROR_NOT_GUI_PROCESS                                                     syscall.Errno = 1471
	ERROR_EVENTLOG_FILE_CORRUPT                                               syscall.Errno = 1500
	ERROR_EVENTLOG_CANT_START                                                 syscall.Errno = 1501
	ERROR_LOG_FILE_FULL                                                       syscall.Errno = 1502
	ERROR_EVENTLOG_FILE_CHANGED                                               syscall.Errno = 1503
	ERROR_CONTAINER_ASSIGNED                                                  syscall.Errno = 1504
	ERROR_JOB_NO_CONTAINER                                                    syscall.Errno = 1505
	ERROR_INVALID_TASK_NAME                                                   syscall.Errno = 1550
	ERROR_INVALID_TASK_INDEX                                                  syscall.Errno = 1551
	ERROR_THREAD_ALREADY_IN_TASK                                              syscall.Errno = 1552
	ERROR_INSTALL_SERVICE_FAILURE                                             syscall.Errno = 1601
	ERROR_INSTALL_USEREXIT                                                    syscall.Errno = 1602
	ERROR_INSTALL_FAILURE                                                     syscall.Errno = 1603
	ERROR_INSTALL_SUSPEND                                                     syscall.Errno = 1604
	ERROR_UNKNOWN_PRODUCT                                                     syscall.Errno = 1605
	ERROR_UNKNOWN_FEATURE                                                     syscall.Errno = 1606
	ERROR_UNKNOWN_COMPONENT                                                   syscall.Errno = 1607
	ERROR_UNKNOWN_PROPERTY                                                    syscall.Errno = 1608
	ERROR_INVALID_HANDLE_STATE                                                syscall.Errno = 1609
	ERROR_BAD_CONFIGURATION                                                   syscall.Errno = 1610
	ERROR_INDEX_ABSENT                                                        syscall.Errno = 1611
	ERROR_INSTALL_SOURCE_ABSENT                                               syscall.Errno = 1612
	ERROR_INSTALL_PACKAGE_VERSION                                             syscall.Errno = 1613
	ERROR_PRODUCT_UNINSTALLED                                                 syscall.Errno = 1614
	ERROR_BAD_QUERY_SYNTAX                                                    syscall.Errno = 1615
	ERROR_INVALID_FIELD                                                       syscall.Errno = 1616
	ERROR_DEVICE_REMOVED                                                      syscall.Errno = 1617
	ERROR_INSTALL_ALREADY_RUNNING                                             syscall.Errno = 1618
	ERROR_INSTALL_PACKAGE_OPEN_FAILED                                         syscall.Errno = 1619
	ERROR_INSTALL_PACKAGE_INVALID                                             syscall.Errno = 1620
	ERROR_INSTALL_UI_FAILURE                                                  syscall.Errno = 1621
	ERROR_INSTALL_LOG_FAILURE                                                 syscall.Errno = 1622
	ERROR_INSTALL_LANGUAGE_UNSUPPORTED                                        syscall.Errno = 1623
	ERROR_INSTALL_TRANSFORM_FAILURE                                           syscall.Errno = 1624
	ERROR_INSTALL_PACKAGE_REJECTED                                            syscall.Errno = 1625
	ERROR_FUNCTION_NOT_CALLED                                                 syscall.Errno = 1626
	ERROR_FUNCTION_FAILED                                                     syscall.Errno = 1627
	ERROR_INVALID_TABLE                                                       syscall.Errno = 1628
	ERROR_DATATYPE_MISMATCH                                                   syscall.Errno = 1629
	ERROR_UNSUPPORTED_TYPE                                                    syscall.Errno = 1630
	ERROR_CREATE_FAILED                                                       syscall.Errno = 1631
	ERROR_INSTALL_TEMP_UNWRITABLE                                             syscall.Errno = 1632
	ERROR_INSTALL_PLATFORM_UNSUPPORTED                                        syscall.Errno = 1633
	ERROR_INSTALL_NOTUSED                                                     syscall.Errno = 1634
	ERROR_PATCH_PACKAGE_OPEN_FAILED                                           syscall.Errno = 1635
	ERROR_PATCH_PACKAGE_INVALID                                               syscall.Errno = 1636
	ERROR_PATCH_PACKAGE_UNSUPPORTED                                           syscall.Errno = 1637
	ERROR_PRODUCT_VERSION                                                     syscall.Errno = 1638
	ERROR_INVALID_COMMAND_LINE                                                syscall.Errno = 1639
	ERROR_INSTALL_REMOTE_DISALLOWED                                           syscall.Errno = 1640
	ERROR_SUCCESS_REBOOT_INITIATED                                            syscall.Errno = 1641
	ERROR_PATCH_TARGET_NOT_FOUND                                              syscall.Errno = 1642
	ERROR_PATCH_PACKAGE_REJECTED                                              syscall.Errno = 1643
	ERROR_INSTALL_TRANSFORM_REJECTED                                          syscall.Errno = 1644
	ERROR_INSTALL_REMOTE_PROHIBITED                                           syscall.Errno = 1645
	ERROR_PATCH_REMOVAL_UNSUPPORTED                                           syscall.Errno = 1646
	ERROR_UNKNOWN_PATCH                                                       syscall.Errno = 1647
	ERROR_PATCH_NO_SEQUENCE                                                   syscall.Errno = 1648
	ERROR_PATCH_REMOVAL_DISALLOWED                                            syscall.Errno = 1649
	ERROR_INVALID_PATCH_XML                                                   syscall.Errno = 1650
	ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT                                    syscall.Errno = 1651
	ERROR_INSTALL_SERVICE_SAFEBOOT                                            syscall.Errno = 1652
	ERROR_FAIL_FAST_EXCEPTION                                                 syscall.Errno = 1653
	ERROR_INSTALL_REJECTED                                                    syscall.Errno = 1654
	ERROR_DYNAMIC_CODE_BLOCKED                                                syscall.Errno = 1655
	ERROR_NOT_SAME_OBJECT                                                     syscall.Errno = 1656
	ERROR_STRICT_CFG_VIOLATION                                                syscall.Errno = 1657
	ERROR_SET_CONTEXT_DENIED                                                  syscall.Errno = 1660
	ERROR_CROSS_PARTITION_VIOLATION                                           syscall.Errno = 1661
	RPC_S_INVALID_STRING_BINDING                                              syscall.Errno = 1700
	RPC_S_WRONG_KIND_OF_BINDING                                               syscall.Errno = 1701
	RPC_S_INVALID_BINDING                                                     syscall.Errno = 1702
	RPC_S_PROTSEQ_NOT_SUPPORTED                                               syscall.Errno = 1703
	RPC_S_INVALID_RPC_PROTSEQ                                                 syscall.Errno = 1704
	RPC_S_INVALID_STRING_UUID                                                 syscall.Errno = 1705
	RPC_S_INVALID_ENDPOINT_FORMAT                                             syscall.Errno = 1706
	RPC_S_INVALID_NET_ADDR                                                    syscall.Errno = 1707
	RPC_S_NO_ENDPOINT_FOUND                                                   syscall.Errno = 1708
	RPC_S_INVALID_TIMEOUT                                                     syscall.Errno = 1709
	RPC_S_OBJECT_NOT_FOUND                                                    syscall.Errno = 1710
	RPC_S_ALREADY_REGISTERED                                                  syscall.Errno = 1711
	RPC_S_TYPE_ALREADY_REGISTERED                                             syscall.Errno = 1712
	RPC_S_ALREADY_LISTENING                                                   syscall.Errno = 1713
	RPC_S_NO_PROTSEQS_REGISTERED                                              syscall.Errno = 1714
	RPC_S_NOT_LISTENING                                                       syscall.Errno = 1715
	RPC_S_UNKNOWN_MGR_TYPE                                                    syscall.Errno = 1716
	RPC_S_UNKNOWN_IF                                                          syscall.Errno = 1717
	RPC_S_NO_BINDINGS                                                         syscall.Errno = 1718
	RPC_S_NO_PROTSEQS                                                         syscall.Errno = 1719
	RPC_S_CANT_CREATE_ENDPOINT                                                syscall.Errno = 1720
	RPC_S_OUT_OF_RESOURCES                                                    syscall.Errno = 1721
	RPC_S_SERVER_UNAVAILABLE                                                  syscall.Errno = 1722
	RPC_S_SERVER_TOO_BUSY                                                     syscall.Errno = 1723
	RPC_S_INVALID_NETWORK_OPTIONS                                             syscall.Errno = 1724
	RPC_S_NO_CALL_ACTIVE                                                      syscall.Errno = 1725
	RPC_S_CALL_FAILED                                                         syscall.Errno = 1726
	RPC_S_CALL_FAILED_DNE                                                     syscall.Errno = 1727
	RPC_S_PROTOCOL_ERROR                                                      syscall.Errno = 1728
	RPC_S_PROXY_ACCESS_DENIED                                                 syscall.Errno = 1729
	RPC_S_UNSUPPORTED_TRANS_SYN                                               syscall.Errno = 1730
	RPC_S_UNSUPPORTED_TYPE                                                    syscall.Errno = 1732
	RPC_S_INVALID_TAG                                                         syscall.Errno = 1733
	RPC_S_INVALID_BOUND                                                       syscall.Errno = 1734
	RPC_S_NO_ENTRY_NAME                                                       syscall.Errno = 1735
	RPC_S_INVALID_NAME_SYNTAX                                                 syscall.Errno = 1736
	RPC_S_UNSUPPORTED_NAME_SYNTAX                                             syscall.Errno = 1737
	RPC_S_UUID_NO_ADDRESS                                                     syscall.Errno = 1739
	RPC_S_DUPLICATE_ENDPOINT                                                  syscall.Errno = 1740
	RPC_S_UNKNOWN_AUTHN_TYPE                                                  syscall.Errno = 1741
	RPC_S_MAX_CALLS_TOO_SMALL                                                 syscall.Errno = 1742
	RPC_S_STRING_TOO_LONG                                                     syscall.Errno = 1743
	RPC_S_PROTSEQ_NOT_FOUND                                                   syscall.Errno = 1744
	RPC_S_PROCNUM_OUT_OF_RANGE                                                syscall.Errno = 1745
	RPC_S_BINDING_HAS_NO_AUTH                                                 syscall.Errno = 1746
	RPC_S_UNKNOWN_AUTHN_SERVICE                                               syscall.Errno = 1747
	RPC_S_UNKNOWN_AUTHN_LEVEL                                                 syscall.Errno = 1748
	RPC_S_INVALID_AUTH_IDENTITY                                               syscall.Errno = 1749
	RPC_S_UNKNOWN_AUTHZ_SERVICE                                               syscall.Errno = 1750
	EPT_S_INVALID_ENTRY                                                       syscall.Errno = 1751
	EPT_S_CANT_PERFORM_OP                                                     syscall.Errno = 1752
	EPT_S_NOT_REGISTERED                                                      syscall.Errno = 1753
	RPC_S_NOTHING_TO_EXPORT                                                   syscall.Errno = 1754
	RPC_S_INCOMPLETE_NAME                                                     syscall.Errno = 1755
	RPC_S_INVALID_VERS_OPTION                                                 syscall.Errno = 1756
	RPC_S_NO_MORE_MEMBERS                                                     syscall.Errno = 1757
	RPC_S_NOT_ALL_OBJS_UNEXPORTED                                             syscall.Errno = 1758
	RPC_S_INTERFACE_NOT_FOUND                                                 syscall.Errno = 1759
	RPC_S_ENTRY_ALREADY_EXISTS                                                syscall.Errno = 1760
	RPC_S_ENTRY_NOT_FOUND                                                     syscall.Errno = 1761
	RPC_S_NAME_SERVICE_UNAVAILABLE                                            syscall.Errno = 1762
	RPC_S_INVALID_NAF_ID                                                      syscall.Errno = 1763
	RPC_S_CANNOT_SUPPORT                                                      syscall.Errno = 1764
	RPC_S_NO_CONTEXT_AVAILABLE                                                syscall.Errno = 1765
	RPC_S_INTERNAL_ERROR                                                      syscall.Errno = 1766
	RPC_S_ZERO_DIVIDE                                                         syscall.Errno = 1767
	RPC_S_ADDRESS_ERROR                                                       syscall.Errno = 1768
	RPC_S_FP_DIV_ZERO                                                         syscall.Errno = 1769
	RPC_S_FP_UNDERFLOW                                                        syscall.Errno = 1770
	RPC_S_FP_OVERFLOW                                                         syscall.Errno = 1771
	RPC_X_NO_MORE_ENTRIES                                                     syscall.Errno = 1772
	RPC_X_SS_CHAR_TRANS_OPEN_FAIL                                             syscall.Errno = 1773
	RPC_X_SS_CHAR_TRANS_SHORT_FILE                                            syscall.Errno = 1774
	RPC_X_SS_IN_NULL_CONTEXT                                                  syscall.Errno = 1775
	RPC_X_SS_CONTEXT_DAMAGED                                                  syscall.Errno = 1777
	RPC_X_SS_HANDLES_MISMATCH                                                 syscall.Errno = 1778
	RPC_X_SS_CANNOT_GET_CALL_HANDLE                                           syscall.Errno = 1779
	RPC_X_NULL_REF_POINTER                                                    syscall.Errno = 1780
	RPC_X_ENUM_VALUE_OUT_OF_RANGE                                             syscall.Errno = 1781
	RPC_X_BYTE_COUNT_TOO_SMALL                                                syscall.Errno = 1782
	RPC_X_BAD_STUB_DATA                                                       syscall.Errno = 1783
	ERROR_INVALID_USER_BUFFER                                                 syscall.Errno = 1784
	ERROR_UNRECOGNIZED_MEDIA                                                  syscall.Errno = 1785
	ERROR_NO_TRUST_LSA_SECRET                                                 syscall.Errno = 1786
	ERROR_NO_TRUST_SAM_ACCOUNT                                                syscall.Errno = 1787
	ERROR_TRUSTED_DOMAIN_FAILURE                                              syscall.Errno = 1788
	ERROR_TRUSTED_RELATIONSHIP_FAILURE                                        syscall.Errno = 1789
	ERROR_TRUST_FAILURE                                                       syscall.Errno = 1790
	RPC_S_CALL_IN_PROGRESS                                                    syscall.Errno = 1791
	ERROR_NETLOGON_NOT_STARTED                                                syscall.Errno = 1792
	ERROR_ACCOUNT_EXPIRED                                                     syscall.Errno = 1793
	ERROR_REDIRECTOR_HAS_OPEN_HANDLES                                         syscall.Errno = 1794
	ERROR_PRINTER_DRIVER_ALREADY_INSTALLED                                    syscall.Errno = 1795
	ERROR_UNKNOWN_PORT                                                        syscall.Errno = 1796
	ERROR_UNKNOWN_PRINTER_DRIVER                                              syscall.Errno = 1797
	ERROR_UNKNOWN_PRINTPROCESSOR                                              syscall.Errno = 1798
	ERROR_INVALID_SEPARATOR_FILE                                              syscall.Errno = 1799
	ERROR_INVALID_PRIORITY                                                    syscall.Errno = 1800
	ERROR_INVALID_PRINTER_NAME                                                syscall.Errno = 1801
	ERROR_PRINTER_ALREADY_EXISTS                                              syscall.Errno = 1802
	ERROR_INVALID_PRINTER_COMMAND                                             syscall.Errno = 1803
	ERROR_INVALID_DATATYPE                                                    syscall.Errno = 1804
	ERROR_INVALID_ENVIRONMENT                                                 syscall.Errno = 1805
	RPC_S_NO_MORE_BINDINGS                                                    syscall.Errno = 1806
	ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT                                   syscall.Errno = 1807
	ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT                                   syscall.Errno = 1808
	ERROR_NOLOGON_SERVER_TRUST_ACCOUNT                                        syscall.Errno = 1809
	ERROR_DOMAIN_TRUST_INCONSISTENT                                           syscall.Errno = 1810
	ERROR_SERVER_HAS_OPEN_HANDLES                                             syscall.Errno = 1811
	ERROR_RESOURCE_DATA_NOT_FOUND                                             syscall.Errno = 1812
	ERROR_RESOURCE_TYPE_NOT_FOUND                                             syscall.Errno = 1813
	ERROR_RESOURCE_NAME_NOT_FOUND                                             syscall.Errno = 1814
	ERROR_RESOURCE_LANG_NOT_FOUND                                             syscall.Errno = 1815
	ERROR_NOT_ENOUGH_QUOTA                                                    syscall.Errno = 1816
	RPC_S_NO_INTERFACES                                                       syscall.Errno = 1817
	RPC_S_CALL_CANCELLED                                                      syscall.Errno = 1818
	RPC_S_BINDING_INCOMPLETE                                                  syscall.Errno = 1819
	RPC_S_COMM_FAILURE                                                        syscall.Errno = 1820
	RPC_S_UNSUPPORTED_AUTHN_LEVEL                                             syscall.Errno = 1821
	RPC_S_NO_PRINC_NAME                                                       syscall.Errno = 1822
	RPC_S_NOT_RPC_ERROR                                                       syscall.Errno = 1823
	RPC_S_UUID_LOCAL_ONLY                                                     syscall.Errno = 1824
	RPC_S_SEC_PKG_ERROR                                                       syscall.Errno = 1825
	RPC_S_NOT_CANCELLED                                                       syscall.Errno = 1826
	RPC_X_INVALID_ES_ACTION                                                   syscall.Errno = 1827
	RPC_X_WRONG_ES_VERSION                                                    syscall.Errno = 1828
	RPC_X_WRONG_STUB_VERSION                                                  syscall.Errno = 1829
	RPC_X_INVALID_PIPE_OBJECT                                                 syscall.Errno = 1830
	RPC_X_WRONG_PIPE_ORDER                                                    syscall.Errno = 1831
	RPC_X_WRONG_PIPE_VERSION                                                  syscall.Errno = 1832
	RPC_S_COOKIE_AUTH_FAILED                                                  syscall.Errno = 1833
	RPC_S_DO_NOT_DISTURB                                                      syscall.Errno = 1834
	RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED                                        syscall.Errno = 1835
	RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH                                         syscall.Errno = 1836
	RPC_S_GROUP_MEMBER_NOT_FOUND                                              syscall.Errno = 1898
	EPT_S_CANT_CREATE                                                         syscall.Errno = 1899
	RPC_S_INVALID_OBJECT                                                      syscall.Errno = 1900
	ERROR_INVALID_TIME                                                        syscall.Errno = 1901
	ERROR_INVALID_FORM_NAME                                                   syscall.Errno = 1902
	ERROR_INVALID_FORM_SIZE                                                   syscall.Errno = 1903
	ERROR_ALREADY_WAITING                                                     syscall.Errno = 1904
	ERROR_PRINTER_DELETED                                                     syscall.Errno = 1905
	ERROR_INVALID_PRINTER_STATE                                               syscall.Errno = 1906
	ERROR_PASSWORD_MUST_CHANGE                                                syscall.Errno = 1907
	ERROR_DOMAIN_CONTROLLER_NOT_FOUND                                         syscall.Errno = 1908
	ERROR_ACCOUNT_LOCKED_OUT                                                  syscall.Errno = 1909
	OR_INVALID_OXID                                                           syscall.Errno = 1910
	OR_INVALID_OID                                                            syscall.Errno = 1911
	OR_INVALID_SET                                                            syscall.Errno = 1912
	RPC_S_SEND_INCOMPLETE                                                     syscall.Errno = 1913
	RPC_S_INVALID_ASYNC_HANDLE                                                syscall.Errno = 1914
	RPC_S_INVALID_ASYNC_CALL                                                  syscall.Errno = 1915
	RPC_X_PIPE_CLOSED                                                         syscall.Errno = 1916
	RPC_X_PIPE_DISCIPLINE_ERROR                                               syscall.Errno = 1917
	RPC_X_PIPE_EMPTY                                                          syscall.Errno = 1918
	ERROR_NO_SITENAME                                                         syscall.Errno = 1919
	ERROR_CANT_ACCESS_FILE                                                    syscall.Errno = 1920
	ERROR_CANT_RESOLVE_FILENAME                                               syscall.Errno = 1921
	RPC_S_ENTRY_TYPE_MISMATCH                                                 syscall.Errno = 1922
	RPC_S_NOT_ALL_OBJS_EXPORTED                                               syscall.Errno = 1923
	RPC_S_INTERFACE_NOT_EXPORTED                                              syscall.Errno = 1924
	RPC_S_PROFILE_NOT_ADDED                                                   syscall.Errno = 1925
	RPC_S_PRF_ELT_NOT_ADDED                                                   syscall.Errno = 1926
	RPC_S_PRF_ELT_NOT_REMOVED                                                 syscall.Errno = 1927
	RPC_S_GRP_ELT_NOT_ADDED                                                   syscall.Errno = 1928
	RPC_S_GRP_ELT_NOT_REMOVED                                                 syscall.Errno = 1929
	ERROR_KM_DRIVER_BLOCKED                                                   syscall.Errno = 1930
	ERROR_CONTEXT_EXPIRED                                                     syscall.Errno = 1931
	ERROR_PER_USER_TRUST_QUOTA_EXCEEDED                                       syscall.Errno = 1932
	ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED                                       syscall.Errno = 1933
	ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED                                    syscall.Errno = 1934
	ERROR_AUTHENTICATION_FIREWALL_FAILED                                      syscall.Errno = 1935
	ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED                                    syscall.Errno = 1936
	ERROR_NTLM_BLOCKED                                                        syscall.Errno = 1937
	ERROR_PASSWORD_CHANGE_REQUIRED                                            syscall.Errno = 1938
	ERROR_LOST_MODE_LOGON_RESTRICTION                                         syscall.Errno = 1939
	ERROR_INVALID_PIXEL_FORMAT                                                syscall.Errno = 2000
	ERROR_BAD_DRIVER                                                          syscall.Errno = 2001
	ERROR_INVALID_WINDOW_STYLE                                                syscall.Errno = 2002
	ERROR_METAFILE_NOT_SUPPORTED                                              syscall.Errno = 2003
	ERROR_TRANSFORM_NOT_SUPPORTED                                             syscall.Errno = 2004
	ERROR_CLIPPING_NOT_SUPPORTED                                              syscall.Errno = 2005
	ERROR_INVALID_CMM                                                         syscall.Errno = 2010
	ERROR_INVALID_PROFILE                                                     syscall.Errno = 2011
	ERROR_TAG_NOT_FOUND                                                       syscall.Errno = 2012
	ERROR_TAG_NOT_PRESENT                                                     syscall.Errno = 2013
	ERROR_DUPLICATE_TAG                                                       syscall.Errno = 2014
	ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE                                  syscall.Errno = 2015
	ERROR_PROFILE_NOT_FOUND                                                   syscall.Errno = 2016
	ERROR_INVALID_COLORSPACE                                                  syscall.Errno = 2017
	ERROR_ICM_NOT_ENABLED                                                     syscall.Errno = 2018
	ERROR_DELETING_ICM_XFORM                                                  syscall.Errno = 2019
	ERROR_INVALID_TRANSFORM                                                   syscall.Errno = 2020
	ERROR_COLORSPACE_MISMATCH                                                 syscall.Errno = 2021
	ERROR_INVALID_COLORINDEX                                                  syscall.Errno = 2022
	ERROR_PROFILE_DOES_NOT_MATCH_DEVICE                                       syscall.Errno = 2023
	ERROR_CONNECTED_OTHER_PASSWORD                                            syscall.Errno = 2108
	ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT                                    syscall.Errno = 2109
	ERROR_BAD_USERNAME                                                        syscall.Errno = 2202
	ERROR_NOT_CONNECTED                                                       syscall.Errno = 2250
	ERROR_OPEN_FILES                                                          syscall.Errno = 2401
	ERROR_ACTIVE_CONNECTIONS                                                  syscall.Errno = 2402
	ERROR_DEVICE_IN_USE                                                       syscall.Errno = 2404
	ERROR_UNKNOWN_PRINT_MONITOR                                               syscall.Errno = 3000
	ERROR_PRINTER_DRIVER_IN_USE                                               syscall.Errno = 3001
	ERROR_SPOOL_FILE_NOT_FOUND                                                syscall.Errno = 3002
	ERROR_SPL_NO_STARTDOC                                                     syscall.Errno = 3003
	ERROR_SPL_NO_ADDJOB                                                       syscall.Errno = 3004
	ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED                                   syscall.Errno = 3005
	ERROR_PRINT_MONITOR_ALREADY_INSTALLED                                     syscall.Errno = 3006
	ERROR_INVALID_PRINT_MONITOR                                               syscall.Errno = 3007
	ERROR_PRINT_MONITOR_IN_USE                                                syscall.Errno = 3008
	ERROR_PRINTER_HAS_JOBS_QUEUED                                             syscall.Errno = 3009
	ERROR_SUCCESS_REBOOT_REQUIRED                                             syscall.Errno = 3010
	ERROR_SUCCESS_RESTART_REQUIRED                                            syscall.Errno = 3011
	ERROR_PRINTER_NOT_FOUND                                                   syscall.Errno = 3012
	ERROR_PRINTER_DRIVER_WARNED                                               syscall.Errno = 3013
	ERROR_PRINTER_DRIVER_BLOCKED                                              syscall.Errno = 3014
	ERROR_PRINTER_DRIVER_PACKAGE_IN_USE                                       syscall.Errno = 3015
	ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND                                       syscall.Errno = 3016
	ERROR_FAIL_REBOOT_REQUIRED                                                syscall.Errno = 3017
	ERROR_FAIL_REBOOT_INITIATED                                               syscall.Errno = 3018
	ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED                                      syscall.Errno = 3019
	ERROR_PRINT_JOB_RESTART_REQUIRED                                          syscall.Errno = 3020
	ERROR_INVALID_PRINTER_DRIVER_MANIFEST                                     syscall.Errno = 3021
	ERROR_PRINTER_NOT_SHAREABLE                                               syscall.Errno = 3022
	ERROR_REQUEST_PAUSED                                                      syscall.Errno = 3050
	ERROR_APPEXEC_CONDITION_NOT_SATISFIED                                     syscall.Errno = 3060
	ERROR_APPEXEC_HANDLE_INVALIDATED                                          syscall.Errno = 3061
	ERROR_APPEXEC_INVALID_HOST_GENERATION                                     syscall.Errno = 3062
	ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION                             syscall.Errno = 3063
	ERROR_APPEXEC_INVALID_HOST_STATE                                          syscall.Errno = 3064
	ERROR_APPEXEC_NO_DONOR                                                    syscall.Errno = 3065
	ERROR_APPEXEC_HOST_ID_MISMATCH                                            syscall.Errno = 3066
	ERROR_APPEXEC_UNKNOWN_USER                                                syscall.Errno = 3067
	ERROR_IO_REISSUE_AS_CACHED                                                syscall.Errno = 3950
	ERROR_WINS_INTERNAL                                                       syscall.Errno = 4000
	ERROR_CAN_NOT_DEL_LOCAL_WINS                                              syscall.Errno = 4001
	ERROR_STATIC_INIT                                                         syscall.Errno = 4002
	ERROR_INC_BACKUP                                                          syscall.Errno = 4003
	ERROR_FULL_BACKUP                                                         syscall.Errno = 4004
	ERROR_REC_NON_EXISTENT                                                    syscall.Errno = 4005
	ERROR_RPL_NOT_ALLOWED                                                     syscall.Errno = 4006
	PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED                            syscall.Errno = 4050
	PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO                                   syscall.Errno = 4051
	PEERDIST_ERROR_MISSING_DATA                                               syscall.Errno = 4052
	PEERDIST_ERROR_NO_MORE                                                    syscall.Errno = 4053
	PEERDIST_ERROR_NOT_INITIALIZED                                            syscall.Errno = 4054
	PEERDIST_ERROR_ALREADY_INITIALIZED                                        syscall.Errno = 4055
	PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS                                       syscall.Errno = 4056
	PEERDIST_ERROR_INVALIDATED                                                syscall.Errno = 4057
	PEERDIST_ERROR_ALREADY_EXISTS                                             syscall.Errno = 4058
	PEERDIST_ERROR_OPERATION_NOTFOUND                                         syscall.Errno = 4059
	PEERDIST_ERROR_ALREADY_COMPLETED                                          syscall.Errno = 4060
	PEERDIST_ERROR_OUT_OF_BOUNDS                                              syscall.Errno = 4061
	PEERDIST_ERROR_VERSION_UNSUPPORTED                                        syscall.Errno = 4062
	PEERDIST_ERROR_INVALID_CONFIGURATION                                      syscall.Errno = 4063
	PEERDIST_ERROR_NOT_LICENSED                                               syscall.Errno = 4064
	PEERDIST_ERROR_SERVICE_UNAVAILABLE                                        syscall.Errno = 4065
	PEERDIST_ERROR_TRUST_FAILURE                                              syscall.Errno = 4066
	ERROR_DHCP_ADDRESS_CONFLICT                                               syscall.Errno = 4100
	ERROR_WMI_GUID_NOT_FOUND                                                  syscall.Errno = 4200
	ERROR_WMI_INSTANCE_NOT_FOUND                                              syscall.Errno = 4201
	ERROR_WMI_ITEMID_NOT_FOUND                                                syscall.Errno = 4202
	ERROR_WMI_TRY_AGAIN                                                       syscall.Errno = 4203
	ERROR_WMI_DP_NOT_FOUND                                                    syscall.Errno = 4204
	ERROR_WMI_UNRESOLVED_INSTANCE_REF                                         syscall.Errno = 4205
	ERROR_WMI_ALREADY_ENABLED                                                 syscall.Errno = 4206
	ERROR_WMI_GUID_DISCONNECTED                                               syscall.Errno = 4207
	ERROR_WMI_SERVER_UNAVAILABLE                                              syscall.Errno = 4208
	ERROR_WMI_DP_FAILED                                                       syscall.Errno = 4209
	ERROR_WMI_INVALID_MOF                                                     syscall.Errno = 4210
	ERROR_WMI_INVALID_REGINFO                                                 syscall.Errno = 4211
	ERROR_WMI_ALREADY_DISABLED                                                syscall.Errno = 4212
	ERROR_WMI_READ_ONLY                                                       syscall.Errno = 4213
	ERROR_WMI_SET_FAILURE                                                     syscall.Errno = 4214
	ERROR_NOT_APPCONTAINER                                                    syscall.Errno = 4250
	ERROR_APPCONTAINER_REQUIRED                                               syscall.Errno = 4251
	ERROR_NOT_SUPPORTED_IN_APPCONTAINER                                       syscall.Errno = 4252
	ERROR_INVALID_PACKAGE_SID_LENGTH                                          syscall.Errno = 4253
	ERROR_INVALID_MEDIA                                                       syscall.Errno = 4300
	ERROR_INVALID_LIBRARY                                                     syscall.Errno = 4301
	ERROR_INVALID_MEDIA_POOL                                                  syscall.Errno = 4302
	ERROR_DRIVE_MEDIA_MISMATCH                                                syscall.Errno = 4303
	ERROR_MEDIA_OFFLINE                                                       syscall.Errno = 4304
	ERROR_LIBRARY_OFFLINE                                                     syscall.Errno = 4305
	ERROR_EMPTY                                                               syscall.Errno = 4306
	ERROR_NOT_EMPTY                                                           syscall.Errno = 4307
	ERROR_MEDIA_UNAVAILABLE                                                   syscall.Errno = 4308
	ERROR_RESOURCE_DISABLED                                                   syscall.Errno = 4309
	ERROR_INVALID_CLEANER                                                     syscall.Errno = 4310
	ERROR_UNABLE_TO_CLEAN                                                     syscall.Errno = 4311
	ERROR_OBJECT_NOT_FOUND                                                    syscall.Errno = 4312
	ERROR_DATABASE_FAILURE                                                    syscall.Errno = 4313
	ERROR_DATABASE_FULL                                                       syscall.Errno = 4314
	ERROR_MEDIA_INCOMPATIBLE                                                  syscall.Errno = 4315
	ERROR_RESOURCE_NOT_PRESENT                                                syscall.Errno = 4316
	ERROR_INVALID_OPERATION                                                   syscall.Errno = 4317
	ERROR_MEDIA_NOT_AVAILABLE                                                 syscall.Errno = 4318
	ERROR_DEVICE_NOT_AVAILABLE                                                syscall.Errno = 4319
	ERROR_REQUEST_REFUSED                                                     syscall.Errno = 4320
	ERROR_INVALID_DRIVE_OBJECT                                                syscall.Errno = 4321
	ERROR_LIBRARY_FULL                                                        syscall.Errno = 4322
	ERROR_MEDIUM_NOT_ACCESSIBLE                                               syscall.Errno = 4323
	ERROR_UNABLE_TO_LOAD_MEDIUM                                               syscall.Errno = 4324
	ERROR_UNABLE_TO_INVENTORY_DRIVE                                           syscall.Errno = 4325
	ERROR_UNABLE_TO_INVENTORY_SLOT                                            syscall.Errno = 4326
	ERROR_UNABLE_TO_INVENTORY_TRANSPORT                                       syscall.Errno = 4327
	ERROR_TRANSPORT_FULL                                                      syscall.Errno = 4328
	ERROR_CONTROLLING_IEPORT                                                  syscall.Errno = 4329
	ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA                                       syscall.Errno = 4330
	ERROR_CLEANER_SLOT_SET                                                    syscall.Errno = 4331
	ERROR_CLEANER_SLOT_NOT_SET                                                syscall.Errno = 4332
	ERROR_CLEANER_CARTRIDGE_SPENT                                             syscall.Errno = 4333
	ERROR_UNEXPECTED_OMID                                                     syscall.Errno = 4334
	ERROR_CANT_DELETE_LAST_ITEM                                               syscall.Errno = 4335
	ERROR_MESSAGE_EXCEEDS_MAX_SIZE                                            syscall.Errno = 4336
	ERROR_VOLUME_CONTAINS_SYS_FILES                                           syscall.Errno = 4337
	ERROR_INDIGENOUS_TYPE                                                     syscall.Errno = 4338
	ERROR_NO_SUPPORTING_DRIVES                                                syscall.Errno = 4339
	ERROR_CLEANER_CARTRIDGE_INSTALLED                                         syscall.Errno = 4340
	ERROR_IEPORT_FULL                                                         syscall.Errno = 4341
	ERROR_FILE_OFFLINE                                                        syscall.Errno = 4350
	ERROR_REMOTE_STORAGE_NOT_ACTIVE                                           syscall.Errno = 4351
	ERROR_REMOTE_STORAGE_MEDIA_ERROR                                          syscall.Errno = 4352
	ERROR_NOT_A_REPARSE_POINT                                                 syscall.Errno = 4390
	ERROR_REPARSE_ATTRIBUTE_CONFLICT                                          syscall.Errno = 4391
	ERROR_INVALID_REPARSE_DATA                                                syscall.Errno = 4392
	ERROR_REPARSE_TAG_INVALID                                                 syscall.Errno = 4393
	ERROR_REPARSE_TAG_MISMATCH                                                syscall.Errno = 4394
	ERROR_REPARSE_POINT_ENCOUNTERED                                           syscall.Errno = 4395
	ERROR_APP_DATA_NOT_FOUND                                                  syscall.Errno = 4400
	ERROR_APP_DATA_EXPIRED                                                    syscall.Errno = 4401
	ERROR_APP_DATA_CORRUPT                                                    syscall.Errno = 4402
	ERROR_APP_DATA_LIMIT_EXCEEDED                                             syscall.Errno = 4403
	ERROR_APP_DATA_REBOOT_REQUIRED                                            syscall.Errno = 4404
	ERROR_SECUREBOOT_ROLLBACK_DETECTED                                        syscall.Errno = 4420
	ERROR_SECUREBOOT_POLICY_VIOLATION                                         syscall.Errno = 4421
	ERROR_SECUREBOOT_INVALID_POLICY                                           syscall.Errno = 4422
	ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND                               syscall.Errno = 4423
	ERROR_SECUREBOOT_POLICY_NOT_SIGNED                                        syscall.Errno = 4424
	ERROR_SECUREBOOT_NOT_ENABLED                                              syscall.Errno = 4425
	ERROR_SECUREBOOT_FILE_REPLACED                                            syscall.Errno = 4426
	ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED                                    syscall.Errno = 4427
	ERROR_SECUREBOOT_POLICY_UNKNOWN                                           syscall.Errno = 4428
	ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION                       syscall.Errno = 4429
	ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH                                     syscall.Errno = 4430
	ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED                                 syscall.Errno = 4431
	ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH                                  syscall.Errno = 4432
	ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING                             syscall.Errno = 4433
	ERROR_SECUREBOOT_NOT_BASE_POLICY                                          syscall.Errno = 4434
	ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY                                  syscall.Errno = 4435
	ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED                                      syscall.Errno = 4440
	ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED                                     syscall.Errno = 4441
	ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED                                     syscall.Errno = 4442
	ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED                                    syscall.Errno = 4443
	ERROR_ALREADY_HAS_STREAM_ID                                               syscall.Errno = 4444
	ERROR_SMR_GARBAGE_COLLECTION_REQUIRED                                     syscall.Errno = 4445
	ERROR_WOF_WIM_HEADER_CORRUPT                                              syscall.Errno = 4446
	ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT                                      syscall.Errno = 4447
	ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT                                     syscall.Errno = 4448
	ERROR_VOLUME_NOT_SIS_ENABLED                                              syscall.Errno = 4500
	ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED                                  syscall.Errno = 4550
	ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION                                   syscall.Errno = 4551
	ERROR_SYSTEM_INTEGRITY_INVALID_POLICY                                     syscall.Errno = 4552
	ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED                                  syscall.Errno = 4553
	ERROR_VSM_NOT_INITIALIZED                                                 syscall.Errno = 4560
	ERROR_VSM_DMA_PROTECTION_NOT_IN_USE                                       syscall.Errno = 4561
	ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED                                    syscall.Errno = 4570
	ERROR_PLATFORM_MANIFEST_INVALID                                           syscall.Errno = 4571
	ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED                               syscall.Errno = 4572
	ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED                            syscall.Errno = 4573
	ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND                               syscall.Errno = 4574
	ERROR_PLATFORM_MANIFEST_NOT_ACTIVE                                        syscall.Errno = 4575
	ERROR_PLATFORM_MANIFEST_NOT_SIGNED                                        syscall.Errno = 4576
	ERROR_DEPENDENT_RESOURCE_EXISTS                                           syscall.Errno = 5001
	ERROR_DEPENDENCY_NOT_FOUND                                                syscall.Errno = 5002
	ERROR_DEPENDENCY_ALREADY_EXISTS                                           syscall.Errno = 5003
	ERROR_RESOURCE_NOT_ONLINE                                                 syscall.Errno = 5004
	ERROR_HOST_NODE_NOT_AVAILABLE                                             syscall.Errno = 5005
	ERROR_RESOURCE_NOT_AVAILABLE                                              syscall.Errno = 5006
	ERROR_RESOURCE_NOT_FOUND                                                  syscall.Errno = 5007
	ERROR_SHUTDOWN_CLUSTER                                                    syscall.Errno = 5008
	ERROR_CANT_EVICT_ACTIVE_NODE                                              syscall.Errno = 5009
	ERROR_OBJECT_ALREADY_EXISTS                                               syscall.Errno = 5010
	ERROR_OBJECT_IN_LIST                                                      syscall.Errno = 5011
	ERROR_GROUP_NOT_AVAILABLE                                                 syscall.Errno = 5012
	ERROR_GROUP_NOT_FOUND                                                     syscall.Errno = 5013
	ERROR_GROUP_NOT_ONLINE                                                    syscall.Errno = 5014
	ERROR_HOST_NODE_NOT_RESOURCE_OWNER                                        syscall.Errno = 5015
	ERROR_HOST_NODE_NOT_GROUP_OWNER                                           syscall.Errno = 5016
	ERROR_RESMON_CREATE_FAILED                                                syscall.Errno = 5017
	ERROR_RESMON_ONLINE_FAILED                                                syscall.Errno = 5018
	ERROR_RESOURCE_ONLINE                                                     syscall.Errno = 5019
	ERROR_QUORUM_RESOURCE                                                     syscall.Errno = 5020
	ERROR_NOT_QUORUM_CAPABLE                                                  syscall.Errno = 5021
	ERROR_CLUSTER_SHUTTING_DOWN                                               syscall.Errno = 5022
	ERROR_INVALID_STATE                                                       syscall.Errno = 5023
	ERROR_RESOURCE_PROPERTIES_STORED                                          syscall.Errno = 5024
	ERROR_NOT_QUORUM_CLASS                                                    syscall.Errno = 5025
	ERROR_CORE_RESOURCE                                                       syscall.Errno = 5026
	ERROR_QUORUM_RESOURCE_ONLINE_FAILED                                       syscall.Errno = 5027
	ERROR_QUORUMLOG_OPEN_FAILED                                               syscall.Errno = 5028
	ERROR_CLUSTERLOG_CORRUPT                                                  syscall.Errno = 5029
	ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE                                   syscall.Errno = 5030
	ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE                                          syscall.Errno = 5031
	ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND                                       syscall.Errno = 5032
	ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE                                         syscall.Errno = 5033
	ERROR_QUORUM_OWNER_ALIVE                                                  syscall.Errno = 5034
	ERROR_NETWORK_NOT_AVAILABLE                                               syscall.Errno = 5035
	ERROR_NODE_NOT_AVAILABLE                                                  syscall.Errno = 5036
	ERROR_ALL_NODES_NOT_AVAILABLE                                             syscall.Errno = 5037
	ERROR_RESOURCE_FAILED                                                     syscall.Errno = 5038
	ERROR_CLUSTER_INVALID_NODE                                                syscall.Errno = 5039
	ERROR_CLUSTER_NODE_EXISTS                                                 syscall.Errno = 5040
	ERROR_CLUSTER_JOIN_IN_PROGRESS                                            syscall.Errno = 5041
	ERROR_CLUSTER_NODE_NOT_FOUND                                              syscall.Errno = 5042
	ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND                                        syscall.Errno = 5043
	ERROR_CLUSTER_NETWORK_EXISTS                                              syscall.Errno = 5044
	ERROR_CLUSTER_NETWORK_NOT_FOUND                                           syscall.Errno = 5045
	ERROR_CLUSTER_NETINTERFACE_EXISTS                                         syscall.Errno = 5046
	ERROR_CLUSTER_NETINTERFACE_NOT_FOUND                                      syscall.Errno = 5047
	ERROR_CLUSTER_INVALID_REQUEST                                             syscall.Errno = 5048
	ERROR_CLUSTER_INVALID_NETWORK_PROVIDER                                    syscall.Errno = 5049
	ERROR_CLUSTER_NODE_DOWN                                                   syscall.Errno = 5050
	ERROR_CLUSTER_NODE_UNREACHABLE                                            syscall.Errno = 5051
	ERROR_CLUSTER_NODE_NOT_MEMBER                                             syscall.Errno = 5052
	ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS                                        syscall.Errno = 5053
	ERROR_CLUSTER_INVALID_NETWORK                                             syscall.Errno = 5054
	ERROR_CLUSTER_NODE_UP                                                     syscall.Errno = 5056
	ERROR_CLUSTER_IPADDR_IN_USE                                               syscall.Errno = 5057
	ERROR_CLUSTER_NODE_NOT_PAUSED                                             syscall.Errno = 5058
	ERROR_CLUSTER_NO_SECURITY_CONTEXT                                         syscall.Errno = 5059
	ERROR_CLUSTER_NETWORK_NOT_INTERNAL                                        syscall.Errno = 5060
	ERROR_CLUSTER_NODE_ALREADY_UP                                             syscall.Errno = 5061
	ERROR_CLUSTER_NODE_ALREADY_DOWN                                           syscall.Errno = 5062
	ERROR_CLUSTER_NETWORK_ALREADY_ONLINE                                      syscall.Errno = 5063
	ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE                                     syscall.Errno = 5064
	ERROR_CLUSTER_NODE_ALREADY_MEMBER                                         syscall.Errno = 5065
	ERROR_CLUSTER_LAST_INTERNAL_NETWORK                                       syscall.Errno = 5066
	ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS                                      syscall.Errno = 5067
	ERROR_INVALID_OPERATION_ON_QUORUM                                         syscall.Errno = 5068
	ERROR_DEPENDENCY_NOT_ALLOWED                                              syscall.Errno = 5069
	ERROR_CLUSTER_NODE_PAUSED                                                 syscall.Errno = 5070
	ERROR_NODE_CANT_HOST_RESOURCE                                             syscall.Errno = 5071
	ERROR_CLUSTER_NODE_NOT_READY                                              syscall.Errno = 5072
	ERROR_CLUSTER_NODE_SHUTTING_DOWN                                          syscall.Errno = 5073
	ERROR_CLUSTER_JOIN_ABORTED                                                syscall.Errno = 5074
	ERROR_CLUSTER_INCOMPATIBLE_VERSIONS                                       syscall.Errno = 5075
	ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED                                syscall.Errno = 5076
	ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED                                       syscall.Errno = 5077
	ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND                                     syscall.Errno = 5078
	ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED                                       syscall.Errno = 5079
	ERROR_CLUSTER_RESNAME_NOT_FOUND                                           syscall.Errno = 5080
	ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED                                  syscall.Errno = 5081
	ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST                                       syscall.Errno = 5082
	ERROR_CLUSTER_DATABASE_SEQMISMATCH                                        syscall.Errno = 5083
	ERROR_RESMON_INVALID_STATE                                                syscall.Errno = 5084
	ERROR_CLUSTER_GUM_NOT_LOCKER                                              syscall.Errno = 5085
	ERROR_QUORUM_DISK_NOT_FOUND                                               syscall.Errno = 5086
	ERROR_DATABASE_BACKUP_CORRUPT                                             syscall.Errno = 5087
	ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT                                   syscall.Errno = 5088
	ERROR_RESOURCE_PROPERTY_UNCHANGEABLE                                      syscall.Errno = 5089
	ERROR_NO_ADMIN_ACCESS_POINT                                               syscall.Errno = 5090
	ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE                                    syscall.Errno = 5890
	ERROR_CLUSTER_QUORUMLOG_NOT_FOUND                                         syscall.Errno = 5891
	ERROR_CLUSTER_MEMBERSHIP_HALT                                             syscall.Errno = 5892
	ERROR_CLUSTER_INSTANCE_ID_MISMATCH                                        syscall.Errno = 5893
	ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP                                    syscall.Errno = 5894
	ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH                                 syscall.Errno = 5895
	ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP                                       syscall.Errno = 5896
	ERROR_CLUSTER_PARAMETER_MISMATCH                                          syscall.Errno = 5897
	ERROR_NODE_CANNOT_BE_CLUSTERED                                            syscall.Errno = 5898
	ERROR_CLUSTER_WRONG_OS_VERSION                                            syscall.Errno = 5899
	ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME                                syscall.Errno = 5900
	ERROR_CLUSCFG_ALREADY_COMMITTED                                           syscall.Errno = 5901
	ERROR_CLUSCFG_ROLLBACK_FAILED                                             syscall.Errno = 5902
	ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT                           syscall.Errno = 5903
	ERROR_CLUSTER_OLD_VERSION                                                 syscall.Errno = 5904
	ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME                               syscall.Errno = 5905
	ERROR_CLUSTER_NO_NET_ADAPTERS                                             syscall.Errno = 5906
	ERROR_CLUSTER_POISONED                                                    syscall.Errno = 5907
	ERROR_CLUSTER_GROUP_MOVING                                                syscall.Errno = 5908
	ERROR_CLUSTER_RESOURCE_TYPE_BUSY                                          syscall.Errno = 5909
	ERROR_RESOURCE_CALL_TIMED_OUT                                             syscall.Errno = 5910
	ERROR_INVALID_CLUSTER_IPV6_ADDRESS                                        syscall.Errno = 5911
	ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION                                   syscall.Errno = 5912
	ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS                                     syscall.Errno = 5913
	ERROR_CLUSTER_PARTIAL_SEND                                                syscall.Errno = 5914
	ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION                                   syscall.Errno = 5915
	ERROR_CLUSTER_INVALID_STRING_TERMINATION                                  syscall.Errno = 5916
	ERROR_CLUSTER_INVALID_STRING_FORMAT                                       syscall.Errno = 5917
	ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS                            syscall.Errno = 5918
	ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS                        syscall.Errno = 5919
	ERROR_CLUSTER_NULL_DATA                                                   syscall.Errno = 5920
	ERROR_CLUSTER_PARTIAL_READ                                                syscall.Errno = 5921
	ERROR_CLUSTER_PARTIAL_WRITE                                               syscall.Errno = 5922
	ERROR_CLUSTER_CANT_DESERIALIZE_DATA                                       syscall.Errno = 5923
	ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT                                syscall.Errno = 5924
	ERROR_CLUSTER_NO_QUORUM                                                   syscall.Errno = 5925
	ERROR_CLUSTER_INVALID_IPV6_NETWORK                                        syscall.Errno = 5926
	ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK                                 syscall.Errno = 5927
	ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP                                    syscall.Errno = 5928
	ERROR_DEPENDENCY_TREE_TOO_COMPLEX                                         syscall.Errno = 5929
	ERROR_EXCEPTION_IN_RESOURCE_CALL                                          syscall.Errno = 5930
	ERROR_CLUSTER_RHS_FAILED_INITIALIZATION                                   syscall.Errno = 5931
	ERROR_CLUSTER_NOT_INSTALLED                                               syscall.Errno = 5932
	ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE                   syscall.Errno = 5933
	ERROR_CLUSTER_MAX_NODES_IN_CLUSTER                                        syscall.Errno = 5934
	ERROR_CLUSTER_TOO_MANY_NODES                                              syscall.Errno = 5935
	ERROR_CLUSTER_OBJECT_ALREADY_USED                                         syscall.Errno = 5936
	ERROR_NONCORE_GROUPS_FOUND                                                syscall.Errno = 5937
	ERROR_FILE_SHARE_RESOURCE_CONFLICT                                        syscall.Errno = 5938
	ERROR_CLUSTER_EVICT_INVALID_REQUEST                                       syscall.Errno = 5939
	ERROR_CLUSTER_SINGLETON_RESOURCE                                          syscall.Errno = 5940
	ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE                                    syscall.Errno = 5941
	ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED                                    syscall.Errno = 5942
	ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR                                syscall.Errno = 5943
	ERROR_CLUSTER_GROUP_BUSY                                                  syscall.Errno = 5944
	ERROR_CLUSTER_NOT_SHARED_VOLUME                                           syscall.Errno = 5945
	ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR                                 syscall.Errno = 5946
	ERROR_CLUSTER_SHARED_VOLUMES_IN_USE                                       syscall.Errno = 5947
	ERROR_CLUSTER_USE_SHARED_VOLUMES_API                                      syscall.Errno = 5948
	ERROR_CLUSTER_BACKUP_IN_PROGRESS                                          syscall.Errno = 5949
	ERROR_NON_CSV_PATH                                                        syscall.Errno = 5950
	ERROR_CSV_VOLUME_NOT_LOCAL                                                syscall.Errno = 5951
	ERROR_CLUSTER_WATCHDOG_TERMINATING                                        syscall.Errno = 5952
	ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES                     syscall.Errno = 5953
	ERROR_CLUSTER_INVALID_NODE_WEIGHT                                         syscall.Errno = 5954
	ERROR_CLUSTER_RESOURCE_VETOED_CALL                                        syscall.Errno = 5955
	ERROR_RESMON_SYSTEM_RESOURCES_LACKING                                     syscall.Errno = 5956
	ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION    syscall.Errno = 5957
	ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE         syscall.Errno = 5958
	ERROR_CLUSTER_GROUP_QUEUED                                                syscall.Errno = 5959
	ERROR_CLUSTER_RESOURCE_LOCKED_STATUS                                      syscall.Errno = 5960
	ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED                          syscall.Errno = 5961
	ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS                                      syscall.Errno = 5962
	ERROR_CLUSTER_DISK_NOT_CONNECTED                                          syscall.Errno = 5963
	ERROR_DISK_NOT_CSV_CAPABLE                                                syscall.Errno = 5964
	ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE                                   syscall.Errno = 5965
	ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED                                    syscall.Errno = 5966
	ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED                                syscall.Errno = 5967
	ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES                                    syscall.Errno = 5968
	ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES  syscall.Errno = 5969
	ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE                             syscall.Errno = 5970
	ERROR_CLUSTER_AFFINITY_CONFLICT                                           syscall.Errno = 5971
	ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE                         syscall.Errno = 5972
	ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS                               syscall.Errno = 5973
	ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED                            syscall.Errno = 5974
	ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED                                    syscall.Errno = 5975
	ERROR_CLUSTER_UPGRADE_IN_PROGRESS                                         syscall.Errno = 5976
	ERROR_CLUSTER_UPGRADE_INCOMPLETE                                          syscall.Errno = 5977
	ERROR_CLUSTER_NODE_IN_GRACE_PERIOD                                        syscall.Errno = 5978
	ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT                                        syscall.Errno = 5979
	ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER                                      syscall.Errno = 5980
	ERROR_CLUSTER_RESOURCE_NOT_MONITORED                                      syscall.Errno = 5981
	ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED                       syscall.Errno = 5982
	ERROR_CLUSTER_RESOURCE_IS_REPLICATED                                      syscall.Errno = 5983
	ERROR_CLUSTER_NODE_ISOLATED                                               syscall.Errno = 5984
	ERROR_CLUSTER_NODE_QUARANTINED                                            syscall.Errno = 5985
	ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED                            syscall.Errno = 5986
	ERROR_CLUSTER_SPACE_DEGRADED                                              syscall.Errno = 5987
	ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED                              syscall.Errno = 5988
	ERROR_CLUSTER_CSV_INVALID_HANDLE                                          syscall.Errno = 5989
	ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR                           syscall.Errno = 5990
	ERROR_GROUPSET_NOT_AVAILABLE                                              syscall.Errno = 5991
	ERROR_GROUPSET_NOT_FOUND                                                  syscall.Errno = 5992
	ERROR_GROUPSET_CANT_PROVIDE                                               syscall.Errno = 5993
	ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND                               syscall.Errno = 5994
	ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY                              syscall.Errno = 5995
	ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION                          syscall.Errno = 5996
	ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS                          syscall.Errno = 5997
	ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME                      syscall.Errno = 5998
	ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE                           syscall.Errno = 5999
	ERROR_ENCRYPTION_FAILED                                                   syscall.Errno = 6000
	ERROR_DECRYPTION_FAILED                                                   syscall.Errno = 6001
	ERROR_FILE_ENCRYPTED                                                      syscall.Errno = 6002
	ERROR_NO_RECOVERY_POLICY                                                  syscall.Errno = 6003
	ERROR_NO_EFS                                                              syscall.Errno = 6004
	ERROR_WRONG_EFS                                                           syscall.Errno = 6005
	ERROR_NO_USER_KEYS                                                        syscall.Errno = 6006
	ERROR_FILE_NOT_ENCRYPTED                                                  syscall.Errno = 6007
	ERROR_NOT_EXPORT_FORMAT                                                   syscall.Errno = 6008
	ERROR_FILE_READ_ONLY                                                      syscall.Errno = 6009
	ERROR_DIR_EFS_DISALLOWED                                                  syscall.Errno = 6010
	ERROR_EFS_SERVER_NOT_TRUSTED                                              syscall.Errno = 6011
	ERROR_BAD_RECOVERY_POLICY                                                 syscall.Errno = 6012
	ERROR_EFS_ALG_BLOB_TOO_BIG                                                syscall.Errno = 6013
	ERROR_VOLUME_NOT_SUPPORT_EFS                                              syscall.Errno = 6014
	ERROR_EFS_DISABLED                                                        syscall.Errno = 6015
	ERROR_EFS_VERSION_NOT_SUPPORT                                             syscall.Errno = 6016
	ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE                               syscall.Errno = 6017
	ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER                                    syscall.Errno = 6018
	ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE                               syscall.Errno = 6019
	ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE                                    syscall.Errno = 6020
	ERROR_CS_ENCRYPTION_FILE_NOT_CSE                                          syscall.Errno = 6021
	ERROR_ENCRYPTION_POLICY_DENIES_OPERATION                                  syscall.Errno = 6022
	ERROR_NO_BROWSER_SERVERS_FOUND                                            syscall.Errno = 6118
	SCHED_E_SERVICE_NOT_LOCALSYSTEM                                           syscall.Errno = 6200
	ERROR_LOG_SECTOR_INVALID                                                  syscall.Errno = 6600
	ERROR_LOG_SECTOR_PARITY_INVALID                                           syscall.Errno = 6601
	ERROR_LOG_SECTOR_REMAPPED                                                 syscall.Errno = 6602
	ERROR_LOG_BLOCK_INCOMPLETE                                                syscall.Errno = 6603
	ERROR_LOG_INVALID_RANGE                                                   syscall.Errno = 6604
	ERROR_LOG_BLOCKS_EXHAUSTED                                                syscall.Errno = 6605
	ERROR_LOG_READ_CONTEXT_INVALID                                            syscall.Errno = 6606
	ERROR_LOG_RESTART_INVALID                                                 syscall.Errno = 6607
	ERROR_LOG_BLOCK_VERSION                                                   syscall.Errno = 6608
	ERROR_LOG_BLOCK_INVALID                                                   syscall.Errno = 6609
	ERROR_LOG_READ_MODE_INVALID                                               syscall.Errno = 6610
	ERROR_LOG_NO_RESTART                                                      syscall.Errno = 6611
	ERROR_LOG_METADATA_CORRUPT                                                syscall.Errno = 6612
	ERROR_LOG_METADATA_INVALID                                                syscall.Errno = 6613
	ERROR_LOG_METADATA_INCONSISTENT                                           syscall.Errno = 6614
	ERROR_LOG_RESERVATION_INVALID                                             syscall.Errno = 6615
	ERROR_LOG_CANT_DELETE                                                     syscall.Errno = 6616
	ERROR_LOG_CONTAINER_LIMIT_EXCEEDED                                        syscall.Errno = 6617
	ERROR_LOG_START_OF_LOG                                                    syscall.Errno = 6618
	ERROR_LOG_POLICY_ALREADY_INSTALLED                                        syscall.Errno = 6619
	ERROR_LOG_POLICY_NOT_INSTALLED                                            syscall.Errno = 6620
	ERROR_LOG_POLICY_INVALID                                                  syscall.Errno = 6621
	ERROR_LOG_POLICY_CONFLICT                                                 syscall.Errno = 6622
	ERROR_LOG_PINNED_ARCHIVE_TAIL                                             syscall.Errno = 6623
	ERROR_LOG_RECORD_NONEXISTENT                                              syscall.Errno = 6624
	ERROR_LOG_RECORDS_RESERVED_INVALID                                        syscall.Errno = 6625
	ERROR_LOG_SPACE_RESERVED_INVALID                                          syscall.Errno = 6626
	ERROR_LOG_TAIL_INVALID                                                    syscall.Errno = 6627
	ERROR_LOG_FULL                                                            syscall.Errno = 6628
	ERROR_COULD_NOT_RESIZE_LOG                                                syscall.Errno = 6629
	ERROR_LOG_MULTIPLEXED                                                     syscall.Errno = 6630
	ERROR_LOG_DEDICATED                                                       syscall.Errno = 6631
	ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS                                         syscall.Errno = 6632
	ERROR_LOG_ARCHIVE_IN_PROGRESS                                             syscall.Errno = 6633
	ERROR_LOG_EPHEMERAL                                                       syscall.Errno = 6634
	ERROR_LOG_NOT_ENOUGH_CONTAINERS                                           syscall.Errno = 6635
	ERROR_LOG_CLIENT_ALREADY_REGISTERED                                       syscall.Errno = 6636
	ERROR_LOG_CLIENT_NOT_REGISTERED                                           syscall.Errno = 6637
	ERROR_LOG_FULL_HANDLER_IN_PROGRESS                                        syscall.Errno = 6638
	ERROR_LOG_CONTAINER_READ_FAILED                                           syscall.Errno = 6639
	ERROR_LOG_CONTAINER_WRITE_FAILED                                          syscall.Errno = 6640
	ERROR_LOG_CONTAINER_OPEN_FAILED                                           syscall.Errno = 6641
	ERROR_LOG_CONTAINER_STATE_INVALID                                         syscall.Errno = 6642
	ERROR_LOG_STATE_INVALID                                                   syscall.Errno = 6643
	ERROR_LOG_PINNED                                                          syscall.Errno = 6644
	ERROR_LOG_METADATA_FLUSH_FAILED                                           syscall.Errno = 6645
	ERROR_LOG_INCONSISTENT_SECURITY                                           syscall.Errno = 6646
	ERROR_LOG_APPENDED_FLUSH_FAILED                                           syscall.Errno = 6647
	ERROR_LOG_PINNED_RESERVATION                                              syscall.Errno = 6648
	ERROR_INVALID_TRANSACTION                                                 syscall.Errno = 6700
	ERROR_TRANSACTION_NOT_ACTIVE                                              syscall.Errno = 6701
	ERROR_TRANSACTION_REQUEST_NOT_VALID                                       syscall.Errno = 6702
	ERROR_TRANSACTION_NOT_REQUESTED                                           syscall.Errno = 6703
	ERROR_TRANSACTION_ALREADY_ABORTED                                         syscall.Errno = 6704
	ERROR_TRANSACTION_ALREADY_COMMITTED                                       syscall.Errno = 6705
	ERROR_TM_INITIALIZATION_FAILED                                            syscall.Errno = 6706
	ERROR_RESOURCEMANAGER_READ_ONLY                                           syscall.Errno = 6707
	ERROR_TRANSACTION_NOT_JOINED                                              syscall.Errno = 6708
	ERROR_TRANSACTION_SUPERIOR_EXISTS                                         syscall.Errno = 6709
	ERROR_CRM_PROTOCOL_ALREADY_EXISTS                                         syscall.Errno = 6710
	ERROR_TRANSACTION_PROPAGATION_FAILED                                      syscall.Errno = 6711
	ERROR_CRM_PROTOCOL_NOT_FOUND                                              syscall.Errno = 6712
	ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER                                 syscall.Errno = 6713
	ERROR_CURRENT_TRANSACTION_NOT_VALID                                       syscall.Errno = 6714
	ERROR_TRANSACTION_NOT_FOUND                                               syscall.Errno = 6715
	ERROR_RESOURCEMANAGER_NOT_FOUND                                           syscall.Errno = 6716
	ERROR_ENLISTMENT_NOT_FOUND                                                syscall.Errno = 6717
	ERROR_TRANSACTIONMANAGER_NOT_FOUND                                        syscall.Errno = 6718
	ERROR_TRANSACTIONMANAGER_NOT_ONLINE                                       syscall.Errno = 6719
	ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION                          syscall.Errno = 6720
	ERROR_TRANSACTION_NOT_ROOT                                                syscall.Errno = 6721
	ERROR_TRANSACTION_OBJECT_EXPIRED                                          syscall.Errno = 6722
	ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED                                   syscall.Errno = 6723
	ERROR_TRANSACTION_RECORD_TOO_LONG                                         syscall.Errno = 6724
	ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED                                  syscall.Errno = 6725
	ERROR_TRANSACTION_INTEGRITY_VIOLATED                                      syscall.Errno = 6726
	ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH                                syscall.Errno = 6727
	ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT                                    syscall.Errno = 6728
	ERROR_TRANSACTION_MUST_WRITETHROUGH                                       syscall.Errno = 6729
	ERROR_TRANSACTION_NO_SUPERIOR                                             syscall.Errno = 6730
	ERROR_HEURISTIC_DAMAGE_POSSIBLE                                           syscall.Errno = 6731
	ERROR_TRANSACTIONAL_CONFLICT                                              syscall.Errno = 6800
	ERROR_RM_NOT_ACTIVE                                                       syscall.Errno = 6801
	ERROR_RM_METADATA_CORRUPT                                                 syscall.Errno = 6802
	ERROR_DIRECTORY_NOT_RM                                                    syscall.Errno = 6803
	ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE                                     syscall.Errno = 6805
	ERROR_LOG_RESIZE_INVALID_SIZE                                             syscall.Errno = 6806
	ERROR_OBJECT_NO_LONGER_EXISTS                                             syscall.Errno = 6807
	ERROR_STREAM_MINIVERSION_NOT_FOUND                                        syscall.Errno = 6808
	ERROR_STREAM_MINIVERSION_NOT_VALID                                        syscall.Errno = 6809
	ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION                 syscall.Errno = 6810
	ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT                            syscall.Errno = 6811
	ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS                                syscall.Errno = 6812
	ERROR_REMOTE_FILE_VERSION_MISMATCH                                        syscall.Errno = 6814
	ERROR_HANDLE_NO_LONGER_VALID                                              syscall.Errno = 6815
	ERROR_NO_TXF_METADATA                                                     syscall.Errno = 6816
	ERROR_LOG_CORRUPTION_DETECTED                                             syscall.Errno = 6817
	ERROR_CANT_RECOVER_WITH_HANDLE_OPEN                                       syscall.Errno = 6818
	ERROR_RM_DISCONNECTED                                                     syscall.Errno = 6819
	ERROR_ENLISTMENT_NOT_SUPERIOR                                             syscall.Errno = 6820
	ERROR_RECOVERY_NOT_NEEDED                                                 syscall.Errno = 6821
	ERROR_RM_ALREADY_STARTED                                                  syscall.Errno = 6822
	ERROR_FILE_IDENTITY_NOT_PERSISTENT                                        syscall.Errno = 6823
	ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY                                 syscall.Errno = 6824
	ERROR_CANT_CROSS_RM_BOUNDARY                                              syscall.Errno = 6825
	ERROR_TXF_DIR_NOT_EMPTY                                                   syscall.Errno = 6826
	ERROR_INDOUBT_TRANSACTIONS_EXIST                                          syscall.Errno = 6827
	ERROR_TM_VOLATILE                                                         syscall.Errno = 6828
	ERROR_ROLLBACK_TIMER_EXPIRED                                              syscall.Errno = 6829
	ERROR_TXF_ATTRIBUTE_CORRUPT                                               syscall.Errno = 6830
	ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION                                      syscall.Errno = 6831
	ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED                                      syscall.Errno = 6832
	ERROR_LOG_GROWTH_FAILED                                                   syscall.Errno = 6833
	ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE                               syscall.Errno = 6834
	ERROR_TXF_METADATA_ALREADY_PRESENT                                        syscall.Errno = 6835
	ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET                                 syscall.Errno = 6836
	ERROR_TRANSACTION_REQUIRED_PROMOTION                                      syscall.Errno = 6837
	ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION                                  syscall.Errno = 6838
	ERROR_TRANSACTIONS_NOT_FROZEN                                             syscall.Errno = 6839
	ERROR_TRANSACTION_FREEZE_IN_PROGRESS                                      syscall.Errno = 6840
	ERROR_NOT_SNAPSHOT_VOLUME                                                 syscall.Errno = 6841
	ERROR_NO_SAVEPOINT_WITH_OPEN_FILES                                        syscall.Errno = 6842
	ERROR_DATA_LOST_REPAIR                                                    syscall.Errno = 6843
	ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION                                   syscall.Errno = 6844
	ERROR_TM_IDENTITY_MISMATCH                                                syscall.Errno = 6845
	ERROR_FLOATED_SECTION                                                     syscall.Errno = 6846
	ERROR_CANNOT_ACCEPT_TRANSACTED_WORK                                       syscall.Errno = 6847
	ERROR_CANNOT_ABORT_TRANSACTIONS                                           syscall.Errno = 6848
	ERROR_BAD_CLUSTERS                                                        syscall.Errno = 6849
	ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION                              syscall.Errno = 6850
	ERROR_VOLUME_DIRTY                                                        syscall.Errno = 6851
	ERROR_NO_LINK_TRACKING_IN_TRANSACTION                                     syscall.Errno = 6852
	ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION                              syscall.Errno = 6853
	ERROR_EXPIRED_HANDLE                                                      syscall.Errno = 6854
	ERROR_TRANSACTION_NOT_ENLISTED                                            syscall.Errno = 6855
	ERROR_CTX_WINSTATION_NAME_INVALID                                         syscall.Errno = 7001
	ERROR_CTX_INVALID_PD                                                      syscall.Errno = 7002
	ERROR_CTX_PD_NOT_FOUND                                                    syscall.Errno = 7003
	ERROR_CTX_WD_NOT_FOUND                                                    syscall.Errno = 7004
	ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY                                      syscall.Errno = 7005
	ERROR_CTX_SERVICE_NAME_COLLISION                                          syscall.Errno = 7006
	ERROR_CTX_CLOSE_PENDING                                                   syscall.Errno = 7007
	ERROR_CTX_NO_OUTBUF                                                       syscall.Errno = 7008
	ERROR_CTX_MODEM_INF_NOT_FOUND                                             syscall.Errno = 7009
	ERROR_CTX_INVALID_MODEMNAME                                               syscall.Errno = 7010
	ERROR_CTX_MODEM_RESPONSE_ERROR                                            syscall.Errno = 7011
	ERROR_CTX_MODEM_RESPONSE_TIMEOUT                                          syscall.Errno = 7012
	ERROR_CTX_MODEM_RESPONSE_NO_CARRIER                                       syscall.Errno = 7013
	ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE                                      syscall.Errno = 7014
	ERROR_CTX_MODEM_RESPONSE_BUSY                                             syscall.Errno = 7015
	ERROR_CTX_MODEM_RESPONSE_VOICE                                            syscall.Errno = 7016
	ERROR_CTX_TD_ERROR                                                        syscall.Errno = 7017
	ERROR_CTX_WINSTATION_NOT_FOUND                                            syscall.Errno = 7022
	ERROR_CTX_WINSTATION_ALREADY_EXISTS                                       syscall.Errno = 7023
	ERROR_CTX_WINSTATION_BUSY                                                 syscall.Errno = 7024
	ERROR_CTX_BAD_VIDEO_MODE                                                  syscall.Errno = 7025
	ERROR_CTX_GRAPHICS_INVALID                                                syscall.Errno = 7035
	ERROR_CTX_LOGON_DISABLED                                                  syscall.Errno = 7037
	ERROR_CTX_NOT_CONSOLE                                                     syscall.Errno = 7038
	ERROR_CTX_CLIENT_QUERY_TIMEOUT                                            syscall.Errno = 7040
	ERROR_CTX_CONSOLE_DISCONNECT                                              syscall.Errno = 7041
	ERROR_CTX_CONSOLE_CONNECT                                                 syscall.Errno = 7042
	ERROR_CTX_SHADOW_DENIED                                                   syscall.Errno = 7044
	ERROR_CTX_WINSTATION_ACCESS_DENIED                                        syscall.Errno = 7045
	ERROR_CTX_INVALID_WD                                                      syscall.Errno = 7049
	ERROR_CTX_SHADOW_INVALID                                                  syscall.Errno = 7050
	ERROR_CTX_SHADOW_DISABLED                                                 syscall.Errno = 7051
	ERROR_CTX_CLIENT_LICENSE_IN_USE                                           syscall.Errno = 7052
	ERROR_CTX_CLIENT_LICENSE_NOT_SET                                          syscall.Errno = 7053
	ERROR_CTX_LICENSE_NOT_AVAILABLE                                           syscall.Errno = 7054
	ERROR_CTX_LICENSE_CLIENT_INVALID                                          syscall.Errno = 7055
	ERROR_CTX_LICENSE_EXPIRED                                                 syscall.Errno = 7056
	ERROR_CTX_SHADOW_NOT_RUNNING                                              syscall.Errno = 7057
	ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE                                     syscall.Errno = 7058
	ERROR_ACTIVATION_COUNT_EXCEEDED                                           syscall.Errno = 7059
	ERROR_CTX_WINSTATIONS_DISABLED                                            syscall.Errno = 7060
	ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED                                       syscall.Errno = 7061
	ERROR_CTX_SESSION_IN_USE                                                  syscall.Errno = 7062
	ERROR_CTX_NO_FORCE_LOGOFF                                                 syscall.Errno = 7063
	ERROR_CTX_ACCOUNT_RESTRICTION                                             syscall.Errno = 7064
	ERROR_RDP_PROTOCOL_ERROR                                                  syscall.Errno = 7065
	ERROR_CTX_CDM_CONNECT                                                     syscall.Errno = 7066
	ERROR_CTX_CDM_DISCONNECT                                                  syscall.Errno = 7067
	ERROR_CTX_SECURITY_LAYER_ERROR                                            syscall.Errno = 7068
	ERROR_TS_INCOMPATIBLE_SESSIONS                                            syscall.Errno = 7069
	ERROR_TS_VIDEO_SUBSYSTEM_ERROR                                            syscall.Errno = 7070
	FRS_ERR_INVALID_API_SEQUENCE                                              syscall.Errno = 8001
	FRS_ERR_STARTING_SERVICE                                                  syscall.Errno = 8002
	FRS_ERR_STOPPING_SERVICE                                                  syscall.Errno = 8003
	FRS_ERR_INTERNAL_API                                                      syscall.Errno = 8004
	FRS_ERR_INTERNAL                                                          syscall.Errno = 8005
	FRS_ERR_SERVICE_COMM                                                      syscall.Errno = 8006
	FRS_ERR_INSUFFICIENT_PRIV                                                 syscall.Errno = 8007
	FRS_ERR_AUTHENTICATION                                                    syscall.Errno = 8008
	FRS_ERR_PARENT_INSUFFICIENT_PRIV                                          syscall.Errno = 8009
	FRS_ERR_PARENT_AUTHENTICATION                                             syscall.Errno = 8010
	FRS_ERR_CHILD_TO_PARENT_COMM                                              syscall.Errno = 8011
	FRS_ERR_PARENT_TO_CHILD_COMM                                              syscall.Errno = 8012
	FRS_ERR_SYSVOL_POPULATE                                                   syscall.Errno = 8013
	FRS_ERR_SYSVOL_POPULATE_TIMEOUT                                           syscall.Errno = 8014
	FRS_ERR_SYSVOL_IS_BUSY                                                    syscall.Errno = 8015
	FRS_ERR_SYSVOL_DEMOTE                                                     syscall.Errno = 8016
	FRS_ERR_INVALID_SERVICE_PARAMETER                                         syscall.Errno = 8017
	DS_S_SUCCESS                                                                            = ERROR_SUCCESS
	ERROR_DS_NOT_INSTALLED                                                    syscall.Errno = 8200
	ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY                                     syscall.Errno = 8201
	ERROR_DS_NO_ATTRIBUTE_OR_VALUE                                            syscall.Errno = 8202
	ERROR_DS_INVALID_ATTRIBUTE_SYNTAX                                         syscall.Errno = 8203
	ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED                                         syscall.Errno = 8204
	ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS                                        syscall.Errno = 8205
	ERROR_DS_BUSY                                                             syscall.Errno = 8206
	ERROR_DS_UNAVAILABLE                                                      syscall.Errno = 8207
	ERROR_DS_NO_RIDS_ALLOCATED                                                syscall.Errno = 8208
	ERROR_DS_NO_MORE_RIDS                                                     syscall.Errno = 8209
	ERROR_DS_INCORRECT_ROLE_OWNER                                             syscall.Errno = 8210
	ERROR_DS_RIDMGR_INIT_ERROR                                                syscall.Errno = 8211
	ERROR_DS_OBJ_CLASS_VIOLATION                                              syscall.Errno = 8212
	ERROR_DS_CANT_ON_NON_LEAF                                                 syscall.Errno = 8213
	ERROR_DS_CANT_ON_RDN                                                      syscall.Errno = 8214
	ERROR_DS_CANT_MOD_OBJ_CLASS                                               syscall.Errno = 8215
	ERROR_DS_CROSS_DOM_MOVE_ERROR                                             syscall.Errno = 8216
	ERROR_DS_GC_NOT_AVAILABLE                                                 syscall.Errno = 8217
	ERROR_SHARED_POLICY                                                       syscall.Errno = 8218
	ERROR_POLICY_OBJECT_NOT_FOUND                                             syscall.Errno = 8219
	ERROR_POLICY_ONLY_IN_DS                                                   syscall.Errno = 8220
	ERROR_PROMOTION_ACTIVE                                                    syscall.Errno = 8221
	ERROR_NO_PROMOTION_ACTIVE                                                 syscall.Errno = 8222
	ERROR_DS_OPERATIONS_ERROR                                                 syscall.Errno = 8224
	ERROR_DS_PROTOCOL_ERROR                                                   syscall.Errno = 8225
	ERROR_DS_TIMELIMIT_EXCEEDED                                               syscall.Errno = 8226
	ERROR_DS_SIZELIMIT_EXCEEDED                                               syscall.Errno = 8227
	ERROR_DS_ADMIN_LIMIT_EXCEEDED                                             syscall.Errno = 8228
	ERROR_DS_COMPARE_FALSE                                                    syscall.Errno = 8229
	ERROR_DS_COMPARE_TRUE                                                     syscall.Errno = 8230
	ERROR_DS_AUTH_METHOD_NOT_SUPPORTED                                        syscall.Errno = 8231
	ERROR_DS_STRONG_AUTH_REQUIRED                                             syscall.Errno = 8232
	ERROR_DS_INAPPROPRIATE_AUTH                                               syscall.Errno = 8233
	ERROR_DS_AUTH_UNKNOWN                                                     syscall.Errno = 8234
	ERROR_DS_REFERRAL                                                         syscall.Errno = 8235
	ERROR_DS_UNAVAILABLE_CRIT_EXTENSION                                       syscall.Errno = 8236
	ERROR_DS_CONFIDENTIALITY_REQUIRED                                         syscall.Errno = 8237
	ERROR_DS_INAPPROPRIATE_MATCHING                                           syscall.Errno = 8238
	ERROR_DS_CONSTRAINT_VIOLATION                                             syscall.Errno = 8239
	ERROR_DS_NO_SUCH_OBJECT                                                   syscall.Errno = 8240
	ERROR_DS_ALIAS_PROBLEM                                                    syscall.Errno = 8241
	ERROR_DS_INVALID_DN_SYNTAX                                                syscall.Errno = 8242
	ERROR_DS_IS_LEAF                                                          syscall.Errno = 8243
	ERROR_DS_ALIAS_DEREF_PROBLEM                                              syscall.Errno = 8244
	ERROR_DS_UNWILLING_TO_PERFORM                                             syscall.Errno = 8245
	ERROR_DS_LOOP_DETECT                                                      syscall.Errno = 8246
	ERROR_DS_NAMING_VIOLATION                                                 syscall.Errno = 8247
	ERROR_DS_OBJECT_RESULTS_TOO_LARGE                                         syscall.Errno = 8248
	ERROR_DS_AFFECTS_MULTIPLE_DSAS                                            syscall.Errno = 8249
	ERROR_DS_SERVER_DOWN                                                      syscall.Errno = 8250
	ERROR_DS_LOCAL_ERROR                                                      syscall.Errno = 8251
	ERROR_DS_ENCODING_ERROR                                                   syscall.Errno = 8252
	ERROR_DS_DECODING_ERROR                                                   syscall.Errno = 8253
	ERROR_DS_FILTER_UNKNOWN                                                   syscall.Errno = 8254
	ERROR_DS_PARAM_ERROR                                                      syscall.Errno = 8255
	ERROR_DS_NOT_SUPPORTED                                                    syscall.Errno = 8256
	ERROR_DS_NO_RESULTS_RETURNED                                              syscall.Errno = 8257
	ERROR_DS_CONTROL_NOT_FOUND                                                syscall.Errno = 8258
	ERROR_DS_CLIENT_LOOP                                                      syscall.Errno = 8259
	ERROR_DS_REFERRAL_LIMIT_EXCEEDED                                          syscall.Errno = 8260
	ERROR_DS_SORT_CONTROL_MISSING                                             syscall.Errno = 8261
	ERROR_DS_OFFSET_RANGE_ERROR                                               syscall.Errno = 8262
	ERROR_DS_RIDMGR_DISABLED                                                  syscall.Errno = 8263
	ERROR_DS_ROOT_MUST_BE_NC                                                  syscall.Errno = 8301
	ERROR_DS_ADD_REPLICA_INHIBITED                                            syscall.Errno = 8302
	ERROR_DS_ATT_NOT_DEF_IN_SCHEMA                                            syscall.Errno = 8303
	ERROR_DS_MAX_OBJ_SIZE_EXCEEDED                                            syscall.Errno = 8304
	ERROR_DS_OBJ_STRING_NAME_EXISTS                                           syscall.Errno = 8305
	ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA                                         syscall.Errno = 8306
	ERROR_DS_RDN_DOESNT_MATCH_SCHEMA                                          syscall.Errno = 8307
	ERROR_DS_NO_REQUESTED_ATTS_FOUND                                          syscall.Errno = 8308
	ERROR_DS_USER_BUFFER_TO_SMALL                                             syscall.Errno = 8309
	ERROR_DS_ATT_IS_NOT_ON_OBJ                                                syscall.Errno = 8310
	ERROR_DS_ILLEGAL_MOD_OPERATION                                            syscall.Errno = 8311
	ERROR_DS_OBJ_TOO_LARGE                                                    syscall.Errno = 8312
	ERROR_DS_BAD_INSTANCE_TYPE                                                syscall.Errno = 8313
	ERROR_DS_MASTERDSA_REQUIRED                                               syscall.Errno = 8314
	ERROR_DS_OBJECT_CLASS_REQUIRED                                            syscall.Errno = 8315
	ERROR_DS_MISSING_REQUIRED_ATT                                             syscall.Errno = 8316
	ERROR_DS_ATT_NOT_DEF_FOR_CLASS                                            syscall.Errno = 8317
	ERROR_DS_ATT_ALREADY_EXISTS                                               syscall.Errno = 8318
	ERROR_DS_CANT_ADD_ATT_VALUES                                              syscall.Errno = 8320
	ERROR_DS_SINGLE_VALUE_CONSTRAINT                                          syscall.Errno = 8321
	ERROR_DS_RANGE_CONSTRAINT                                                 syscall.Errno = 8322
	ERROR_DS_ATT_VAL_ALREADY_EXISTS                                           syscall.Errno = 8323
	ERROR_DS_CANT_REM_MISSING_ATT                                             syscall.Errno = 8324
	ERROR_DS_CANT_REM_MISSING_ATT_VAL                                         syscall.Errno = 8325
	ERROR_DS_ROOT_CANT_BE_SUBREF                                              syscall.Errno = 8326
	ERROR_DS_NO_CHAINING                                                      syscall.Errno = 8327
	ERROR_DS_NO_CHAINED_EVAL                                                  syscall.Errno = 8328
	ERROR_DS_NO_PARENT_OBJECT                                                 syscall.Errno = 8329
	ERROR_DS_PARENT_IS_AN_ALIAS                                               syscall.Errno = 8330
	ERROR_DS_CANT_MIX_MASTER_AND_REPS                                         syscall.Errno = 8331
	ERROR_DS_CHILDREN_EXIST                                                   syscall.Errno = 8332
	ERROR_DS_OBJ_NOT_FOUND                                                    syscall.Errno = 8333
	ERROR_DS_ALIASED_OBJ_MISSING                                              syscall.Errno = 8334
	ERROR_DS_BAD_NAME_SYNTAX                                                  syscall.Errno = 8335
	ERROR_DS_ALIAS_POINTS_TO_ALIAS                                            syscall.Errno = 8336
	ERROR_DS_CANT_DEREF_ALIAS                                                 syscall.Errno = 8337
	ERROR_DS_OUT_OF_SCOPE                                                     syscall.Errno = 8338
	ERROR_DS_OBJECT_BEING_REMOVED                                             syscall.Errno = 8339
	ERROR_DS_CANT_DELETE_DSA_OBJ                                              syscall.Errno = 8340
	ERROR_DS_GENERIC_ERROR                                                    syscall.Errno = 8341
	ERROR_DS_DSA_MUST_BE_INT_MASTER                                           syscall.Errno = 8342
	ERROR_DS_CLASS_NOT_DSA                                                    syscall.Errno = 8343
	ERROR_DS_INSUFF_ACCESS_RIGHTS                                             syscall.Errno = 8344
	ERROR_DS_ILLEGAL_SUPERIOR                                                 syscall.Errno = 8345
	ERROR_DS_ATTRIBUTE_OWNED_BY_SAM                                           syscall.Errno = 8346
	ERROR_DS_NAME_TOO_MANY_PARTS                                              syscall.Errno = 8347
	ERROR_DS_NAME_TOO_LONG                                                    syscall.Errno = 8348
	ERROR_DS_NAME_VALUE_TOO_LONG                                              syscall.Errno = 8349
	ERROR_DS_NAME_UNPARSEABLE                                                 syscall.Errno = 8350
	ERROR_DS_NAME_TYPE_UNKNOWN                                                syscall.Errno = 8351
	ERROR_DS_NOT_AN_OBJECT                                                    syscall.Errno = 8352
	ERROR_DS_SEC_DESC_TOO_SHORT                                               syscall.Errno = 8353
	ERROR_DS_SEC_DESC_INVALID                                                 syscall.Errno = 8354
	ERROR_DS_NO_DELETED_NAME                                                  syscall.Errno = 8355
	ERROR_DS_SUBREF_MUST_HAVE_PARENT                                          syscall.Errno = 8356
	ERROR_DS_NCNAME_MUST_BE_NC                                                syscall.Errno = 8357
	ERROR_DS_CANT_ADD_SYSTEM_ONLY                                             syscall.Errno = 8358
	ERROR_DS_CLASS_MUST_BE_CONCRETE                                           syscall.Errno = 8359
	ERROR_DS_INVALID_DMD                                                      syscall.Errno = 8360
	ERROR_DS_OBJ_GUID_EXISTS                                                  syscall.Errno = 8361
	ERROR_DS_NOT_ON_BACKLINK                                                  syscall.Errno = 8362
	ERROR_DS_NO_CROSSREF_FOR_NC                                               syscall.Errno = 8363
	ERROR_DS_SHUTTING_DOWN                                                    syscall.Errno = 8364
	ERROR_DS_UNKNOWN_OPERATION                                                syscall.Errno = 8365
	ERROR_DS_INVALID_ROLE_OWNER                                               syscall.Errno = 8366
	ERROR_DS_COULDNT_CONTACT_FSMO                                             syscall.Errno = 8367
	ERROR_DS_CROSS_NC_DN_RENAME                                               syscall.Errno = 8368
	ERROR_DS_CANT_MOD_SYSTEM_ONLY                                             syscall.Errno = 8369
	ERROR_DS_REPLICATOR_ONLY                                                  syscall.Errno = 8370
	ERROR_DS_OBJ_CLASS_NOT_DEFINED                                            syscall.Errno = 8371
	ERROR_DS_OBJ_CLASS_NOT_SUBCLASS                                           syscall.Errno = 8372
	ERROR_DS_NAME_REFERENCE_INVALID                                           syscall.Errno = 8373
	ERROR_DS_CROSS_REF_EXISTS                                                 syscall.Errno = 8374
	ERROR_DS_CANT_DEL_MASTER_CROSSREF                                         syscall.Errno = 8375
	ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD                                       syscall.Errno = 8376
	ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX                                        syscall.Errno = 8377
	ERROR_DS_DUP_RDN                                                          syscall.Errno = 8378
	ERROR_DS_DUP_OID                                                          syscall.Errno = 8379
	ERROR_DS_DUP_MAPI_ID                                                      syscall.Errno = 8380
	ERROR_DS_DUP_SCHEMA_ID_GUID                                               syscall.Errno = 8381
	ERROR_DS_DUP_LDAP_DISPLAY_NAME                                            syscall.Errno = 8382
	ERROR_DS_SEMANTIC_ATT_TEST                                                syscall.Errno = 8383
	ERROR_DS_SYNTAX_MISMATCH                                                  syscall.Errno = 8384
	ERROR_DS_EXISTS_IN_MUST_HAVE                                              syscall.Errno = 8385
	ERROR_DS_EXISTS_IN_MAY_HAVE                                               syscall.Errno = 8386
	ERROR_DS_NONEXISTENT_MAY_HAVE                                             syscall.Errno = 8387
	ERROR_DS_NONEXISTENT_MUST_HAVE                                            syscall.Errno = 8388
	ERROR_DS_AUX_CLS_TEST_FAIL                                                syscall.Errno = 8389
	ERROR_DS_NONEXISTENT_POSS_SUP                                             syscall.Errno = 8390
	ERROR_DS_SUB_CLS_TEST_FAIL                                                syscall.Errno = 8391
	ERROR_DS_BAD_RDN_ATT_ID_SYNTAX                                            syscall.Errno = 8392
	ERROR_DS_EXISTS_IN_AUX_CLS                                                syscall.Errno = 8393
	ERROR_DS_EXISTS_IN_SUB_CLS                                                syscall.Errno = 8394
	ERROR_DS_EXISTS_IN_POSS_SUP                                               syscall.Errno = 8395
	ERROR_DS_RECALCSCHEMA_FAILED                                              syscall.Errno = 8396
	ERROR_DS_TREE_DELETE_NOT_FINISHED                                         syscall.Errno = 8397
	ERROR_DS_CANT_DELETE                                                      syscall.Errno = 8398
	ERROR_DS_ATT_SCHEMA_REQ_ID                                                syscall.Errno = 8399
	ERROR_DS_BAD_ATT_SCHEMA_SYNTAX                                            syscall.Errno = 8400
	ERROR_DS_CANT_CACHE_ATT                                                   syscall.Errno = 8401
	ERROR_DS_CANT_CACHE_CLASS                                                 syscall.Errno = 8402
	ERROR_DS_CANT_REMOVE_ATT_CACHE                                            syscall.Errno = 8403
	ERROR_DS_CANT_REMOVE_CLASS_CACHE                                          syscall.Errno = 8404
	ERROR_DS_CANT_RETRIEVE_DN                                                 syscall.Errno = 8405
	ERROR_DS_MISSING_SUPREF                                                   syscall.Errno = 8406
	ERROR_DS_CANT_RETRIEVE_INSTANCE                                           syscall.Errno = 8407
	ERROR_DS_CODE_INCONSISTENCY                                               syscall.Errno = 8408
	ERROR_DS_DATABASE_ERROR                                                   syscall.Errno = 8409
	ERROR_DS_GOVERNSID_MISSING                                                syscall.Errno = 8410
	ERROR_DS_MISSING_EXPECTED_ATT                                             syscall.Errno = 8411
	ERROR_DS_NCNAME_MISSING_CR_REF                                            syscall.Errno = 8412
	ERROR_DS_SECURITY_CHECKING_ERROR                                          syscall.Errno = 8413
	ERROR_DS_SCHEMA_NOT_LOADED                                                syscall.Errno = 8414
	ERROR_DS_SCHEMA_ALLOC_FAILED                                              syscall.Errno = 8415
	ERROR_DS_ATT_SCHEMA_REQ_SYNTAX                                            syscall.Errno = 8416
	ERROR_DS_GCVERIFY_ERROR                                                   syscall.Errno = 8417
	ERROR_DS_DRA_SCHEMA_MISMATCH                                              syscall.Errno = 8418
	ERROR_DS_CANT_FIND_DSA_OBJ                                                syscall.Errno = 8419
	ERROR_DS_CANT_FIND_EXPECTED_NC                                            syscall.Errno = 8420
	ERROR_DS_CANT_FIND_NC_IN_CACHE                                            syscall.Errno = 8421
	ERROR_DS_CANT_RETRIEVE_CHILD                                              syscall.Errno = 8422
	ERROR_DS_SECURITY_ILLEGAL_MODIFY                                          syscall.Errno = 8423
	ERROR_DS_CANT_REPLACE_HIDDEN_REC                                          syscall.Errno = 8424
	ERROR_DS_BAD_HIERARCHY_FILE                                               syscall.Errno = 8425
	ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED                                     syscall.Errno = 8426
	ERROR_DS_CONFIG_PARAM_MISSING                                             syscall.Errno = 8427
	ERROR_DS_COUNTING_AB_INDICES_FAILED                                       syscall.Errno = 8428
	ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED                                    syscall.Errno = 8429
	ERROR_DS_INTERNAL_FAILURE                                                 syscall.Errno = 8430
	ERROR_DS_UNKNOWN_ERROR                                                    syscall.Errno = 8431
	ERROR_DS_ROOT_REQUIRES_CLASS_TOP                                          syscall.Errno = 8432
	ERROR_DS_REFUSING_FSMO_ROLES                                              syscall.Errno = 8433
	ERROR_DS_MISSING_FSMO_SETTINGS                                            syscall.Errno = 8434
	ERROR_DS_UNABLE_TO_SURRENDER_ROLES                                        syscall.Errno = 8435
	ERROR_DS_DRA_GENERIC                                                      syscall.Errno = 8436
	ERROR_DS_DRA_INVALID_PARAMETER                                            syscall.Errno = 8437
	ERROR_DS_DRA_BUSY                                                         syscall.Errno = 8438
	ERROR_DS_DRA_BAD_DN                                                       syscall.Errno = 8439
	ERROR_DS_DRA_BAD_NC                                                       syscall.Errno = 8440
	ERROR_DS_DRA_DN_EXISTS                                                    syscall.Errno = 8441
	ERROR_DS_DRA_INTERNAL_ERROR                                               syscall.Errno = 8442
	ERROR_DS_DRA_INCONSISTENT_DIT                                             syscall.Errno = 8443
	ERROR_DS_DRA_CONNECTION_FAILED                                            syscall.Errno = 8444
	ERROR_DS_DRA_BAD_INSTANCE_TYPE                                            syscall.Errno = 8445
	ERROR_DS_DRA_OUT_OF_MEM                                                   syscall.Errno = 8446
	ERROR_DS_DRA_MAIL_PROBLEM                                                 syscall.Errno = 8447
	ERROR_DS_DRA_REF_ALREADY_EXISTS                                           syscall.Errno = 8448
	ERROR_DS_DRA_REF_NOT_FOUND                                                syscall.Errno = 8449
	ERROR_DS_DRA_OBJ_IS_REP_SOURCE                                            syscall.Errno = 8450
	ERROR_DS_DRA_DB_ERROR                                                     syscall.Errno = 8451
	ERROR_DS_DRA_NO_REPLICA                                                   syscall.Errno = 8452
	ERROR_DS_DRA_ACCESS_DENIED                                                syscall.Errno = 8453
	ERROR_DS_DRA_NOT_SUPPORTED                                                syscall.Errno = 8454
	ERROR_DS_DRA_RPC_CANCELLED                                                syscall.Errno = 8455
	ERROR_DS_DRA_SOURCE_DISABLED                                              syscall.Errno = 8456
	ERROR_DS_DRA_SINK_DISABLED                                                syscall.Errno = 8457
	ERROR_DS_DRA_NAME_COLLISION                                               syscall.Errno = 8458
	ERROR_DS_DRA_SOURCE_REINSTALLED                                           syscall.Errno = 8459
	ERROR_DS_DRA_MISSING_PARENT                                               syscall.Errno = 8460
	ERROR_DS_DRA_PREEMPTED                                                    syscall.Errno = 8461
	ERROR_DS_DRA_ABANDON_SYNC                                                 syscall.Errno = 8462
	ERROR_DS_DRA_SHUTDOWN                                                     syscall.Errno = 8463
	ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET                                     syscall.Errno = 8464
	ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA                                    syscall.Errno = 8465
	ERROR_DS_DRA_EXTN_CONNECTION_FAILED                                       syscall.Errno = 8466
	ERROR_DS_INSTALL_SCHEMA_MISMATCH                                          syscall.Errno = 8467
	ERROR_DS_DUP_LINK_ID                                                      syscall.Errno = 8468
	ERROR_DS_NAME_ERROR_RESOLVING                                             syscall.Errno = 8469
	ERROR_DS_NAME_ERROR_NOT_FOUND                                             syscall.Errno = 8470
	ERROR_DS_NAME_ERROR_NOT_UNIQUE                                            syscall.Errno = 8471
	ERROR_DS_NAME_ERROR_NO_MAPPING                                            syscall.Errno = 8472
	ERROR_DS_NAME_ERROR_DOMAIN_ONLY                                           syscall.Errno = 8473
	ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING                                syscall.Errno = 8474
	ERROR_DS_CONSTRUCTED_ATT_MOD                                              syscall.Errno = 8475
	ERROR_DS_WRONG_OM_OBJ_CLASS                                               syscall.Errno = 8476
	ERROR_DS_DRA_REPL_PENDING                                                 syscall.Errno = 8477
	ERROR_DS_DS_REQUIRED                                                      syscall.Errno = 8478
	ERROR_DS_INVALID_LDAP_DISPLAY_NAME                                        syscall.Errno = 8479
	ERROR_DS_NON_BASE_SEARCH                                                  syscall.Errno = 8480
	ERROR_DS_CANT_RETRIEVE_ATTS                                               syscall.Errno = 8481
	ERROR_DS_BACKLINK_WITHOUT_LINK                                            syscall.Errno = 8482
	ERROR_DS_EPOCH_MISMATCH                                                   syscall.Errno = 8483
	ERROR_DS_SRC_NAME_MISMATCH                                                syscall.Errno = 8484
	ERROR_DS_SRC_AND_DST_NC_IDENTICAL                                         syscall.Errno = 8485
	ERROR_DS_DST_NC_MISMATCH                                                  syscall.Errno = 8486
	ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC                                       syscall.Errno = 8487
	ERROR_DS_SRC_GUID_MISMATCH                                                syscall.Errno = 8488
	ERROR_DS_CANT_MOVE_DELETED_OBJECT                                         syscall.Errno = 8489
	ERROR_DS_PDC_OPERATION_IN_PROGRESS                                        syscall.Errno = 8490
	ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD                                        syscall.Errno = 8491
	ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION                                      syscall.Errno = 8492
	ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS                                  syscall.Errno = 8493
	ERROR_DS_NC_MUST_HAVE_NC_PARENT                                           syscall.Errno = 8494
	ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE                                        syscall.Errno = 8495
	ERROR_DS_DST_DOMAIN_NOT_NATIVE                                            syscall.Errno = 8496
	ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER                                 syscall.Errno = 8497
	ERROR_DS_CANT_MOVE_ACCOUNT_GROUP                                          syscall.Errno = 8498
	ERROR_DS_CANT_MOVE_RESOURCE_GROUP                                         syscall.Errno = 8499
	ERROR_DS_INVALID_SEARCH_FLAG                                              syscall.Errno = 8500
	ERROR_DS_NO_TREE_DELETE_ABOVE_NC                                          syscall.Errno = 8501
	ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE                                     syscall.Errno = 8502
	ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE                         syscall.Errno = 8503
	ERROR_DS_SAM_INIT_FAILURE                                                 syscall.Errno = 8504
	ERROR_DS_SENSITIVE_GROUP_VIOLATION                                        syscall.Errno = 8505
	ERROR_DS_CANT_MOD_PRIMARYGROUPID                                          syscall.Errno = 8506
	ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD                                          syscall.Errno = 8507
	ERROR_DS_NONSAFE_SCHEMA_CHANGE                                            syscall.Errno = 8508
	ERROR_DS_SCHEMA_UPDATE_DISALLOWED                                         syscall.Errno = 8509
	ERROR_DS_CANT_CREATE_UNDER_SCHEMA                                         syscall.Errno = 8510
	ERROR_DS_INSTALL_NO_SRC_SCH_VERSION                                       syscall.Errno = 8511
	ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE                                syscall.Errno = 8512
	ERROR_DS_INVALID_GROUP_TYPE                                               syscall.Errno = 8513
	ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN                               syscall.Errno = 8514
	ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN                                syscall.Errno = 8515
	ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER                                    syscall.Errno = 8516
	ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER                                syscall.Errno = 8517
	ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER                                 syscall.Errno = 8518
	ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER                              syscall.Errno = 8519
	ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER                         syscall.Errno = 8520
	ERROR_DS_HAVE_PRIMARY_MEMBERS                                             syscall.Errno = 8521
	ERROR_DS_STRING_SD_CONVERSION_FAILED                                      syscall.Errno = 8522
	ERROR_DS_NAMING_MASTER_GC                                                 syscall.Errno = 8523
	ERROR_DS_DNS_LOOKUP_FAILURE                                               syscall.Errno = 8524
	ERROR_DS_COULDNT_UPDATE_SPNS                                              syscall.Errno = 8525
	ERROR_DS_CANT_RETRIEVE_SD                                                 syscall.Errno = 8526
	ERROR_DS_KEY_NOT_UNIQUE                                                   syscall.Errno = 8527
	ERROR_DS_WRONG_LINKED_ATT_SYNTAX                                          syscall.Errno = 8528
	ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD                                        syscall.Errno = 8529
	ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY                                          syscall.Errno = 8530
	ERROR_DS_CANT_START                                                       syscall.Errno = 8531
	ERROR_DS_INIT_FAILURE                                                     syscall.Errno = 8532
	ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION                                     syscall.Errno = 8533
	ERROR_DS_SOURCE_DOMAIN_IN_FOREST                                          syscall.Errno = 8534
	ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST                                 syscall.Errno = 8535
	ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED                                 syscall.Errno = 8536
	ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN                                      syscall.Errno = 8537
	ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER                                        syscall.Errno = 8538
	ERROR_DS_SRC_SID_EXISTS_IN_FOREST                                         syscall.Errno = 8539
	ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH                                syscall.Errno = 8540
	ERROR_SAM_INIT_FAILURE                                                    syscall.Errno = 8541
	ERROR_DS_DRA_SCHEMA_INFO_SHIP                                             syscall.Errno = 8542
	ERROR_DS_DRA_SCHEMA_CONFLICT                                              syscall.Errno = 8543
	ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT                                      syscall.Errno = 8544
	ERROR_DS_DRA_OBJ_NC_MISMATCH                                              syscall.Errno = 8545
	ERROR_DS_NC_STILL_HAS_DSAS                                                syscall.Errno = 8546
	ERROR_DS_GC_REQUIRED                                                      syscall.Errno = 8547
	ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY                                       syscall.Errno = 8548
	ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS                                       syscall.Errno = 8549
	ERROR_DS_CANT_ADD_TO_GC                                                   syscall.Errno = 8550
	ERROR_DS_NO_CHECKPOINT_WITH_PDC                                           syscall.Errno = 8551
	ERROR_DS_SOURCE_AUDITING_NOT_ENABLED                                      syscall.Errno = 8552
	ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC                                      syscall.Errno = 8553
	ERROR_DS_INVALID_NAME_FOR_SPN                                             syscall.Errno = 8554
	ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS                                     syscall.Errno = 8555
	ERROR_DS_UNICODEPWD_NOT_IN_QUOTES                                         syscall.Errno = 8556
	ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED                                   syscall.Errno = 8557
	ERROR_DS_MUST_BE_RUN_ON_DST_DC                                            syscall.Errno = 8558
	ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER                                    syscall.Errno = 8559
	ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ                                    syscall.Errno = 8560
	ERROR_DS_INIT_FAILURE_CONSOLE                                             syscall.Errno = 8561
	ERROR_DS_SAM_INIT_FAILURE_CONSOLE                                         syscall.Errno = 8562
	ERROR_DS_FOREST_VERSION_TOO_HIGH                                          syscall.Errno = 8563
	ERROR_DS_DOMAIN_VERSION_TOO_HIGH                                          syscall.Errno = 8564
	ERROR_DS_FOREST_VERSION_TOO_LOW                                           syscall.Errno = 8565
	ERROR_DS_DOMAIN_VERSION_TOO_LOW                                           syscall.Errno = 8566
	ERROR_DS_INCOMPATIBLE_VERSION                                             syscall.Errno = 8567
	ERROR_DS_LOW_DSA_VERSION                                                  syscall.Errno = 8568
	ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN                               syscall.Errno = 8569
	ERROR_DS_NOT_SUPPORTED_SORT_ORDER                                         syscall.Errno = 8570
	ERROR_DS_NAME_NOT_UNIQUE                                                  syscall.Errno = 8571
	ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4                                   syscall.Errno = 8572
	ERROR_DS_OUT_OF_VERSION_STORE                                             syscall.Errno = 8573
	ERROR_DS_INCOMPATIBLE_CONTROLS_USED                                       syscall.Errno = 8574
	ERROR_DS_NO_REF_DOMAIN                                                    syscall.Errno = 8575
	ERROR_DS_RESERVED_LINK_ID                                                 syscall.Errno = 8576
	ERROR_DS_LINK_ID_NOT_AVAILABLE                                            syscall.Errno = 8577
	ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER                                    syscall.Errno = 8578
	ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE                             syscall.Errno = 8579
	ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC                                      syscall.Errno = 8580
	ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG                                      syscall.Errno = 8581
	ERROR_DS_MODIFYDN_WRONG_GRANDPARENT                                       syscall.Errno = 8582
	ERROR_DS_NAME_ERROR_TRUST_REFERRAL                                        syscall.Errno = 8583
	ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER                                    syscall.Errno = 8584
	ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD                                    syscall.Errno = 8585
	ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2                                     syscall.Errno = 8586
	ERROR_DS_THREAD_LIMIT_EXCEEDED                                            syscall.Errno = 8587
	ERROR_DS_NOT_CLOSEST                                                      syscall.Errno = 8588
	ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF                               syscall.Errno = 8589
	ERROR_DS_SINGLE_USER_MODE_FAILED                                          syscall.Errno = 8590
	ERROR_DS_NTDSCRIPT_SYNTAX_ERROR                                           syscall.Errno = 8591
	ERROR_DS_NTDSCRIPT_PROCESS_ERROR                                          syscall.Errno = 8592
	ERROR_DS_DIFFERENT_REPL_EPOCHS                                            syscall.Errno = 8593
	ERROR_DS_DRS_EXTENSIONS_CHANGED                                           syscall.Errno = 8594
	ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR                    syscall.Errno = 8595
	ERROR_DS_NO_MSDS_INTID                                                    syscall.Errno = 8596
	ERROR_DS_DUP_MSDS_INTID                                                   syscall.Errno = 8597
	ERROR_DS_EXISTS_IN_RDNATTID                                               syscall.Errno = 8598
	ERROR_DS_AUTHORIZATION_FAILED                                             syscall.Errno = 8599
	ERROR_DS_INVALID_SCRIPT                                                   syscall.Errno = 8600
	ERROR_DS_REMOTE_CROSSREF_OP_FAILED                                        syscall.Errno = 8601
	ERROR_DS_CROSS_REF_BUSY                                                   syscall.Errno = 8602
	ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN                               syscall.Errno = 8603
	ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC                                    syscall.Errno = 8604
	ERROR_DS_DUPLICATE_ID_FOUND                                               syscall.Errno = 8605
	ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT                               syscall.Errno = 8606
	ERROR_DS_GROUP_CONVERSION_ERROR                                           syscall.Errno = 8607
	ERROR_DS_CANT_MOVE_APP_BASIC_GROUP                                        syscall.Errno = 8608
	ERROR_DS_CANT_MOVE_APP_QUERY_GROUP                                        syscall.Errno = 8609
	ERROR_DS_ROLE_NOT_VERIFIED                                                syscall.Errno = 8610
	ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL                                  syscall.Errno = 8611
	ERROR_DS_DOMAIN_RENAME_IN_PROGRESS                                        syscall.Errno = 8612
	ERROR_DS_EXISTING_AD_CHILD_NC                                             syscall.Errno = 8613
	ERROR_DS_REPL_LIFETIME_EXCEEDED                                           syscall.Errno = 8614
	ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER                                   syscall.Errno = 8615
	ERROR_DS_LDAP_SEND_QUEUE_FULL                                             syscall.Errno = 8616
	ERROR_DS_DRA_OUT_SCHEDULE_WINDOW                                          syscall.Errno = 8617
	ERROR_DS_POLICY_NOT_KNOWN                                                 syscall.Errno = 8618
	ERROR_NO_SITE_SETTINGS_OBJECT                                             syscall.Errno = 8619
	ERROR_NO_SECRETS                                                          syscall.Errno = 8620
	ERROR_NO_WRITABLE_DC_FOUND                                                syscall.Errno = 8621
	ERROR_DS_NO_SERVER_OBJECT                                                 syscall.Errno = 8622
	ERROR_DS_NO_NTDSA_OBJECT                                                  syscall.Errno = 8623
	ERROR_DS_NON_ASQ_SEARCH                                                   syscall.Errno = 8624
	ERROR_DS_AUDIT_FAILURE                                                    syscall.Errno = 8625
	ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE                                      syscall.Errno = 8626
	ERROR_DS_INVALID_SEARCH_FLAG_TUPLE                                        syscall.Errno = 8627
	ERROR_DS_HIERARCHY_TABLE_TOO_DEEP                                         syscall.Errno = 8628
	ERROR_DS_DRA_CORRUPT_UTD_VECTOR                                           syscall.Errno = 8629
	ERROR_DS_DRA_SECRETS_DENIED                                               syscall.Errno = 8630
	ERROR_DS_RESERVED_MAPI_ID                                                 syscall.Errno = 8631
	ERROR_DS_MAPI_ID_NOT_AVAILABLE                                            syscall.Errno = 8632
	ERROR_DS_DRA_MISSING_KRBTGT_SECRET                                        syscall.Errno = 8633
	ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST                                     syscall.Errno = 8634
	ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST                                       syscall.Errno = 8635
	ERROR_INVALID_USER_PRINCIPAL_NAME                                         syscall.Errno = 8636
	ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS                               syscall.Errno = 8637
	ERROR_DS_OID_NOT_FOUND                                                    syscall.Errno = 8638
	ERROR_DS_DRA_RECYCLED_TARGET                                              syscall.Errno = 8639
	ERROR_DS_DISALLOWED_NC_REDIRECT                                           syscall.Errno = 8640
	ERROR_DS_HIGH_ADLDS_FFL                                                   syscall.Errno = 8641
	ERROR_DS_HIGH_DSA_VERSION                                                 syscall.Errno = 8642
	ERROR_DS_LOW_ADLDS_FFL                                                    syscall.Errno = 8643
	ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION                                syscall.Errno = 8644
	ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED                                   syscall.Errno = 8645
	ERROR_INCORRECT_ACCOUNT_TYPE                                              syscall.Errno = 8646
	ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST                                   syscall.Errno = 8647
	ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST                                   syscall.Errno = 8648
	ERROR_DS_MISSING_FOREST_TRUST                                             syscall.Errno = 8649
	ERROR_DS_VALUE_KEY_NOT_UNIQUE                                             syscall.Errno = 8650
	DNS_ERROR_RESPONSE_CODES_BASE                                             syscall.Errno = 9000
	DNS_ERROR_RCODE_NO_ERROR                                                                = ERROR_SUCCESS
	DNS_ERROR_MASK                                                            syscall.Errno = 0x00002328
	DNS_ERROR_RCODE_FORMAT_ERROR                                              syscall.Errno = 9001
	DNS_ERROR_RCODE_SERVER_FAILURE                                            syscall.Errno = 9002
	DNS_ERROR_RCODE_NAME_ERROR                                                syscall.Errno = 9003
	DNS_ERROR_RCODE_NOT_IMPLEMENTED                                           syscall.Errno = 9004
	DNS_ERROR_RCODE_REFUSED                                                   syscall.Errno = 9005
	DNS_ERROR_RCODE_YXDOMAIN                                                  syscall.Errno = 9006
	DNS_ERROR_RCODE_YXRRSET                                                   syscall.Errno = 9007
	DNS_ERROR_RCODE_NXRRSET                                                   syscall.Errno = 9008
	DNS_ERROR_RCODE_NOTAUTH                                                   syscall.Errno = 9009
	DNS_ERROR_RCODE_NOTZONE                                                   syscall.Errno = 9010
	DNS_ERROR_RCODE_BADSIG                                                    syscall.Errno = 9016
	DNS_ERROR_RCODE_BADKEY                                                    syscall.Errno = 9017
	DNS_ERROR_RCODE_BADTIME                                                   syscall.Errno = 9018
	DNS_ERROR_RCODE_LAST                                                                    = DNS_ERROR_RCODE_BADTIME
	DNS_ERROR_DNSSEC_BASE                                                     syscall.Errno = 9100
	DNS_ERROR_KEYMASTER_REQUIRED                                              syscall.Errno = 9101
	DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE                                      syscall.Errno = 9102
	DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1                                syscall.Errno = 9103
	DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS                              syscall.Errno = 9104
	DNS_ERROR_UNSUPPORTED_ALGORITHM                                           syscall.Errno = 9105
	DNS_ERROR_INVALID_KEY_SIZE                                                syscall.Errno = 9106
	DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE                                      syscall.Errno = 9107
	DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION                                 syscall.Errno = 9108
	DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR                                syscall.Errno = 9109
	DNS_ERROR_UNEXPECTED_CNG_ERROR                                            syscall.Errno = 9110
	DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION                               syscall.Errno = 9111
	DNS_ERROR_KSP_NOT_ACCESSIBLE                                              syscall.Errno = 9112
	DNS_ERROR_TOO_MANY_SKDS                                                   syscall.Errno = 9113
	DNS_ERROR_INVALID_ROLLOVER_PERIOD                                         syscall.Errno = 9114
	DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET                                 syscall.Errno = 9115
	DNS_ERROR_ROLLOVER_IN_PROGRESS                                            syscall.Errno = 9116
	DNS_ERROR_STANDBY_KEY_NOT_PRESENT                                         syscall.Errno = 9117
	DNS_ERROR_NOT_ALLOWED_ON_ZSK                                              syscall.Errno = 9118
	DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD                                       syscall.Errno = 9119
	DNS_ERROR_ROLLOVER_ALREADY_QUEUED                                         syscall.Errno = 9120
	DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE                                    syscall.Errno = 9121
	DNS_ERROR_BAD_KEYMASTER                                                   syscall.Errno = 9122
	DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD                               syscall.Errno = 9123
	DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT                                   syscall.Errno = 9124
	DNS_ERROR_DNSSEC_IS_DISABLED                                              syscall.Errno = 9125
	DNS_ERROR_INVALID_XML                                                     syscall.Errno = 9126
	DNS_ERROR_NO_VALID_TRUST_ANCHORS                                          syscall.Errno = 9127
	DNS_ERROR_ROLLOVER_NOT_POKEABLE                                           syscall.Errno = 9128
	DNS_ERROR_NSEC3_NAME_COLLISION                                            syscall.Errno = 9129
	DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1                           syscall.Errno = 9130
	DNS_ERROR_PACKET_FMT_BASE                                                 syscall.Errno = 9500
	DNS_INFO_NO_RECORDS                                                       syscall.Errno = 9501
	DNS_ERROR_BAD_PACKET                                                      syscall.Errno = 9502
	DNS_ERROR_NO_PACKET                                                       syscall.Errno = 9503
	DNS_ERROR_RCODE                                                           syscall.Errno = 9504
	DNS_ERROR_UNSECURE_PACKET                                                 syscall.Errno = 9505
	DNS_STATUS_PACKET_UNSECURE                                                              = DNS_ERROR_UNSECURE_PACKET
	DNS_REQUEST_PENDING                                                       syscall.Errno = 9506
	DNS_ERROR_NO_MEMORY                                                                     = ERROR_OUTOFMEMORY
	DNS_ERROR_INVALID_NAME                                                                  = ERROR_INVALID_NAME
	DNS_ERROR_INVALID_DATA                                                                  = ERROR_INVALID_DATA
	DNS_ERROR_GENERAL_API_BASE                                                syscall.Errno = 9550
	DNS_ERROR_INVALID_TYPE                                                    syscall.Errno = 9551
	DNS_ERROR_INVALID_IP_ADDRESS                                              syscall.Errno = 9552
	DNS_ERROR_INVALID_PROPERTY                                                syscall.Errno = 9553
	DNS_ERROR_TRY_AGAIN_LATER                                                 syscall.Errno = 9554
	DNS_ERROR_NOT_UNIQUE                                                      syscall.Errno = 9555
	DNS_ERROR_NON_RFC_NAME                                                    syscall.Errno = 9556
	DNS_STATUS_FQDN                                                           syscall.Errno = 9557
	DNS_STATUS_DOTTED_NAME                                                    syscall.Errno = 9558
	DNS_STATUS_SINGLE_PART_NAME                                               syscall.Errno = 9559
	DNS_ERROR_INVALID_NAME_CHAR                                               syscall.Errno = 9560
	DNS_ERROR_NUMERIC_NAME                                                    syscall.Errno = 9561
	DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER                                      syscall.Errno = 9562
	DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION                                    syscall.Errno = 9563
	DNS_ERROR_CANNOT_FIND_ROOT_HINTS                                          syscall.Errno = 9564
	DNS_ERROR_INCONSISTENT_ROOT_HINTS                                         syscall.Errno = 9565
	DNS_ERROR_DWORD_VALUE_TOO_SMALL                                           syscall.Errno = 9566
	DNS_ERROR_DWORD_VALUE_TOO_LARGE                                           syscall.Errno = 9567
	DNS_ERROR_BACKGROUND_LOADING                                              syscall.Errno = 9568
	DNS_ERROR_NOT_ALLOWED_ON_RODC                                             syscall.Errno = 9569
	DNS_ERROR_NOT_ALLOWED_UNDER_DNAME                                         syscall.Errno = 9570
	DNS_ERROR_DELEGATION_REQUIRED                                             syscall.Errno = 9571
	DNS_ERROR_INVALID_POLICY_TABLE                                            syscall.Errno = 9572
	DNS_ERROR_ADDRESS_REQUIRED                                                syscall.Errno = 9573
	DNS_ERROR_ZONE_BASE                                                       syscall.Errno = 9600
	DNS_ERROR_ZONE_DOES_NOT_EXIST                                             syscall.Errno = 9601
	DNS_ERROR_NO_ZONE_INFO                                                    syscall.Errno = 9602
	DNS_ERROR_INVALID_ZONE_OPERATION                                          syscall.Errno = 9603
	DNS_ERROR_ZONE_CONFIGURATION_ERROR                                        syscall.Errno = 9604
	DNS_ERROR_ZONE_HAS_NO_SOA_RECORD                                          syscall.Errno = 9605
	DNS_ERROR_ZONE_HAS_NO_NS_RECORDS                                          syscall.Errno = 9606
	DNS_ERROR_ZONE_LOCKED                                                     syscall.Errno = 9607
	DNS_ERROR_ZONE_CREATION_FAILED                                            syscall.Errno = 9608
	DNS_ERROR_ZONE_ALREADY_EXISTS                                             syscall.Errno = 9609
	DNS_ERROR_AUTOZONE_ALREADY_EXISTS                                         syscall.Errno = 9610
	DNS_ERROR_INVALID_ZONE_TYPE                                               syscall.Errno = 9611
	DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP                                    syscall.Errno = 9612
	DNS_ERROR_ZONE_NOT_SECONDARY                                              syscall.Errno = 9613
	DNS_ERROR_NEED_SECONDARY_ADDRESSES                                        syscall.Errno = 9614
	DNS_ERROR_WINS_INIT_FAILED                                                syscall.Errno = 9615
	DNS_ERROR_NEED_WINS_SERVERS                                               syscall.Errno = 9616
	DNS_ERROR_NBSTAT_INIT_FAILED                                              syscall.Errno = 9617
	DNS_ERROR_SOA_DELETE_INVALID                                              syscall.Errno = 9618
	DNS_ERROR_FORWARDER_ALREADY_EXISTS                                        syscall.Errno = 9619
	DNS_ERROR_ZONE_REQUIRES_MASTER_IP                                         syscall.Errno = 9620
	DNS_ERROR_ZONE_IS_SHUTDOWN                                                syscall.Errno = 9621
	DNS_ERROR_ZONE_LOCKED_FOR_SIGNING                                         syscall.Errno = 9622
	DNS_ERROR_DATAFILE_BASE                                                   syscall.Errno = 9650
	DNS_ERROR_PRIMARY_REQUIRES_DATAFILE                                       syscall.Errno = 9651
	DNS_ERROR_INVALID_DATAFILE_NAME                                           syscall.Errno = 9652
	DNS_ERROR_DATAFILE_OPEN_FAILURE                                           syscall.Errno = 9653
	DNS_ERROR_FILE_WRITEBACK_FAILED                                           syscall.Errno = 9654
	DNS_ERROR_DATAFILE_PARSING                                                syscall.Errno = 9655
	DNS_ERROR_DATABASE_BASE                                                   syscall.Errno = 9700
	DNS_ERROR_RECORD_DOES_NOT_EXIST                                           syscall.Errno = 9701
	DNS_ERROR_RECORD_FORMAT                                                   syscall.Errno = 9702
	DNS_ERROR_NODE_CREATION_FAILED                                            syscall.Errno = 9703
	DNS_ERROR_UNKNOWN_RECORD_TYPE                                             syscall.Errno = 9704
	DNS_ERROR_RECORD_TIMED_OUT                                                syscall.Errno = 9705
	DNS_ERROR_NAME_NOT_IN_ZONE                                                syscall.Errno = 9706
	DNS_ERROR_CNAME_LOOP                                                      syscall.Errno = 9707
	DNS_ERROR_NODE_IS_CNAME                                                   syscall.Errno = 9708
	DNS_ERROR_CNAME_COLLISION                                                 syscall.Errno = 9709
	DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT                                        syscall.Errno = 9710
	DNS_ERROR_RECORD_ALREADY_EXISTS                                           syscall.Errno = 9711
	DNS_ERROR_SECONDARY_DATA                                                  syscall.Errno = 9712
	DNS_ERROR_NO_CREATE_CACHE_DATA                                            syscall.Errno = 9713
	DNS_ERROR_NAME_DOES_NOT_EXIST                                             syscall.Errno = 9714
	DNS_WARNING_PTR_CREATE_FAILED                                             syscall.Errno = 9715
	DNS_WARNING_DOMAIN_UNDELETED                                              syscall.Errno = 9716
	DNS_ERROR_DS_UNAVAILABLE                                                  syscall.Errno = 9717
	DNS_ERROR_DS_ZONE_ALREADY_EXISTS                                          syscall.Errno = 9718
	DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE                                          syscall.Errno = 9719
	DNS_ERROR_NODE_IS_DNAME                                                   syscall.Errno = 9720
	DNS_ERROR_DNAME_COLLISION                                                 syscall.Errno = 9721
	DNS_ERROR_ALIAS_LOOP                                                      syscall.Errno = 9722
	DNS_ERROR_OPERATION_BASE                                                  syscall.Errno = 9750
	DNS_INFO_AXFR_COMPLETE                                                    syscall.Errno = 9751
	DNS_ERROR_AXFR                                                            syscall.Errno = 9752
	DNS_INFO_ADDED_LOCAL_WINS                                                 syscall.Errno = 9753
	DNS_ERROR_SECURE_BASE                                                     syscall.Errno = 9800
	DNS_STATUS_CONTINUE_NEEDED                                                syscall.Errno = 9801
	DNS_ERROR_SETUP_BASE                                                      syscall.Errno = 9850
	DNS_ERROR_NO_TCPIP                                                        syscall.Errno = 9851
	DNS_ERROR_NO_DNS_SERVERS                                                  syscall.Errno = 9852
	DNS_ERROR_DP_BASE                                                         syscall.Errno = 9900
	DNS_ERROR_DP_DOES_NOT_EXIST                                               syscall.Errno = 9901
	DNS_ERROR_DP_ALREADY_EXISTS                                               syscall.Errno = 9902
	DNS_ERROR_DP_NOT_ENLISTED                                                 syscall.Errno = 9903
	DNS_ERROR_DP_ALREADY_ENLISTED                                             syscall.Errno = 9904
	DNS_ERROR_DP_NOT_AVAILABLE                                                syscall.Errno = 9905
	DNS_ERROR_DP_FSMO_ERROR                                                   syscall.Errno = 9906
	DNS_ERROR_RRL_NOT_ENABLED                                                 syscall.Errno = 9911
	DNS_ERROR_RRL_INVALID_WINDOW_SIZE                                         syscall.Errno = 9912
	DNS_ERROR_RRL_INVALID_IPV4_PREFIX                                         syscall.Errno = 9913
	DNS_ERROR_RRL_INVALID_IPV6_PREFIX                                         syscall.Errno = 9914
	DNS_ERROR_RRL_INVALID_TC_RATE                                             syscall.Errno = 9915
	DNS_ERROR_RRL_INVALID_LEAK_RATE                                           syscall.Errno = 9916
	DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE                                  syscall.Errno = 9917
	DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS                          syscall.Errno = 9921
	DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST                          syscall.Errno = 9922
	DNS_ERROR_VIRTUALIZATION_TREE_LOCKED                                      syscall.Errno = 9923
	DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME                            syscall.Errno = 9924
	DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE                                 syscall.Errno = 9925
	DNS_ERROR_ZONESCOPE_ALREADY_EXISTS                                        syscall.Errno = 9951
	DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST                                        syscall.Errno = 9952
	DNS_ERROR_DEFAULT_ZONESCOPE                                               syscall.Errno = 9953
	DNS_ERROR_INVALID_ZONESCOPE_NAME                                          syscall.Errno = 9954
	DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES                                     syscall.Errno = 9955
	DNS_ERROR_LOAD_ZONESCOPE_FAILED                                           syscall.Errno = 9956
	DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED                                 syscall.Errno = 9957
	DNS_ERROR_INVALID_SCOPE_NAME                                              syscall.Errno = 9958
	DNS_ERROR_SCOPE_DOES_NOT_EXIST                                            syscall.Errno = 9959
	DNS_ERROR_DEFAULT_SCOPE                                                   syscall.Errno = 9960
	DNS_ERROR_INVALID_SCOPE_OPERATION                                         syscall.Errno = 9961
	DNS_ERROR_SCOPE_LOCKED                                                    syscall.Errno = 9962
	DNS_ERROR_SCOPE_ALREADY_EXISTS                                            syscall.Errno = 9963
	DNS_ERROR_POLICY_ALREADY_EXISTS                                           syscall.Errno = 9971
	DNS_ERROR_POLICY_DOES_NOT_EXIST                                           syscall.Errno = 9972
	DNS_ERROR_POLICY_INVALID_CRITERIA                                         syscall.Errno = 9973
	DNS_ERROR_POLICY_INVALID_SETTINGS                                         syscall.Errno = 9974
	DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED                                       syscall.Errno = 9975
	DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST                                    syscall.Errno = 9976
	DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS                                    syscall.Errno = 9977
	DNS_ERROR_SUBNET_DOES_NOT_EXIST                                           syscall.Errno = 9978
	DNS_ERROR_SUBNET_ALREADY_EXISTS                                           syscall.Errno = 9979
	DNS_ERROR_POLICY_LOCKED                                                   syscall.Errno = 9980
	DNS_ERROR_POLICY_INVALID_WEIGHT                                           syscall.Errno = 9981
	DNS_ERROR_POLICY_INVALID_NAME                                             syscall.Errno = 9982
	DNS_ERROR_POLICY_MISSING_CRITERIA                                         syscall.Errno = 9983
	DNS_ERROR_INVALID_CLIENT_SUBNET_NAME                                      syscall.Errno = 9984
	DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID                                 syscall.Errno = 9985
	DNS_ERROR_POLICY_SCOPE_MISSING                                            syscall.Errno = 9986
	DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED                                        syscall.Errno = 9987
	DNS_ERROR_SERVERSCOPE_IS_REFERENCED                                       syscall.Errno = 9988
	DNS_ERROR_ZONESCOPE_IS_REFERENCED                                         syscall.Errno = 9989
	DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET                           syscall.Errno = 9990
	DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL                      syscall.Errno = 9991
	DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL                        syscall.Errno = 9992
	DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE                               syscall.Errno = 9993
	DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN                                    syscall.Errno = 9994
	DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE                              syscall.Errno = 9995
	DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY                             syscall.Errno = 9996
	WSABASEERR                                                                syscall.Errno = 10000
	WSAEINTR                                                                  syscall.Errno = 10004
	WSAEBADF                                                                  syscall.Errno = 10009
	WSAEACCES                                                                 syscall.Errno = 10013
	WSAEFAULT                                                                 syscall.Errno = 10014
	WSAEINVAL                                                                 syscall.Errno = 10022
	WSAEMFILE                                                                 syscall.Errno = 10024
	WSAEWOULDBLOCK                                                            syscall.Errno = 10035
	WSAEINPROGRESS                                                            syscall.Errno = 10036
	WSAEALREADY                                                               syscall.Errno = 10037
	WSAENOTSOCK                                                               syscall.Errno = 10038
	WSAEDESTADDRREQ                                                           syscall.Errno = 10039
	WSAEMSGSIZE                                                               syscall.Errno = 10040
	WSAEPROTOTYPE                                                             syscall.Errno = 10041
	WSAENOPROTOOPT                                                            syscall.Errno = 10042
	WSAEPROTONOSUPPORT                                                        syscall.Errno = 10043
	WSAESOCKTNOSUPPORT                                                        syscall.Errno = 10044
	WSAEOPNOTSUPP                                                             syscall.Errno = 10045
	WSAEPFNOSUPPORT                                                           syscall.Errno = 10046
	WSAEAFNOSUPPORT                                                           syscall.Errno = 10047
	WSAEADDRINUSE                                                             syscall.Errno = 10048
	WSAEADDRNOTAVAIL                                                          syscall.Errno = 10049
	WSAENETDOWN                                                               syscall.Errno = 10050
	WSAENETUNREACH                                                            syscall.Errno = 10051
	WSAENETRESET                                                              syscall.Errno = 10052
	WSAECONNABORTED                                                           syscall.Errno = 10053
	WSAECONNRESET                                                             syscall.Errno = 10054
	WSAENOBUFS                                                                syscall.Errno = 10055
	WSAEISCONN                                                                syscall.Errno = 10056
	WSAENOTCONN                                                               syscall.Errno = 10057
	WSAESHUTDOWN                                                              syscall.Errno = 10058
	WSAETOOMANYREFS                                                           syscall.Errno = 10059
	WSAETIMEDOUT                                                              syscall.Errno = 10060
	WSAECONNREFUSED                                                           syscall.Errno = 10061
	WSAELOOP                                                                  syscall.Errno = 10062
	WSAENAMETOOLONG                                                           syscall.Errno = 10063
	WSAEHOSTDOWN                                                              syscall.Errno = 10064
	WSAEHOSTUNREACH                                                           syscall.Errno = 10065
	WSAENOTEMPTY                                                              syscall.Errno = 10066
	WSAEPROCLIM                                                               syscall.Errno = 10067
	WSAEUSERS                                                                 syscall.Errno = 10068
	WSAEDQUOT                                                                 syscall.Errno = 10069
	WSAESTALE                                                                 syscall.Errno = 10070
	WSAEREMOTE                                                                syscall.Errno = 10071
	WSASYSNOTREADY                                                            syscall.Errno = 10091
	WSAVERNOTSUPPORTED                                                        syscall.Errno = 10092
	WSANOTINITIALISED                                                         syscall.Errno = 10093
	WSAEDISCON                                                                syscall.Errno = 10101
	WSAENOMORE                                                                syscall.Errno = 10102
	WSAECANCELLED                                                             syscall.Errno = 10103
	WSAEINVALIDPROCTABLE                                                      syscall.Errno = 10104
	WSAEINVALIDPROVIDER                                                       syscall.Errno = 10105
	WSAEPROVIDERFAILEDINIT                                                    syscall.Errno = 10106
	WSASYSCALLFAILURE                                                         syscall.Errno = 10107
	WSASERVICE_NOT_FOUND                                                      syscall.Errno = 10108
	WSATYPE_NOT_FOUND                                                         syscall.Errno = 10109
	WSA_E_NO_MORE                                                             syscall.Errno = 10110
	WSA_E_CANCELLED                                                           syscall.Errno = 10111
	WSAEREFUSED                                                               syscall.Errno = 10112
	WSAHOST_NOT_FOUND                                                         syscall.Errno = 11001
	WSATRY_AGAIN                                                              syscall.Errno = 11002
	WSANO_RECOVERY                                                            syscall.Errno = 11003
	WSANO_DATA                                                                syscall.Errno = 11004
	WSA_QOS_RECEIVERS                                                         syscall.Errno = 11005
	WSA_QOS_SENDERS                                                           syscall.Errno = 11006
	WSA_QOS_NO_SENDERS                                                        syscall.Errno = 11007
	WSA_QOS_NO_RECEIVERS                                                      syscall.Errno = 11008
	WSA_QOS_REQUEST_CONFIRMED                                                 syscall.Errno = 11009
	WSA_QOS_ADMISSION_FAILURE                                                 syscall.Errno = 11010
	WSA_QOS_POLICY_FAILURE                                                    syscall.Errno = 11011
	WSA_QOS_BAD_STYLE                                                         syscall.Errno = 11012
	WSA_QOS_BAD_OBJECT                                                        syscall.Errno = 11013
	WSA_QOS_TRAFFIC_CTRL_ERROR                                                syscall.Errno = 11014
	WSA_QOS_GENERIC_ERROR                                                     syscall.Errno = 11015
	WSA_QOS_ESERVICETYPE                                                      syscall.Errno = 11016
	WSA_QOS_EFLOWSPEC                                                         syscall.Errno = 11017
	WSA_QOS_EPROVSPECBUF                                                      syscall.Errno = 11018
	WSA_QOS_EFILTERSTYLE                                                      syscall.Errno = 11019
	WSA_QOS_EFILTERTYPE                                                       syscall.Errno = 11020
	WSA_QOS_EFILTERCOUNT                                                      syscall.Errno = 11021
	WSA_QOS_EOBJLENGTH                                                        syscall.Errno = 11022
	WSA_QOS_EFLOWCOUNT                                                        syscall.Errno = 11023
	WSA_QOS_EUNKOWNPSOBJ                                                      syscall.Errno = 11024
	WSA_QOS_EPOLICYOBJ                                                        syscall.Errno = 11025
	WSA_QOS_EFLOWDESC                                                         syscall.Errno = 11026
	WSA_QOS_EPSFLOWSPEC                                                       syscall.Errno = 11027
	WSA_QOS_EPSFILTERSPEC                                                     syscall.Errno = 11028
	WSA_QOS_ESDMODEOBJ                                                        syscall.Errno = 11029
	WSA_QOS_ESHAPERATEOBJ                                                     syscall.Errno = 11030
	WSA_QOS_RESERVED_PETYPE                                                   syscall.Errno = 11031
	WSA_SECURE_HOST_NOT_FOUND                                                 syscall.Errno = 11032
	WSA_IPSEC_NAME_POLICY_ERROR                                               syscall.Errno = 11033
	ERROR_IPSEC_QM_POLICY_EXISTS                                              syscall.Errno = 13000
	ERROR_IPSEC_QM_POLICY_NOT_FOUND                                           syscall.Errno = 13001
	ERROR_IPSEC_QM_POLICY_IN_USE                                              syscall.Errno = 13002
	ERROR_IPSEC_MM_POLICY_EXISTS                                              syscall.Errno = 13003
	ERROR_IPSEC_MM_POLICY_NOT_FOUND                                           syscall.Errno = 13004
	ERROR_IPSEC_MM_POLICY_IN_USE                                              syscall.Errno = 13005
	ERROR_IPSEC_MM_FILTER_EXISTS                                              syscall.Errno = 13006
	ERROR_IPSEC_MM_FILTER_NOT_FOUND                                           syscall.Errno = 13007
	ERROR_IPSEC_TRANSPORT_FILTER_EXISTS                                       syscall.Errno = 13008
	ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND                                    syscall.Errno = 13009
	ERROR_IPSEC_MM_AUTH_EXISTS                                                syscall.Errno = 13010
	ERROR_IPSEC_MM_AUTH_NOT_FOUND                                             syscall.Errno = 13011
	ERROR_IPSEC_MM_AUTH_IN_USE                                                syscall.Errno = 13012
	ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND                                   syscall.Errno = 13013
	ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND                                     syscall.Errno = 13014
	ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND                                   syscall.Errno = 13015
	ERROR_IPSEC_TUNNEL_FILTER_EXISTS                                          syscall.Errno = 13016
	ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND                                       syscall.Errno = 13017
	ERROR_IPSEC_MM_FILTER_PENDING_DELETION                                    syscall.Errno = 13018
	ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION                             syscall.Errno = 13019
	ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION                                syscall.Errno = 13020
	ERROR_IPSEC_MM_POLICY_PENDING_DELETION                                    syscall.Errno = 13021
	ERROR_IPSEC_MM_AUTH_PENDING_DELETION                                      syscall.Errno = 13022
	ERROR_IPSEC_QM_POLICY_PENDING_DELETION                                    syscall.Errno = 13023
	WARNING_IPSEC_MM_POLICY_PRUNED                                            syscall.Errno = 13024
	WARNING_IPSEC_QM_POLICY_PRUNED                                            syscall.Errno = 13025
	ERROR_IPSEC_IKE_NEG_STATUS_BEGIN                                          syscall.Errno = 13800
	ERROR_IPSEC_IKE_AUTH_FAIL                                                 syscall.Errno = 13801
	ERROR_IPSEC_IKE_ATTRIB_FAIL                                               syscall.Errno = 13802
	ERROR_IPSEC_IKE_NEGOTIATION_PENDING                                       syscall.Errno = 13803
	ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR                                  syscall.Errno = 13804
	ERROR_IPSEC_IKE_TIMED_OUT                                                 syscall.Errno = 13805
	ERROR_IPSEC_IKE_NO_CERT                                                   syscall.Errno = 13806
	ERROR_IPSEC_IKE_SA_DELETED                                                syscall.Errno = 13807
	ERROR_IPSEC_IKE_SA_REAPED                                                 syscall.Errno = 13808
	ERROR_IPSEC_IKE_MM_ACQUIRE_DROP                                           syscall.Errno = 13809
	ERROR_IPSEC_IKE_QM_ACQUIRE_DROP                                           syscall.Errno = 13810
	ERROR_IPSEC_IKE_QUEUE_DROP_MM                                             syscall.Errno = 13811
	ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM                                          syscall.Errno = 13812
	ERROR_IPSEC_IKE_DROP_NO_RESPONSE                                          syscall.Errno = 13813
	ERROR_IPSEC_IKE_MM_DELAY_DROP                                             syscall.Errno = 13814
	ERROR_IPSEC_IKE_QM_DELAY_DROP                                             syscall.Errno = 13815
	ERROR_IPSEC_IKE_ERROR                                                     syscall.Errno = 13816
	ERROR_IPSEC_IKE_CRL_FAILED                                                syscall.Errno = 13817
	ERROR_IPSEC_IKE_INVALID_KEY_USAGE                                         syscall.Errno = 13818
	ERROR_IPSEC_IKE_INVALID_CERT_TYPE                                         syscall.Errno = 13819
	ERROR_IPSEC_IKE_NO_PRIVATE_KEY                                            syscall.Errno = 13820
	ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY                                        syscall.Errno = 13821
	ERROR_IPSEC_IKE_DH_FAIL                                                   syscall.Errno = 13822
	ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED                           syscall.Errno = 13823
	ERROR_IPSEC_IKE_INVALID_HEADER                                            syscall.Errno = 13824
	ERROR_IPSEC_IKE_NO_POLICY                                                 syscall.Errno = 13825
	ERROR_IPSEC_IKE_INVALID_SIGNATURE                                         syscall.Errno = 13826
	ERROR_IPSEC_IKE_KERBEROS_ERROR                                            syscall.Errno = 13827
	ERROR_IPSEC_IKE_NO_PUBLIC_KEY                                             syscall.Errno = 13828
	ERROR_IPSEC_IKE_PROCESS_ERR                                               syscall.Errno = 13829
	ERROR_IPSEC_IKE_PROCESS_ERR_SA                                            syscall.Errno = 13830
	ERROR_IPSEC_IKE_PROCESS_ERR_PROP                                          syscall.Errno = 13831
	ERROR_IPSEC_IKE_PROCESS_ERR_TRANS                                         syscall.Errno = 13832
	ERROR_IPSEC_IKE_PROCESS_ERR_KE                                            syscall.Errno = 13833
	ERROR_IPSEC_IKE_PROCESS_ERR_ID                                            syscall.Errno = 13834
	ERROR_IPSEC_IKE_PROCESS_ERR_CERT                                          syscall.Errno = 13835
	ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ                                      syscall.Errno = 13836
	ERROR_IPSEC_IKE_PROCESS_ERR_HASH                                          syscall.Errno = 13837
	ERROR_IPSEC_IKE_PROCESS_ERR_SIG                                           syscall.Errno = 13838
	ERROR_IPSEC_IKE_PROCESS_ERR_NONCE                                         syscall.Errno = 13839
	ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY                                        syscall.Errno = 13840
	ERROR_IPSEC_IKE_PROCESS_ERR_DELETE                                        syscall.Errno = 13841
	ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR                                        syscall.Errno = 13842
	ERROR_IPSEC_IKE_INVALID_PAYLOAD                                           syscall.Errno = 13843
	ERROR_IPSEC_IKE_LOAD_SOFT_SA                                              syscall.Errno = 13844
	ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN                                         syscall.Errno = 13845
	ERROR_IPSEC_IKE_INVALID_COOKIE                                            syscall.Errno = 13846
	ERROR_IPSEC_IKE_NO_PEER_CERT                                              syscall.Errno = 13847
	ERROR_IPSEC_IKE_PEER_CRL_FAILED                                           syscall.Errno = 13848
	ERROR_IPSEC_IKE_POLICY_CHANGE                                             syscall.Errno = 13849
	ERROR_IPSEC_IKE_NO_MM_POLICY                                              syscall.Errno = 13850
	ERROR_IPSEC_IKE_NOTCBPRIV                                                 syscall.Errno = 13851
	ERROR_IPSEC_IKE_SECLOADFAIL                                               syscall.Errno = 13852
	ERROR_IPSEC_IKE_FAILSSPINIT                                               syscall.Errno = 13853
	ERROR_IPSEC_IKE_FAILQUERYSSP                                              syscall.Errno = 13854
	ERROR_IPSEC_IKE_SRVACQFAIL                                                syscall.Errno = 13855
	ERROR_IPSEC_IKE_SRVQUERYCRED                                              syscall.Errno = 13856
	ERROR_IPSEC_IKE_GETSPIFAIL                                                syscall.Errno = 13857
	ERROR_IPSEC_IKE_INVALID_FILTER                                            syscall.Errno = 13858
	ERROR_IPSEC_IKE_OUT_OF_MEMORY                                             syscall.Errno = 13859
	ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED                                     syscall.Errno = 13860
	ERROR_IPSEC_IKE_INVALID_POLICY                                            syscall.Errno = 13861
	ERROR_IPSEC_IKE_UNKNOWN_DOI                                               syscall.Errno = 13862
	ERROR_IPSEC_IKE_INVALID_SITUATION                                         syscall.Errno = 13863
	ERROR_IPSEC_IKE_DH_FAILURE                                                syscall.Errno = 13864
	ERROR_IPSEC_IKE_INVALID_GROUP                                             syscall.Errno = 13865
	ERROR_IPSEC_IKE_ENCRYPT                                                   syscall.Errno = 13866
	ERROR_IPSEC_IKE_DECRYPT                                                   syscall.Errno = 13867
	ERROR_IPSEC_IKE_POLICY_MATCH                                              syscall.Errno = 13868
	ERROR_IPSEC_IKE_UNSUPPORTED_ID                                            syscall.Errno = 13869
	ERROR_IPSEC_IKE_INVALID_HASH                                              syscall.Errno = 13870
	ERROR_IPSEC_IKE_INVALID_HASH_ALG                                          syscall.Errno = 13871
	ERROR_IPSEC_IKE_INVALID_HASH_SIZE                                         syscall.Errno = 13872
	ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG                                       syscall.Errno = 13873
	ERROR_IPSEC_IKE_INVALID_AUTH_ALG                                          syscall.Errno = 13874
	ERROR_IPSEC_IKE_INVALID_SIG                                               syscall.Errno = 13875
	ERROR_IPSEC_IKE_LOAD_FAILED                                               syscall.Errno = 13876
	ERROR_IPSEC_IKE_RPC_DELETE                                                syscall.Errno = 13877
	ERROR_IPSEC_IKE_BENIGN_REINIT                                             syscall.Errno = 13878
	ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY                         syscall.Errno = 13879
	ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION                                     syscall.Errno = 13880
	ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN                                       syscall.Errno = 13881
	ERROR_IPSEC_IKE_MM_LIMIT                                                  syscall.Errno = 13882
	ERROR_IPSEC_IKE_NEGOTIATION_DISABLED                                      syscall.Errno = 13883
	ERROR_IPSEC_IKE_QM_LIMIT                                                  syscall.Errno = 13884
	ERROR_IPSEC_IKE_MM_EXPIRED                                                syscall.Errno = 13885
	ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID                                   syscall.Errno = 13886
	ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH                                syscall.Errno = 13887
	ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID                                     syscall.Errno = 13888
	ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD                                      syscall.Errno = 13889
	ERROR_IPSEC_IKE_DOS_COOKIE_SENT                                           syscall.Errno = 13890
	ERROR_IPSEC_IKE_SHUTTING_DOWN                                             syscall.Errno = 13891
	ERROR_IPSEC_IKE_CGA_AUTH_FAILED                                           syscall.Errno = 13892
	ERROR_IPSEC_IKE_PROCESS_ERR_NATOA                                         syscall.Errno = 13893
	ERROR_IPSEC_IKE_INVALID_MM_FOR_QM                                         syscall.Errno = 13894
	ERROR_IPSEC_IKE_QM_EXPIRED                                                syscall.Errno = 13895
	ERROR_IPSEC_IKE_TOO_MANY_FILTERS                                          syscall.Errno = 13896
	ERROR_IPSEC_IKE_NEG_STATUS_END                                            syscall.Errno = 13897
	ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL                                     syscall.Errno = 13898
	ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE                               syscall.Errno = 13899
	ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING                                syscall.Errno = 13900
	ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING                  syscall.Errno = 13901
	ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS                                      syscall.Errno = 13902
	ERROR_IPSEC_IKE_RATELIMIT_DROP                                            syscall.Errno = 13903
	ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE                                syscall.Errno = 13904
	ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE                                     syscall.Errno = 13905
	ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE                         syscall.Errno = 13906
	ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY                 syscall.Errno = 13907
	ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE             syscall.Errno = 13908
	ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END                                   syscall.Errno = 13909
	ERROR_IPSEC_BAD_SPI                                                       syscall.Errno = 13910
	ERROR_IPSEC_SA_LIFETIME_EXPIRED                                           syscall.Errno = 13911
	ERROR_IPSEC_WRONG_SA                                                      syscall.Errno = 13912
	ERROR_IPSEC_REPLAY_CHECK_FAILED                                           syscall.Errno = 13913
	ERROR_IPSEC_INVALID_PACKET                                                syscall.Errno = 13914
	ERROR_IPSEC_INTEGRITY_CHECK_FAILED                                        syscall.Errno = 13915
	ERROR_IPSEC_CLEAR_TEXT_DROP                                               syscall.Errno = 13916
	ERROR_IPSEC_AUTH_FIREWALL_DROP                                            syscall.Errno = 13917
	ERROR_IPSEC_THROTTLE_DROP                                                 syscall.Errno = 13918
	ERROR_IPSEC_DOSP_BLOCK                                                    syscall.Errno = 13925
	ERROR_IPSEC_DOSP_RECEIVED_MULTICAST                                       syscall.Errno = 13926
	ERROR_IPSEC_DOSP_INVALID_PACKET                                           syscall.Errno = 13927
	ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED                                      syscall.Errno = 13928
	ERROR_IPSEC_DOSP_MAX_ENTRIES                                              syscall.Errno = 13929
	ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED                                       syscall.Errno = 13930
	ERROR_IPSEC_DOSP_NOT_INSTALLED                                            syscall.Errno = 13931
	ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES                              syscall.Errno = 13932
	ERROR_SXS_SECTION_NOT_FOUND                                               syscall.Errno = 14000
	ERROR_SXS_CANT_GEN_ACTCTX                                                 syscall.Errno = 14001
	ERROR_SXS_INVALID_ACTCTXDATA_FORMAT                                       syscall.Errno = 14002
	ERROR_SXS_ASSEMBLY_NOT_FOUND                                              syscall.Errno = 14003
	ERROR_SXS_MANIFEST_FORMAT_ERROR                                           syscall.Errno = 14004
	ERROR_SXS_MANIFEST_PARSE_ERROR                                            syscall.Errno = 14005
	ERROR_SXS_ACTIVATION_CONTEXT_DISABLED                                     syscall.Errno = 14006
	ERROR_SXS_KEY_NOT_FOUND                                                   syscall.Errno = 14007
	ERROR_SXS_VERSION_CONFLICT                                                syscall.Errno = 14008
	ERROR_SXS_WRONG_SECTION_TYPE                                              syscall.Errno = 14009
	ERROR_SXS_THREAD_QUERIES_DISABLED                                         syscall.Errno = 14010
	ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET                                     syscall.Errno = 14011
	ERROR_SXS_UNKNOWN_ENCODING_GROUP                                          syscall.Errno = 14012
	ERROR_SXS_UNKNOWN_ENCODING                                                syscall.Errno = 14013
	ERROR_SXS_INVALID_XML_NAMESPACE_URI                                       syscall.Errno = 14014
	ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED                          syscall.Errno = 14015
	ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED                          syscall.Errno = 14016
	ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE                             syscall.Errno = 14017
	ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE                     syscall.Errno = 14018
	ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE                     syscall.Errno = 14019
	ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT                  syscall.Errno = 14020
	ERROR_SXS_DUPLICATE_DLL_NAME                                              syscall.Errno = 14021
	ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME                                      syscall.Errno = 14022
	ERROR_SXS_DUPLICATE_CLSID                                                 syscall.Errno = 14023
	ERROR_SXS_DUPLICATE_IID                                                   syscall.Errno = 14024
	ERROR_SXS_DUPLICATE_TLBID                                                 syscall.Errno = 14025
	ERROR_SXS_DUPLICATE_PROGID                                                syscall.Errno = 14026
	ERROR_SXS_DUPLICATE_ASSEMBLY_NAME                                         syscall.Errno = 14027
	ERROR_SXS_FILE_HASH_MISMATCH                                              syscall.Errno = 14028
	ERROR_SXS_POLICY_PARSE_ERROR                                              syscall.Errno = 14029
	ERROR_SXS_XML_E_MISSINGQUOTE                                              syscall.Errno = 14030
	ERROR_SXS_XML_E_COMMENTSYNTAX                                             syscall.Errno = 14031
	ERROR_SXS_XML_E_BADSTARTNAMECHAR                                          syscall.Errno = 14032
	ERROR_SXS_XML_E_BADNAMECHAR                                               syscall.Errno = 14033
	ERROR_SXS_XML_E_BADCHARINSTRING                                           syscall.Errno = 14034
	ERROR_SXS_XML_E_XMLDECLSYNTAX                                             syscall.Errno = 14035
	ERROR_SXS_XML_E_BADCHARDATA                                               syscall.Errno = 14036
	ERROR_SXS_XML_E_MISSINGWHITESPACE                                         syscall.Errno = 14037
	ERROR_SXS_XML_E_EXPECTINGTAGEND                                           syscall.Errno = 14038
	ERROR_SXS_XML_E_MISSINGSEMICOLON                                          syscall.Errno = 14039
	ERROR_SXS_XML_E_UNBALANCEDPAREN                                           syscall.Errno = 14040
	ERROR_SXS_XML_E_INTERNALERROR                                             syscall.Errno = 14041
	ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE                                     syscall.Errno = 14042
	ERROR_SXS_XML_E_INCOMPLETE_ENCODING                                       syscall.Errno = 14043
	ERROR_SXS_XML_E_MISSING_PAREN                                             syscall.Errno = 14044
	ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE                                       syscall.Errno = 14045
	ERROR_SXS_XML_E_MULTIPLE_COLONS                                           syscall.Errno = 14046
	ERROR_SXS_XML_E_INVALID_DECIMAL                                           syscall.Errno = 14047
	ERROR_SXS_XML_E_INVALID_HEXIDECIMAL                                       syscall.Errno = 14048
	ERROR_SXS_XML_E_INVALID_UNICODE                                           syscall.Errno = 14049
	ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK                                  syscall.Errno = 14050
	ERROR_SXS_XML_E_UNEXPECTEDENDTAG                                          syscall.Errno = 14051
	ERROR_SXS_XML_E_UNCLOSEDTAG                                               syscall.Errno = 14052
	ERROR_SXS_XML_E_DUPLICATEATTRIBUTE                                        syscall.Errno = 14053
	ERROR_SXS_XML_E_MULTIPLEROOTS                                             syscall.Errno = 14054
	ERROR_SXS_XML_E_INVALIDATROOTLEVEL                                        syscall.Errno = 14055
	ERROR_SXS_XML_E_BADXMLDECL                                                syscall.Errno = 14056
	ERROR_SXS_XML_E_MISSINGROOT                                               syscall.Errno = 14057
	ERROR_SXS_XML_E_UNEXPECTEDEOF                                             syscall.Errno = 14058
	ERROR_SXS_XML_E_BADPEREFINSUBSET                                          syscall.Errno = 14059
	ERROR_SXS_XML_E_UNCLOSEDSTARTTAG                                          syscall.Errno = 14060
	ERROR_SXS_XML_E_UNCLOSEDENDTAG                                            syscall.Errno = 14061
	ERROR_SXS_XML_E_UNCLOSEDSTRING                                            syscall.Errno = 14062
	ERROR_SXS_XML_E_UNCLOSEDCOMMENT                                           syscall.Errno = 14063
	ERROR_SXS_XML_E_UNCLOSEDDECL                                              syscall.Errno = 14064
	ERROR_SXS_XML_E_UNCLOSEDCDATA                                             syscall.Errno = 14065
	ERROR_SXS_XML_E_RESERVEDNAMESPACE                                         syscall.Errno = 14066
	ERROR_SXS_XML_E_INVALIDENCODING                                           syscall.Errno = 14067
	ERROR_SXS_XML_E_INVALIDSWITCH                                             syscall.Errno = 14068
	ERROR_SXS_XML_E_BADXMLCASE                                                syscall.Errno = 14069
	ERROR_SXS_XML_E_INVALID_STANDALONE                                        syscall.Errno = 14070
	ERROR_SXS_XML_E_UNEXPECTED_STANDALONE                                     syscall.Errno = 14071
	ERROR_SXS_XML_E_INVALID_VERSION                                           syscall.Errno = 14072
	ERROR_SXS_XML_E_MISSINGEQUALS                                             syscall.Errno = 14073
	ERROR_SXS_PROTECTION_RECOVERY_FAILED                                      syscall.Errno = 14074
	ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT                                 syscall.Errno = 14075
	ERROR_SXS_PROTECTION_CATALOG_NOT_VALID                                    syscall.Errno = 14076
	ERROR_SXS_UNTRANSLATABLE_HRESULT                                          syscall.Errno = 14077
	ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING                                 syscall.Errno = 14078
	ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE                             syscall.Errno = 14079
	ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME                        syscall.Errno = 14080
	ERROR_SXS_ASSEMBLY_MISSING                                                syscall.Errno = 14081
	ERROR_SXS_CORRUPT_ACTIVATION_STACK                                        syscall.Errno = 14082
	ERROR_SXS_CORRUPTION                                                      syscall.Errno = 14083
	ERROR_SXS_EARLY_DEACTIVATION                                              syscall.Errno = 14084
	ERROR_SXS_INVALID_DEACTIVATION                                            syscall.Errno = 14085
	ERROR_SXS_MULTIPLE_DEACTIVATION                                           syscall.Errno = 14086
	ERROR_SXS_PROCESS_TERMINATION_REQUESTED                                   syscall.Errno = 14087
	ERROR_SXS_RELEASE_ACTIVATION_CONTEXT                                      syscall.Errno = 14088
	ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY                         syscall.Errno = 14089
	ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE                                syscall.Errno = 14090
	ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME                                 syscall.Errno = 14091
	ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE                                    syscall.Errno = 14092
	ERROR_SXS_IDENTITY_PARSE_ERROR                                            syscall.Errno = 14093
	ERROR_MALFORMED_SUBSTITUTION_STRING                                       syscall.Errno = 14094
	ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN                                      syscall.Errno = 14095
	ERROR_UNMAPPED_SUBSTITUTION_STRING                                        syscall.Errno = 14096
	ERROR_SXS_ASSEMBLY_NOT_LOCKED                                             syscall.Errno = 14097
	ERROR_SXS_COMPONENT_STORE_CORRUPT                                         syscall.Errno = 14098
	ERROR_ADVANCED_INSTALLER_FAILED                                           syscall.Errno = 14099
	ERROR_XML_ENCODING_MISMATCH                                               syscall.Errno = 14100
	ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT                   syscall.Errno = 14101
	ERROR_SXS_IDENTITIES_DIFFERENT                                            syscall.Errno = 14102
	ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT                                    syscall.Errno = 14103
	ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY                                       syscall.Errno = 14104
	ERROR_SXS_MANIFEST_TOO_BIG                                                syscall.Errno = 14105
	ERROR_SXS_SETTING_NOT_REGISTERED                                          syscall.Errno = 14106
	ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE                                  syscall.Errno = 14107
	ERROR_SMI_PRIMITIVE_INSTALLER_FAILED                                      syscall.Errno = 14108
	ERROR_GENERIC_COMMAND_FAILED                                              syscall.Errno = 14109
	ERROR_SXS_FILE_HASH_MISSING                                               syscall.Errno = 14110
	ERROR_EVT_INVALID_CHANNEL_PATH                                            syscall.Errno = 15000
	ERROR_EVT_INVALID_QUERY                                                   syscall.Errno = 15001
	ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND                                    syscall.Errno = 15002
	ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND                                        syscall.Errno = 15003
	ERROR_EVT_INVALID_PUBLISHER_NAME                                          syscall.Errno = 15004
	ERROR_EVT_INVALID_EVENT_DATA                                              syscall.Errno = 15005
	ERROR_EVT_CHANNEL_NOT_FOUND                                               syscall.Errno = 15007
	ERROR_EVT_MALFORMED_XML_TEXT                                              syscall.Errno = 15008
	ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL                                  syscall.Errno = 15009
	ERROR_EVT_CONFIGURATION_ERROR                                             syscall.Errno = 15010
	ERROR_EVT_QUERY_RESULT_STALE                                              syscall.Errno = 15011
	ERROR_EVT_QUERY_RESULT_INVALID_POSITION                                   syscall.Errno = 15012
	ERROR_EVT_NON_VALIDATING_MSXML                                            syscall.Errno = 15013
	ERROR_EVT_FILTER_ALREADYSCOPED                                            syscall.Errno = 15014
	ERROR_EVT_FILTER_NOTELTSET                                                syscall.Errno = 15015
	ERROR_EVT_FILTER_INVARG                                                   syscall.Errno = 15016
	ERROR_EVT_FILTER_INVTEST                                                  syscall.Errno = 15017
	ERROR_EVT_FILTER_INVTYPE                                                  syscall.Errno = 15018
	ERROR_EVT_FILTER_PARSEERR                                                 syscall.Errno = 15019
	ERROR_EVT_FILTER_UNSUPPORTEDOP                                            syscall.Errno = 15020
	ERROR_EVT_FILTER_UNEXPECTEDTOKEN                                          syscall.Errno = 15021
	ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL                   syscall.Errno = 15022
	ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE                                  syscall.Errno = 15023
	ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE                                syscall.Errno = 15024
	ERROR_EVT_CHANNEL_CANNOT_ACTIVATE                                         syscall.Errno = 15025
	ERROR_EVT_FILTER_TOO_COMPLEX                                              syscall.Errno = 15026
	ERROR_EVT_MESSAGE_NOT_FOUND                                               syscall.Errno = 15027
	ERROR_EVT_MESSAGE_ID_NOT_FOUND                                            syscall.Errno = 15028
	ERROR_EVT_UNRESOLVED_VALUE_INSERT                                         syscall.Errno = 15029
	ERROR_EVT_UNRESOLVED_PARAMETER_INSERT                                     syscall.Errno = 15030
	ERROR_EVT_MAX_INSERTS_REACHED                                             syscall.Errno = 15031
	ERROR_EVT_EVENT_DEFINITION_NOT_FOUND                                      syscall.Errno = 15032
	ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND                                        syscall.Errno = 15033
	ERROR_EVT_VERSION_TOO_OLD                                                 syscall.Errno = 15034
	ERROR_EVT_VERSION_TOO_NEW                                                 syscall.Errno = 15035
	ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY                                    syscall.Errno = 15036
	ERROR_EVT_PUBLISHER_DISABLED                                              syscall.Errno = 15037
	ERROR_EVT_FILTER_OUT_OF_RANGE                                             syscall.Errno = 15038
	ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE                                     syscall.Errno = 15080
	ERROR_EC_LOG_DISABLED                                                     syscall.Errno = 15081
	ERROR_EC_CIRCULAR_FORWARDING                                              syscall.Errno = 15082
	ERROR_EC_CREDSTORE_FULL                                                   syscall.Errno = 15083
	ERROR_EC_CRED_NOT_FOUND                                                   syscall.Errno = 15084
	ERROR_EC_NO_ACTIVE_CHANNEL                                                syscall.Errno = 15085
	ERROR_MUI_FILE_NOT_FOUND                                                  syscall.Errno = 15100
	ERROR_MUI_INVALID_FILE                                                    syscall.Errno = 15101
	ERROR_MUI_INVALID_RC_CONFIG                                               syscall.Errno = 15102
	ERROR_MUI_INVALID_LOCALE_NAME                                             syscall.Errno = 15103
	ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME                                   syscall.Errno = 15104
	ERROR_MUI_FILE_NOT_LOADED                                                 syscall.Errno = 15105
	ERROR_RESOURCE_ENUM_USER_STOP                                             syscall.Errno = 15106
	ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED                               syscall.Errno = 15107
	ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME                                syscall.Errno = 15108
	ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE                          syscall.Errno = 15110
	ERROR_MRM_INVALID_PRICONFIG                                               syscall.Errno = 15111
	ERROR_MRM_INVALID_FILE_TYPE                                               syscall.Errno = 15112
	ERROR_MRM_UNKNOWN_QUALIFIER                                               syscall.Errno = 15113
	ERROR_MRM_INVALID_QUALIFIER_VALUE                                         syscall.Errno = 15114
	ERROR_MRM_NO_CANDIDATE                                                    syscall.Errno = 15115
	ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE                                   syscall.Errno = 15116
	ERROR_MRM_RESOURCE_TYPE_MISMATCH                                          syscall.Errno = 15117
	ERROR_MRM_DUPLICATE_MAP_NAME                                              syscall.Errno = 15118
	ERROR_MRM_DUPLICATE_ENTRY                                                 syscall.Errno = 15119
	ERROR_MRM_INVALID_RESOURCE_IDENTIFIER                                     syscall.Errno = 15120
	ERROR_MRM_FILEPATH_TOO_LONG                                               syscall.Errno = 15121
	ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE                                      syscall.Errno = 15122
	ERROR_MRM_INVALID_PRI_FILE                                                syscall.Errno = 15126
	ERROR_MRM_NAMED_RESOURCE_NOT_FOUND                                        syscall.Errno = 15127
	ERROR_MRM_MAP_NOT_FOUND                                                   syscall.Errno = 15135
	ERROR_MRM_UNSUPPORTED_PROFILE_TYPE                                        syscall.Errno = 15136
	ERROR_MRM_INVALID_QUALIFIER_OPERATOR                                      syscall.Errno = 15137
	ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE                                   syscall.Errno = 15138
	ERROR_MRM_AUTOMERGE_ENABLED                                               syscall.Errno = 15139
	ERROR_MRM_TOO_MANY_RESOURCES                                              syscall.Errno = 15140
	ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE                                 syscall.Errno = 15141
	ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE                  syscall.Errno = 15142
	ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD                                       syscall.Errno = 15143
	ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST                            syscall.Errno = 15144
	ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT                         syscall.Errno = 15145
	ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE                              syscall.Errno = 15146
	ERROR_MRM_GENERATION_COUNT_MISMATCH                                       syscall.Errno = 15147
	ERROR_PRI_MERGE_VERSION_MISMATCH                                          syscall.Errno = 15148
	ERROR_PRI_MERGE_MISSING_SCHEMA                                            syscall.Errno = 15149
	ERROR_PRI_MERGE_LOAD_FILE_FAILED                                          syscall.Errno = 15150
	ERROR_PRI_MERGE_ADD_FILE_FAILED                                           syscall.Errno = 15151
	ERROR_PRI_MERGE_WRITE_FILE_FAILED                                         syscall.Errno = 15152
	ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED                     syscall.Errno = 15153
	ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED                        syscall.Errno = 15154
	ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED                               syscall.Errno = 15155
	ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED                                     syscall.Errno = 15156
	ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED                                 syscall.Errno = 15157
	ERROR_PRI_MERGE_INVALID_FILE_NAME                                         syscall.Errno = 15158
	ERROR_MRM_PACKAGE_NOT_FOUND                                               syscall.Errno = 15159
	ERROR_MCA_INVALID_CAPABILITIES_STRING                                     syscall.Errno = 15200
	ERROR_MCA_INVALID_VCP_VERSION                                             syscall.Errno = 15201
	ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION                             syscall.Errno = 15202
	ERROR_MCA_MCCS_VERSION_MISMATCH                                           syscall.Errno = 15203
	ERROR_MCA_UNSUPPORTED_MCCS_VERSION                                        syscall.Errno = 15204
	ERROR_MCA_INTERNAL_ERROR                                                  syscall.Errno = 15205
	ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED                                syscall.Errno = 15206
	ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE                                   syscall.Errno = 15207
	ERROR_AMBIGUOUS_SYSTEM_DEVICE                                             syscall.Errno = 15250
	ERROR_SYSTEM_DEVICE_NOT_FOUND                                             syscall.Errno = 15299
	ERROR_HASH_NOT_SUPPORTED                                                  syscall.Errno = 15300
	ERROR_HASH_NOT_PRESENT                                                    syscall.Errno = 15301
	ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED                                syscall.Errno = 15321
	ERROR_GPIO_CLIENT_INFORMATION_INVALID                                     syscall.Errno = 15322
	ERROR_GPIO_VERSION_NOT_SUPPORTED                                          syscall.Errno = 15323
	ERROR_GPIO_INVALID_REGISTRATION_PACKET                                    syscall.Errno = 15324
	ERROR_GPIO_OPERATION_DENIED                                               syscall.Errno = 15325
	ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE                                      syscall.Errno = 15326
	ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED                                     syscall.Errno = 15327
	ERROR_CANNOT_SWITCH_RUNLEVEL                                              syscall.Errno = 15400
	ERROR_INVALID_RUNLEVEL_SETTING                                            syscall.Errno = 15401
	ERROR_RUNLEVEL_SWITCH_TIMEOUT                                             syscall.Errno = 15402
	ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT                                       syscall.Errno = 15403
	ERROR_RUNLEVEL_SWITCH_IN_PROGRESS                                         syscall.Errno = 15404
	ERROR_SERVICES_FAILED_AUTOSTART                                           syscall.Errno = 15405
	ERROR_COM_TASK_STOP_PENDING                                               syscall.Errno = 15501
	ERROR_INSTALL_OPEN_PACKAGE_FAILED                                         syscall.Errno = 15600
	ERROR_INSTALL_PACKAGE_NOT_FOUND                                           syscall.Errno = 15601
	ERROR_INSTALL_INVALID_PACKAGE                                             syscall.Errno = 15602
	ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED                                   syscall.Errno = 15603
	ERROR_INSTALL_OUT_OF_DISK_SPACE                                           syscall.Errno = 15604
	ERROR_INSTALL_NETWORK_FAILURE                                             syscall.Errno = 15605
	ERROR_INSTALL_REGISTRATION_FAILURE                                        syscall.Errno = 15606
	ERROR_INSTALL_DEREGISTRATION_FAILURE                                      syscall.Errno = 15607
	ERROR_INSTALL_CANCEL                                                      syscall.Errno = 15608
	ERROR_INSTALL_FAILED                                                      syscall.Errno = 15609
	ERROR_REMOVE_FAILED                                                       syscall.Errno = 15610
	ERROR_PACKAGE_ALREADY_EXISTS                                              syscall.Errno = 15611
	ERROR_NEEDS_REMEDIATION                                                   syscall.Errno = 15612
	ERROR_INSTALL_PREREQUISITE_FAILED                                         syscall.Errno = 15613
	ERROR_PACKAGE_REPOSITORY_CORRUPTED                                        syscall.Errno = 15614
	ERROR_INSTALL_POLICY_FAILURE                                              syscall.Errno = 15615
	ERROR_PACKAGE_UPDATING                                                    syscall.Errno = 15616
	ERROR_DEPLOYMENT_BLOCKED_BY_POLICY                                        syscall.Errno = 15617
	ERROR_PACKAGES_IN_USE                                                     syscall.Errno = 15618
	ERROR_RECOVERY_FILE_CORRUPT                                               syscall.Errno = 15619
	ERROR_INVALID_STAGED_SIGNATURE                                            syscall.Errno = 15620
	ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED                      syscall.Errno = 15621
	ERROR_INSTALL_PACKAGE_DOWNGRADE                                           syscall.Errno = 15622
	ERROR_SYSTEM_NEEDS_REMEDIATION                                            syscall.Errno = 15623
	ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN                                     syscall.Errno = 15624
	ERROR_RESILIENCY_FILE_CORRUPT                                             syscall.Errno = 15625
	ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING                                syscall.Errno = 15626
	ERROR_PACKAGE_MOVE_FAILED                                                 syscall.Errno = 15627
	ERROR_INSTALL_VOLUME_NOT_EMPTY                                            syscall.Errno = 15628
	ERROR_INSTALL_VOLUME_OFFLINE                                              syscall.Errno = 15629
	ERROR_INSTALL_VOLUME_CORRUPT                                              syscall.Errno = 15630
	ERROR_NEEDS_REGISTRATION                                                  syscall.Errno = 15631
	ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE                                syscall.Errno = 15632
	ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED                                         syscall.Errno = 15633
	ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE                      syscall.Errno = 15634
	ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM                                 syscall.Errno = 15635
	ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING                                   syscall.Errno = 15636
	ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE                   syscall.Errno = 15637
	ERROR_PACKAGE_STAGING_ONHOLD                                              syscall.Errno = 15638
	ERROR_INSTALL_INVALID_RELATED_SET_UPDATE                                  syscall.Errno = 15639
	ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY syscall.Errno = 15640
	ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF                                  syscall.Errno = 15641
	ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED        syscall.Errno = 15642
	ERROR_PACKAGES_REPUTATION_CHECK_FAILED                                    syscall.Errno = 15643
	ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT                                  syscall.Errno = 15644
	ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED                                     syscall.Errno = 15645
	ERROR_APPINSTALLER_ACTIVATION_BLOCKED                                     syscall.Errno = 15646
	ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED                        syscall.Errno = 15647
	APPMODEL_ERROR_NO_PACKAGE                                                 syscall.Errno = 15700
	APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT                                    syscall.Errno = 15701
	APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT                                   syscall.Errno = 15702
	APPMODEL_ERROR_NO_APPLICATION                                             syscall.Errno = 15703
	APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED                               syscall.Errno = 15704
	APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID                                   syscall.Errno = 15705
	APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE                                      syscall.Errno = 15706
	ERROR_STATE_LOAD_STORE_FAILED                                             syscall.Errno = 15800
	ERROR_STATE_GET_VERSION_FAILED                                            syscall.Errno = 15801
	ERROR_STATE_SET_VERSION_FAILED                                            syscall.Errno = 15802
	ERROR_STATE_STRUCTURED_RESET_FAILED                                       syscall.Errno = 15803
	ERROR_STATE_OPEN_CONTAINER_FAILED                                         syscall.Errno = 15804
	ERROR_STATE_CREATE_CONTAINER_FAILED                                       syscall.Errno = 15805
	ERROR_STATE_DELETE_CONTAINER_FAILED                                       syscall.Errno = 15806
	ERROR_STATE_READ_SETTING_FAILED                                           syscall.Errno = 15807
	ERROR_STATE_WRITE_SETTING_FAILED                                          syscall.Errno = 15808
	ERROR_STATE_DELETE_SETTING_FAILED                                         syscall.Errno = 15809
	ERROR_STATE_QUERY_SETTING_FAILED                                          syscall.Errno = 15810
	ERROR_STATE_READ_COMPOSITE_SETTING_FAILED                                 syscall.Errno = 15811
	ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED                                syscall.Errno = 15812
	ERROR_STATE_ENUMERATE_CONTAINER_FAILED                                    syscall.Errno = 15813
	ERROR_STATE_ENUMERATE_SETTINGS_FAILED                                     syscall.Errno = 15814
	ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED                   syscall.Errno = 15815
	ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED                             syscall.Errno = 15816
	ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED                              syscall.Errno = 15817
	ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED                            syscall.Errno = 15818
	ERROR_API_UNAVAILABLE                                                     syscall.Errno = 15841
	STORE_ERROR_UNLICENSED                                                    syscall.Errno = 15861
	STORE_ERROR_UNLICENSED_USER                                               syscall.Errno = 15862
	STORE_ERROR_PENDING_COM_TRANSACTION                                       syscall.Errno = 15863
	STORE_ERROR_LICENSE_REVOKED                                               syscall.Errno = 15864
	SEVERITY_SUCCESS                                                          syscall.Errno = 0
	SEVERITY_ERROR                                                            syscall.Errno = 1
	FACILITY_NT_BIT                                                                         = 0x10000000
	E_NOT_SET                                                                               = ERROR_NOT_FOUND
	E_NOT_VALID_STATE                                                                       = ERROR_INVALID_STATE
	E_NOT_SUFFICIENT_BUFFER                                                                 = ERROR_INSUFFICIENT_BUFFER
	E_TIME_CRITICAL_THREAD                                                                  = ERROR_TIME_CRITICAL_THREAD
	NOERROR                                                                   syscall.Errno = 0
	E_UNEXPECTED                                                              Handle        = 0x8000FFFF
	E_NOTIMPL                                                                 Handle        = 0x80004001
	E_OUTOFMEMORY                                                             Handle        = 0x8007000E
	E_INVALIDARG                                                              Handle        = 0x80070057
	E_NOINTERFACE                                                             Handle        = 0x80004002
	E_POINTER                                                                 Handle        = 0x80004003
	E_HANDLE                                                                  Handle        = 0x80070006
	E_ABORT                                                                   Handle        = 0x80004004
	E_FAIL                                                                    Handle        = 0x80004005
	E_ACCESSDENIED                                                            Handle        = 0x80070005
	E_PENDING                                                                 Handle        = 0x8000000A
	E_BOUNDS                                                                  Handle        = 0x8000000B
	E_CHANGED_STATE                                                           Handle        = 0x8000000C
	E_ILLEGAL_STATE_CHANGE                                                    Handle        = 0x8000000D
	E_ILLEGAL_METHOD_CALL                                                     Handle        = 0x8000000E
	RO_E_METADATA_NAME_NOT_FOUND                                              Handle        = 0x8000000F
	RO_E_METADATA_NAME_IS_NAMESPACE                                           Handle        = 0x80000010
	RO_E_METADATA_INVALID_TYPE_FORMAT                                         Handle        = 0x80000011
	RO_E_INVALID_METADATA_FILE                                                Handle        = 0x80000012
	RO_E_CLOSED                                                               Handle        = 0x80000013
	RO_E_EXCLUSIVE_WRITE                                                      Handle        = 0x80000014
	RO_E_CHANGE_NOTIFICATION_IN_PROGRESS                                      Handle        = 0x80000015
	RO_E_ERROR_STRING_NOT_FOUND                                               Handle        = 0x80000016
	E_STRING_NOT_NULL_TERMINATED                                              Handle        = 0x80000017
	E_ILLEGAL_DELEGATE_ASSIGNMENT                                             Handle        = 0x80000018
	E_ASYNC_OPERATION_NOT_STARTED                                             Handle        = 0x80000019
	E_APPLICATION_EXITING                                                     Handle        = 0x8000001A
	E_APPLICATION_VIEW_EXITING                                                Handle        = 0x8000001B
	RO_E_MUST_BE_AGILE                                                        Handle        = 0x8000001C
	RO_E_UNSUPPORTED_FROM_MTA                                                 Handle        = 0x8000001D
	RO_E_COMMITTED                                                            Handle        = 0x8000001E
	RO_E_BLOCKED_CROSS_ASTA_CALL                                              Handle        = 0x8000001F
	RO_E_CANNOT_ACTIVATE_FULL_TRUST_SERVER                                    Handle        = 0x80000020
	RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER                         Handle        = 0x80000021
	CO_E_INIT_TLS                                                             Handle        = 0x80004006
	CO_E_INIT_SHARED_ALLOCATOR                                                Handle        = 0x80004007
	CO_E_INIT_MEMORY_ALLOCATOR                                                Handle        = 0x80004008
	CO_E_INIT_CLASS_CACHE                                                     Handle        = 0x80004009
	CO_E_INIT_RPC_CHANNEL                                                     Handle        = 0x8000400A
	CO_E_INIT_TLS_SET_CHANNEL_CONTROL                                         Handle        = 0x8000400B
	CO_E_INIT_TLS_CHANNEL_CONTROL                                             Handle        = 0x8000400C
	CO_E_INIT_UNACCEPTED_USER_ALLOCATOR                                       Handle        = 0x8000400D
	CO_E_INIT_SCM_MUTEX_EXISTS                                                Handle        = 0x8000400E
	CO_E_INIT_SCM_FILE_MAPPING_EXISTS                                         Handle        = 0x8000400F
	CO_E_INIT_SCM_MAP_VIEW_OF_FILE                                            Handle        = 0x80004010
	CO_E_INIT_SCM_EXEC_FAILURE                                                Handle        = 0x80004011
	CO_E_INIT_ONLY_SINGLE_THREADED                                            Handle        = 0x80004012
	CO_E_CANT_REMOTE                                                          Handle        = 0x80004013
	CO_E_BAD_SERVER_NAME                                                      Handle        = 0x80004014
	CO_E_WRONG_SERVER_IDENTITY                                                Handle        = 0x80004015
	CO_E_OLE1DDE_DISABLED                                                     Handle        = 0x80004016
	CO_E_RUNAS_SYNTAX                                                         Handle        = 0x80004017
	CO_E_CREATEPROCESS_FAILURE                                                Handle        = 0x80004018
	CO_E_RUNAS_CREATEPROCESS_FAILURE                                          Handle        = 0x80004019
	CO_E_RUNAS_LOGON_FAILURE                                                  Handle        = 0x8000401A
	CO_E_LAUNCH_PERMSSION_DENIED                                              Handle        = 0x8000401B
	CO_E_START_SERVICE_FAILURE                                                Handle        = 0x8000401C
	CO_E_REMOTE_COMMUNICATION_FAILURE                                         Handle        = 0x8000401D
	CO_E_SERVER_START_TIMEOUT                                                 Handle        = 0x8000401E
	CO_E_CLSREG_INCONSISTENT                                                  Handle        = 0x8000401F
	CO_E_IIDREG_INCONSISTENT                                                  Handle        = 0x80004020
	CO_E_NOT_SUPPORTED                                                        Handle        = 0x80004021
	CO_E_RELOAD_DLL                                                           Handle        = 0x80004022
	CO_E_MSI_ERROR                                                            Handle        = 0x80004023
	CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT                             Handle        = 0x80004024
	CO_E_SERVER_PAUSED                                                        Handle        = 0x80004025
	CO_E_SERVER_NOT_PAUSED                                                    Handle        = 0x80004026
	CO_E_CLASS_DISABLED                                                       Handle        = 0x80004027
	CO_E_CLRNOTAVAILABLE                                                      Handle        = 0x80004028
	CO_E_ASYNC_WORK_REJECTED                                                  Handle        = 0x80004029
	CO_E_SERVER_INIT_TIMEOUT                                                  Handle        = 0x8000402A
	CO_E_NO_SECCTX_IN_ACTIVATE                                                Handle        = 0x8000402B
	CO_E_TRACKER_CONFIG                                                       Handle        = 0x80004030
	CO_E_THREADPOOL_CONFIG                                                    Handle        = 0x80004031
	CO_E_SXS_CONFIG                                                           Handle        = 0x80004032
	CO_E_MALFORMED_SPN                                                        Handle        = 0x80004033
	CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN                         Handle        = 0x80004034
	CO_E_PREMATURE_STUB_RUNDOWN                                               Handle        = 0x80004035
	S_OK                                                                      Handle        = 0
	S_FALSE                                                                   Handle        = 1
	OLE_E_FIRST                                                               Handle        = 0x80040000
	OLE_E_LAST                                                                Handle        = 0x800400FF
	OLE_S_FIRST                                                               Handle        = 0x00040000
	OLE_S_LAST                                                                Handle        = 0x000400FF
	OLE_E_OLEVERB                                                             Handle        = 0x80040000
	OLE_E_ADVF                                                                Handle        = 0x80040001
	OLE_E_ENUM_NOMORE                                                         Handle        = 0x80040002
	OLE_E_ADVISENOTSUPPORTED                                                  Handle        = 0x80040003
	OLE_E_NOCONNECTION                                                        Handle        = 0x80040004
	OLE_E_NOTRUNNING                                                          Handle        = 0x80040005
	OLE_E_NOCACHE                                                             Handle        = 0x80040006
	OLE_E_BLANK                                                               Handle        = 0x80040007
	OLE_E_CLASSDIFF                                                           Handle        = 0x80040008
	OLE_E_CANT_GETMONIKER                                                     Handle        = 0x80040009
	OLE_E_CANT_BINDTOSOURCE                                                   Handle        = 0x8004000A
	OLE_E_STATIC                                                              Handle        = 0x8004000B
	OLE_E_PROMPTSAVECANCELLED                                                 Handle        = 0x8004000C
	OLE_E_INVALIDRECT                                                         Handle        = 0x8004000D
	OLE_E_WRONGCOMPOBJ                                                        Handle        = 0x8004000E
	OLE_E_INVALIDHWND                                                         Handle        = 0x8004000F
	OLE_E_NOT_INPLACEACTIVE                                                   Handle        = 0x80040010
	OLE_E_CANTCONVERT                                                         Handle        = 0x80040011
	OLE_E_NOSTORAGE                                                           Handle        = 0x80040012
	DV_E_FORMATETC                                                            Handle        = 0x80040064
	DV_E_DVTARGETDEVICE                                                       Handle        = 0x80040065
	DV_E_STGMEDIUM                                                            Handle        = 0x80040066
	DV_E_STATDATA                                                             Handle        = 0x80040067
	DV_E_LINDEX                                                               Handle        = 0x80040068
	DV_E_TYMED                                                                Handle        = 0x80040069
	DV_E_CLIPFORMAT                                                           Handle        = 0x8004006A
	DV_E_DVASPECT                                                             Handle        = 0x8004006B
	DV_E_DVTARGETDEVICE_SIZE                                                  Handle        = 0x8004006C
	DV_E_NOIVIEWOBJECT                                                        Handle        = 0x8004006D
	DRAGDROP_E_FIRST                                                          syscall.Errno = 0x80040100
	DRAGDROP_E_LAST                                                           syscall.Errno = 0x8004010F
	DRAGDROP_S_FIRST                                                          syscall.Errno = 0x00040100
	DRAGDROP_S_LAST                                                           syscall.Errno = 0x0004010F
	DRAGDROP_E_NOTREGISTERED                                                  Handle        = 0x80040100
	DRAGDROP_E_ALREADYREGISTERED                                              Handle        = 0x80040101
	DRAGDROP_E_INVALIDHWND                                                    Handle        = 0x80040102
	DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED                                      Handle        = 0x80040103
	CLASSFACTORY_E_FIRST                                                      syscall.Errno = 0x80040110
	CLASSFACTORY_E_LAST                                                       syscall.Errno = 0x8004011F
	CLASSFACTORY_S_FIRST                                                      syscall.Errno = 0x00040110
	CLASSFACTORY_S_LAST                                                       syscall.Errno = 0x0004011F
	CLASS_E_NOAGGREGATION                                                     Handle        = 0x80040110
	CLASS_E_CLASSNOTAVAILABLE                                                 Handle        = 0x80040111
	CLASS_E_NOTLICENSED                                                       Handle        = 0x80040112
	MARSHAL_E_FIRST                                                           syscall.Errno = 0x80040120
	MARSHAL_E_LAST                                                            syscall.Errno = 0x8004012F
	MARSHAL_S_FIRST                                                           syscall.Errno = 0x00040120
	MARSHAL_S_LAST                                                            syscall.Errno = 0x0004012F
	DATA_E_FIRST                                                              syscall.Errno = 0x80040130
	DATA_E_LAST                                                               syscall.Errno = 0x8004013F
	DATA_S_FIRST                                                              syscall.Errno = 0x00040130
	DATA_S_LAST                                                               syscall.Errno = 0x0004013F
	VIEW_E_FIRST                                                              syscall.Errno = 0x80040140
	VIEW_E_LAST                                                               syscall.Errno = 0x8004014F
	VIEW_S_FIRST                                                              syscall.Errno = 0x00040140
	VIEW_S_LAST                                                               syscall.Errno = 0x0004014F
	VIEW_E_DRAW                                                               Handle        = 0x80040140
	REGDB_E_FIRST                                                             syscall.Errno = 0x80040150
	REGDB_E_LAST                                                              syscall.Errno = 0x8004015F
	REGDB_S_FIRST                                                             syscall.Errno = 0x00040150
	REGDB_S_LAST                                                              syscall.Errno = 0x0004015F
	REGDB_E_READREGDB                                                         Handle        = 0x80040150
	REGDB_E_WRITEREGDB                                                        Handle        = 0x80040151
	REGDB_E_KEYMISSING                                                        Handle        = 0x80040152
	REGDB_E_INVALIDVALUE                                                      Handle        = 0x80040153
	REGDB_E_CLASSNOTREG                                                       Handle        = 0x80040154
	REGDB_E_IIDNOTREG                                                         Handle        = 0x80040155
	REGDB_E_BADTHREADINGMODEL                                                 Handle        = 0x80040156
	REGDB_E_PACKAGEPOLICYVIOLATION                                            Handle        = 0x80040157
	CAT_E_FIRST                                                               syscall.Errno = 0x80040160
	CAT_E_LAST                                                                syscall.Errno = 0x80040161
	CAT_E_CATIDNOEXIST                                                        Handle        = 0x80040160
	CAT_E_NODESCRIPTION                                                       Handle        = 0x80040161
	CS_E_FIRST                                                                syscall.Errno = 0x80040164
	CS_E_LAST                                                                 syscall.Errno = 0x8004016F
	CS_E_PACKAGE_NOTFOUND                                                     Handle        = 0x80040164
	CS_E_NOT_DELETABLE                                                        Handle        = 0x80040165
	CS_E_CLASS_NOTFOUND                                                       Handle        = 0x80040166
	CS_E_INVALID_VERSION                                                      Handle        = 0x80040167
	CS_E_NO_CLASSSTORE                                                        Handle        = 0x80040168
	CS_E_OBJECT_NOTFOUND                                                      Handle        = 0x80040169
	CS_E_OBJECT_ALREADY_EXISTS                                                Handle        = 0x8004016A
	CS_E_INVALID_PATH                                                         Handle        = 0x8004016B
	CS_E_NETWORK_ERROR                                                        Handle        = 0x8004016C
	CS_E_ADMIN_LIMIT_EXCEEDED                                                 Handle        = 0x8004016D
	CS_E_SCHEMA_MISMATCH                                                      Handle        = 0x8004016E
	CS_E_INTERNAL_ERROR                                                       Handle        = 0x8004016F
	CACHE_E_FIRST                                                             syscall.Errno = 0x80040170
	CACHE_E_LAST                                                              syscall.Errno = 0x8004017F
	CACHE_S_FIRST                                                             syscall.Errno = 0x00040170
	CACHE_S_LAST                                                              syscall.Errno = 0x0004017F
	CACHE_E_NOCACHE_UPDATED                                                   Handle        = 0x80040170
	OLEOBJ_E_FIRST                                                            syscall.Errno = 0x80040180
	OLEOBJ_E_LAST                                                             syscall.Errno = 0x8004018F
	OLEOBJ_S_FIRST                                                            syscall.Errno = 0x00040180
	OLEOBJ_S_LAST                                                             syscall.Errno = 0x0004018F
	OLEOBJ_E_NOVERBS                                                          Handle        = 0x80040180
	OLEOBJ_E_INVALIDVERB                                                      Handle        = 0x80040181
	CLIENTSITE_E_FIRST                                                        syscall.Errno = 0x80040190
	CLIENTSITE_E_LAST                                                         syscall.Errno = 0x8004019F
	CLIENTSITE_S_FIRST                                                        syscall.Errno = 0x00040190
	CLIENTSITE_S_LAST                                                         syscall.Errno = 0x0004019F
	INPLACE_E_NOTUNDOABLE                                                     Handle        = 0x800401A0
	INPLACE_E_NOTOOLSPACE                                                     Handle        = 0x800401A1
	INPLACE_E_FIRST                                                           syscall.Errno = 0x800401A0
	INPLACE_E_LAST                                                            syscall.Errno = 0x800401AF
	INPLACE_S_FIRST                                                           syscall.Errno = 0x000401A0
	INPLACE_S_LAST                                                            syscall.Errno = 0x000401AF
	ENUM_E_FIRST                                                              syscall.Errno = 0x800401B0
	ENUM_E_LAST                                                               syscall.Errno = 0x800401BF
	ENUM_S_FIRST                                                              syscall.Errno = 0x000401B0
	ENUM_S_LAST                                                               syscall.Errno = 0x000401BF
	CONVERT10_E_FIRST                                                         syscall.Errno = 0x800401C0
	CONVERT10_E_LAST                                                          syscall.Errno = 0x800401CF
	CONVERT10_S_FIRST                                                         syscall.Errno = 0x000401C0
	CONVERT10_S_LAST                                                          syscall.Errno = 0x000401CF
	CONVERT10_E_OLESTREAM_GET                                                 Handle        = 0x800401C0
	CONVERT10_E_OLESTREAM_PUT                                                 Handle        = 0x800401C1
	CONVERT10_E_OLESTREAM_FMT                                                 Handle        = 0x800401C2
	CONVERT10_E_OLESTREAM_BITMAP_TO_DIB                                       Handle        = 0x800401C3
	CONVERT10_E_STG_FMT                                                       Handle        = 0x800401C4
	CONVERT10_E_STG_NO_STD_STREAM                                             Handle        = 0x800401C5
	CONVERT10_E_STG_DIB_TO_BITMAP                                             Handle        = 0x800401C6
	CLIPBRD_E_FIRST                                                           syscall.Errno = 0x800401D0
	CLIPBRD_E_LAST                                                            syscall.Errno = 0x800401DF
	CLIPBRD_S_FIRST                                                           syscall.Errno = 0x000401D0
	CLIPBRD_S_LAST                                                            syscall.Errno = 0x000401DF
	CLIPBRD_E_CANT_OPEN                                                       Handle        = 0x800401D0
	CLIPBRD_E_CANT_EMPTY                                                      Handle        = 0x800401D1
	CLIPBRD_E_CANT_SET                                                        Handle        = 0x800401D2
	CLIPBRD_E_BAD_DATA                                                        Handle        = 0x800401D3
	CLIPBRD_E_CANT_CLOSE                                                      Handle        = 0x800401D4
	MK_E_FIRST                                                                syscall.Errno = 0x800401E0
	MK_E_LAST                                                                 syscall.Errno = 0x800401EF
	MK_S_FIRST                                                                syscall.Errno = 0x000401E0
	MK_S_LAST                                                                 syscall.Errno = 0x000401EF
	MK_E_CONNECTMANUALLY                                                      Handle        = 0x800401E0
	MK_E_EXCEEDEDDEADLINE                                                     Handle        = 0x800401E1
	MK_E_NEEDGENERIC                                                          Handle        = 0x800401E2
	MK_E_UNAVAILABLE                                                          Handle        = 0x800401E3
	MK_E_SYNTAX                                                               Handle        = 0x800401E4
	MK_E_NOOBJECT                                                             Handle        = 0x800401E5
	MK_E_INVALIDEXTENSION                                                     Handle        = 0x800401E6
	MK_E_INTERMEDIATEINTERFACENOTSUPPORTED                                    Handle        = 0x800401E7
	MK_E_NOTBINDABLE                                                          Handle        = 0x800401E8
	MK_E_NOTBOUND                                                             Handle        = 0x800401E9
	MK_E_CANTOPENFILE                                                         Handle        = 0x800401EA
	MK_E_MUSTBOTHERUSER                                                       Handle        = 0x800401EB
	MK_E_NOINVERSE                                                            Handle        = 0x800401EC
	MK_E_NOSTORAGE                                                            Handle        = 0x800401ED
	MK_E_NOPREFIX                                                             Handle        = 0x800401EE
	MK_E_ENUMERATION_FAILED                                                   Handle        = 0x800401EF
	CO_E_FIRST                                                                syscall.Errno = 0x800401F0
	CO_E_LAST                                                                 syscall.Errno = 0x800401FF
	CO_S_FIRST                                                                syscall.Errno = 0x000401F0
	CO_S_LAST                                                                 syscall.Errno = 0x000401FF
	CO_E_NOTINITIALIZED                                                       Handle        = 0x800401F0
	CO_E_ALREADYINITIALIZED                                                   Handle        = 0x800401F1
	CO_E_CANTDETERMINECLASS                                                   Handle        = 0x800401F2
	CO_E_CLASSSTRING                                                          Handle        = 0x800401F3
	CO_E_IIDSTRING                                                            Handle        = 0x800401F4
	CO_E_APPNOTFOUND                                                          Handle        = 0x800401F5
	CO_E_APPSINGLEUSE                                                         Handle        = 0x800401F6
	CO_E_ERRORINAPP                                                           Handle        = 0x800401F7
	CO_E_DLLNOTFOUND                                                          Handle        = 0x800401F8
	CO_E_ERRORINDLL                                                           Handle        = 0x800401F9
	CO_E_WRONGOSFORAPP                                                        Handle        = 0x800401FA
	CO_E_OBJNOTREG                                                            Handle        = 0x800401FB
	CO_E_OBJISREG                                                             Handle        = 0x800401FC
	CO_E_OBJNOTCONNECTED                                                      Handle        = 0x800401FD
	CO_E_APPDIDNTREG                                                          Handle        = 0x800401FE
	CO_E_RELEASED                                                             Handle        = 0x800401FF
	EVENT_E_FIRST                                                             syscall.Errno = 0x80040200
	EVENT_E_LAST                                                              syscall.Errno = 0x8004021F
	EVENT_S_FIRST                                                             syscall.Errno = 0x00040200
	EVENT_S_LAST                                                              syscall.Errno = 0x0004021F
	EVENT_S_SOME_SUBSCRIBERS_FAILED                                           Handle        = 0x00040200
	EVENT_E_ALL_SUBSCRIBERS_FAILED                                            Handle        = 0x80040201
	EVENT_S_NOSUBSCRIBERS                                                     Handle        = 0x00040202
	EVENT_E_QUERYSYNTAX                                                       Handle        = 0x80040203
	EVENT_E_QUERYFIELD                                                        Handle        = 0x80040204
	EVENT_E_INTERNALEXCEPTION                                                 Handle        = 0x80040205
	EVENT_E_INTERNALERROR                                                     Handle        = 0x80040206
	EVENT_E_INVALID_PER_USER_SID                                              Handle        = 0x80040207
	EVENT_E_USER_EXCEPTION                                                    Handle        = 0x80040208
	EVENT_E_TOO_MANY_METHODS                                                  Handle        = 0x80040209
	EVENT_E_MISSING_EVENTCLASS                                                Handle        = 0x8004020A
	EVENT_E_NOT_ALL_REMOVED                                                   Handle        = 0x8004020B
	EVENT_E_COMPLUS_NOT_INSTALLED                                             Handle        = 0x8004020C
	EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT                         Handle        = 0x8004020D
	EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT                           Handle        = 0x8004020E
	EVENT_E_INVALID_EVENT_CLASS_PARTITION                                     Handle        = 0x8004020F
	EVENT_E_PER_USER_SID_NOT_LOGGED_ON                                        Handle        = 0x80040210
	TPC_E_INVALID_PROPERTY                                                    Handle        = 0x80040241
	TPC_E_NO_DEFAULT_TABLET                                                   Handle        = 0x80040212
	TPC_E_UNKNOWN_PROPERTY                                                    Handle        = 0x8004021B
	TPC_E_INVALID_INPUT_RECT                                                  Handle        = 0x80040219
	TPC_E_INVALID_STROKE                                                      Handle        = 0x80040222
	TPC_E_INITIALIZE_FAIL                                                     Handle        = 0x80040223
	TPC_E_NOT_RELEVANT                                                        Handle        = 0x80040232
	TPC_E_INVALID_PACKET_DESCRIPTION                                          Handle        = 0x80040233
	TPC_E_RECOGNIZER_NOT_REGISTERED                                           Handle        = 0x80040235
	TPC_E_INVALID_RIGHTS                                                      Handle        = 0x80040236
	TPC_E_OUT_OF_ORDER_CALL                                                   Handle        = 0x80040237
	TPC_E_QUEUE_FULL                                                          Handle        = 0x80040238
	TPC_E_INVALID_CONFIGURATION                                               Handle        = 0x80040239
	TPC_E_INVALID_DATA_FROM_RECOGNIZER                                        Handle        = 0x8004023A
	TPC_S_TRUNCATED                                                           Handle        = 0x00040252
	TPC_S_INTERRUPTED                                                         Handle        = 0x00040253
	TPC_S_NO_DATA_TO_PROCESS                                                  Handle        = 0x00040254
	XACT_E_FIRST                                                              syscall.Errno = 0x8004D000
	XACT_E_LAST                                                               syscall.Errno = 0x8004D02B
	XACT_S_FIRST                                                              syscall.Errno = 0x0004D000
	XACT_S_LAST                                                               syscall.Errno = 0x0004D010
	XACT_E_ALREADYOTHERSINGLEPHASE                                            Handle        = 0x8004D000
	XACT_E_CANTRETAIN                                                         Handle        = 0x8004D001
	XACT_E_COMMITFAILED                                                       Handle        = 0x8004D002
	XACT_E_COMMITPREVENTED                                                    Handle        = 0x8004D003
	XACT_E_HEURISTICABORT                                                     Handle        = 0x8004D004
	XACT_E_HEURISTICCOMMIT                                                    Handle        = 0x8004D005
	XACT_E_HEURISTICDAMAGE                                                    Handle        = 0x8004D006
	XACT_E_HEURISTICDANGER                                                    Handle        = 0x8004D007
	XACT_E_ISOLATIONLEVEL                                                     Handle        = 0x8004D008
	XACT_E_NOASYNC                                                            Handle        = 0x8004D009
	XACT_E_NOENLIST                                                           Handle        = 0x8004D00A
	XACT_E_NOISORETAIN                                                        Handle        = 0x8004D00B
	XACT_E_NORESOURCE                                                         Handle        = 0x8004D00C
	XACT_E_NOTCURRENT                                                         Handle        = 0x8004D00D
	XACT_E_NOTRANSACTION                                                      Handle        = 0x8004D00E
	XACT_E_NOTSUPPORTED                                                       Handle        = 0x8004D00F
	XACT_E_UNKNOWNRMGRID                                                      Handle        = 0x8004D010
	XACT_E_WRONGSTATE                                                         Handle        = 0x8004D011
	XACT_E_WRONGUOW                                                           Handle        = 0x8004D012
	XACT_E_XTIONEXISTS                                                        Handle        = 0x8004D013
	XACT_E_NOIMPORTOBJECT                                                     Handle        = 0x8004D014
	XACT_E_INVALIDCOOKIE                                                      Handle        = 0x8004D015
	XACT_E_INDOUBT                                                            Handle        = 0x8004D016
	XACT_E_NOTIMEOUT                                                          Handle        = 0x8004D017
	XACT_E_ALREADYINPROGRESS                                                  Handle        = 0x8004D018
	XACT_E_ABORTED                                                            Handle        = 0x8004D019
	XACT_E_LOGFULL                                                            Handle        = 0x8004D01A
	XACT_E_TMNOTAVAILABLE                                                     Handle        = 0x8004D01B
	XACT_E_CONNECTION_DOWN                                                    Handle        = 0x8004D01C
	XACT_E_CONNECTION_DENIED                                                  Handle        = 0x8004D01D
	XACT_E_REENLISTTIMEOUT                                                    Handle        = 0x8004D01E
	XACT_E_TIP_CONNECT_FAILED                                                 Handle        = 0x8004D01F
	XACT_E_TIP_PROTOCOL_ERROR                                                 Handle        = 0x8004D020
	XACT_E_TIP_PULL_FAILED                                                    Handle        = 0x8004D021
	XACT_E_DEST_TMNOTAVAILABLE                                                Handle        = 0x8004D022
	XACT_E_TIP_DISABLED                                                       Handle        = 0x8004D023
	XACT_E_NETWORK_TX_DISABLED                                                Handle        = 0x8004D024
	XACT_E_PARTNER_NETWORK_TX_DISABLED                                        Handle        = 0x8004D025
	XACT_E_XA_TX_DISABLED                                                     Handle        = 0x8004D026
	XACT_E_UNABLE_TO_READ_DTC_CONFIG                                          Handle        = 0x8004D027
	XACT_E_UNABLE_TO_LOAD_DTC_PROXY                                           Handle        = 0x8004D028
	XACT_E_ABORTING                                                           Handle        = 0x8004D029
	XACT_E_PUSH_COMM_FAILURE                                                  Handle        = 0x8004D02A
	XACT_E_PULL_COMM_FAILURE                                                  Handle        = 0x8004D02B
	XACT_E_LU_TX_DISABLED                                                     Handle        = 0x8004D02C
	XACT_E_CLERKNOTFOUND                                                      Handle        = 0x8004D080
	XACT_E_CLERKEXISTS                                                        Handle        = 0x8004D081
	XACT_E_RECOVERYINPROGRESS                                                 Handle        = 0x8004D082
	XACT_E_TRANSACTIONCLOSED                                                  Handle        = 0x8004D083
	XACT_E_INVALIDLSN                                                         Handle        = 0x8004D084
	XACT_E_REPLAYREQUEST                                                      Handle        = 0x8004D085
	XACT_S_ASYNC                                                              Handle        = 0x0004D000
	XACT_S_DEFECT                                                             Handle        = 0x0004D001
	XACT_S_READONLY                                                           Handle        = 0x0004D002
	XACT_S_SOMENORETAIN                                                       Handle        = 0x0004D003
	XACT_S_OKINFORM                                                           Handle        = 0x0004D004
	XACT_S_MADECHANGESCONTENT                                                 Handle        = 0x0004D005
	XACT_S_MADECHANGESINFORM                                                  Handle        = 0x0004D006
	XACT_S_ALLNORETAIN                                                        Handle        = 0x0004D007
	XACT_S_ABORTING                                                           Handle        = 0x0004D008
	XACT_S_SINGLEPHASE                                                        Handle        = 0x0004D009
	XACT_S_LOCALLY_OK                                                         Handle        = 0x0004D00A
	XACT_S_LASTRESOURCEMANAGER                                                Handle        = 0x0004D010
	CONTEXT_E_FIRST                                                           syscall.Errno = 0x8004E000
	CONTEXT_E_LAST                                                            syscall.Errno = 0x8004E02F
	CONTEXT_S_FIRST                                                           syscall.Errno = 0x0004E000
	CONTEXT_S_LAST                                                            syscall.Errno = 0x0004E02F
	CONTEXT_E_ABORTED                                                         Handle        = 0x8004E002
	CONTEXT_E_ABORTING                                                        Handle        = 0x8004E003
	CONTEXT_E_NOCONTEXT                                                       Handle        = 0x8004E004
	CONTEXT_E_WOULD_DEADLOCK                                                  Handle        = 0x8004E005
	CONTEXT_E_SYNCH_TIMEOUT                                                   Handle        = 0x8004E006
	CONTEXT_E_OLDREF                                                          Handle        = 0x8004E007
	CONTEXT_E_ROLENOTFOUND                                                    Handle        = 0x8004E00C
	CONTEXT_E_TMNOTAVAILABLE                                                  Handle        = 0x8004E00F
	CO_E_ACTIVATIONFAILED                                                     Handle        = 0x8004E021
	CO_E_ACTIVATIONFAILED_EVENTLOGGED                                         Handle        = 0x8004E022
	CO_E_ACTIVATIONFAILED_CATALOGERROR                                        Handle        = 0x8004E023
	CO_E_ACTIVATIONFAILED_TIMEOUT                                             Handle        = 0x8004E024
	CO_E_INITIALIZATIONFAILED                                                 Handle        = 0x8004E025
	CONTEXT_E_NOJIT                                                           Handle        = 0x8004E026
	CONTEXT_E_NOTRANSACTION                                                   Handle        = 0x8004E027
	CO_E_THREADINGMODEL_CHANGED                                               Handle        = 0x8004E028
	CO_E_NOIISINTRINSICS                                                      Handle        = 0x8004E029
	CO_E_NOCOOKIES                                                            Handle        = 0x8004E02A
	CO_E_DBERROR                                                              Handle        = 0x8004E02B
	CO_E_NOTPOOLED                                                            Handle        = 0x8004E02C
	CO_E_NOTCONSTRUCTED                                                       Handle        = 0x8004E02D
	CO_E_NOSYNCHRONIZATION                                                    Handle        = 0x8004E02E
	CO_E_ISOLEVELMISMATCH                                                     Handle        = 0x8004E02F
	CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED                                     Handle        = 0x8004E030
	CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED                                    Handle        = 0x8004E031
	OLE_S_USEREG                                                              Handle        = 0x00040000
	OLE_S_STATIC                                                              Handle        = 0x00040001
	OLE_S_MAC_CLIPFORMAT                                                      Handle        = 0x00040002
	DRAGDROP_S_DROP                                                           Handle        = 0x00040100
	DRAGDROP_S_CANCEL                                                         Handle        = 0x00040101
	DRAGDROP_S_USEDEFAULTCURSORS                                              Handle        = 0x00040102
	DATA_S_SAMEFORMATETC                                                      Handle        = 0x00040130
	VIEW_S_ALREADY_FROZEN                                                     Handle        = 0x00040140
	CACHE_S_FORMATETC_NOTSUPPORTED                                            Handle        = 0x00040170
	CACHE_S_SAMECACHE                                                         Handle        = 0x00040171
	CACHE_S_SOMECACHES_NOTUPDATED                                             Handle        = 0x00040172
	OLEOBJ_S_INVALIDVERB                                                      Handle        = 0x00040180
	OLEOBJ_S_CANNOT_DOVERB_NOW                                                Handle        = 0x00040181
	OLEOBJ_S_INVALIDHWND                                                      Handle        = 0x00040182
	INPLACE_S_TRUNCATED                                                       Handle        = 0x000401A0
	CONVERT10_S_NO_PRESENTATION                                               Handle        = 0x000401C0
	MK_S_REDUCED_TO_SELF                                                      Handle        = 0x000401E2
	MK_S_ME                                                                   Handle        = 0x000401E4
	MK_S_HIM                                                                  Handle        = 0x000401E5
	MK_S_US                                                                   Handle        = 0x000401E6
	MK_S_MONIKERALREADYREGISTERED                                             Handle        = 0x000401E7
	SCHED_S_TASK_READY                                                        Handle        = 0x00041300
	SCHED_S_TASK_RUNNING                                                      Handle        = 0x00041301
	SCHED_S_TASK_DISABLED                                                     Handle        = 0x00041302
	SCHED_S_TASK_HAS_NOT_RUN                                                  Handle        = 0x00041303
	SCHED_S_TASK_NO_MORE_RUNS                                                 Handle        = 0x00041304
	SCHED_S_TASK_NOT_SCHEDULED                                                Handle        = 0x00041305
	SCHED_S_TASK_TERMINATED                                                   Handle        = 0x00041306
	SCHED_S_TASK_NO_VALID_TRIGGERS                                            Handle        = 0x00041307
	SCHED_S_EVENT_TRIGGER                                                     Handle        = 0x00041308
	SCHED_E_TRIGGER_NOT_FOUND                                                 Handle        = 0x80041309
	SCHED_E_TASK_NOT_READY                                                    Handle        = 0x8004130A
	SCHED_E_TASK_NOT_RUNNING                                                  Handle        = 0x8004130B
	SCHED_E_SERVICE_NOT_INSTALLED                                             Handle        = 0x8004130C
	SCHED_E_CANNOT_OPEN_TASK                                                  Handle        = 0x8004130D
	SCHED_E_INVALID_TASK                                                      Handle        = 0x8004130E
	SCHED_E_ACCOUNT_INFORMATION_NOT_SET                                       Handle        = 0x8004130F
	SCHED_E_ACCOUNT_NAME_NOT_FOUND                                            Handle        = 0x80041310
	SCHED_E_ACCOUNT_DBASE_CORRUPT                                             Handle        = 0x80041311
	SCHED_E_NO_SECURITY_SERVICES                                              Handle        = 0x80041312
	SCHED_E_UNKNOWN_OBJECT_VERSION                                            Handle        = 0x80041313
	SCHED_E_UNSUPPORTED_ACCOUNT_OPTION                                        Handle        = 0x80041314
	SCHED_E_SERVICE_NOT_RUNNING                                               Handle        = 0x80041315
	SCHED_E_UNEXPECTEDNODE                                                    Handle        = 0x80041316
	SCHED_E_NAMESPACE                                                         Handle        = 0x80041317
	SCHED_E_INVALIDVALUE                                                      Handle        = 0x80041318
	SCHED_E_MISSINGNODE                                                       Handle        = 0x80041319
	SCHED_E_MALFORMEDXML                                                      Handle        = 0x8004131A
	SCHED_S_SOME_TRIGGERS_FAILED                                              Handle        = 0x0004131B
	SCHED_S_BATCH_LOGON_PROBLEM                                               Handle        = 0x0004131C
	SCHED_E_TOO_MANY_NODES                                                    Handle        = 0x8004131D
	SCHED_E_PAST_END_BOUNDARY                                                 Handle        = 0x8004131E
	SCHED_E_ALREADY_RUNNING                                                   Handle        = 0x8004131F
	SCHED_E_USER_NOT_LOGGED_ON                                                Handle        = 0x80041320
	SCHED_E_INVALID_TASK_HASH                                                 Handle        = 0x80041321
	SCHED_E_SERVICE_NOT_AVAILABLE                                             Handle        = 0x80041322
	SCHED_E_SERVICE_TOO_BUSY                                                  Handle        = 0x80041323
	SCHED_E_TASK_ATTEMPTED                                                    Handle        = 0x80041324
	SCHED_S_TASK_QUEUED                                                       Handle        = 0x00041325
	SCHED_E_TASK_DISABLED                                                     Handle        = 0x80041326
	SCHED_E_TASK_NOT_V1_COMPAT                                                Handle        = 0x80041327
	SCHED_E_START_ON_DEMAND                                                   Handle        = 0x80041328
	SCHED_E_TASK_NOT_UBPM_COMPAT                                              Handle        = 0x80041329
	SCHED_E_DEPRECATED_FEATURE_USED                                           Handle        = 0x80041330
	CO_E_CLASS_CREATE_FAILED                                                  Handle        = 0x80080001
	CO_E_SCM_ERROR                                                            Handle        = 0x80080002
	CO_E_SCM_RPC_FAILURE                                                      Handle        = 0x80080003
	CO_E_BAD_PATH                                                             Handle        = 0x80080004
	CO_E_SERVER_EXEC_FAILURE                                                  Handle        = 0x80080005
	CO_E_OBJSRV_RPC_FAILURE                                                   Handle        = 0x80080006
	MK_E_NO_NORMALIZED                                                        Handle        = 0x80080007
	CO_E_SERVER_STOPPING                                                      Handle        = 0x80080008
	MEM_E_INVALID_ROOT                                                        Handle        = 0x80080009
	MEM_E_INVALID_LINK                                                        Handle        = 0x80080010
	MEM_E_INVALID_SIZE                                                        Handle        = 0x80080011
	CO_S_NOTALLINTERFACES                                                     Handle        = 0x00080012
	CO_S_MACHINENAMENOTFOUND                                                  Handle        = 0x00080013
	CO_E_MISSING_DISPLAYNAME                                                  Handle        = 0x80080015
	CO_E_RUNAS_VALUE_MUST_BE_AAA                                              Handle        = 0x80080016
	CO_E_ELEVATION_DISABLED                                                   Handle        = 0x80080017
	APPX_E_PACKAGING_INTERNAL                                                 Handle        = 0x80080200
	APPX_E_INTERLEAVING_NOT_ALLOWED                                           Handle        = 0x80080201
	APPX_E_RELATIONSHIPS_NOT_ALLOWED                                          Handle        = 0x80080202
	APPX_E_MISSING_REQUIRED_FILE                                              Handle        = 0x80080203
	APPX_E_INVALID_MANIFEST                                                   Handle        = 0x80080204
	APPX_E_INVALID_BLOCKMAP                                                   Handle        = 0x80080205
	APPX_E_CORRUPT_CONTENT                                                    Handle        = 0x80080206
	APPX_E_BLOCK_HASH_INVALID                                                 Handle        = 0x80080207
	APPX_E_REQUESTED_RANGE_TOO_LARGE                                          Handle        = 0x80080208
	APPX_E_INVALID_SIP_CLIENT_DATA                                            Handle        = 0x80080209
	APPX_E_INVALID_KEY_INFO                                                   Handle        = 0x8008020A
	APPX_E_INVALID_CONTENTGROUPMAP                                            Handle        = 0x8008020B
	APPX_E_INVALID_APPINSTALLER                                               Handle        = 0x8008020C
	APPX_E_DELTA_BASELINE_VERSION_MISMATCH                                    Handle        = 0x8008020D
	APPX_E_DELTA_PACKAGE_MISSING_FILE                                         Handle        = 0x8008020E
	APPX_E_INVALID_DELTA_PACKAGE                                              Handle        = 0x8008020F
	APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED                                 Handle        = 0x80080210
	APPX_E_INVALID_PACKAGING_LAYOUT                                           Handle        = 0x80080211
	APPX_E_INVALID_PACKAGESIGNCONFIG                                          Handle        = 0x80080212
	APPX_E_RESOURCESPRI_NOT_ALLOWED                                           Handle        = 0x80080213
	APPX_E_FILE_COMPRESSION_MISMATCH                                          Handle        = 0x80080214
	APPX_E_INVALID_PAYLOAD_PACKAGE_EXTENSION                                  Handle        = 0x80080215
	APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST                             Handle        = 0x80080216
	BT_E_SPURIOUS_ACTIVATION                                                  Handle        = 0x80080300
	DISP_E_UNKNOWNINTERFACE                                                   Handle        = 0x80020001
	DISP_E_MEMBERNOTFOUND                                                     Handle        = 0x80020003
	DISP_E_PARAMNOTFOUND                                                      Handle        = 0x80020004
	DISP_E_TYPEMISMATCH                                                       Handle        = 0x80020005
	DISP_E_UNKNOWNNAME                                                        Handle        = 0x80020006
	DISP_E_NONAMEDARGS                                                        Handle        = 0x80020007
	DISP_E_BADVARTYPE                                                         Handle        = 0x80020008
	DISP_E_EXCEPTION                                                          Handle        = 0x80020009
	DISP_E_OVERFLOW                                                           Handle        = 0x8002000A
	DISP_E_BADINDEX                                                           Handle        = 0x8002000B
	DISP_E_UNKNOWNLCID                                                        Handle        = 0x8002000C
	DISP_E_ARRAYISLOCKED                                                      Handle        = 0x8002000D
	DISP_E_BADPARAMCOUNT                                                      Handle        = 0x8002000E
	DISP_E_PARAMNOTOPTIONAL                                                   Handle        = 0x8002000F
	DISP_E_BADCALLEE                                                          Handle        = 0x80020010
	DISP_E_NOTACOLLECTION                                                     Handle        = 0x80020011
	DISP_E_DIVBYZERO                                                          Handle        = 0x80020012
	DISP_E_BUFFERTOOSMALL                                                     Handle        = 0x80020013
	TYPE_E_BUFFERTOOSMALL                                                     Handle        = 0x80028016
	TYPE_E_FIELDNOTFOUND                                                      Handle        = 0x80028017
	TYPE_E_INVDATAREAD                                                        Handle        = 0x80028018
	TYPE_E_UNSUPFORMAT                                                        Handle        = 0x80028019
	TYPE_E_REGISTRYACCESS                                                     Handle        = 0x8002801C
	TYPE_E_LIBNOTREGISTERED                                                   Handle        = 0x8002801D
	TYPE_E_UNDEFINEDTYPE                                                      Handle        = 0x80028027
	TYPE_E_QUALIFIEDNAMEDISALLOWED                                            Handle        = 0x80028028
	TYPE_E_INVALIDSTATE                                                       Handle        = 0x80028029
	TYPE_E_WRONGTYPEKIND                                                      Handle        = 0x8002802A
	TYPE_E_ELEMENTNOTFOUND                                                    Handle        = 0x8002802B
	TYPE_E_AMBIGUOUSNAME                                                      Handle        = 0x8002802C
	TYPE_E_NAMECONFLICT                                                       Handle        = 0x8002802D
	TYPE_E_UNKNOWNLCID                                                        Handle        = 0x8002802E
	TYPE_E_DLLFUNCTIONNOTFOUND                                                Handle        = 0x8002802F
	TYPE_E_BADMODULEKIND                                                      Handle        = 0x800288BD
	TYPE_E_SIZETOOBIG                                                         Handle        = 0x800288C5
	TYPE_E_DUPLICATEID                                                        Handle        = 0x800288C6
	TYPE_E_INVALIDID                                                          Handle        = 0x800288CF
	TYPE_E_TYPEMISMATCH                                                       Handle        = 0x80028CA0
	TYPE_E_OUTOFBOUNDS                                                        Handle        = 0x80028CA1
	TYPE_E_IOERROR                                                            Handle        = 0x80028CA2
	TYPE_E_CANTCREATETMPFILE                                                  Handle        = 0x80028CA3
	TYPE_E_CANTLOADLIBRARY                                                    Handle        = 0x80029C4A
	TYPE_E_INCONSISTENTPROPFUNCS                                              Handle        = 0x80029C83
	TYPE_E_CIRCULARTYPE                                                       Handle        = 0x80029C84
	STG_E_INVALIDFUNCTION                                                     Handle        = 0x80030001
	STG_E_FILENOTFOUND                                                        Handle        = 0x80030002
	STG_E_PATHNOTFOUND                                                        Handle        = 0x80030003
	STG_E_TOOMANYOPENFILES                                                    Handle        = 0x80030004
	STG_E_ACCESSDENIED                                                        Handle        = 0x80030005
	STG_E_INVALIDHANDLE                                                       Handle        = 0x80030006
	STG_E_INSUFFICIENTMEMORY                                                  Handle        = 0x80030008
	STG_E_INVALIDPOINTER                                                      Handle        = 0x80030009
	STG_E_NOMOREFILES                                                         Handle        = 0x80030012
	STG_E_DISKISWRITEPROTECTED                                                Handle        = 0x80030013
	STG_E_SEEKERROR                                                           Handle        = 0x80030019
	STG_E_WRITEFAULT                                                          Handle        = 0x8003001D
	STG_E_READFAULT                                                           Handle        = 0x8003001E
	STG_E_SHAREVIOLATION                                                      Handle        = 0x80030020
	STG_E_LOCKVIOLATION                                                       Handle        = 0x80030021
	STG_E_FILEALREADYEXISTS                                                   Handle        = 0x80030050
	STG_E_INVALIDPARAMETER                                                    Handle        = 0x80030057
	STG_E_MEDIUMFULL                                                          Handle        = 0x80030070
	STG_E_PROPSETMISMATCHED                                                   Handle        = 0x800300F0
	STG_E_ABNORMALAPIEXIT                                                     Handle        = 0x800300FA
	STG_E_INVALIDHEADER                                                       Handle        = 0x800300FB
	STG_E_INVALIDNAME                                                         Handle        = 0x800300FC
	STG_E_UNKNOWN                                                             Handle        = 0x800300FD
	STG_E_UNIMPLEMENTEDFUNCTION                                               Handle        = 0x800300FE
	STG_E_INVALIDFLAG                                                         Handle        = 0x800300FF
	STG_E_INUSE                                                               Handle        = 0x80030100
	STG_E_NOTCURRENT                                                          Handle        = 0x80030101
	STG_E_REVERTED                                                            Handle        = 0x80030102
	STG_E_CANTSAVE                                                            Handle        = 0x80030103
	STG_E_OLDFORMAT                                                           Handle        = 0x80030104
	STG_E_OLDDLL                                                              Handle        = 0x80030105
	STG_E_SHAREREQUIRED                                                       Handle        = 0x80030106
	STG_E_NOTFILEBASEDSTORAGE                                                 Handle        = 0x80030107
	STG_E_EXTANTMARSHALLINGS                                                  Handle        = 0x80030108
	STG_E_DOCFILECORRUPT                                                      Handle        = 0x80030109
	STG_E_BADBASEADDRESS                                                      Handle        = 0x80030110
	STG_E_DOCFILETOOLARGE                                                     Handle        = 0x80030111
	STG_E_NOTSIMPLEFORMAT                                                     Handle        = 0x80030112
	STG_E_INCOMPLETE                                                          Handle        = 0x80030201
	STG_E_TERMINATED                                                          Handle        = 0x80030202
	STG_S_CONVERTED                                                           Handle        = 0x00030200
	STG_S_BLOCK                                                               Handle        = 0x00030201
	STG_S_RETRYNOW                                                            Handle        = 0x00030202
	STG_S_MONITORING                                                          Handle        = 0x00030203
	STG_S_MULTIPLEOPENS                                                       Handle        = 0x00030204
	STG_S_CONSOLIDATIONFAILED                                                 Handle        = 0x00030205
	STG_S_CANNOTCONSOLIDATE                                                   Handle        = 0x00030206
	STG_S_POWER_CYCLE_REQUIRED                                                Handle        = 0x00030207
	STG_E_FIRMWARE_SLOT_INVALID                                               Handle        = 0x80030208
	STG_E_FIRMWARE_IMAGE_INVALID                                              Handle        = 0x80030209
	STG_E_DEVICE_UNRESPONSIVE                                                 Handle        = 0x8003020A
	STG_E_STATUS_COPY_PROTECTION_FAILURE                                      Handle        = 0x80030305
	STG_E_CSS_AUTHENTICATION_FAILURE                                          Handle        = 0x80030306
	STG_E_CSS_KEY_NOT_PRESENT                                                 Handle        = 0x80030307
	STG_E_CSS_KEY_NOT_ESTABLISHED                                             Handle        = 0x80030308
	STG_E_CSS_SCRAMBLED_SECTOR                                                Handle        = 0x80030309
	STG_E_CSS_REGION_MISMATCH                                                 Handle        = 0x8003030A
	STG_E_RESETS_EXHAUSTED                                                    Handle        = 0x8003030B
	RPC_E_CALL_REJECTED                                                       Handle        = 0x80010001
	RPC_E_CALL_CANCELED                                                       Handle        = 0x80010002
	RPC_E_CANTPOST_INSENDCALL                                                 Handle        = 0x80010003
	RPC_E_CANTCALLOUT_INASYNCCALL                                             Handle        = 0x80010004
	RPC_E_CANTCALLOUT_INEXTERNALCALL                                          Handle        = 0x80010005
	RPC_E_CONNECTION_TERMINATED                                               Handle        = 0x80010006
	RPC_E_SERVER_DIED                                                         Handle        = 0x80010007
	RPC_E_CLIENT_DIED                                                         Handle        = 0x80010008
	RPC_E_INVALID_DATAPACKET                                                  Handle        = 0x80010009
	RPC_E_CANTTRANSMIT_CALL                                                   Handle        = 0x8001000A
	RPC_E_CLIENT_CANTMARSHAL_DATA                                             Handle        = 0x8001000B
	RPC_E_CLIENT_CANTUNMARSHAL_DATA                                           Handle        = 0x8001000C
	RPC_E_SERVER_CANTMARSHAL_DATA                                             Handle        = 0x8001000D
	RPC_E_SERVER_CANTUNMARSHAL_DATA                                           Handle        = 0x8001000E
	RPC_E_INVALID_DATA                                                        Handle        = 0x8001000F
	RPC_E_INVALID_PARAMETER                                                   Handle        = 0x80010010
	RPC_E_CANTCALLOUT_AGAIN                                                   Handle        = 0x80010011
	RPC_E_SERVER_DIED_DNE                                                     Handle        = 0x80010012
	RPC_E_SYS_CALL_FAILED                                                     Handle        = 0x80010100
	RPC_E_OUT_OF_RESOURCES                                                    Handle        = 0x80010101
	RPC_E_ATTEMPTED_MULTITHREAD                                               Handle        = 0x80010102
	RPC_E_NOT_REGISTERED                                                      Handle        = 0x80010103
	RPC_E_FAULT                                                               Handle        = 0x80010104
	RPC_E_SERVERFAULT                                                         Handle        = 0x80010105
	RPC_E_CHANGED_MODE                                                        Handle        = 0x80010106
	RPC_E_INVALIDMETHOD                                                       Handle        = 0x80010107
	RPC_E_DISCONNECTED                                                        Handle        = 0x80010108
	RPC_E_RETRY                                                               Handle        = 0x80010109
	RPC_E_SERVERCALL_RETRYLATER                                               Handle        = 0x8001010A
	RPC_E_SERVERCALL_REJECTED                                                 Handle        = 0x8001010B
	RPC_E_INVALID_CALLDATA                                                    Handle        = 0x8001010C
	RPC_E_CANTCALLOUT_ININPUTSYNCCALL                                         Handle        = 0x8001010D
	RPC_E_WRONG_THREAD                                                        Handle        = 0x8001010E
	RPC_E_THREAD_NOT_INIT                                                     Handle        = 0x8001010F
	RPC_E_VERSION_MISMATCH                                                    Handle        = 0x80010110
	RPC_E_INVALID_HEADER                                                      Handle        = 0x80010111
	RPC_E_INVALID_EXTENSION                                                   Handle        = 0x80010112
	RPC_E_INVALID_IPID                                                        Handle        = 0x80010113
	RPC_E_INVALID_OBJECT                                                      Handle        = 0x80010114
	RPC_S_CALLPENDING                                                         Handle        = 0x80010115
	RPC_S_WAITONTIMER                                                         Handle        = 0x80010116
	RPC_E_CALL_COMPLETE                                                       Handle        = 0x80010117
	RPC_E_UNSECURE_CALL                                                       Handle        = 0x80010118
	RPC_E_TOO_LATE                                                            Handle        = 0x80010119
	RPC_E_NO_GOOD_SECURITY_PACKAGES                                           Handle        = 0x8001011A
	RPC_E_ACCESS_DENIED                                                       Handle        = 0x8001011B
	RPC_E_REMOTE_DISABLED                                                     Handle        = 0x8001011C
	RPC_E_INVALID_OBJREF                                                      Handle        = 0x8001011D
	RPC_E_NO_CONTEXT                                                          Handle        = 0x8001011E
	RPC_E_TIMEOUT                                                             Handle        = 0x8001011F
	RPC_E_NO_SYNC                                                             Handle        = 0x80010120
	RPC_E_FULLSIC_REQUIRED                                                    Handle        = 0x80010121
	RPC_E_INVALID_STD_NAME                                                    Handle        = 0x80010122
	CO_E_FAILEDTOIMPERSONATE                                                  Handle        = 0x80010123
	CO_E_FAILEDTOGETSECCTX                                                    Handle        = 0x80010124
	CO_E_FAILEDTOOPENTHREADTOKEN                                              Handle        = 0x80010125
	CO_E_FAILEDTOGETTOKENINFO                                                 Handle        = 0x80010126
	CO_E_TRUSTEEDOESNTMATCHCLIENT                                             Handle        = 0x80010127
	CO_E_FAILEDTOQUERYCLIENTBLANKET                                           Handle        = 0x80010128
	CO_E_FAILEDTOSETDACL                                                      Handle        = 0x80010129
	CO_E_ACCESSCHECKFAILED                                                    Handle        = 0x8001012A
	CO_E_NETACCESSAPIFAILED                                                   Handle        = 0x8001012B
	CO_E_WRONGTRUSTEENAMESYNTAX                                               Handle        = 0x8001012C
	CO_E_INVALIDSID                                                           Handle        = 0x8001012D
	CO_E_CONVERSIONFAILED                                                     Handle        = 0x8001012E
	CO_E_NOMATCHINGSIDFOUND                                                   Handle        = 0x8001012F
	CO_E_LOOKUPACCSIDFAILED                                                   Handle        = 0x80010130
	CO_E_NOMATCHINGNAMEFOUND                                                  Handle        = 0x80010131
	CO_E_LOOKUPACCNAMEFAILED                                                  Handle        = 0x80010132
	CO_E_SETSERLHNDLFAILED                                                    Handle        = 0x80010133
	CO_E_FAILEDTOGETWINDIR                                                    Handle        = 0x80010134
	CO_E_PATHTOOLONG                                                          Handle        = 0x80010135
	CO_E_FAILEDTOGENUUID                                                      Handle        = 0x80010136
	CO_E_FAILEDTOCREATEFILE                                                   Handle        = 0x80010137
	CO_E_FAILEDTOCLOSEHANDLE                                                  Handle        = 0x80010138
	CO_E_EXCEEDSYSACLLIMIT                                                    Handle        = 0x80010139
	CO_E_ACESINWRONGORDER                                                     Handle        = 0x8001013A
	CO_E_INCOMPATIBLESTREAMVERSION                                            Handle        = 0x8001013B
	CO_E_FAILEDTOOPENPROCESSTOKEN                                             Handle        = 0x8001013C
	CO_E_DECODEFAILED                                                         Handle        = 0x8001013D
	CO_E_ACNOTINITIALIZED                                                     Handle        = 0x8001013F
	CO_E_CANCEL_DISABLED                                                      Handle        = 0x80010140
	RPC_E_UNEXPECTED                                                          Handle        = 0x8001FFFF
	ERROR_AUDITING_DISABLED                                                   Handle        = 0xC0090001
	ERROR_ALL_SIDS_FILTERED                                                   Handle        = 0xC0090002
	ERROR_BIZRULES_NOT_ENABLED                                                Handle        = 0xC0090003
	NTE_BAD_UID                                                               Handle        = 0x80090001
	NTE_BAD_HASH                                                              Handle        = 0x80090002
	NTE_BAD_KEY                                                               Handle        = 0x80090003
	NTE_BAD_LEN                                                               Handle        = 0x80090004
	NTE_BAD_DATA                                                              Handle        = 0x80090005
	NTE_BAD_SIGNATURE                                                         Handle        = 0x80090006
	NTE_BAD_VER                                                               Handle        = 0x80090007
	NTE_BAD_ALGID                                                             Handle        = 0x80090008
	NTE_BAD_FLAGS                                                             Handle        = 0x80090009
	NTE_BAD_TYPE                                                              Handle        = 0x8009000A
	NTE_BAD_KEY_STATE                                                         Handle        = 0x8009000B
	NTE_BAD_HASH_STATE                                                        Handle        = 0x8009000C
	NTE_NO_KEY                                                                Handle        = 0x8009000D
	NTE_NO_MEMORY                                                             Handle        = 0x8009000E
	NTE_EXISTS                                                                Handle        = 0x8009000F
	NTE_PERM                                                                  Handle        = 0x80090010
	NTE_NOT_FOUND                                                             Handle        = 0x80090011
	NTE_DOUBLE_ENCRYPT                                                        Handle        = 0x80090012
	NTE_BAD_PROVIDER                                                          Handle        = 0x80090013
	NTE_BAD_PROV_TYPE                                                         Handle        = 0x80090014
	NTE_BAD_PUBLIC_KEY                                                        Handle        = 0x80090015
	NTE_BAD_KEYSET                                                            Handle        = 0x80090016
	NTE_PROV_TYPE_NOT_DEF                                                     Handle        = 0x80090017
	NTE_PROV_TYPE_ENTRY_BAD                                                   Handle        = 0x80090018
	NTE_KEYSET_NOT_DEF                                                        Handle        = 0x80090019
	NTE_KEYSET_ENTRY_BAD                                                      Handle        = 0x8009001A
	NTE_PROV_TYPE_NO_MATCH                                                    Handle        = 0x8009001B
	NTE_SIGNATURE_FILE_BAD                                                    Handle        = 0x8009001C
	NTE_PROVIDER_DLL_FAIL                                                     Handle        = 0x8009001D
	NTE_PROV_DLL_NOT_FOUND                                                    Handle        = 0x8009001E
	NTE_BAD_KEYSET_PARAM                                                      Handle        = 0x8009001F
	NTE_FAIL                                                                  Handle        = 0x80090020
	NTE_SYS_ERR                                                               Handle        = 0x80090021
	NTE_SILENT_CONTEXT                                                        Handle        = 0x80090022
	NTE_TOKEN_KEYSET_STORAGE_FULL                                             Handle        = 0x80090023
	NTE_TEMPORARY_PROFILE                                                     Handle        = 0x80090024
	NTE_FIXEDPARAMETER                                                        Handle        = 0x80090025
	NTE_INVALID_HANDLE                                                        Handle        = 0x80090026
	NTE_INVALID_PARAMETER                                                     Handle        = 0x80090027
	NTE_BUFFER_TOO_SMALL                                                      Handle        = 0x80090028
	NTE_NOT_SUPPORTED                                                         Handle        = 0x80090029
	NTE_NO_MORE_ITEMS                                                         Handle        = 0x8009002A
	NTE_BUFFERS_OVERLAP                                                       Handle        = 0x8009002B
	NTE_DECRYPTION_FAILURE                                                    Handle        = 0x8009002C
	NTE_INTERNAL_ERROR                                                        Handle        = 0x8009002D
	NTE_UI_REQUIRED                                                           Handle        = 0x8009002E
	NTE_HMAC_NOT_SUPPORTED                                                    Handle        = 0x8009002F
	NTE_DEVICE_NOT_READY                                                      Handle        = 0x80090030
	NTE_AUTHENTICATION_IGNORED                                                Handle        = 0x80090031
	NTE_VALIDATION_FAILED                                                     Handle        = 0x80090032
	NTE_INCORRECT_PASSWORD                                                    Handle        = 0x80090033
	NTE_ENCRYPTION_FAILURE                                                    Handle        = 0x80090034
	NTE_DEVICE_NOT_FOUND                                                      Handle        = 0x80090035
	NTE_USER_CANCELLED                                                        Handle        = 0x80090036
	NTE_PASSWORD_CHANGE_REQUIRED                                              Handle        = 0x80090037
	NTE_NOT_ACTIVE_CONSOLE                                                    Handle        = 0x80090038
	SEC_E_INSUFFICIENT_MEMORY                                                 Handle        = 0x80090300
	SEC_E_INVALID_HANDLE                                                      Handle        = 0x80090301
	SEC_E_UNSUPPORTED_FUNCTION                                                Handle        = 0x80090302
	SEC_E_TARGET_UNKNOWN                                                      Handle        = 0x80090303
	SEC_E_INTERNAL_ERROR                                                      Handle        = 0x80090304
	SEC_E_SECPKG_NOT_FOUND                                                    Handle        = 0x80090305
	SEC_E_NOT_OWNER                                                           Handle        = 0x80090306
	SEC_E_CANNOT_INSTALL                                                      Handle        = 0x80090307
	SEC_E_INVALID_TOKEN                                                       Handle        = 0x80090308
	SEC_E_CANNOT_PACK                                                         Handle        = 0x80090309
	SEC_E_QOP_NOT_SUPPORTED                                                   Handle        = 0x8009030A
	SEC_E_NO_IMPERSONATION                                                    Handle        = 0x8009030B
	SEC_E_LOGON_DENIED                                                        Handle        = 0x8009030C
	SEC_E_UNKNOWN_CREDENTIALS                                                 Handle        = 0x8009030D
	SEC_E_NO_CREDENTIALS                                                      Handle        = 0x8009030E
	SEC_E_MESSAGE_ALTERED                                                     Handle        = 0x8009030F
	SEC_E_OUT_OF_SEQUENCE                                                     Handle        = 0x80090310
	SEC_E_NO_AUTHENTICATING_AUTHORITY                                         Handle        = 0x80090311
	SEC_I_CONTINUE_NEEDED                                                     Handle        = 0x00090312
	SEC_I_COMPLETE_NEEDED                                                     Handle        = 0x00090313
	SEC_I_COMPLETE_AND_CONTINUE                                               Handle        = 0x00090314
	SEC_I_LOCAL_LOGON                                                         Handle        = 0x00090315
	SEC_E_BAD_PKGID                                                           Handle        = 0x80090316
	SEC_E_CONTEXT_EXPIRED                                                     Handle        = 0x80090317
	SEC_I_CONTEXT_EXPIRED                                                     Handle        = 0x00090317
	SEC_E_INCOMPLETE_MESSAGE                                                  Handle        = 0x80090318
	SEC_E_INCOMPLETE_CREDENTIALS                                              Handle        = 0x80090320
	SEC_E_BUFFER_TOO_SMALL                                                    Handle        = 0x80090321
	SEC_I_INCOMPLETE_CREDENTIALS                                              Handle        = 0x00090320
	SEC_I_RENEGOTIATE                                                         Handle        = 0x00090321
	SEC_E_WRONG_PRINCIPAL                                                     Handle        = 0x80090322
	SEC_I_NO_LSA_CONTEXT                                                      Handle        = 0x00090323
	SEC_E_TIME_SKEW                                                           Handle        = 0x80090324
	SEC_E_UNTRUSTED_ROOT                                                      Handle        = 0x80090325
	SEC_E_ILLEGAL_MESSAGE                                                     Handle        = 0x80090326
	SEC_E_CERT_UNKNOWN                                                        Handle        = 0x80090327
	SEC_E_CERT_EXPIRED                                                        Handle        = 0x80090328
	SEC_E_ENCRYPT_FAILURE                                                     Handle        = 0x80090329
	SEC_E_DECRYPT_FAILURE                                                     Handle        = 0x80090330
	SEC_E_ALGORITHM_MISMATCH                                                  Handle        = 0x80090331
	SEC_E_SECURITY_QOS_FAILED                                                 Handle        = 0x80090332
	SEC_E_UNFINISHED_CONTEXT_DELETED                                          Handle        = 0x80090333
	SEC_E_NO_TGT_REPLY                                                        Handle        = 0x80090334
	SEC_E_NO_IP_ADDRESSES                                                     Handle        = 0x80090335
	SEC_E_WRONG_CREDENTIAL_HANDLE                                             Handle        = 0x80090336
	SEC_E_CRYPTO_SYSTEM_INVALID                                               Handle        = 0x80090337
	SEC_E_MAX_REFERRALS_EXCEEDED                                              Handle        = 0x80090338
	SEC_E_MUST_BE_KDC                                                         Handle        = 0x80090339
	SEC_E_STRONG_CRYPTO_NOT_SUPPORTED                                         Handle        = 0x8009033A
	SEC_E_TOO_MANY_PRINCIPALS                                                 Handle        = 0x8009033B
	SEC_E_NO_PA_DATA                                                          Handle        = 0x8009033C
	SEC_E_PKINIT_NAME_MISMATCH                                                Handle        = 0x8009033D
	SEC_E_SMARTCARD_LOGON_REQUIRED                                            Handle        = 0x8009033E
	SEC_E_SHUTDOWN_IN_PROGRESS                                                Handle        = 0x8009033F
	SEC_E_KDC_INVALID_REQUEST                                                 Handle        = 0x80090340
	SEC_E_KDC_UNABLE_TO_REFER                                                 Handle        = 0x80090341
	SEC_E_KDC_UNKNOWN_ETYPE                                                   Handle        = 0x80090342
	SEC_E_UNSUPPORTED_PREAUTH                                                 Handle        = 0x80090343
	SEC_E_DELEGATION_REQUIRED                                                 Handle        = 0x80090345
	SEC_E_BAD_BINDINGS                                                        Handle        = 0x80090346
	SEC_E_MULTIPLE_ACCOUNTS                                                   Handle        = 0x80090347
	SEC_E_NO_KERB_KEY                                                         Handle        = 0x80090348
	SEC_E_CERT_WRONG_USAGE                                                    Handle        = 0x80090349
	SEC_E_DOWNGRADE_DETECTED                                                  Handle        = 0x80090350
	SEC_E_SMARTCARD_CERT_REVOKED                                              Handle        = 0x80090351
	SEC_E_ISSUING_CA_UNTRUSTED                                                Handle        = 0x80090352
	SEC_E_REVOCATION_OFFLINE_C                                                Handle        = 0x80090353
	SEC_E_PKINIT_CLIENT_FAILURE                                               Handle        = 0x80090354
	SEC_E_SMARTCARD_CERT_EXPIRED                                              Handle        = 0x80090355
	SEC_E_NO_S4U_PROT_SUPPORT                                                 Handle        = 0x80090356
	SEC_E_CROSSREALM_DELEGATION_FAILURE                                       Handle        = 0x80090357
	SEC_E_REVOCATION_OFFLINE_KDC                                              Handle        = 0x80090358
	SEC_E_ISSUING_CA_UNTRUSTED_KDC                                            Handle        = 0x80090359
	SEC_E_KDC_CERT_EXPIRED                                                    Handle        = 0x8009035A
	SEC_E_KDC_CERT_REVOKED                                                    Handle        = 0x8009035B
	SEC_I_SIGNATURE_NEEDED                                                    Handle        = 0x0009035C
	SEC_E_INVALID_PARAMETER                                                   Handle        = 0x8009035D
	SEC_E_DELEGATION_POLICY                                                   Handle        = 0x8009035E
	SEC_E_POLICY_NLTM_ONLY                                                    Handle        = 0x8009035F
	SEC_I_NO_RENEGOTIATION                                                    Handle        = 0x00090360
	SEC_E_NO_CONTEXT                                                          Handle        = 0x80090361
	SEC_E_PKU2U_CERT_FAILURE                                                  Handle        = 0x80090362
	SEC_E_MUTUAL_AUTH_FAILED                                                  Handle        = 0x80090363
	SEC_I_MESSAGE_FRAGMENT                                                    Handle        = 0x00090364
	SEC_E_ONLY_HTTPS_ALLOWED                                                  Handle        = 0x80090365
	SEC_I_CONTINUE_NEEDED_MESSAGE_OK                                          Handle        = 0x00090366
	SEC_E_APPLICATION_PROTOCOL_MISMATCH                                       Handle        = 0x80090367
	SEC_I_ASYNC_CALL_PENDING                                                  Handle        = 0x00090368
	SEC_E_INVALID_UPN_NAME                                                    Handle        = 0x80090369
	SEC_E_NO_SPM                                                                            = SEC_E_INTERNAL_ERROR
	SEC_E_NOT_SUPPORTED                                                                     = SEC_E_UNSUPPORTED_FUNCTION
	CRYPT_E_MSG_ERROR                                                         Handle        = 0x80091001
	CRYPT_E_UNKNOWN_ALGO                                                      Handle        = 0x80091002
	CRYPT_E_OID_FORMAT                                                        Handle        = 0x80091003
	CRYPT_E_INVALID_MSG_TYPE                                                  Handle        = 0x80091004
	CRYPT_E_UNEXPECTED_ENCODING                                               Handle        = 0x80091005
	CRYPT_E_AUTH_ATTR_MISSING                                                 Handle        = 0x80091006
	CRYPT_E_HASH_VALUE                                                        Handle        = 0x80091007
	CRYPT_E_INVALID_INDEX                                                     Handle        = 0x80091008
	CRYPT_E_ALREADY_DECRYPTED                                                 Handle        = 0x80091009
	CRYPT_E_NOT_DECRYPTED                                                     Handle        = 0x8009100A
	CRYPT_E_RECIPIENT_NOT_FOUND                                               Handle        = 0x8009100B
	CRYPT_E_CONTROL_TYPE                                                      Handle        = 0x8009100C
	CRYPT_E_ISSUER_SERIALNUMBER                                               Handle        = 0x8009100D
	CRYPT_E_SIGNER_NOT_FOUND                                                  Handle        = 0x8009100E
	CRYPT_E_ATTRIBUTES_MISSING                                                Handle        = 0x8009100F
	CRYPT_E_STREAM_MSG_NOT_READY                                              Handle        = 0x80091010
	CRYPT_E_STREAM_INSUFFICIENT_DATA                                          Handle        = 0x80091011
	CRYPT_I_NEW_PROTECTION_REQUIRED                                           Handle        = 0x00091012
	CRYPT_E_BAD_LEN                                                           Handle        = 0x80092001
	CRYPT_E_BAD_ENCODE                                                        Handle        = 0x80092002
	CRYPT_E_FILE_ERROR                                                        Handle        = 0x80092003
	CRYPT_E_NOT_FOUND                                                         Handle        = 0x80092004
	CRYPT_E_EXISTS                                                            Handle        = 0x80092005
	CRYPT_E_NO_PROVIDER                                                       Handle        = 0x80092006
	CRYPT_E_SELF_SIGNED                                                       Handle        = 0x80092007
	CRYPT_E_DELETED_PREV                                                      Handle        = 0x80092008
	CRYPT_E_NO_MATCH                                                          Handle        = 0x80092009
	CRYPT_E_UNEXPECTED_MSG_TYPE                                               Handle        = 0x8009200A
	CRYPT_E_NO_KEY_PROPERTY                                                   Handle        = 0x8009200B
	CRYPT_E_NO_DECRYPT_CERT                                                   Handle        = 0x8009200C
	CRYPT_E_BAD_MSG                                                           Handle        = 0x8009200D
	CRYPT_E_NO_SIGNER                                                         Handle        = 0x8009200E
	CRYPT_E_PENDING_CLOSE                                                     Handle        = 0x8009200F
	CRYPT_E_REVOKED                                                           Handle        = 0x80092010
	CRYPT_E_NO_REVOCATION_DLL                                                 Handle        = 0x80092011
	CRYPT_E_NO_REVOCATION_CHECK                                               Handle        = 0x80092012
	CRYPT_E_REVOCATION_OFFLINE                                                Handle        = 0x80092013
	CRYPT_E_NOT_IN_REVOCATION_DATABASE                                        Handle        = 0x80092014
	CRYPT_E_INVALID_NUMERIC_STRING                                            Handle        = 0x80092020
	CRYPT_E_INVALID_PRINTABLE_STRING                                          Handle        = 0x80092021
	CRYPT_E_INVALID_IA5_STRING                                                Handle        = 0x80092022
	CRYPT_E_INVALID_X500_STRING                                               Handle        = 0x80092023
	CRYPT_E_NOT_CHAR_STRING                                                   Handle        = 0x80092024
	CRYPT_E_FILERESIZED                                                       Handle        = 0x80092025
	CRYPT_E_SECURITY_SETTINGS                                                 Handle        = 0x80092026
	CRYPT_E_NO_VERIFY_USAGE_DLL                                               Handle        = 0x80092027
	CRYPT_E_NO_VERIFY_USAGE_CHECK                                             Handle        = 0x80092028
	CRYPT_E_VERIFY_USAGE_OFFLINE                                              Handle        = 0x80092029
	CRYPT_E_NOT_IN_CTL                                                        Handle        = 0x8009202A
	CRYPT_E_NO_TRUSTED_SIGNER                                                 Handle        = 0x8009202B
	CRYPT_E_MISSING_PUBKEY_PARA                                               Handle        = 0x8009202C
	CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND                                   Handle        = 0x8009202D
	CRYPT_E_OSS_ERROR                                                         Handle        = 0x80093000
	OSS_MORE_BUF                                                              Handle        = 0x80093001
	OSS_NEGATIVE_UINTEGER                                                     Handle        = 0x80093002
	OSS_PDU_RANGE                                                             Handle        = 0x80093003
	OSS_MORE_INPUT                                                            Handle        = 0x80093004
	OSS_DATA_ERROR                                                            Handle        = 0x80093005
	OSS_BAD_ARG                                                               Handle        = 0x80093006
	OSS_BAD_VERSION                                                           Handle        = 0x80093007
	OSS_OUT_MEMORY                                                            Handle        = 0x80093008
	OSS_PDU_MISMATCH                                                          Handle        = 0x80093009
	OSS_LIMITED                                                               Handle        = 0x8009300A
	OSS_BAD_PTR                                                               Handle        = 0x8009300B
	OSS_BAD_TIME                                                              Handle        = 0x8009300C
	OSS_INDEFINITE_NOT_SUPPORTED                                              Handle        = 0x8009300D
	OSS_MEM_ERROR                                                             Handle        = 0x8009300E
	OSS_BAD_TABLE                                                             Handle        = 0x8009300F
	OSS_TOO_LONG                                                              Handle        = 0x80093010
	OSS_CONSTRAINT_VIOLATED                                                   Handle        = 0x80093011
	OSS_FATAL_ERROR                                                           Handle        = 0x80093012
	OSS_ACCESS_SERIALIZATION_ERROR                                            Handle        = 0x80093013
	OSS_NULL_TBL                                                              Handle        = 0x80093014
	OSS_NULL_FCN                                                              Handle        = 0x80093015
	OSS_BAD_ENCRULES                                                          Handle        = 0x80093016
	OSS_UNAVAIL_ENCRULES                                                      Handle        = 0x80093017
	OSS_CANT_OPEN_TRACE_WINDOW                                                Handle        = 0x80093018
	OSS_UNIMPLEMENTED                                                         Handle        = 0x80093019
	OSS_OID_DLL_NOT_LINKED                                                    Handle        = 0x8009301A
	OSS_CANT_OPEN_TRACE_FILE                                                  Handle        = 0x8009301B
	OSS_TRACE_FILE_ALREADY_OPEN                                               Handle        = 0x8009301C
	OSS_TABLE_MISMATCH                                                        Handle        = 0x8009301D
	OSS_TYPE_NOT_SUPPORTED                                                    Handle        = 0x8009301E
	OSS_REAL_DLL_NOT_LINKED                                                   Handle        = 0x8009301F
	OSS_REAL_CODE_NOT_LINKED                                                  Handle        = 0x80093020
	OSS_OUT_OF_RANGE                                                          Handle        = 0x80093021
	OSS_COPIER_DLL_NOT_LINKED                                                 Handle        = 0x80093022
	OSS_CONSTRAINT_DLL_NOT_LINKED                                             Handle        = 0x80093023
	OSS_COMPARATOR_DLL_NOT_LINKED                                             Handle        = 0x80093024
	OSS_COMPARATOR_CODE_NOT_LINKED                                            Handle        = 0x80093025
	OSS_MEM_MGR_DLL_NOT_LINKED                                                Handle        = 0x80093026
	OSS_PDV_DLL_NOT_LINKED                                                    Handle        = 0x80093027
	OSS_PDV_CODE_NOT_LINKED                                                   Handle        = 0x80093028
	OSS_API_DLL_NOT_LINKED                                                    Handle        = 0x80093029
	OSS_BERDER_DLL_NOT_LINKED                                                 Handle        = 0x8009302A
	OSS_PER_DLL_NOT_LINKED                                                    Handle        = 0x8009302B
	OSS_OPEN_TYPE_ERROR                                                       Handle        = 0x8009302C
	OSS_MUTEX_NOT_CREATED                                                     Handle        = 0x8009302D
	OSS_CANT_CLOSE_TRACE_FILE                                                 Handle        = 0x8009302E
	CRYPT_E_ASN1_ERROR                                                        Handle        = 0x80093100
	CRYPT_E_ASN1_INTERNAL                                                     Handle        = 0x80093101
	CRYPT_E_ASN1_EOD                                                          Handle        = 0x80093102
	CRYPT_E_ASN1_CORRUPT                                                      Handle        = 0x80093103
	CRYPT_E_ASN1_LARGE                                                        Handle        = 0x80093104
	CRYPT_E_ASN1_CONSTRAINT                                                   Handle        = 0x80093105
	CRYPT_E_ASN1_MEMORY                                                       Handle        = 0x80093106
	CRYPT_E_ASN1_OVERFLOW                                                     Handle        = 0x80093107
	CRYPT_E_ASN1_BADPDU                                                       Handle        = 0x80093108
	CRYPT_E_ASN1_BADARGS                                                      Handle        = 0x80093109
	CRYPT_E_ASN1_BADREAL                                                      Handle        = 0x8009310A
	CRYPT_E_ASN1_BADTAG                                                       Handle        = 0x8009310B
	CRYPT_E_ASN1_CHOICE                                                       Handle        = 0x8009310C
	CRYPT_E_ASN1_RULE                                                         Handle        = 0x8009310D
	CRYPT_E_ASN1_UTF8                                                         Handle        = 0x8009310E
	CRYPT_E_ASN1_PDU_TYPE                                                     Handle        = 0x80093133
	CRYPT_E_ASN1_NYI                                                          Handle        = 0x80093134
	CRYPT_E_ASN1_EXTENDED                                                     Handle        = 0x80093201
	CRYPT_E_ASN1_NOEOD                                                        Handle        = 0x80093202
	CERTSRV_E_BAD_REQUESTSUBJECT                                              Handle        = 0x80094001
	CERTSRV_E_NO_REQUEST                                                      Handle        = 0x80094002
	CERTSRV_E_BAD_REQUESTSTATUS                                               Handle        = 0x80094003
	CERTSRV_E_PROPERTY_EMPTY                                                  Handle        = 0x80094004
	CERTSRV_E_INVALID_CA_CERTIFICATE                                          Handle        = 0x80094005
	CERTSRV_E_SERVER_SUSPENDED                                                Handle        = 0x80094006
	CERTSRV_E_ENCODING_LENGTH                                                 Handle        = 0x80094007
	CERTSRV_E_ROLECONFLICT                                                    Handle        = 0x80094008
	CERTSRV_E_RESTRICTEDOFFICER                                               Handle        = 0x80094009
	CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED                                     Handle        = 0x8009400A
	CERTSRV_E_NO_VALID_KRA                                                    Handle        = 0x8009400B
	CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL                                        Handle        = 0x8009400C
	CERTSRV_E_NO_CAADMIN_DEFINED                                              Handle        = 0x8009400D
	CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE                                      Handle        = 0x8009400E
	CERTSRV_E_NO_DB_SESSIONS                                                  Handle        = 0x8009400F
	CERTSRV_E_ALIGNMENT_FAULT                                                 Handle        = 0x80094010
	CERTSRV_E_ENROLL_DENIED                                                   Handle        = 0x80094011
	CERTSRV_E_TEMPLATE_DENIED                                                 Handle        = 0x80094012
	CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE                                     Handle        = 0x80094013
	CERTSRV_E_ADMIN_DENIED_REQUEST                                            Handle        = 0x80094014
	CERTSRV_E_NO_POLICY_SERVER                                                Handle        = 0x80094015
	CERTSRV_E_WEAK_SIGNATURE_OR_KEY                                           Handle        = 0x80094016
	CERTSRV_E_KEY_ATTESTATION_NOT_SUPPORTED                                   Handle        = 0x80094017
	CERTSRV_E_ENCRYPTION_CERT_REQUIRED                                        Handle        = 0x80094018
	CERTSRV_E_UNSUPPORTED_CERT_TYPE                                           Handle        = 0x80094800
	CERTSRV_E_NO_CERT_TYPE                                                    Handle        = 0x80094801
	CERTSRV_E_TEMPLATE_CONFLICT                                               Handle        = 0x80094802
	CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED                                       Handle        = 0x80094803
	CERTSRV_E_ARCHIVED_KEY_REQUIRED                                           Handle        = 0x80094804
	CERTSRV_E_SMIME_REQUIRED                                                  Handle        = 0x80094805
	CERTSRV_E_BAD_RENEWAL_SUBJECT                                             Handle        = 0x80094806
	CERTSRV_E_BAD_TEMPLATE_VERSION                                            Handle        = 0x80094807
	CERTSRV_E_TEMPLATE_POLICY_REQUIRED                                        Handle        = 0x80094808
	CERTSRV_E_SIGNATURE_POLICY_REQUIRED                                       Handle        = 0x80094809
	CERTSRV_E_SIGNATURE_COUNT                                                 Handle        = 0x8009480A
	CERTSRV_E_SIGNATURE_REJECTED                                              Handle        = 0x8009480B
	CERTSRV_E_ISSUANCE_POLICY_REQUIRED                                        Handle        = 0x8009480C
	CERTSRV_E_SUBJECT_UPN_REQUIRED                                            Handle        = 0x8009480D
	CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED                                 Handle        = 0x8009480E
	CERTSRV_E_SUBJECT_DNS_REQUIRED                                            Handle        = 0x8009480F
	CERTSRV_E_ARCHIVED_KEY_UNEXPECTED                                         Handle        = 0x80094810
	CERTSRV_E_KEY_LENGTH                                                      Handle        = 0x80094811
	CERTSRV_E_SUBJECT_EMAIL_REQUIRED                                          Handle        = 0x80094812
	CERTSRV_E_UNKNOWN_CERT_TYPE                                               Handle        = 0x80094813
	CERTSRV_E_CERT_TYPE_OVERLAP                                               Handle        = 0x80094814
	CERTSRV_E_TOO_MANY_SIGNATURES                                             Handle        = 0x80094815
	CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY                                          Handle        = 0x80094816
	CERTSRV_E_INVALID_EK                                                      Handle        = 0x80094817
	CERTSRV_E_INVALID_IDBINDING                                               Handle        = 0x80094818
	CERTSRV_E_INVALID_ATTESTATION                                             Handle        = 0x80094819
	CERTSRV_E_KEY_ATTESTATION                                                 Handle        = 0x8009481A
	CERTSRV_E_CORRUPT_KEY_ATTESTATION                                         Handle        = 0x8009481B
	CERTSRV_E_EXPIRED_CHALLENGE                                               Handle        = 0x8009481C
	CERTSRV_E_INVALID_RESPONSE                                                Handle        = 0x8009481D
	CERTSRV_E_INVALID_REQUESTID                                               Handle        = 0x8009481E
	CERTSRV_E_REQUEST_PRECERTIFICATE_MISMATCH                                 Handle        = 0x8009481F
	CERTSRV_E_PENDING_CLIENT_RESPONSE                                         Handle        = 0x80094820
	XENROLL_E_KEY_NOT_EXPORTABLE                                              Handle        = 0x80095000
	XENROLL_E_CANNOT_ADD_ROOT_CERT                                            Handle        = 0x80095001
	XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND                                      Handle        = 0x80095002
	XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH                                     Handle        = 0x80095003
	XENROLL_E_RESPONSE_KA_HASH_MISMATCH                                       Handle        = 0x80095004
	XENROLL_E_KEYSPEC_SMIME_MISMATCH                                          Handle        = 0x80095005
	TRUST_E_SYSTEM_ERROR                                                      Handle        = 0x80096001
	TRUST_E_NO_SIGNER_CERT                                                    Handle        = 0x80096002
	TRUST_E_COUNTER_SIGNER                                                    Handle        = 0x80096003
	TRUST_E_CERT_SIGNATURE                                                    Handle        = 0x80096004
	TRUST_E_TIME_STAMP                                                        Handle        = 0x80096005
	TRUST_E_BAD_DIGEST                                                        Handle        = 0x80096010
	TRUST_E_MALFORMED_SIGNATURE                                               Handle        = 0x80096011
	TRUST_E_BASIC_CONSTRAINTS                                                 Handle        = 0x80096019
	TRUST_E_FINANCIAL_CRITERIA                                                Handle        = 0x8009601E
	MSSIPOTF_E_OUTOFMEMRANGE                                                  Handle        = 0x80097001
	MSSIPOTF_E_CANTGETOBJECT                                                  Handle        = 0x80097002
	MSSIPOTF_E_NOHEADTABLE                                                    Handle        = 0x80097003
	MSSIPOTF_E_BAD_MAGICNUMBER                                                Handle        = 0x80097004
	MSSIPOTF_E_BAD_OFFSET_TABLE                                               Handle        = 0x80097005
	MSSIPOTF_E_TABLE_TAGORDER                                                 Handle        = 0x80097006
	MSSIPOTF_E_TABLE_LONGWORD                                                 Handle        = 0x80097007
	MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT                                      Handle        = 0x80097008
	MSSIPOTF_E_TABLES_OVERLAP                                                 Handle        = 0x80097009
	MSSIPOTF_E_TABLE_PADBYTES                                                 Handle        = 0x8009700A
	MSSIPOTF_E_FILETOOSMALL                                                   Handle        = 0x8009700B
	MSSIPOTF_E_TABLE_CHECKSUM                                                 Handle        = 0x8009700C
	MSSIPOTF_E_FILE_CHECKSUM                                                  Handle        = 0x8009700D
	MSSIPOTF_E_FAILED_POLICY                                                  Handle        = 0x80097010
	MSSIPOTF_E_FAILED_HINTS_CHECK                                             Handle        = 0x80097011
	MSSIPOTF_E_NOT_OPENTYPE                                                   Handle        = 0x80097012
	MSSIPOTF_E_FILE                                                           Handle        = 0x80097013
	MSSIPOTF_E_CRYPT                                                          Handle        = 0x80097014
	MSSIPOTF_E_BADVERSION                                                     Handle        = 0x80097015
	MSSIPOTF_E_DSIG_STRUCTURE                                                 Handle        = 0x80097016
	MSSIPOTF_E_PCONST_CHECK                                                   Handle        = 0x80097017
	MSSIPOTF_E_STRUCTURE                                                      Handle        = 0x80097018
	ERROR_CRED_REQUIRES_CONFIRMATION                                          Handle        = 0x80097019
	NTE_OP_OK                                                                 syscall.Errno = 0
	TRUST_E_PROVIDER_UNKNOWN                                                  Handle        = 0x800B0001
	TRUST_E_ACTION_UNKNOWN                                                    Handle        = 0x800B0002
	TRUST_E_SUBJECT_FORM_UNKNOWN                                              Handle        = 0x800B0003
	TRUST_E_SUBJECT_NOT_TRUSTED                                               Handle        = 0x800B0004
	DIGSIG_E_ENCODE                                                           Handle        = 0x800B0005
	DIGSIG_E_DECODE                                                           Handle        = 0x800B0006
	DIGSIG_E_EXTENSIBILITY                                                    Handle        = 0x800B0007
	DIGSIG_E_CRYPTO                                                           Handle        = 0x800B0008
	PERSIST_E_SIZEDEFINITE                                                    Handle        = 0x800B0009
	PERSIST_E_SIZEINDEFINITE                                                  Handle        = 0x800B000A
	PERSIST_E_NOTSELFSIZING                                                   Handle        = 0x800B000B
	TRUST_E_NOSIGNATURE                                                       Handle        = 0x800B0100
	CERT_E_EXPIRED                                                            Handle        = 0x800B0101
	CERT_E_VALIDITYPERIODNESTING                                              Handle        = 0x800B0102
	CERT_E_ROLE                                                               Handle        = 0x800B0103
	CERT_E_PATHLENCONST                                                       Handle        = 0x800B0104
	CERT_E_CRITICAL                                                           Handle        = 0x800B0105
	CERT_E_PURPOSE                                                            Handle        = 0x800B0106
	CERT_E_ISSUERCHAINING                                                     Handle        = 0x800B0107
	CERT_E_MALFORMED                                                          Handle        = 0x800B0108
	CERT_E_UNTRUSTEDROOT                                                      Handle        = 0x800B0109
	CERT_E_CHAINING                                                           Handle        = 0x800B010A
	TRUST_E_FAIL                                                              Handle        = 0x800B010B
	CERT_E_REVOKED                                                            Handle        = 0x800B010C
	CERT_E_UNTRUSTEDTESTROOT                                                  Handle        = 0x800B010D
	CERT_E_REVOCATION_FAILURE                                                 Handle        = 0x800B010E
	CERT_E_CN_NO_MATCH                                                        Handle        = 0x800B010F
	CERT_E_WRONG_USAGE                                                        Handle        = 0x800B0110
	TRUST_E_EXPLICIT_DISTRUST                                                 Handle        = 0x800B0111
	CERT_E_UNTRUSTEDCA                                                        Handle        = 0x800B0112
	CERT_E_INVALID_POLICY                                                     Handle        = 0x800B0113
	CERT_E_INVALID_NAME                                                       Handle        = 0x800B0114
	SPAPI_E_EXPECTED_SECTION_NAME                                             Handle        = 0x800F0000
	SPAPI_E_BAD_SECTION_NAME_LINE                                             Handle        = 0x800F0001
	SPAPI_E_SECTION_NAME_TOO_LONG                                             Handle        = 0x800F0002
	SPAPI_E_GENERAL_SYNTAX                                                    Handle        = 0x800F0003
	SPAPI_E_WRONG_INF_STYLE                                                   Handle        = 0x800F0100
	SPAPI_E_SECTION_NOT_FOUND                                                 Handle        = 0x800F0101
	SPAPI_E_LINE_NOT_FOUND                                                    Handle        = 0x800F0102
	SPAPI_E_NO_BACKUP                                                         Handle        = 0x800F0103
	SPAPI_E_NO_ASSOCIATED_CLASS                                               Handle        = 0x800F0200
	SPAPI_E_CLASS_MISMATCH                                                    Handle        = 0x800F0201
	SPAPI_E_DUPLICATE_FOUND                                                   Handle        = 0x800F0202
	SPAPI_E_NO_DRIVER_SELECTED                                                Handle        = 0x800F0203
	SPAPI_E_KEY_DOES_NOT_EXIST                                                Handle        = 0x800F0204
	SPAPI_E_INVALID_DEVINST_NAME                                              Handle        = 0x800F0205
	SPAPI_E_INVALID_CLASS                                                     Handle        = 0x800F0206
	SPAPI_E_DEVINST_ALREADY_EXISTS                                            Handle        = 0x800F0207
	SPAPI_E_DEVINFO_NOT_REGISTERED                                            Handle        = 0x800F0208
	SPAPI_E_INVALID_REG_PROPERTY                                              Handle        = 0x800F0209
	SPAPI_E_NO_INF                                                            Handle        = 0x800F020A
	SPAPI_E_NO_SUCH_DEVINST                                                   Handle        = 0x800F020B
	SPAPI_E_CANT_LOAD_CLASS_ICON                                              Handle        = 0x800F020C
	SPAPI_E_INVALID_CLASS_INSTALLER                                           Handle        = 0x800F020D
	SPAPI_E_DI_DO_DEFAULT                                                     Handle        = 0x800F020E
	SPAPI_E_DI_NOFILECOPY                                                     Handle        = 0x800F020F
	SPAPI_E_INVALID_HWPROFILE                                                 Handle        = 0x800F0210
	SPAPI_E_NO_DEVICE_SELECTED                                                Handle        = 0x800F0211
	SPAPI_E_DEVINFO_LIST_LOCKED                                               Handle        = 0x800F0212
	SPAPI_E_DEVINFO_DATA_LOCKED                                               Handle        = 0x800F0213
	SPAPI_E_DI_BAD_PATH                                                       Handle        = 0x800F0214
	SPAPI_E_NO_CLASSINSTALL_PARAMS                                            Handle        = 0x800F0215
	SPAPI_E_FILEQUEUE_LOCKED                                                  Handle        = 0x800F0216
	SPAPI_E_BAD_SERVICE_INSTALLSECT                                           Handle        = 0x800F0217
	SPAPI_E_NO_CLASS_DRIVER_LIST                                              Handle        = 0x800F0218
	SPAPI_E_NO_ASSOCIATED_SERVICE                                             Handle        = 0x800F0219
	SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE                                       Handle        = 0x800F021A
	SPAPI_E_DEVICE_INTERFACE_ACTIVE                                           Handle        = 0x800F021B
	SPAPI_E_DEVICE_INTERFACE_REMOVED                                          Handle        = 0x800F021C
	SPAPI_E_BAD_INTERFACE_INSTALLSECT                                         Handle        = 0x800F021D
	SPAPI_E_NO_SUCH_INTERFACE_CLASS                                           Handle        = 0x800F021E
	SPAPI_E_INVALID_REFERENCE_STRING                                          Handle        = 0x800F021F
	SPAPI_E_INVALID_MACHINENAME                                               Handle        = 0x800F0220
	SPAPI_E_REMOTE_COMM_FAILURE                                               Handle        = 0x800F0221
	SPAPI_E_MACHINE_UNAVAILABLE                                               Handle        = 0x800F0222
	SPAPI_E_NO_CONFIGMGR_SERVICES                                             Handle        = 0x800F0223
	SPAPI_E_INVALID_PROPPAGE_PROVIDER                                         Handle        = 0x800F0224
	SPAPI_E_NO_SUCH_DEVICE_INTERFACE                                          Handle        = 0x800F0225
	SPAPI_E_DI_POSTPROCESSING_REQUIRED                                        Handle        = 0x800F0226
	SPAPI_E_INVALID_COINSTALLER                                               Handle        = 0x800F0227
	SPAPI_E_NO_COMPAT_DRIVERS                                                 Handle        = 0x800F0228
	SPAPI_E_NO_DEVICE_ICON                                                    Handle        = 0x800F0229
	SPAPI_E_INVALID_INF_LOGCONFIG                                             Handle        = 0x800F022A
	SPAPI_E_DI_DONT_INSTALL                                                   Handle        = 0x800F022B
	SPAPI_E_INVALID_FILTER_DRIVER                                             Handle        = 0x800F022C
	SPAPI_E_NON_WINDOWS_NT_DRIVER                                             Handle        = 0x800F022D
	SPAPI_E_NON_WINDOWS_DRIVER                                                Handle        = 0x800F022E
	SPAPI_E_NO_CATALOG_FOR_OEM_INF                                            Handle        = 0x800F022F
	SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE                                        Handle        = 0x800F0230
	SPAPI_E_NOT_DISABLEABLE                                                   Handle        = 0x800F0231
	SPAPI_E_CANT_REMOVE_DEVINST                                               Handle        = 0x800F0232
	SPAPI_E_INVALID_TARGET                                                    Handle        = 0x800F0233
	SPAPI_E_DRIVER_NONNATIVE                                                  Handle        = 0x800F0234
	SPAPI_E_IN_WOW64                                                          Handle        = 0x800F0235
	SPAPI_E_SET_SYSTEM_RESTORE_POINT                                          Handle        = 0x800F0236
	SPAPI_E_INCORRECTLY_COPIED_INF                                            Handle        = 0x800F0237
	SPAPI_E_SCE_DISABLED                                                      Handle        = 0x800F0238
	SPAPI_E_UNKNOWN_EXCEPTION                                                 Handle        = 0x800F0239
	SPAPI_E_PNP_REGISTRY_ERROR                                                Handle        = 0x800F023A
	SPAPI_E_REMOTE_REQUEST_UNSUPPORTED                                        Handle        = 0x800F023B
	SPAPI_E_NOT_AN_INSTALLED_OEM_INF                                          Handle        = 0x800F023C
	SPAPI_E_INF_IN_USE_BY_DEVICES                                             Handle        = 0x800F023D
	SPAPI_E_DI_FUNCTION_OBSOLETE                                              Handle        = 0x800F023E
	SPAPI_E_NO_AUTHENTICODE_CATALOG                                           Handle        = 0x800F023F
	SPAPI_E_AUTHENTICODE_DISALLOWED                                           Handle        = 0x800F0240
	SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER                                    Handle        = 0x800F0241
	SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED                                Handle        = 0x800F0242
	SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED                                Handle        = 0x800F0243
	SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH                                    Handle        = 0x800F0244
	SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE                                    Handle        = 0x800F0245
	SPAPI_E_DEVICE_INSTALLER_NOT_READY                                        Handle        = 0x800F0246
	SPAPI_E_DRIVER_STORE_ADD_FAILED                                           Handle        = 0x800F0247
	SPAPI_E_DEVICE_INSTALL_BLOCKED                                            Handle        = 0x800F0248
	SPAPI_E_DRIVER_INSTALL_BLOCKED                                            Handle        = 0x800F0249
	SPAPI_E_WRONG_INF_TYPE                                                    Handle        = 0x800F024A
	SPAPI_E_FILE_HASH_NOT_IN_CATALOG                                          Handle        = 0x800F024B
	SPAPI_E_DRIVER_STORE_DELETE_FAILED                                        Handle        = 0x800F024C
	SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW                                      Handle        = 0x800F0300
	SPAPI_E_ERROR_NOT_INSTALLED                                               Handle        = 0x800F1000
	SCARD_S_SUCCESS                                                                         = S_OK
	SCARD_F_INTERNAL_ERROR                                                    Handle        = 0x80100001
	SCARD_E_CANCELLED                                                         Handle        = 0x80100002
	SCARD_E_INVALID_HANDLE                                                    Handle        = 0x80100003
	SCARD_E_INVALID_PARAMETER                                                 Handle        = 0x80100004
	SCARD_E_INVALID_TARGET                                                    Handle        = 0x80100005
	SCARD_E_NO_MEMORY                                                         Handle        = 0x80100006
	SCARD_F_WAITED_TOO_LONG                                                   Handle        = 0x80100007
	SCARD_E_INSUFFICIENT_BUFFER                                               Handle        = 0x80100008
	SCARD_E_UNKNOWN_READER                                                    Handle        = 0x80100009
	SCARD_E_TIMEOUT                                                           Handle        = 0x8010000A
	SCARD_E_SHARING_VIOLATION                                                 Handle        = 0x8010000B
	SCARD_E_NO_SMARTCARD                                                      Handle        = 0x8010000C
	SCARD_E_UNKNOWN_CARD                                                      Handle        = 0x8010000D
	SCARD_E_CANT_DISPOSE                                                      Handle        = 0x8010000E
	SCARD_E_PROTO_MISMATCH                                                    Handle        = 0x8010000F
	SCARD_E_NOT_READY                                                         Handle        = 0x80100010
	SCARD_E_INVALID_VALUE                                                     Handle        = 0x80100011
	SCARD_E_SYSTEM_CANCELLED                                                  Handle        = 0x80100012
	SCARD_F_COMM_ERROR                                                        Handle        = 0x80100013
	SCARD_F_UNKNOWN_ERROR                                                     Handle        = 0x80100014
	SCARD_E_INVALID_ATR                                                       Handle        = 0x80100015
	SCARD_E_NOT_TRANSACTED                                                    Handle        = 0x80100016
	SCARD_E_READER_UNAVAILABLE                                                Handle        = 0x80100017
	SCARD_P_SHUTDOWN                                                          Handle        = 0x80100018
	SCARD_E_PCI_TOO_SMALL                                                     Handle        = 0x80100019
	SCARD_E_READER_UNSUPPORTED                                                Handle        = 0x8010001A
	SCARD_E_DUPLICATE_READER                                                  Handle        = 0x8010001B
	SCARD_E_CARD_UNSUPPORTED                                                  Handle        = 0x8010001C
	SCARD_E_NO_SERVICE                                                        Handle        = 0x8010001D
	SCARD_E_SERVICE_STOPPED                                                   Handle        = 0x8010001E
	SCARD_E_UNEXPECTED                                                        Handle        = 0x8010001F
	SCARD_E_ICC_INSTALLATION                                                  Handle        = 0x80100020
	SCARD_E_ICC_CREATEORDER                                                   Handle        = 0x80100021
	SCARD_E_UNSUPPORTED_FEATURE                                               Handle        = 0x80100022
	SCARD_E_DIR_NOT_FOUND                                                     Handle        = 0x80100023
	SCARD_E_FILE_NOT_FOUND                                                    Handle        = 0x80100024
	SCARD_E_NO_DIR                                                            Handle        = 0x80100025
	SCARD_E_NO_FILE                                                           Handle        = 0x80100026
	SCARD_E_NO_ACCESS                                                         Handle        = 0x80100027
	SCARD_E_WRITE_TOO_MANY                                                    Handle        = 0x80100028
	SCARD_E_BAD_SEEK                                                          Handle        = 0x80100029
	SCARD_E_INVALID_CHV                                                       Handle        = 0x8010002A
	SCARD_E_UNKNOWN_RES_MNG                                                   Handle        = 0x8010002B
	SCARD_E_NO_SUCH_CERTIFICATE                                               Handle        = 0x8010002C
	SCARD_E_CERTIFICATE_UNAVAILABLE                                           Handle        = 0x8010002D
	SCARD_E_NO_READERS_AVAILABLE                                              Handle        = 0x8010002E
	SCARD_E_COMM_DATA_LOST                                                    Handle        = 0x8010002F
	SCARD_E_NO_KEY_CONTAINER                                                  Handle        = 0x80100030
	SCARD_E_SERVER_TOO_BUSY                                                   Handle        = 0x80100031
	SCARD_E_PIN_CACHE_EXPIRED                                                 Handle        = 0x80100032
	SCARD_E_NO_PIN_CACHE                                                      Handle        = 0x80100033
	SCARD_E_READ_ONLY_CARD                                                    Handle        = 0x80100034
	SCARD_W_UNSUPPORTED_CARD                                                  Handle        = 0x80100065
	SCARD_W_UNRESPONSIVE_CARD                                                 Handle        = 0x80100066
	SCARD_W_UNPOWERED_CARD                                                    Handle        = 0x80100067
	SCARD_W_RESET_CARD                                                        Handle        = 0x80100068
	SCARD_W_REMOVED_CARD                                                      Handle        = 0x80100069
	SCARD_W_SECURITY_VIOLATION                                                Handle        = 0x8010006A
	SCARD_W_WRONG_CHV                                                         Handle        = 0x8010006B
	SCARD_W_CHV_BLOCKED                                                       Handle        = 0x8010006C
	SCARD_W_EOF                                                               Handle        = 0x8010006D
	SCARD_W_CANCELLED_BY_USER                                                 Handle        = 0x8010006E
	SCARD_W_CARD_NOT_AUTHENTICATED                                            Handle        = 0x8010006F
	SCARD_W_CACHE_ITEM_NOT_FOUND                                              Handle        = 0x80100070
	SCARD_W_CACHE_ITEM_STALE                                                  Handle        = 0x80100071
	SCARD_W_CACHE_ITEM_TOO_BIG                                                Handle        = 0x80100072
	COMADMIN_E_OBJECTERRORS                                                   Handle        = 0x80110401
	COMADMIN_E_OBJECTINVALID                                                  Handle        = 0x80110402
	COMADMIN_E_KEYMISSING                                                     Handle        = 0x80110403
	COMADMIN_E_ALREADYINSTALLED                                               Handle        = 0x80110404
	COMADMIN_E_APP_FILE_WRITEFAIL                                             Handle        = 0x80110407
	COMADMIN_E_APP_FILE_READFAIL                                              Handle        = 0x80110408
	COMADMIN_E_APP_FILE_VERSION                                               Handle        = 0x80110409
	COMADMIN_E_BADPATH                                                        Handle        = 0x8011040A
	COMADMIN_E_APPLICATIONEXISTS                                              Handle        = 0x8011040B
	COMADMIN_E_ROLEEXISTS                                                     Handle        = 0x8011040C
	COMADMIN_E_CANTCOPYFILE                                                   Handle        = 0x8011040D
	COMADMIN_E_NOUSER                                                         Handle        = 0x8011040F
	COMADMIN_E_INVALIDUSERIDS                                                 Handle        = 0x80110410
	COMADMIN_E_NOREGISTRYCLSID                                                Handle        = 0x80110411
	COMADMIN_E_BADREGISTRYPROGID                                              Handle        = 0x80110412
	COMADMIN_E_AUTHENTICATIONLEVEL                                            Handle        = 0x80110413
	COMADMIN_E_USERPASSWDNOTVALID                                             Handle        = 0x80110414
	COMADMIN_E_CLSIDORIIDMISMATCH                                             Handle        = 0x80110418
	COMADMIN_E_REMOTEINTERFACE                                                Handle        = 0x80110419
	COMADMIN_E_DLLREGISTERSERVER                                              Handle        = 0x8011041A
	COMADMIN_E_NOSERVERSHARE                                                  Handle        = 0x8011041B
	COMADMIN_E_DLLLOADFAILED                                                  Handle        = 0x8011041D
	COMADMIN_E_BADREGISTRYLIBID                                               Handle        = 0x8011041E
	COMADMIN_E_APPDIRNOTFOUND                                                 Handle        = 0x8011041F
	COMADMIN_E_REGISTRARFAILED                                                Handle        = 0x80110423
	COMADMIN_E_COMPFILE_DOESNOTEXIST                                          Handle        = 0x80110424
	COMADMIN_E_COMPFILE_LOADDLLFAIL                                           Handle        = 0x80110425
	COMADMIN_E_COMPFILE_GETCLASSOBJ                                           Handle        = 0x80110426
	COMADMIN_E_COMPFILE_CLASSNOTAVAIL                                         Handle        = 0x80110427
	COMADMIN_E_COMPFILE_BADTLB                                                Handle        = 0x80110428
	COMADMIN_E_COMPFILE_NOTINSTALLABLE                                        Handle        = 0x80110429
	COMADMIN_E_NOTCHANGEABLE                                                  Handle        = 0x8011042A
	COMADMIN_E_NOTDELETEABLE                                                  Handle        = 0x8011042B
	COMADMIN_E_SESSION                                                        Handle        = 0x8011042C
	COMADMIN_E_COMP_MOVE_LOCKED                                               Handle        = 0x8011042D
	COMADMIN_E_COMP_MOVE_BAD_DEST                                             Handle        = 0x8011042E
	COMADMIN_E_REGISTERTLB                                                    Handle        = 0x80110430
	COMADMIN_E_SYSTEMAPP                                                      Handle        = 0x80110433
	COMADMIN_E_COMPFILE_NOREGISTRAR                                           Handle        = 0x80110434
	COMADMIN_E_COREQCOMPINSTALLED                                             Handle        = 0x80110435
	COMADMIN_E_SERVICENOTINSTALLED                                            Handle        = 0x80110436
	COMADMIN_E_PROPERTYSAVEFAILED                                             Handle        = 0x80110437
	COMADMIN_E_OBJECTEXISTS                                                   Handle        = 0x80110438
	COMADMIN_E_COMPONENTEXISTS                                                Handle        = 0x80110439
	COMADMIN_E_REGFILE_CORRUPT                                                Handle        = 0x8011043B
	COMADMIN_E_PROPERTY_OVERFLOW                                              Handle        = 0x8011043C
	COMADMIN_E_NOTINREGISTRY                                                  Handle        = 0x8011043E
	COMADMIN_E_OBJECTNOTPOOLABLE                                              Handle        = 0x8011043F
	COMADMIN_E_APPLID_MATCHES_CLSID                                           Handle        = 0x80110446
	COMADMIN_E_ROLE_DOES_NOT_EXIST                                            Handle        = 0x80110447
	COMADMIN_E_START_APP_NEEDS_COMPONENTS                                     Handle        = 0x80110448
	COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM                                    Handle        = 0x80110449
	COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY                                       Handle        = 0x8011044A
	COMADMIN_E_CAN_NOT_START_APP                                              Handle        = 0x8011044B
	COMADMIN_E_CAN_NOT_EXPORT_SYS_APP                                         Handle        = 0x8011044C
	COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT                                    Handle        = 0x8011044D
	COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER                                  Handle        = 0x8011044E
	COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE                                     Handle        = 0x8011044F
	COMADMIN_E_BASE_PARTITION_ONLY                                            Handle        = 0x80110450
	COMADMIN_E_START_APP_DISABLED                                             Handle        = 0x80110451
	COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME                                   Handle        = 0x80110457
	COMADMIN_E_CAT_INVALID_PARTITION_NAME                                     Handle        = 0x80110458
	COMADMIN_E_CAT_PARTITION_IN_USE                                           Handle        = 0x80110459
	COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES                                 Handle        = 0x8011045A
	COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED                            Handle        = 0x8011045B
	COMADMIN_E_AMBIGUOUS_APPLICATION_NAME                                     Handle        = 0x8011045C
	COMADMIN_E_AMBIGUOUS_PARTITION_NAME                                       Handle        = 0x8011045D
	COMADMIN_E_REGDB_NOTINITIALIZED                                           Handle        = 0x80110472
	COMADMIN_E_REGDB_NOTOPEN                                                  Handle        = 0x80110473
	COMADMIN_E_REGDB_SYSTEMERR                                                Handle        = 0x80110474
	COMADMIN_E_REGDB_ALREADYRUNNING                                           Handle        = 0x80110475
	COMADMIN_E_MIG_VERSIONNOTSUPPORTED                                        Handle        = 0x80110480
	COMADMIN_E_MIG_SCHEMANOTFOUND                                             Handle        = 0x80110481
	COMADMIN_E_CAT_BITNESSMISMATCH                                            Handle        = 0x80110482
	COMADMIN_E_CAT_UNACCEPTABLEBITNESS                                        Handle        = 0x80110483
	COMADMIN_E_CAT_WRONGAPPBITNESS                                            Handle        = 0x80110484
	COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED                                 Handle        = 0x80110485
	COMADMIN_E_CAT_SERVERFAULT                                                Handle        = 0x80110486
	COMQC_E_APPLICATION_NOT_QUEUED                                            Handle        = 0x80110600
	COMQC_E_NO_QUEUEABLE_INTERFACES                                           Handle        = 0x80110601
	COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE                                     Handle        = 0x80110602
	COMQC_E_NO_IPERSISTSTREAM                                                 Handle        = 0x80110603
	COMQC_E_BAD_MESSAGE                                                       Handle        = 0x80110604
	COMQC_E_UNAUTHENTICATED                                                   Handle        = 0x80110605
	COMQC_E_UNTRUSTED_ENQUEUER                                                Handle        = 0x80110606
	MSDTC_E_DUPLICATE_RESOURCE                                                Handle        = 0x80110701
	COMADMIN_E_OBJECT_PARENT_MISSING                                          Handle        = 0x80110808
	COMADMIN_E_OBJECT_DOES_NOT_EXIST                                          Handle        = 0x80110809
	COMADMIN_E_APP_NOT_RUNNING                                                Handle        = 0x8011080A
	COMADMIN_E_INVALID_PARTITION                                              Handle        = 0x8011080B
	COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE                              Handle        = 0x8011080D
	COMADMIN_E_USER_IN_SET                                                    Handle        = 0x8011080E
	COMADMIN_E_CANTRECYCLELIBRARYAPPS                                         Handle        = 0x8011080F
	COMADMIN_E_CANTRECYCLESERVICEAPPS                                         Handle        = 0x80110811
	COMADMIN_E_PROCESSALREADYRECYCLED                                         Handle        = 0x80110812
	COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED                                  Handle        = 0x80110813
	COMADMIN_E_CANTMAKEINPROCSERVICE                                          Handle        = 0x80110814
	COMADMIN_E_PROGIDINUSEBYCLSID                                             Handle        = 0x80110815
	COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET                                   Handle        = 0x80110816
	COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED                                  Handle        = 0x80110817
	COMADMIN_E_PARTITION_ACCESSDENIED                                         Handle        = 0x80110818
	COMADMIN_E_PARTITION_MSI_ONLY                                             Handle        = 0x80110819
	COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT                          Handle        = 0x8011081A
	COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS                  Handle        = 0x8011081B
	COMADMIN_E_COMP_MOVE_SOURCE                                               Handle        = 0x8011081C
	COMADMIN_E_COMP_MOVE_DEST                                                 Handle        = 0x8011081D
	COMADMIN_E_COMP_MOVE_PRIVATE                                              Handle        = 0x8011081E
	COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET                                  Handle        = 0x8011081F
	COMADMIN_E_CANNOT_ALIAS_EVENTCLASS                                        Handle        = 0x80110820
	COMADMIN_E_PRIVATE_ACCESSDENIED                                           Handle        = 0x80110821
	COMADMIN_E_SAFERINVALID                                                   Handle        = 0x80110822
	COMADMIN_E_REGISTRY_ACCESSDENIED                                          Handle        = 0x80110823
	COMADMIN_E_PARTITIONS_DISABLED                                            Handle        = 0x80110824
	WER_S_REPORT_DEBUG                                                        Handle        = 0x001B0000
	WER_S_REPORT_UPLOADED                                                     Handle        = 0x001B0001
	WER_S_REPORT_QUEUED                                                       Handle        = 0x001B0002
	WER_S_DISABLED                                                            Handle        = 0x001B0003
	WER_S_SUSPENDED_UPLOAD                                                    Handle        = 0x001B0004
	WER_S_DISABLED_QUEUE                                                      Handle        = 0x001B0005
	WER_S_DISABLED_ARCHIVE                                                    Handle        = 0x001B0006
	WER_S_REPORT_ASYNC                                                        Handle        = 0x001B0007
	WER_S_IGNORE_ASSERT_INSTANCE                                              Handle        = 0x001B0008
	WER_S_IGNORE_ALL_ASSERTS                                                  Handle        = 0x001B0009
	WER_S_ASSERT_CONTINUE                                                     Handle        = 0x001B000A
	WER_S_THROTTLED                                                           Handle        = 0x001B000B
	WER_S_REPORT_UPLOADED_CAB                                                 Handle        = 0x001B000C
	WER_E_CRASH_FAILURE                                                       Handle        = 0x801B8000
	WER_E_CANCELED                                                            Handle        = 0x801B8001
	WER_E_NETWORK_FAILURE                                                     Handle        = 0x801B8002
	WER_E_NOT_INITIALIZED                                                     Handle        = 0x801B8003
	WER_E_ALREADY_REPORTING                                                   Handle        = 0x801B8004
	WER_E_DUMP_THROTTLED                                                      Handle        = 0x801B8005
	WER_E_INSUFFICIENT_CONSENT                                                Handle        = 0x801B8006
	WER_E_TOO_HEAVY                                                           Handle        = 0x801B8007
	ERROR_FLT_IO_COMPLETE                                                     Handle        = 0x001F0001
	ERROR_FLT_NO_HANDLER_DEFINED                                              Handle        = 0x801F0001
	ERROR_FLT_CONTEXT_ALREADY_DEFINED                                         Handle        = 0x801F0002
	ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST                                    Handle        = 0x801F0003
	ERROR_FLT_DISALLOW_FAST_IO                                                Handle        = 0x801F0004
	ERROR_FLT_INVALID_NAME_REQUEST                                            Handle        = 0x801F0005
	ERROR_FLT_NOT_SAFE_TO_POST_OPERATION                                      Handle        = 0x801F0006
	ERROR_FLT_NOT_INITIALIZED                                                 Handle        = 0x801F0007
	ERROR_FLT_FILTER_NOT_READY                                                Handle        = 0x801F0008
	ERROR_FLT_POST_OPERATION_CLEANUP                                          Handle        = 0x801F0009
	ERROR_FLT_INTERNAL_ERROR                                                  Handle        = 0x801F000A
	ERROR_FLT_DELETING_OBJECT                                                 Handle        = 0x801F000B
	ERROR_FLT_MUST_BE_NONPAGED_POOL                                           Handle        = 0x801F000C
	ERROR_FLT_DUPLICATE_ENTRY                                                 Handle        = 0x801F000D
	ERROR_FLT_CBDQ_DISABLED                                                   Handle        = 0x801F000E
	ERROR_FLT_DO_NOT_ATTACH                                                   Handle        = 0x801F000F
	ERROR_FLT_DO_NOT_DETACH                                                   Handle        = 0x801F0010
	ERROR_FLT_INSTANCE_ALTITUDE_COLLISION                                     Handle        = 0x801F0011
	ERROR_FLT_INSTANCE_NAME_COLLISION                                         Handle        = 0x801F0012
	ERROR_FLT_FILTER_NOT_FOUND                                                Handle        = 0x801F0013
	ERROR_FLT_VOLUME_NOT_FOUND                                                Handle        = 0x801F0014
	ERROR_FLT_INSTANCE_NOT_FOUND                                              Handle        = 0x801F0015
	ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND                                    Handle        = 0x801F0016
	ERROR_FLT_INVALID_CONTEXT_REGISTRATION                                    Handle        = 0x801F0017
	ERROR_FLT_NAME_CACHE_MISS                                                 Handle        = 0x801F0018
	ERROR_FLT_NO_DEVICE_OBJECT                                                Handle        = 0x801F0019
	ERROR_FLT_VOLUME_ALREADY_MOUNTED                                          Handle        = 0x801F001A
	ERROR_FLT_ALREADY_ENLISTED                                                Handle        = 0x801F001B
	ERROR_FLT_CONTEXT_ALREADY_LINKED                                          Handle        = 0x801F001C
	ERROR_FLT_NO_WAITER_FOR_REPLY                                             Handle        = 0x801F0020
	ERROR_FLT_REGISTRATION_BUSY                                               Handle        = 0x801F0023
	ERROR_HUNG_DISPLAY_DRIVER_THREAD                                          Handle        = 0x80260001
	DWM_E_COMPOSITIONDISABLED                                                 Handle        = 0x80263001
	DWM_E_REMOTING_NOT_SUPPORTED                                              Handle        = 0x80263002
	DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE                                    Handle        = 0x80263003
	DWM_E_NOT_QUEUING_PRESENTS                                                Handle        = 0x80263004
	DWM_E_ADAPTER_NOT_FOUND                                                   Handle        = 0x80263005
	DWM_S_GDI_REDIRECTION_SURFACE                                             Handle        = 0x00263005
	DWM_E_TEXTURE_TOO_LARGE                                                   Handle        = 0x80263007
	DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI                                 Handle        = 0x00263008
	ERROR_MONITOR_NO_DESCRIPTOR                                               Handle        = 0x00261001
	ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT                                   Handle        = 0x00261002
	ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM                                 Handle        = 0xC0261003
	ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK                               Handle        = 0xC0261004
	ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED                           Handle        = 0xC0261005
	ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK                          Handle        = 0xC0261006
	ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK                          Handle        = 0xC0261007
	ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA                                     Handle        = 0xC0261008
	ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK                               Handle        = 0xC0261009
	ERROR_MONITOR_INVALID_MANUFACTURE_DATE                                    Handle        = 0xC026100A
	ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER                                   Handle        = 0xC0262000
	ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER                                    Handle        = 0xC0262001
	ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER                                    Handle        = 0xC0262002
	ERROR_GRAPHICS_ADAPTER_WAS_RESET                                          Handle        = 0xC0262003
	ERROR_GRAPHICS_INVALID_DRIVER_MODEL                                       Handle        = 0xC0262004
	ERROR_GRAPHICS_PRESENT_MODE_CHANGED                                       Handle        = 0xC0262005
	ERROR_GRAPHICS_PRESENT_OCCLUDED                                           Handle        = 0xC0262006
	ERROR_GRAPHICS_PRESENT_DENIED                                             Handle        = 0xC0262007
	ERROR_GRAPHICS_CANNOTCOLORCONVERT                                         Handle        = 0xC0262008
	ERROR_GRAPHICS_DRIVER_MISMATCH                                            Handle        = 0xC0262009
	ERROR_GRAPHICS_PARTIAL_DATA_POPULATED                                     Handle        = 0x4026200A
	ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED                               Handle        = 0xC026200B
	ERROR_GRAPHICS_PRESENT_UNOCCLUDED                                         Handle        = 0xC026200C
	ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE                                     Handle        = 0xC026200D
	ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED                                Handle        = 0xC026200E
	ERROR_GRAPHICS_PRESENT_INVALID_WINDOW                                     Handle        = 0xC026200F
	ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND                                   Handle        = 0xC0262010
	ERROR_GRAPHICS_VAIL_STATE_CHANGED                                         Handle        = 0xC0262011
	ERROR_GRAPHICS_NO_VIDEO_MEMORY                                            Handle        = 0xC0262100
	ERROR_GRAPHICS_CANT_LOCK_MEMORY                                           Handle        = 0xC0262101
	ERROR_GRAPHICS_ALLOCATION_BUSY                                            Handle        = 0xC0262102
	ERROR_GRAPHICS_TOO_MANY_REFERENCES                                        Handle        = 0xC0262103
	ERROR_GRAPHICS_TRY_AGAIN_LATER                                            Handle        = 0xC0262104
	ERROR_GRAPHICS_TRY_AGAIN_NOW                                              Handle        = 0xC0262105
	ERROR_GRAPHICS_ALLOCATION_INVALID                                         Handle        = 0xC0262106
	ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE                           Handle        = 0xC0262107
	ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED                           Handle        = 0xC0262108
	ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION                               Handle        = 0xC0262109
	ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE                                   Handle        = 0xC0262110
	ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION                              Handle        = 0xC0262111
	ERROR_GRAPHICS_ALLOCATION_CLOSED                                          Handle        = 0xC0262112
	ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE                                Handle        = 0xC0262113
	ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE                                  Handle        = 0xC0262114
	ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE                                    Handle        = 0xC0262115
	ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST                                    Handle        = 0xC0262116
	ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE                                    Handle        = 0xC0262200
	ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION                                Handle        = 0x40262201
	ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY                                     Handle        = 0xC0262300
	ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED                               Handle        = 0xC0262301
	ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED                     Handle        = 0xC0262302
	ERROR_GRAPHICS_INVALID_VIDPN                                              Handle        = 0xC0262303
	ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE                               Handle        = 0xC0262304
	ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET                               Handle        = 0xC0262305
	ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED                               Handle        = 0xC0262306
	ERROR_GRAPHICS_MODE_NOT_PINNED                                            Handle        = 0x00262307
	ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET                                Handle        = 0xC0262308
	ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET                                Handle        = 0xC0262309
	ERROR_GRAPHICS_INVALID_FREQUENCY                                          Handle        = 0xC026230A
	ERROR_GRAPHICS_INVALID_ACTIVE_REGION                                      Handle        = 0xC026230B
	ERROR_GRAPHICS_INVALID_TOTAL_REGION                                       Handle        = 0xC026230C
	ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE                          Handle        = 0xC0262310
	ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE                          Handle        = 0xC0262311
	ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET                             Handle        = 0xC0262312
	ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY                                   Handle        = 0xC0262313
	ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET                                    Handle        = 0xC0262314
	ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET                              Handle        = 0xC0262315
	ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET                              Handle        = 0xC0262316
	ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET                                      Handle        = 0xC0262317
	ERROR_GRAPHICS_TARGET_ALREADY_IN_SET                                      Handle        = 0xC0262318
	ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH                                 Handle        = 0xC0262319
	ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY                              Handle        = 0xC026231A
	ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET                          Handle        = 0xC026231B
	ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE                             Handle        = 0xC026231C
	ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET                                  Handle        = 0xC026231D
	ERROR_GRAPHICS_NO_PREFERRED_MODE                                          Handle        = 0x0026231E
	ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET                              Handle        = 0xC026231F
	ERROR_GRAPHICS_STALE_MODESET                                              Handle        = 0xC0262320
	ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET                              Handle        = 0xC0262321
	ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE                                Handle        = 0xC0262322
	ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN                            Handle        = 0xC0262323
	ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE                                     Handle        = 0xC0262324
	ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION            Handle        = 0xC0262325
	ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES                    Handle        = 0xC0262326
	ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY                                       Handle        = 0xC0262327
	ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE                      Handle        = 0xC0262328
	ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET                      Handle        = 0xC0262329
	ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET                               Handle        = 0xC026232A
	ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR                                  Handle        = 0xC026232B
	ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET                               Handle        = 0xC026232C
	ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET                           Handle        = 0xC026232D
	ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE                        Handle        = 0xC026232E
	ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE                           Handle        = 0xC026232F
	ERROR_GRAPHICS_RESOURCES_NOT_RELATED                                      Handle        = 0xC0262330
	ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE                                   Handle        = 0xC0262331
	ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE                                   Handle        = 0xC0262332
	ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET                                  Handle        = 0xC0262333
	ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER               Handle        = 0xC0262334
	ERROR_GRAPHICS_NO_VIDPNMGR                                                Handle        = 0xC0262335
	ERROR_GRAPHICS_NO_ACTIVE_VIDPN                                            Handle        = 0xC0262336
	ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY                                       Handle        = 0xC0262337
	ERROR_GRAPHICS_MONITOR_NOT_CONNECTED                                      Handle        = 0xC0262338
	ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY                                     Handle        = 0xC0262339
	ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE                                Handle        = 0xC026233A
	ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE                                 Handle        = 0xC026233B
	ERROR_GRAPHICS_INVALID_STRIDE                                             Handle        = 0xC026233C
	ERROR_GRAPHICS_INVALID_PIXELFORMAT                                        Handle        = 0xC026233D
	ERROR_GRAPHICS_INVALID_COLORBASIS                                         Handle        = 0xC026233E
	ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE                               Handle        = 0xC026233F
	ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY                                     Handle        = 0xC0262340
	ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT                         Handle        = 0xC0262341
	ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE                                        Handle        = 0xC0262342
	ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN                                   Handle        = 0xC0262343
	ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL                            Handle        = 0xC0262344
	ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION               Handle        = 0xC0262345
	ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED         Handle        = 0xC0262346
	ERROR_GRAPHICS_INVALID_GAMMA_RAMP                                         Handle        = 0xC0262347
	ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED                                   Handle        = 0xC0262348
	ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED                                Handle        = 0xC0262349
	ERROR_GRAPHICS_MODE_NOT_IN_MODESET                                        Handle        = 0xC026234A
	ERROR_GRAPHICS_DATASET_IS_EMPTY                                           Handle        = 0x0026234B
	ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET                                Handle        = 0x0026234C
	ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON               Handle        = 0xC026234D
	ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE                                  Handle        = 0xC026234E
	ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE                                Handle        = 0xC026234F
	ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS                          Handle        = 0xC0262350
	ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED            Handle        = 0x00262351
	ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING                                  Handle        = 0xC0262352
	ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED                               Handle        = 0xC0262353
	ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS                           Handle        = 0xC0262354
	ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT                                Handle        = 0xC0262355
	ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM                             Handle        = 0xC0262356
	ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN                          Handle        = 0xC0262357
	ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT                  Handle        = 0xC0262358
	ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED                                      Handle        = 0xC0262359
	ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION                         Handle        = 0xC026235A
	ERROR_GRAPHICS_INVALID_CLIENT_TYPE                                        Handle        = 0xC026235B
	ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET                                        Handle        = 0xC026235C
	ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED                          Handle        = 0xC0262400
	ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED                             Handle        = 0xC0262401
	ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS                                       Handle        = 0x4026242F
	ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER                                       Handle        = 0xC0262430
	ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED                                    Handle        = 0xC0262431
	ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED                                  Handle        = 0xC0262432
	ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY                                    Handle        = 0xC0262433
	ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED                                     Handle        = 0xC0262434
	ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON                                  Handle        = 0xC0262435
	ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE                             Handle        = 0xC0262436
	ERROR_GRAPHICS_LEADLINK_START_DEFERRED                                    Handle        = 0x40262437
	ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER                                     Handle        = 0xC0262438
	ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY                                     Handle        = 0x40262439
	ERROR_GRAPHICS_START_DEFERRED                                             Handle        = 0x4026243A
	ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED                                Handle        = 0xC026243B
	ERROR_GRAPHICS_DEPENDABLE_CHILD_STATUS                                    Handle        = 0x4026243C
	ERROR_GRAPHICS_OPM_NOT_SUPPORTED                                          Handle        = 0xC0262500
	ERROR_GRAPHICS_COPP_NOT_SUPPORTED                                         Handle        = 0xC0262501
	ERROR_GRAPHICS_UAB_NOT_SUPPORTED                                          Handle        = 0xC0262502
	ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS                           Handle        = 0xC0262503
	ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST                                 Handle        = 0xC0262505
	ERROR_GRAPHICS_OPM_INTERNAL_ERROR                                         Handle        = 0xC026250B
	ERROR_GRAPHICS_OPM_INVALID_HANDLE                                         Handle        = 0xC026250C
	ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH                             Handle        = 0xC026250E
	ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED                                  Handle        = 0xC026250F
	ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED                                   Handle        = 0xC0262510
	ERROR_GRAPHICS_PVP_HFS_FAILED                                             Handle        = 0xC0262511
	ERROR_GRAPHICS_OPM_INVALID_SRM                                            Handle        = 0xC0262512
	ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP                           Handle        = 0xC0262513
	ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP                            Handle        = 0xC0262514
	ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA                          Handle        = 0xC0262515
	ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET                                     Handle        = 0xC0262516
	ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH                                    Handle        = 0xC0262517
	ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE                       Handle        = 0xC0262518
	ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS                          Handle        = 0xC026251A
	ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS                        Handle        = 0xC026251B
	ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS              Handle        = 0xC026251C
	ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST                            Handle        = 0xC026251D
	ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR                                  Handle        = 0xC026251E
	ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS               Handle        = 0xC026251F
	ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED                                Handle        = 0xC0262520
	ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST                          Handle        = 0xC0262521
	ERROR_GRAPHICS_I2C_NOT_SUPPORTED                                          Handle        = 0xC0262580
	ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST                                  Handle        = 0xC0262581
	ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA                                Handle        = 0xC0262582
	ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA                                   Handle        = 0xC0262583
	ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED                                    Handle        = 0xC0262584
	ERROR_GRAPHICS_DDCCI_INVALID_DATA                                         Handle        = 0xC0262585
	ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE          Handle        = 0xC0262586
	ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING                            Handle        = 0xC0262587
	ERROR_GRAPHICS_MCA_INTERNAL_ERROR                                         Handle        = 0xC0262588
	ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND                              Handle        = 0xC0262589
	ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH                               Handle        = 0xC026258A
	ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM                             Handle        = 0xC026258B
	ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE                            Handle        = 0xC026258C
	ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS                                   Handle        = 0xC026258D
	ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE     Handle        = 0xC02625D8
	ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION                                    Handle        = 0xC02625D9
	ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION                    Handle        = 0xC02625DA
	ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH                                  Handle        = 0xC02625DB
	ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION                               Handle        = 0xC02625DC
	ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED                       Handle        = 0xC02625DE
	ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE                          Handle        = 0xC02625DF
	ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED                             Handle        = 0xC02625E0
	ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME                      Handle        = 0xC02625E1
	ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP                     Handle        = 0xC02625E2
	ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED                            Handle        = 0xC02625E3
	ERROR_GRAPHICS_INVALID_POINTER                                            Handle        = 0xC02625E4
	ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE                   Handle        = 0xC02625E5
	ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL                                  Handle        = 0xC02625E6
	ERROR_GRAPHICS_INTERNAL_ERROR                                             Handle        = 0xC02625E7
	ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS                            Handle        = 0xC02605E8
	NAP_E_INVALID_PACKET                                                      Handle        = 0x80270001
	NAP_E_MISSING_SOH                                                         Handle        = 0x80270002
	NAP_E_CONFLICTING_ID                                                      Handle        = 0x80270003
	NAP_E_NO_CACHED_SOH                                                       Handle        = 0x80270004
	NAP_E_STILL_BOUND                                                         Handle        = 0x80270005
	NAP_E_NOT_REGISTERED                                                      Handle        = 0x80270006
	NAP_E_NOT_INITIALIZED                                                     Handle        = 0x80270007
	NAP_E_MISMATCHED_ID                                                       Handle        = 0x80270008
	NAP_E_NOT_PENDING                                                         Handle        = 0x80270009
	NAP_E_ID_NOT_FOUND                                                        Handle        = 0x8027000A
	NAP_E_MAXSIZE_TOO_SMALL                                                   Handle        = 0x8027000B
	NAP_E_SERVICE_NOT_RUNNING                                                 Handle        = 0x8027000C
	NAP_S_CERT_ALREADY_PRESENT                                                Handle        = 0x0027000D
	NAP_E_ENTITY_DISABLED                                                     Handle        = 0x8027000E
	NAP_E_NETSH_GROUPPOLICY_ERROR                                             Handle        = 0x8027000F
	NAP_E_TOO_MANY_CALLS                                                      Handle        = 0x80270010
	NAP_E_SHV_CONFIG_EXISTED                                                  Handle        = 0x80270011
	NAP_E_SHV_CONFIG_NOT_FOUND                                                Handle        = 0x80270012
	NAP_E_SHV_TIMEOUT                                                         Handle        = 0x80270013
	TPM_E_ERROR_MASK                                                          Handle        = 0x80280000
	TPM_E_AUTHFAIL                                                            Handle        = 0x80280001
	TPM_E_BADINDEX                                                            Handle        = 0x80280002
	TPM_E_BAD_PARAMETER                                                       Handle        = 0x80280003
	TPM_E_AUDITFAILURE                                                        Handle        = 0x80280004
	TPM_E_CLEAR_DISABLED                                                      Handle        = 0x80280005
	TPM_E_DEACTIVATED                                                         Handle        = 0x80280006
	TPM_E_DISABLED                                                            Handle        = 0x80280007
	TPM_E_DISABLED_CMD                                                        Handle        = 0x80280008
	TPM_E_FAIL                                                                Handle        = 0x80280009
	TPM_E_BAD_ORDINAL                                                         Handle        = 0x8028000A
	TPM_E_INSTALL_DISABLED                                                    Handle        = 0x8028000B
	TPM_E_INVALID_KEYHANDLE                                                   Handle        = 0x8028000C
	TPM_E_KEYNOTFOUND                                                         Handle        = 0x8028000D
	TPM_E_INAPPROPRIATE_ENC                                                   Handle        = 0x8028000E
	TPM_E_MIGRATEFAIL                                                         Handle        = 0x8028000F
	TPM_E_INVALID_PCR_INFO                                                    Handle        = 0x80280010
	TPM_E_NOSPACE                                                             Handle        = 0x80280011
	TPM_E_NOSRK                                                               Handle        = 0x80280012
	TPM_E_NOTSEALED_BLOB                                                      Handle        = 0x80280013
	TPM_E_OWNER_SET                                                           Handle        = 0x80280014
	TPM_E_RESOURCES                                                           Handle        = 0x80280015
	TPM_E_SHORTRANDOM                                                         Handle        = 0x80280016
	TPM_E_SIZE                                                                Handle        = 0x80280017
	TPM_E_WRONGPCRVAL                                                         Handle        = 0x80280018
	TPM_E_BAD_PARAM_SIZE                                                      Handle        = 0x80280019
	TPM_E_SHA_THREAD                                                          Handle        = 0x8028001A
	TPM_E_SHA_ERROR                                                           Handle        = 0x8028001B
	TPM_E_FAILEDSELFTEST                                                      Handle        = 0x8028001C
	TPM_E_AUTH2FAIL                                                           Handle        = 0x8028001D
	TPM_E_BADTAG                                                              Handle        = 0x8028001E
	TPM_E_IOERROR                                                             Handle        = 0x8028001F
	TPM_E_ENCRYPT_ERROR                                                       Handle        = 0x80280020
	TPM_E_DECRYPT_ERROR                                                       Handle        = 0x80280021
	TPM_E_INVALID_AUTHHANDLE                                                  Handle        = 0x80280022
	TPM_E_NO_ENDORSEMENT                                                      Handle        = 0x80280023
	TPM_E_INVALID_KEYUSAGE                                                    Handle        = 0x80280024
	TPM_E_WRONG_ENTITYTYPE                                                    Handle        = 0x80280025
	TPM_E_INVALID_POSTINIT                                                    Handle        = 0x80280026
	TPM_E_INAPPROPRIATE_SIG                                                   Handle        = 0x80280027
	TPM_E_BAD_KEY_PROPERTY                                                    Handle        = 0x80280028
	TPM_E_BAD_MIGRATION                                                       Handle        = 0x80280029
	TPM_E_BAD_SCHEME                                                          Handle        = 0x8028002A
	TPM_E_BAD_DATASIZE                                                        Handle        = 0x8028002B
	TPM_E_BAD_MODE                                                            Handle        = 0x8028002C
	TPM_E_BAD_PRESENCE                                                        Handle        = 0x8028002D
	TPM_E_BAD_VERSION                                                         Handle        = 0x8028002E
	TPM_E_NO_WRAP_TRANSPORT                                                   Handle        = 0x8028002F
	TPM_E_AUDITFAIL_UNSUCCESSFUL                                              Handle        = 0x80280030
	TPM_E_AUDITFAIL_SUCCESSFUL                                                Handle        = 0x80280031
	TPM_E_NOTRESETABLE                                                        Handle        = 0x80280032
	TPM_E_NOTLOCAL                                                            Handle        = 0x80280033
	TPM_E_BAD_TYPE                                                            Handle        = 0x80280034
	TPM_E_INVALID_RESOURCE                                                    Handle        = 0x80280035
	TPM_E_NOTFIPS                                                             Handle        = 0x80280036
	TPM_E_INVALID_FAMILY                                                      Handle        = 0x80280037
	TPM_E_NO_NV_PERMISSION                                                    Handle        = 0x80280038
	TPM_E_REQUIRES_SIGN                                                       Handle        = 0x80280039
	TPM_E_KEY_NOTSUPPORTED                                                    Handle        = 0x8028003A
	TPM_E_AUTH_CONFLICT                                                       Handle        = 0x8028003B
	TPM_E_AREA_LOCKED                                                         Handle        = 0x8028003C
	TPM_E_BAD_LOCALITY                                                        Handle        = 0x8028003D
	TPM_E_READ_ONLY                                                           Handle        = 0x8028003E
	TPM_E_PER_NOWRITE                                                         Handle        = 0x8028003F
	TPM_E_FAMILYCOUNT                                                         Handle        = 0x80280040
	TPM_E_WRITE_LOCKED                                                        Handle        = 0x80280041
	TPM_E_BAD_ATTRIBUTES                                                      Handle        = 0x80280042
	TPM_E_INVALID_STRUCTURE                                                   Handle        = 0x80280043
	TPM_E_KEY_OWNER_CONTROL                                                   Handle        = 0x80280044
	TPM_E_BAD_COUNTER                                                         Handle        = 0x80280045
	TPM_E_NOT_FULLWRITE                                                       Handle        = 0x80280046
	TPM_E_CONTEXT_GAP                                                         Handle        = 0x80280047
	TPM_E_MAXNVWRITES                                                         Handle        = 0x80280048
	TPM_E_NOOPERATOR                                                          Handle        = 0x80280049
	TPM_E_RESOURCEMISSING                                                     Handle        = 0x8028004A
	TPM_E_DELEGATE_LOCK                                                       Handle        = 0x8028004B
	TPM_E_DELEGATE_FAMILY                                                     Handle        = 0x8028004C
	TPM_E_DELEGATE_ADMIN                                                      Handle        = 0x8028004D
	TPM_E_TRANSPORT_NOTEXCLUSIVE                                              Handle        = 0x8028004E
	TPM_E_OWNER_CONTROL                                                       Handle        = 0x8028004F
	TPM_E_DAA_RESOURCES                                                       Handle        = 0x80280050
	TPM_E_DAA_INPUT_DATA0                                                     Handle        = 0x80280051
	TPM_E_DAA_INPUT_DATA1                                                     Handle        = 0x80280052
	TPM_E_DAA_ISSUER_SETTINGS                                                 Handle        = 0x80280053
	TPM_E_DAA_TPM_SETTINGS                                                    Handle        = 0x80280054
	TPM_E_DAA_STAGE                                                           Handle        = 0x80280055
	TPM_E_DAA_ISSUER_VALIDITY                                                 Handle        = 0x80280056
	TPM_E_DAA_WRONG_W                                                         Handle        = 0x80280057
	TPM_E_BAD_HANDLE                                                          Handle        = 0x80280058
	TPM_E_BAD_DELEGATE                                                        Handle        = 0x80280059
	TPM_E_BADCONTEXT                                                          Handle        = 0x8028005A
	TPM_E_TOOMANYCONTEXTS                                                     Handle        = 0x8028005B
	TPM_E_MA_TICKET_SIGNATURE                                                 Handle        = 0x8028005C
	TPM_E_MA_DESTINATION                                                      Handle        = 0x8028005D
	TPM_E_MA_SOURCE                                                           Handle        = 0x8028005E
	TPM_E_MA_AUTHORITY                                                        Handle        = 0x8028005F
	TPM_E_PERMANENTEK                                                         Handle        = 0x80280061
	TPM_E_BAD_SIGNATURE                                                       Handle        = 0x80280062
	TPM_E_NOCONTEXTSPACE                                                      Handle        = 0x80280063
	TPM_20_E_ASYMMETRIC                                                       Handle        = 0x80280081
	TPM_20_E_ATTRIBUTES                                                       Handle        = 0x80280082
	TPM_20_E_HASH                                                             Handle        = 0x80280083
	TPM_20_E_VALUE                                                            Handle        = 0x80280084
	TPM_20_E_HIERARCHY                                                        Handle        = 0x80280085
	TPM_20_E_KEY_SIZE                                                         Handle        = 0x80280087
	TPM_20_E_MGF                                                              Handle        = 0x80280088
	TPM_20_E_MODE                                                             Handle        = 0x80280089
	TPM_20_E_TYPE                                                             Handle        = 0x8028008A
	TPM_20_E_HANDLE                                                           Handle        = 0x8028008B
	TPM_20_E_KDF                                                              Handle        = 0x8028008C
	TPM_20_E_RANGE                                                            Handle        = 0x8028008D
	TPM_20_E_AUTH_FAIL                                                        Handle        = 0x8028008E
	TPM_20_E_NONCE                                                            Handle        = 0x8028008F
	TPM_20_E_PP                                                               Handle        = 0x80280090
	TPM_20_E_SCHEME                                                           Handle        = 0x80280092
	TPM_20_E_SIZE                                                             Handle        = 0x80280095
	TPM_20_E_SYMMETRIC                                                        Handle        = 0x80280096
	TPM_20_E_TAG                                                              Handle        = 0x80280097
	TPM_20_E_SELECTOR                                                         Handle        = 0x80280098
	TPM_20_E_INSUFFICIENT                                                     Handle        = 0x8028009A
	TPM_20_E_SIGNATURE                                                        Handle        = 0x8028009B
	TPM_20_E_KEY                                                              Handle        = 0x8028009C
	TPM_20_E_POLICY_FAIL                                                      Handle        = 0x8028009D
	TPM_20_E_INTEGRITY                                                        Handle        = 0x8028009F
	TPM_20_E_TICKET                                                           Handle        = 0x802800A0
	TPM_20_E_RESERVED_BITS                                                    Handle        = 0x802800A1
	TPM_20_E_BAD_AUTH                                                         Handle        = 0x802800A2
	TPM_20_E_EXPIRED                                                          Handle        = 0x802800A3
	TPM_20_E_POLICY_CC                                                        Handle        = 0x802800A4
	TPM_20_E_BINDING                                                          Handle        = 0x802800A5
	TPM_20_E_CURVE                                                            Handle        = 0x802800A6
	TPM_20_E_ECC_POINT                                                        Handle        = 0x802800A7
	TPM_20_E_INITIALIZE                                                       Handle        = 0x80280100
	TPM_20_E_FAILURE                                                          Handle        = 0x80280101
	TPM_20_E_SEQUENCE                                                         Handle        = 0x80280103
	TPM_20_E_PRIVATE                                                          Handle        = 0x8028010B
	TPM_20_E_HMAC                                                             Handle        = 0x80280119
	TPM_20_E_DISABLED                                                         Handle        = 0x80280120
	TPM_20_E_EXCLUSIVE                                                        Handle        = 0x80280121
	TPM_20_E_ECC_CURVE                                                        Handle        = 0x80280123
	TPM_20_E_AUTH_TYPE                                                        Handle        = 0x80280124
	TPM_20_E_AUTH_MISSING                                                     Handle        = 0x80280125
	TPM_20_E_POLICY                                                           Handle        = 0x80280126
	TPM_20_E_PCR                                                              Handle        = 0x80280127
	TPM_20_E_PCR_CHANGED                                                      Handle        = 0x80280128
	TPM_20_E_UPGRADE                                                          Handle        = 0x8028012D
	TPM_20_E_TOO_MANY_CONTEXTS                                                Handle        = 0x8028012E
	TPM_20_E_AUTH_UNAVAILABLE                                                 Handle        = 0x8028012F
	TPM_20_E_REBOOT                                                           Handle        = 0x80280130
	TPM_20_E_UNBALANCED                                                       Handle        = 0x80280131
	TPM_20_E_COMMAND_SIZE                                                     Handle        = 0x80280142
	TPM_20_E_COMMAND_CODE                                                     Handle        = 0x80280143
	TPM_20_E_AUTHSIZE                                                         Handle        = 0x80280144
	TPM_20_E_AUTH_CONTEXT                                                     Handle        = 0x80280145
	TPM_20_E_NV_RANGE                                                         Handle        = 0x80280146
	TPM_20_E_NV_SIZE                                                          Handle        = 0x80280147
	TPM_20_E_NV_LOCKED                                                        Handle        = 0x80280148
	TPM_20_E_NV_AUTHORIZATION                                                 Handle        = 0x80280149
	TPM_20_E_NV_UNINITIALIZED                                                 Handle        = 0x8028014A
	TPM_20_E_NV_SPACE                                                         Handle        = 0x8028014B
	TPM_20_E_NV_DEFINED                                                       Handle        = 0x8028014C
	TPM_20_E_BAD_CONTEXT                                                      Handle        = 0x80280150
	TPM_20_E_CPHASH                                                           Handle        = 0x80280151
	TPM_20_E_PARENT                                                           Handle        = 0x80280152
	TPM_20_E_NEEDS_TEST                                                       Handle        = 0x80280153
	TPM_20_E_NO_RESULT                                                        Handle        = 0x80280154
	TPM_20_E_SENSITIVE                                                        Handle        = 0x80280155
	TPM_E_COMMAND_BLOCKED                                                     Handle        = 0x80280400
	TPM_E_INVALID_HANDLE                                                      Handle        = 0x80280401
	TPM_E_DUPLICATE_VHANDLE                                                   Handle        = 0x80280402
	TPM_E_EMBEDDED_COMMAND_BLOCKED                                            Handle        = 0x80280403
	TPM_E_EMBEDDED_COMMAND_UNSUPPORTED                                        Handle        = 0x80280404
	TPM_E_RETRY                                                               Handle        = 0x80280800
	TPM_E_NEEDS_SELFTEST                                                      Handle        = 0x80280801
	TPM_E_DOING_SELFTEST                                                      Handle        = 0x80280802
	TPM_E_DEFEND_LOCK_RUNNING                                                 Handle        = 0x80280803
	TPM_20_E_CONTEXT_GAP                                                      Handle        = 0x80280901
	TPM_20_E_OBJECT_MEMORY                                                    Handle        = 0x80280902
	TPM_20_E_SESSION_MEMORY                                                   Handle        = 0x80280903
	TPM_20_E_MEMORY                                                           Handle        = 0x80280904
	TPM_20_E_SESSION_HANDLES                                                  Handle        = 0x80280905
	TPM_20_E_OBJECT_HANDLES                                                   Handle        = 0x80280906
	TPM_20_E_LOCALITY                                                         Handle        = 0x80280907
	TPM_20_E_YIELDED                                                          Handle        = 0x80280908
	TPM_20_E_CANCELED                                                         Handle        = 0x80280909
	TPM_20_E_TESTING                                                          Handle        = 0x8028090A
	TPM_20_E_NV_RATE                                                          Handle        = 0x80280920
	TPM_20_E_LOCKOUT                                                          Handle        = 0x80280921
	TPM_20_E_RETRY                                                            Handle        = 0x80280922
	TPM_20_E_NV_UNAVAILABLE                                                   Handle        = 0x80280923
	TBS_E_INTERNAL_ERROR                                                      Handle        = 0x80284001
	TBS_E_BAD_PARAMETER                                                       Handle        = 0x80284002
	TBS_E_INVALID_OUTPUT_POINTER                                              Handle        = 0x80284003
	TBS_E_INVALID_CONTEXT                                                     Handle        = 0x80284004
	TBS_E_INSUFFICIENT_BUFFER                                                 Handle        = 0x80284005
	TBS_E_IOERROR                                                             Handle        = 0x80284006
	TBS_E_INVALID_CONTEXT_PARAM                                               Handle        = 0x80284007
	TBS_E_SERVICE_NOT_RUNNING                                                 Handle        = 0x80284008
	TBS_E_TOO_MANY_TBS_CONTEXTS                                               Handle        = 0x80284009
	TBS_E_TOO_MANY_RESOURCES                                                  Handle        = 0x8028400A
	TBS_E_SERVICE_START_PENDING                                               Handle        = 0x8028400B
	TBS_E_PPI_NOT_SUPPORTED                                                   Handle        = 0x8028400C
	TBS_E_COMMAND_CANCELED                                                    Handle        = 0x8028400D
	TBS_E_BUFFER_TOO_LARGE                                                    Handle        = 0x8028400E
	TBS_E_TPM_NOT_FOUND                                                       Handle        = 0x8028400F
	TBS_E_SERVICE_DISABLED                                                    Handle        = 0x80284010
	TBS_E_NO_EVENT_LOG                                                        Handle        = 0x80284011
	TBS_E_ACCESS_DENIED                                                       Handle        = 0x80284012
	TBS_E_PROVISIONING_NOT_ALLOWED                                            Handle        = 0x80284013
	TBS_E_PPI_FUNCTION_UNSUPPORTED                                            Handle        = 0x80284014
	TBS_E_OWNERAUTH_NOT_FOUND                                                 Handle        = 0x80284015
	TBS_E_PROVISIONING_INCOMPLETE                                             Handle        = 0x80284016
	TPMAPI_E_INVALID_STATE                                                    Handle        = 0x80290100
	TPMAPI_E_NOT_ENOUGH_DATA                                                  Handle        = 0x80290101
	TPMAPI_E_TOO_MUCH_DATA                                                    Handle        = 0x80290102
	TPMAPI_E_INVALID_OUTPUT_POINTER                                           Handle        = 0x80290103
	TPMAPI_E_INVALID_PARAMETER                                                Handle        = 0x80290104
	TPMAPI_E_OUT_OF_MEMORY                                                    Handle        = 0x80290105
	TPMAPI_E_BUFFER_TOO_SMALL                                                 Handle        = 0x80290106
	TPMAPI_E_INTERNAL_ERROR                                                   Handle        = 0x80290107
	TPMAPI_E_ACCESS_DENIED                                                    Handle        = 0x80290108
	TPMAPI_E_AUTHORIZATION_FAILED                                             Handle        = 0x80290109
	TPMAPI_E_INVALID_CONTEXT_HANDLE                                           Handle        = 0x8029010A
	TPMAPI_E_TBS_COMMUNICATION_ERROR                                          Handle        = 0x8029010B
	TPMAPI_E_TPM_COMMAND_ERROR                                                Handle        = 0x8029010C
	TPMAPI_E_MESSAGE_TOO_LARGE                                                Handle        = 0x8029010D
	TPMAPI_E_INVALID_ENCODING                                                 Handle        = 0x8029010E
	TPMAPI_E_INVALID_KEY_SIZE                                                 Handle        = 0x8029010F
	TPMAPI_E_ENCRYPTION_FAILED                                                Handle        = 0x80290110
	TPMAPI_E_INVALID_KEY_PARAMS                                               Handle        = 0x80290111
	TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB                             Handle        = 0x80290112
	TPMAPI_E_INVALID_PCR_INDEX                                                Handle        = 0x80290113
	TPMAPI_E_INVALID_DELEGATE_BLOB                                            Handle        = 0x80290114
	TPMAPI_E_INVALID_CONTEXT_PARAMS                                           Handle        = 0x80290115
	TPMAPI_E_INVALID_KEY_BLOB                                                 Handle        = 0x80290116
	TPMAPI_E_INVALID_PCR_DATA                                                 Handle        = 0x80290117
	TPMAPI_E_INVALID_OWNER_AUTH                                               Handle        = 0x80290118
	TPMAPI_E_FIPS_RNG_CHECK_FAILED                                            Handle        = 0x80290119
	TPMAPI_E_EMPTY_TCG_LOG                                                    Handle        = 0x8029011A
	TPMAPI_E_INVALID_TCG_LOG_ENTRY                                            Handle        = 0x8029011B
	TPMAPI_E_TCG_SEPARATOR_ABSENT                                             Handle        = 0x8029011C
	TPMAPI_E_TCG_INVALID_DIGEST_ENTRY                                         Handle        = 0x8029011D
	TPMAPI_E_POLICY_DENIES_OPERATION                                          Handle        = 0x8029011E
	TPMAPI_E_NV_BITS_NOT_DEFINED                                              Handle        = 0x8029011F
	TPMAPI_E_NV_BITS_NOT_READY                                                Handle        = 0x80290120
	TPMAPI_E_SEALING_KEY_NOT_AVAILABLE                                        Handle        = 0x80290121
	TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND                                     Handle        = 0x80290122
	TPMAPI_E_SVN_COUNTER_NOT_AVAILABLE                                        Handle        = 0x80290123
	TPMAPI_E_OWNER_AUTH_NOT_NULL                                              Handle        = 0x80290124
	TPMAPI_E_ENDORSEMENT_AUTH_NOT_NULL                                        Handle        = 0x80290125
	TPMAPI_E_AUTHORIZATION_REVOKED                                            Handle        = 0x80290126
	TPMAPI_E_MALFORMED_AUTHORIZATION_KEY                                      Handle        = 0x80290127
	TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED                                    Handle        = 0x80290128
	TPMAPI_E_INVALID_AUTHORIZATION_SIGNATURE                                  Handle        = 0x80290129
	TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY                                   Handle        = 0x8029012A
	TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER                                    Handle        = 0x8029012B
	TPMAPI_E_SEALING_KEY_CHANGED                                              Handle        = 0x8029012C
	TBSIMP_E_BUFFER_TOO_SMALL                                                 Handle        = 0x80290200
	TBSIMP_E_CLEANUP_FAILED                                                   Handle        = 0x80290201
	TBSIMP_E_INVALID_CONTEXT_HANDLE                                           Handle        = 0x80290202
	TBSIMP_E_INVALID_CONTEXT_PARAM                                            Handle        = 0x80290203
	TBSIMP_E_TPM_ERROR                                                        Handle        = 0x80290204
	TBSIMP_E_HASH_BAD_KEY                                                     Handle        = 0x80290205
	TBSIMP_E_DUPLICATE_VHANDLE                                                Handle        = 0x80290206
	TBSIMP_E_INVALID_OUTPUT_POINTER                                           Handle        = 0x80290207
	TBSIMP_E_INVALID_PARAMETER                                                Handle        = 0x80290208
	TBSIMP_E_RPC_INIT_FAILED                                                  Handle        = 0x80290209
	TBSIMP_E_SCHEDULER_NOT_RUNNING                                            Handle        = 0x8029020A
	TBSIMP_E_COMMAND_CANCELED                                                 Handle        = 0x8029020B
	TBSIMP_E_OUT_OF_MEMORY                                                    Handle        = 0x8029020C
	TBSIMP_E_LIST_NO_MORE_ITEMS                                               Handle        = 0x8029020D
	TBSIMP_E_LIST_NOT_FOUND                                                   Handle        = 0x8029020E
	TBSIMP_E_NOT_ENOUGH_SPACE                                                 Handle        = 0x8029020F
	TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS                                          Handle        = 0x80290210
	TBSIMP_E_COMMAND_FAILED                                                   Handle        = 0x80290211
	TBSIMP_E_UNKNOWN_ORDINAL                                                  Handle        = 0x80290212
	TBSIMP_E_RESOURCE_EXPIRED                                                 Handle        = 0x80290213
	TBSIMP_E_INVALID_RESOURCE                                                 Handle        = 0x80290214
	TBSIMP_E_NOTHING_TO_UNLOAD                                                Handle        = 0x80290215
	TBSIMP_E_HASH_TABLE_FULL                                                  Handle        = 0x80290216
	TBSIMP_E_TOO_MANY_TBS_CONTEXTS                                            Handle        = 0x80290217
	TBSIMP_E_TOO_MANY_RESOURCES                                               Handle        = 0x80290218
	TBSIMP_E_PPI_NOT_SUPPORTED                                                Handle        = 0x80290219
	TBSIMP_E_TPM_INCOMPATIBLE                                                 Handle        = 0x8029021A
	TBSIMP_E_NO_EVENT_LOG                                                     Handle        = 0x8029021B
	TPM_E_PPI_ACPI_FAILURE                                                    Handle        = 0x80290300
	TPM_E_PPI_USER_ABORT                                                      Handle        = 0x80290301
	TPM_E_PPI_BIOS_FAILURE                                                    Handle        = 0x80290302
	TPM_E_PPI_NOT_SUPPORTED                                                   Handle        = 0x80290303
	TPM_E_PPI_BLOCKED_IN_BIOS                                                 Handle        = 0x80290304
	TPM_E_PCP_ERROR_MASK                                                      Handle        = 0x80290400
	TPM_E_PCP_DEVICE_NOT_READY                                                Handle        = 0x80290401
	TPM_E_PCP_INVALID_HANDLE                                                  Handle        = 0x80290402
	TPM_E_PCP_INVALID_PARAMETER                                               Handle        = 0x80290403
	TPM_E_PCP_FLAG_NOT_SUPPORTED                                              Handle        = 0x80290404
	TPM_E_PCP_NOT_SUPPORTED                                                   Handle        = 0x80290405
	TPM_E_PCP_BUFFER_TOO_SMALL                                                Handle        = 0x80290406
	TPM_E_PCP_INTERNAL_ERROR                                                  Handle        = 0x80290407
	TPM_E_PCP_AUTHENTICATION_FAILED                                           Handle        = 0x80290408
	TPM_E_PCP_AUTHENTICATION_IGNORED                                          Handle        = 0x80290409
	TPM_E_PCP_POLICY_NOT_FOUND                                                Handle        = 0x8029040A
	TPM_E_PCP_PROFILE_NOT_FOUND                                               Handle        = 0x8029040B
	TPM_E_PCP_VALIDATION_FAILED                                               Handle        = 0x8029040C
	TPM_E_PCP_WRONG_PARENT                                                    Handle        = 0x8029040E
	TPM_E_KEY_NOT_LOADED                                                      Handle        = 0x8029040F
	TPM_E_NO_KEY_CERTIFICATION                                                Handle        = 0x80290410
	TPM_E_KEY_NOT_FINALIZED                                                   Handle        = 0x80290411
	TPM_E_ATTESTATION_CHALLENGE_NOT_SET                                       Handle        = 0x80290412
	TPM_E_NOT_PCR_BOUND                                                       Handle        = 0x80290413
	TPM_E_KEY_ALREADY_FINALIZED                                               Handle        = 0x80290414
	TPM_E_KEY_USAGE_POLICY_NOT_SUPPORTED                                      Handle        = 0x80290415
	TPM_E_KEY_USAGE_POLICY_INVALID                                            Handle        = 0x80290416
	TPM_E_SOFT_KEY_ERROR                                                      Handle        = 0x80290417
	TPM_E_KEY_NOT_AUTHENTICATED                                               Handle        = 0x80290418
	TPM_E_PCP_KEY_NOT_AIK                                                     Handle        = 0x80290419
	TPM_E_KEY_NOT_SIGNING_KEY                                                 Handle        = 0x8029041A
	TPM_E_LOCKED_OUT                                                          Handle        = 0x8029041B
	TPM_E_CLAIM_TYPE_NOT_SUPPORTED                                            Handle        = 0x8029041C
	TPM_E_VERSION_NOT_SUPPORTED                                               Handle        = 0x8029041D
	TPM_E_BUFFER_LENGTH_MISMATCH                                              Handle        = 0x8029041E
	TPM_E_PCP_IFX_RSA_KEY_CREATION_BLOCKED                                    Handle        = 0x8029041F
	TPM_E_PCP_TICKET_MISSING                                                  Handle        = 0x80290420
	TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED                                        Handle        = 0x80290421
	TPM_E_PCP_KEY_HANDLE_INVALIDATED                                          Handle        = 0x80290422
	TPM_E_PCP_UNSUPPORTED_PSS_SALT                                            Handle        = 0x40290423
	TPM_E_ZERO_EXHAUST_ENABLED                                                Handle        = 0x80290500
	PLA_E_DCS_NOT_FOUND                                                       Handle        = 0x80300002
	PLA_E_DCS_IN_USE                                                          Handle        = 0x803000AA
	PLA_E_TOO_MANY_FOLDERS                                                    Handle        = 0x80300045
	PLA_E_NO_MIN_DISK                                                         Handle        = 0x80300070
	PLA_E_DCS_ALREADY_EXISTS                                                  Handle        = 0x803000B7
	PLA_S_PROPERTY_IGNORED                                                    Handle        = 0x00300100
	PLA_E_PROPERTY_CONFLICT                                                   Handle        = 0x80300101
	PLA_E_DCS_SINGLETON_REQUIRED                                              Handle        = 0x80300102
	PLA_E_CREDENTIALS_REQUIRED                                                Handle        = 0x80300103
	PLA_E_DCS_NOT_RUNNING                                                     Handle        = 0x80300104
	PLA_E_CONFLICT_INCL_EXCL_API                                              Handle        = 0x80300105
	PLA_E_NETWORK_EXE_NOT_VALID                                               Handle        = 0x80300106
	PLA_E_EXE_ALREADY_CONFIGURED                                              Handle        = 0x80300107
	PLA_E_EXE_PATH_NOT_VALID                                                  Handle        = 0x80300108
	PLA_E_DC_ALREADY_EXISTS                                                   Handle        = 0x80300109
	PLA_E_DCS_START_WAIT_TIMEOUT                                              Handle        = 0x8030010A
	PLA_E_DC_START_WAIT_TIMEOUT                                               Handle        = 0x8030010B
	PLA_E_REPORT_WAIT_TIMEOUT                                                 Handle        = 0x8030010C
	PLA_E_NO_DUPLICATES                                                       Handle        = 0x8030010D
	PLA_E_EXE_FULL_PATH_REQUIRED                                              Handle        = 0x8030010E
	PLA_E_INVALID_SESSION_NAME                                                Handle        = 0x8030010F
	PLA_E_PLA_CHANNEL_NOT_ENABLED                                             Handle        = 0x80300110
	PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED                                       Handle        = 0x80300111
	PLA_E_RULES_MANAGER_FAILED                                                Handle        = 0x80300112
	PLA_E_CABAPI_FAILURE                                                      Handle        = 0x80300113
	FVE_E_LOCKED_VOLUME                                                       Handle        = 0x80310000
	FVE_E_NOT_ENCRYPTED                                                       Handle        = 0x80310001
	FVE_E_NO_TPM_BIOS                                                         Handle        = 0x80310002
	FVE_E_NO_MBR_METRIC                                                       Handle        = 0x80310003
	FVE_E_NO_BOOTSECTOR_METRIC                                                Handle        = 0x80310004
	FVE_E_NO_BOOTMGR_METRIC                                                   Handle        = 0x80310005
	FVE_E_WRONG_BOOTMGR                                                       Handle        = 0x80310006
	FVE_E_SECURE_KEY_REQUIRED                                                 Handle        = 0x80310007
	FVE_E_NOT_ACTIVATED                                                       Handle        = 0x80310008
	FVE_E_ACTION_NOT_ALLOWED                                                  Handle        = 0x80310009
	FVE_E_AD_SCHEMA_NOT_INSTALLED                                             Handle        = 0x8031000A
	FVE_E_AD_INVALID_DATATYPE                                                 Handle        = 0x8031000B
	FVE_E_AD_INVALID_DATASIZE                                                 Handle        = 0x8031000C
	FVE_E_AD_NO_VALUES                                                        Handle        = 0x8031000D
	FVE_E_AD_ATTR_NOT_SET                                                     Handle        = 0x8031000E
	FVE_E_AD_GUID_NOT_FOUND                                                   Handle        = 0x8031000F
	FVE_E_BAD_INFORMATION                                                     Handle        = 0x80310010
	FVE_E_TOO_SMALL                                                           Handle        = 0x80310011
	FVE_E_SYSTEM_VOLUME                                                       Handle        = 0x80310012
	FVE_E_FAILED_WRONG_FS                                                     Handle        = 0x80310013
	FVE_E_BAD_PARTITION_SIZE                                                  Handle        = 0x80310014
	FVE_E_NOT_SUPPORTED                                                       Handle        = 0x80310015
	FVE_E_BAD_DATA                                                            Handle        = 0x80310016
	FVE_E_VOLUME_NOT_BOUND                                                    Handle        = 0x80310017
	FVE_E_TPM_NOT_OWNED                                                       Handle        = 0x80310018
	FVE_E_NOT_DATA_VOLUME                                                     Handle        = 0x80310019
	FVE_E_AD_INSUFFICIENT_BUFFER                                              Handle        = 0x8031001A
	FVE_E_CONV_READ                                                           Handle        = 0x8031001B
	FVE_E_CONV_WRITE                                                          Handle        = 0x8031001C
	FVE_E_KEY_REQUIRED                                                        Handle        = 0x8031001D
	FVE_E_CLUSTERING_NOT_SUPPORTED                                            Handle        = 0x8031001E
	FVE_E_VOLUME_BOUND_ALREADY                                                Handle        = 0x8031001F
	FVE_E_OS_NOT_PROTECTED                                                    Handle        = 0x80310020
	FVE_E_PROTECTION_DISABLED                                                 Handle        = 0x80310021
	FVE_E_RECOVERY_KEY_REQUIRED                                               Handle        = 0x80310022
	FVE_E_FOREIGN_VOLUME                                                      Handle        = 0x80310023
	FVE_E_OVERLAPPED_UPDATE                                                   Handle        = 0x80310024
	FVE_E_TPM_SRK_AUTH_NOT_ZERO                                               Handle        = 0x80310025
	FVE_E_FAILED_SECTOR_SIZE                                                  Handle        = 0x80310026
	FVE_E_FAILED_AUTHENTICATION                                               Handle        = 0x80310027
	FVE_E_NOT_OS_VOLUME                                                       Handle        = 0x80310028
	FVE_E_AUTOUNLOCK_ENABLED                                                  Handle        = 0x80310029
	FVE_E_WRONG_BOOTSECTOR                                                    Handle        = 0x8031002A
	FVE_E_WRONG_SYSTEM_FS                                                     Handle        = 0x8031002B
	FVE_E_POLICY_PASSWORD_REQUIRED                                            Handle        = 0x8031002C
	FVE_E_CANNOT_SET_FVEK_ENCRYPTED                                           Handle        = 0x8031002D
	FVE_E_CANNOT_ENCRYPT_NO_KEY                                               Handle        = 0x8031002E
	FVE_E_BOOTABLE_CDDVD                                                      Handle        = 0x80310030
	FVE_E_PROTECTOR_EXISTS                                                    Handle        = 0x80310031
	FVE_E_RELATIVE_PATH                                                       Handle        = 0x80310032
	FVE_E_PROTECTOR_NOT_FOUND                                                 Handle        = 0x80310033
	FVE_E_INVALID_KEY_FORMAT                                                  Handle        = 0x80310034
	FVE_E_INVALID_PASSWORD_FORMAT                                             Handle        = 0x80310035
	FVE_E_FIPS_RNG_CHECK_FAILED                                               Handle        = 0x80310036
	FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD                                     Handle        = 0x80310037
	FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT                                   Handle        = 0x80310038
	FVE_E_NOT_DECRYPTED                                                       Handle        = 0x80310039
	FVE_E_INVALID_PROTECTOR_TYPE                                              Handle        = 0x8031003A
	FVE_E_NO_PROTECTORS_TO_TEST                                               Handle        = 0x8031003B
	FVE_E_KEYFILE_NOT_FOUND                                                   Handle        = 0x8031003C
	FVE_E_KEYFILE_INVALID                                                     Handle        = 0x8031003D
	FVE_E_KEYFILE_NO_VMK                                                      Handle        = 0x8031003E
	FVE_E_TPM_DISABLED                                                        Handle        = 0x8031003F
	FVE_E_NOT_ALLOWED_IN_SAFE_MODE                                            Handle        = 0x80310040
	FVE_E_TPM_INVALID_PCR                                                     Handle        = 0x80310041
	FVE_E_TPM_NO_VMK                                                          Handle        = 0x80310042
	FVE_E_PIN_INVALID                                                         Handle        = 0x80310043
	FVE_E_AUTH_INVALID_APPLICATION                                            Handle        = 0x80310044
	FVE_E_AUTH_INVALID_CONFIG                                                 Handle        = 0x80310045
	FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED                                 Handle        = 0x80310046
	FVE_E_FS_NOT_EXTENDED                                                     Handle        = 0x80310047
	FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED                                         Handle        = 0x80310048
	FVE_E_NO_LICENSE                                                          Handle        = 0x80310049
	FVE_E_NOT_ON_STACK                                                        Handle        = 0x8031004A
	FVE_E_FS_MOUNTED                                                          Handle        = 0x8031004B
	FVE_E_TOKEN_NOT_IMPERSONATED                                              Handle        = 0x8031004C
	FVE_E_DRY_RUN_FAILED                                                      Handle        = 0x8031004D
	FVE_E_REBOOT_REQUIRED                                                     Handle        = 0x8031004E
	FVE_E_DEBUGGER_ENABLED                                                    Handle        = 0x8031004F
	FVE_E_RAW_ACCESS                                                          Handle        = 0x80310050
	FVE_E_RAW_BLOCKED                                                         Handle        = 0x80310051
	FVE_E_BCD_APPLICATIONS_PATH_INCORRECT                                     Handle        = 0x80310052
	FVE_E_NOT_ALLOWED_IN_VERSION                                              Handle        = 0x80310053
	FVE_E_NO_AUTOUNLOCK_MASTER_KEY                                            Handle        = 0x80310054
	FVE_E_MOR_FAILED                                                          Handle        = 0x80310055
	FVE_E_HIDDEN_VOLUME                                                       Handle        = 0x80310056
	FVE_E_TRANSIENT_STATE                                                     Handle        = 0x80310057
	FVE_E_PUBKEY_NOT_ALLOWED                                                  Handle        = 0x80310058
	FVE_E_VOLUME_HANDLE_OPEN                                                  Handle        = 0x80310059
	FVE_E_NO_FEATURE_LICENSE                                                  Handle        = 0x8031005A
	FVE_E_INVALID_STARTUP_OPTIONS                                             Handle        = 0x8031005B
	FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED                                Handle        = 0x8031005C
	FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED                                   Handle        = 0x8031005D
	FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED                                     Handle        = 0x8031005E
	FVE_E_POLICY_RECOVERY_KEY_REQUIRED                                        Handle        = 0x8031005F
	FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED                                      Handle        = 0x80310060
	FVE_E_POLICY_STARTUP_PIN_REQUIRED                                         Handle        = 0x80310061
	FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED                                      Handle        = 0x80310062
	FVE_E_POLICY_STARTUP_KEY_REQUIRED                                         Handle        = 0x80310063
	FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED                                  Handle        = 0x80310064
	FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED                                     Handle        = 0x80310065
	FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED                                      Handle        = 0x80310066
	FVE_E_POLICY_STARTUP_TPM_REQUIRED                                         Handle        = 0x80310067
	FVE_E_POLICY_INVALID_PIN_LENGTH                                           Handle        = 0x80310068
	FVE_E_KEY_PROTECTOR_NOT_SUPPORTED                                         Handle        = 0x80310069
	FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED                                       Handle        = 0x8031006A
	FVE_E_POLICY_PASSPHRASE_REQUIRED                                          Handle        = 0x8031006B
	FVE_E_FIPS_PREVENTS_PASSPHRASE                                            Handle        = 0x8031006C
	FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED                                    Handle        = 0x8031006D
	FVE_E_INVALID_BITLOCKER_OID                                               Handle        = 0x8031006E
	FVE_E_VOLUME_TOO_SMALL                                                    Handle        = 0x8031006F
	FVE_E_DV_NOT_SUPPORTED_ON_FS                                              Handle        = 0x80310070
	FVE_E_DV_NOT_ALLOWED_BY_GP                                                Handle        = 0x80310071
	FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED                                 Handle        = 0x80310072
	FVE_E_POLICY_USER_CERTIFICATE_REQUIRED                                    Handle        = 0x80310073
	FVE_E_POLICY_USER_CERT_MUST_BE_HW                                         Handle        = 0x80310074
	FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED                    Handle        = 0x80310075
	FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED                    Handle        = 0x80310076
	FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED                               Handle        = 0x80310077
	FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED                                  Handle        = 0x80310078
	FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED                                 Handle        = 0x80310079
	FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH                                    Handle        = 0x80310080
	FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE                                        Handle        = 0x80310081
	FVE_E_RECOVERY_PARTITION                                                  Handle        = 0x80310082
	FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON                                   Handle        = 0x80310083
	FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON                                   Handle        = 0x80310084
	FVE_E_NON_BITLOCKER_OID                                                   Handle        = 0x80310085
	FVE_E_POLICY_PROHIBITS_SELFSIGNED                                         Handle        = 0x80310086
	FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED                         Handle        = 0x80310087
	FVE_E_CONV_RECOVERY_FAILED                                                Handle        = 0x80310088
	FVE_E_VIRTUALIZED_SPACE_TOO_BIG                                           Handle        = 0x80310089
	FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON                                   Handle        = 0x80310090
	FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON                                   Handle        = 0x80310091
	FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON                                   Handle        = 0x80310092
	FVE_E_NON_BITLOCKER_KU                                                    Handle        = 0x80310093
	FVE_E_PRIVATEKEY_AUTH_FAILED                                              Handle        = 0x80310094
	FVE_E_REMOVAL_OF_DRA_FAILED                                               Handle        = 0x80310095
	FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME                             Handle        = 0x80310096
	FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME                                 Handle        = 0x80310097
	FVE_E_FIPS_HASH_KDF_NOT_ALLOWED                                           Handle        = 0x80310098
	FVE_E_ENH_PIN_INVALID                                                     Handle        = 0x80310099
	FVE_E_INVALID_PIN_CHARS                                                   Handle        = 0x8031009A
	FVE_E_INVALID_DATUM_TYPE                                                  Handle        = 0x8031009B
	FVE_E_EFI_ONLY                                                            Handle        = 0x8031009C
	FVE_E_MULTIPLE_NKP_CERTS                                                  Handle        = 0x8031009D
	FVE_E_REMOVAL_OF_NKP_FAILED                                               Handle        = 0x8031009E
	FVE_E_INVALID_NKP_CERT                                                    Handle        = 0x8031009F
	FVE_E_NO_EXISTING_PIN                                                     Handle        = 0x803100A0
	FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH                                       Handle        = 0x803100A1
	FVE_E_PIN_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED                         Handle        = 0x803100A2
	FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED                    Handle        = 0x803100A3
	FVE_E_POLICY_PASSPHRASE_REQUIRES_ASCII                                    Handle        = 0x803100A4
	FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE                           Handle        = 0x803100A5
	FVE_E_WIPE_NOT_ALLOWED_ON_TP_STORAGE                                      Handle        = 0x803100A6
	FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE                                  Handle        = 0x803100A7
	FVE_E_NO_EXISTING_PASSPHRASE                                              Handle        = 0x803100A8
	FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH                                Handle        = 0x803100A9
	FVE_E_PASSPHRASE_TOO_LONG                                                 Handle        = 0x803100AA
	FVE_E_NO_PASSPHRASE_WITH_TPM                                              Handle        = 0x803100AB
	FVE_E_NO_TPM_WITH_PASSPHRASE                                              Handle        = 0x803100AC
	FVE_E_NOT_ALLOWED_ON_CSV_STACK                                            Handle        = 0x803100AD
	FVE_E_NOT_ALLOWED_ON_CLUSTER                                              Handle        = 0x803100AE
	FVE_E_EDRIVE_NO_FAILOVER_TO_SW                                            Handle        = 0x803100AF
	FVE_E_EDRIVE_BAND_IN_USE                                                  Handle        = 0x803100B0
	FVE_E_EDRIVE_DISALLOWED_BY_GP                                             Handle        = 0x803100B1
	FVE_E_EDRIVE_INCOMPATIBLE_VOLUME                                          Handle        = 0x803100B2
	FVE_E_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING                             Handle        = 0x803100B3
	FVE_E_EDRIVE_DV_NOT_SUPPORTED                                             Handle        = 0x803100B4
	FVE_E_NO_PREBOOT_KEYBOARD_DETECTED                                        Handle        = 0x803100B5
	FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED                               Handle        = 0x803100B6
	FVE_E_POLICY_REQUIRES_STARTUP_PIN_ON_TOUCH_DEVICE                         Handle        = 0x803100B7
	FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE                   Handle        = 0x803100B8
	FVE_E_WIPE_CANCEL_NOT_APPLICABLE                                          Handle        = 0x803100B9
	FVE_E_SECUREBOOT_DISABLED                                                 Handle        = 0x803100BA
	FVE_E_SECUREBOOT_CONFIGURATION_INVALID                                    Handle        = 0x803100BB
	FVE_E_EDRIVE_DRY_RUN_FAILED                                               Handle        = 0x803100BC
	FVE_E_SHADOW_COPY_PRESENT                                                 Handle        = 0x803100BD
	FVE_E_POLICY_INVALID_ENHANCED_BCD_SETTINGS                                Handle        = 0x803100BE
	FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE                                        Handle        = 0x803100BF
	FVE_E_PROTECTOR_CHANGE_MAX_PASSPHRASE_CHANGE_ATTEMPTS_REACHED             Handle        = 0x803100C0
	FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED                  Handle        = 0x803100C1
	FVE_E_LIVEID_ACCOUNT_SUSPENDED                                            Handle        = 0x803100C2
	FVE_E_LIVEID_ACCOUNT_BLOCKED                                              Handle        = 0x803100C3
	FVE_E_NOT_PROVISIONED_ON_ALL_VOLUMES                                      Handle        = 0x803100C4
	FVE_E_DE_FIXED_DATA_NOT_SUPPORTED                                         Handle        = 0x803100C5
	FVE_E_DE_HARDWARE_NOT_COMPLIANT                                           Handle        = 0x803100C6
	FVE_E_DE_WINRE_NOT_CONFIGURED                                             Handle        = 0x803100C7
	FVE_E_DE_PROTECTION_SUSPENDED                                             Handle        = 0x803100C8
	FVE_E_DE_OS_VOLUME_NOT_PROTECTED                                          Handle        = 0x803100C9
	FVE_E_DE_DEVICE_LOCKEDOUT                                                 Handle        = 0x803100CA
	FVE_E_DE_PROTECTION_NOT_YET_ENABLED                                       Handle        = 0x803100CB
	FVE_E_INVALID_PIN_CHARS_DETAILED                                          Handle        = 0x803100CC
	FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE                                  Handle        = 0x803100CD
	FVE_E_DEVICELOCKOUT_COUNTER_MISMATCH                                      Handle        = 0x803100CE
	FVE_E_BUFFER_TOO_LARGE                                                    Handle        = 0x803100CF
	FVE_E_NO_SUCH_CAPABILITY_ON_TARGET                                        Handle        = 0x803100D0
	FVE_E_DE_PREVENTED_FOR_OS                                                 Handle        = 0x803100D1
	FVE_E_DE_VOLUME_OPTED_OUT                                                 Handle        = 0x803100D2
	FVE_E_DE_VOLUME_NOT_SUPPORTED                                             Handle        = 0x803100D3
	FVE_E_EOW_NOT_SUPPORTED_IN_VERSION                                        Handle        = 0x803100D4
	FVE_E_ADBACKUP_NOT_ENABLED                                                Handle        = 0x803100D5
	FVE_E_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT                                  Handle        = 0x803100D6
	FVE_E_NOT_DE_VOLUME                                                       Handle        = 0x803100D7
	FVE_E_PROTECTION_CANNOT_BE_DISABLED                                       Handle        = 0x803100D8
	FVE_E_OSV_KSR_NOT_ALLOWED                                                 Handle        = 0x803100D9
	FWP_E_CALLOUT_NOT_FOUND                                                   Handle        = 0x80320001
	FWP_E_CONDITION_NOT_FOUND                                                 Handle        = 0x80320002
	FWP_E_FILTER_NOT_FOUND                                                    Handle        = 0x80320003
	FWP_E_LAYER_NOT_FOUND                                                     Handle        = 0x80320004
	FWP_E_PROVIDER_NOT_FOUND                                                  Handle        = 0x80320005
	FWP_E_PROVIDER_CONTEXT_NOT_FOUND                                          Handle        = 0x80320006
	FWP_E_SUBLAYER_NOT_FOUND                                                  Handle        = 0x80320007
	FWP_E_NOT_FOUND                                                           Handle        = 0x80320008
	FWP_E_ALREADY_EXISTS                                                      Handle        = 0x80320009
	FWP_E_IN_USE                                                              Handle        = 0x8032000A
	FWP_E_DYNAMIC_SESSION_IN_PROGRESS                                         Handle        = 0x8032000B
	FWP_E_WRONG_SESSION                                                       Handle        = 0x8032000C
	FWP_E_NO_TXN_IN_PROGRESS                                                  Handle        = 0x8032000D
	FWP_E_TXN_IN_PROGRESS                                                     Handle        = 0x8032000E
	FWP_E_TXN_ABORTED                                                         Handle        = 0x8032000F
	FWP_E_SESSION_ABORTED                                                     Handle        = 0x80320010
	FWP_E_INCOMPATIBLE_TXN                                                    Handle        = 0x80320011
	FWP_E_TIMEOUT                                                             Handle        = 0x80320012
	FWP_E_NET_EVENTS_DISABLED                                                 Handle        = 0x80320013
	FWP_E_INCOMPATIBLE_LAYER                                                  Handle        = 0x80320014
	FWP_E_KM_CLIENTS_ONLY                                                     Handle        = 0x80320015
	FWP_E_LIFETIME_MISMATCH                                                   Handle        = 0x80320016
	FWP_E_BUILTIN_OBJECT                                                      Handle        = 0x80320017
	FWP_E_TOO_MANY_CALLOUTS                                                   Handle        = 0x80320018
	FWP_E_NOTIFICATION_DROPPED                                                Handle        = 0x80320019
	FWP_E_TRAFFIC_MISMATCH                                                    Handle        = 0x8032001A
	FWP_E_INCOMPATIBLE_SA_STATE                                               Handle        = 0x8032001B
	FWP_E_NULL_POINTER                                                        Handle        = 0x8032001C
	FWP_E_INVALID_ENUMERATOR                                                  Handle        = 0x8032001D
	FWP_E_INVALID_FLAGS                                                       Handle        = 0x8032001E
	FWP_E_INVALID_NET_MASK                                                    Handle        = 0x8032001F
	FWP_E_INVALID_RANGE                                                       Handle        = 0x80320020
	FWP_E_INVALID_INTERVAL                                                    Handle        = 0x80320021
	FWP_E_ZERO_LENGTH_ARRAY                                                   Handle        = 0x80320022
	FWP_E_NULL_DISPLAY_NAME                                                   Handle        = 0x80320023
	FWP_E_INVALID_ACTION_TYPE                                                 Handle        = 0x80320024
	FWP_E_INVALID_WEIGHT                                                      Handle        = 0x80320025
	FWP_E_MATCH_TYPE_MISMATCH                                                 Handle        = 0x80320026
	FWP_E_TYPE_MISMATCH                                                       Handle        = 0x80320027
	FWP_E_OUT_OF_BOUNDS                                                       Handle        = 0x80320028
	FWP_E_RESERVED                                                            Handle        = 0x80320029
	FWP_E_DUPLICATE_CONDITION                                                 Handle        = 0x8032002A
	FWP_E_DUPLICATE_KEYMOD                                                    Handle        = 0x8032002B
	FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER                                      Handle        = 0x8032002C
	FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER                                   Handle        = 0x8032002D
	FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER                                     Handle        = 0x8032002E
	FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT                                   Handle        = 0x8032002F
	FWP_E_INCOMPATIBLE_AUTH_METHOD                                            Handle        = 0x80320030
	FWP_E_INCOMPATIBLE_DH_GROUP                                               Handle        = 0x80320031
	FWP_E_EM_NOT_SUPPORTED                                                    Handle        = 0x80320032
	FWP_E_NEVER_MATCH                                                         Handle        = 0x80320033
	FWP_E_PROVIDER_CONTEXT_MISMATCH                                           Handle        = 0x80320034
	FWP_E_INVALID_PARAMETER                                                   Handle        = 0x80320035
	FWP_E_TOO_MANY_SUBLAYERS                                                  Handle        = 0x80320036
	FWP_E_CALLOUT_NOTIFICATION_FAILED                                         Handle        = 0x80320037
	FWP_E_INVALID_AUTH_TRANSFORM                                              Handle        = 0x80320038
	FWP_E_INVALID_CIPHER_TRANSFORM                                            Handle        = 0x80320039
	FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM                                       Handle        = 0x8032003A
	FWP_E_INVALID_TRANSFORM_COMBINATION                                       Handle        = 0x8032003B
	FWP_E_DUPLICATE_AUTH_METHOD                                               Handle        = 0x8032003C
	FWP_E_INVALID_TUNNEL_ENDPOINT                                             Handle        = 0x8032003D
	FWP_E_L2_DRIVER_NOT_READY                                                 Handle        = 0x8032003E
	FWP_E_KEY_DICTATOR_ALREADY_REGISTERED                                     Handle        = 0x8032003F
	FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL                               Handle        = 0x80320040
	FWP_E_CONNECTIONS_DISABLED                                                Handle        = 0x80320041
	FWP_E_INVALID_DNS_NAME                                                    Handle        = 0x80320042
	FWP_E_STILL_ON                                                            Handle        = 0x80320043
	FWP_E_IKEEXT_NOT_RUNNING                                                  Handle        = 0x80320044
	FWP_E_DROP_NOICMP                                                         Handle        = 0x80320104
	WS_S_ASYNC                                                                Handle        = 0x003D0000
	WS_S_END                                                                  Handle        = 0x003D0001
	WS_E_INVALID_FORMAT                                                       Handle        = 0x803D0000
	WS_E_OBJECT_FAULTED                                                       Handle        = 0x803D0001
	WS_E_NUMERIC_OVERFLOW                                                     Handle        = 0x803D0002
	WS_E_INVALID_OPERATION                                                    Handle        = 0x803D0003
	WS_E_OPERATION_ABORTED                                                    Handle        = 0x803D0004
	WS_E_ENDPOINT_ACCESS_DENIED                                               Handle        = 0x803D0005
	WS_E_OPERATION_TIMED_OUT                                                  Handle        = 0x803D0006
	WS_E_OPERATION_ABANDONED                                                  Handle        = 0x803D0007
	WS_E_QUOTA_EXCEEDED                                                       Handle        = 0x803D0008
	WS_E_NO_TRANSLATION_AVAILABLE                                             Handle        = 0x803D0009
	WS_E_SECURITY_VERIFICATION_FAILURE                                        Handle        = 0x803D000A
	WS_E_ADDRESS_IN_USE                                                       Handle        = 0x803D000B
	WS_E_ADDRESS_NOT_AVAILABLE                                                Handle        = 0x803D000C
	WS_E_ENDPOINT_NOT_FOUND                                                   Handle        = 0x803D000D
	WS_E_ENDPOINT_NOT_AVAILABLE                                               Handle        = 0x803D000E
	WS_E_ENDPOINT_FAILURE                                                     Handle        = 0x803D000F
	WS_E_ENDPOINT_UNREACHABLE                                                 Handle        = 0x803D0010
	WS_E_ENDPOINT_ACTION_NOT_SUPPORTED                                        Handle        = 0x803D0011
	WS_E_ENDPOINT_TOO_BUSY                                                    Handle        = 0x803D0012
	WS_E_ENDPOINT_FAULT_RECEIVED                                              Handle        = 0x803D0013
	WS_E_ENDPOINT_DISCONNECTED                                                Handle        = 0x803D0014
	WS_E_PROXY_FAILURE                                                        Handle        = 0x803D0015
	WS_E_PROXY_ACCESS_DENIED                                                  Handle        = 0x803D0016
	WS_E_NOT_SUPPORTED                                                        Handle        = 0x803D0017
	WS_E_PROXY_REQUIRES_BASIC_AUTH                                            Handle        = 0x803D0018
	WS_E_PROXY_REQUIRES_DIGEST_AUTH                                           Handle        = 0x803D0019
	WS_E_PROXY_REQUIRES_NTLM_AUTH                                             Handle        = 0x803D001A
	WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH                                        Handle        = 0x803D001B
	WS_E_SERVER_REQUIRES_BASIC_AUTH                                           Handle        = 0x803D001C
	WS_E_SERVER_REQUIRES_DIGEST_AUTH                                          Handle        = 0x803D001D
	WS_E_SERVER_REQUIRES_NTLM_AUTH                                            Handle        = 0x803D001E
	WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH                                       Handle        = 0x803D001F
	WS_E_INVALID_ENDPOINT_URL                                                 Handle        = 0x803D0020
	WS_E_OTHER                                                                Handle        = 0x803D0021
	WS_E_SECURITY_TOKEN_EXPIRED                                               Handle        = 0x803D0022
	WS_E_SECURITY_SYSTEM_FAILURE                                              Handle        = 0x803D0023
	ERROR_NDIS_INTERFACE_CLOSING                                              syscall.Errno = 0x80340002
	ERROR_NDIS_BAD_VERSION                                                    syscall.Errno = 0x80340004
	ERROR_NDIS_BAD_CHARACTERISTICS                                            syscall.Errno = 0x80340005
	ERROR_NDIS_ADAPTER_NOT_FOUND                                              syscall.Errno = 0x80340006
	ERROR_NDIS_OPEN_FAILED                                                    syscall.Errno = 0x80340007
	ERROR_NDIS_DEVICE_FAILED                                                  syscall.Errno = 0x80340008
	ERROR_NDIS_MULTICAST_FULL                                                 syscall.Errno = 0x80340009
	ERROR_NDIS_MULTICAST_EXISTS                                               syscall.Errno = 0x8034000A
	ERROR_NDIS_MULTICAST_NOT_FOUND                                            syscall.Errno = 0x8034000B
	ERROR_NDIS_REQUEST_ABORTED                                                syscall.Errno = 0x8034000C
	ERROR_NDIS_RESET_IN_PROGRESS                                              syscall.Errno = 0x8034000D
	ERROR_NDIS_NOT_SUPPORTED                                                  syscall.Errno = 0x803400BB
	ERROR_NDIS_INVALID_PACKET                                                 syscall.Errno = 0x8034000F
	ERROR_NDIS_ADAPTER_NOT_READY                                              syscall.Errno = 0x80340011
	ERROR_NDIS_INVALID_LENGTH                                                 syscall.Errno = 0x80340014
	ERROR_NDIS_INVALID_DATA                                                   syscall.Errno = 0x80340015
	ERROR_NDIS_BUFFER_TOO_SHORT                                               syscall.Errno = 0x80340016
	ERROR_NDIS_INVALID_OID                                                    syscall.Errno = 0x80340017
	ERROR_NDIS_ADAPTER_REMOVED                                                syscall.Errno = 0x80340018
	ERROR_NDIS_UNSUPPORTED_MEDIA                                              syscall.Errno = 0x80340019
	ERROR_NDIS_GROUP_ADDRESS_IN_USE                                           syscall.Errno = 0x8034001A
	ERROR_NDIS_FILE_NOT_FOUND                                                 syscall.Errno = 0x8034001B
	ERROR_NDIS_ERROR_READING_FILE                                             syscall.Errno = 0x8034001C
	ERROR_NDIS_ALREADY_MAPPED                                                 syscall.Errno = 0x8034001D
	ERROR_NDIS_RESOURCE_CONFLICT                                              syscall.Errno = 0x8034001E
	ERROR_NDIS_MEDIA_DISCONNECTED                                             syscall.Errno = 0x8034001F
	ERROR_NDIS_INVALID_ADDRESS                                                syscall.Errno = 0x80340022
	ERROR_NDIS_INVALID_DEVICE_REQUEST                                         syscall.Errno = 0x80340010
	ERROR_NDIS_PAUSED                                                         syscall.Errno = 0x8034002A
	ERROR_NDIS_INTERFACE_NOT_FOUND                                            syscall.Errno = 0x8034002B
	ERROR_NDIS_UNSUPPORTED_REVISION                                           syscall.Errno = 0x8034002C
	ERROR_NDIS_INVALID_PORT                                                   syscall.Errno = 0x8034002D
	ERROR_NDIS_INVALID_PORT_STATE                                             syscall.Errno = 0x8034002E
	ERROR_NDIS_LOW_POWER_STATE                                                syscall.Errno = 0x8034002F
	ERROR_NDIS_REINIT_REQUIRED                                                syscall.Errno = 0x80340030
	ERROR_NDIS_NO_QUEUES                                                      syscall.Errno = 0x80340031
	ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED                                      syscall.Errno = 0x80342000
	ERROR_NDIS_DOT11_MEDIA_IN_USE                                             syscall.Errno = 0x80342001
	ERROR_NDIS_DOT11_POWER_STATE_INVALID                                      syscall.Errno = 0x80342002
	ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL                                       syscall.Errno = 0x80342003
	ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL                                  syscall.Errno = 0x80342004
	ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE                       syscall.Errno = 0x80342005
	ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE                          syscall.Errno = 0x80342006
	ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED                                   syscall.Errno = 0x80342007
	ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED                                      syscall.Errno = 0x80342008
	ERROR_NDIS_INDICATION_REQUIRED                                            syscall.Errno = 0x00340001
	ERROR_NDIS_OFFLOAD_POLICY                                                 syscall.Errno = 0xC034100F
	ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED                                    syscall.Errno = 0xC0341012
	ERROR_NDIS_OFFLOAD_PATH_REJECTED                                          syscall.Errno = 0xC0341013
	ERROR_HV_INVALID_HYPERCALL_CODE                                           syscall.Errno = 0xC0350002
	ERROR_HV_INVALID_HYPERCALL_INPUT                                          syscall.Errno = 0xC0350003
	ERROR_HV_INVALID_ALIGNMENT                                                syscall.Errno = 0xC0350004
	ERROR_HV_INVALID_PARAMETER                                                syscall.Errno = 0xC0350005
	ERROR_HV_ACCESS_DENIED                                                    syscall.Errno = 0xC0350006
	ERROR_HV_INVALID_PARTITION_STATE                                          syscall.Errno = 0xC0350007
	ERROR_HV_OPERATION_DENIED                                                 syscall.Errno = 0xC0350008
	ERROR_HV_UNKNOWN_PROPERTY                                                 syscall.Errno = 0xC0350009
	ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE                                      syscall.Errno = 0xC035000A
	ERROR_HV_INSUFFICIENT_MEMORY                                              syscall.Errno = 0xC035000B
	ERROR_HV_PARTITION_TOO_DEEP                                               syscall.Errno = 0xC035000C
	ERROR_HV_INVALID_PARTITION_ID                                             syscall.Errno = 0xC035000D
	ERROR_HV_INVALID_VP_INDEX                                                 syscall.Errno = 0xC035000E
	ERROR_HV_INVALID_PORT_ID                                                  syscall.Errno = 0xC0350011
	ERROR_HV_INVALID_CONNECTION_ID                                            syscall.Errno = 0xC0350012
	ERROR_HV_INSUFFICIENT_BUFFERS                                             syscall.Errno = 0xC0350013
	ERROR_HV_NOT_ACKNOWLEDGED                                                 syscall.Errno = 0xC0350014
	ERROR_HV_INVALID_VP_STATE                                                 syscall.Errno = 0xC0350015
	ERROR_HV_ACKNOWLEDGED                                                     syscall.Errno = 0xC0350016
	ERROR_HV_INVALID_SAVE_RESTORE_STATE                                       syscall.Errno = 0xC0350017
	ERROR_HV_INVALID_SYNIC_STATE                                              syscall.Errno = 0xC0350018
	ERROR_HV_OBJECT_IN_USE                                                    syscall.Errno = 0xC0350019
	ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO                                    syscall.Errno = 0xC035001A
	ERROR_HV_NO_DATA                                                          syscall.Errno = 0xC035001B
	ERROR_HV_INACTIVE                                                         syscall.Errno = 0xC035001C
	ERROR_HV_NO_RESOURCES                                                     syscall.Errno = 0xC035001D
	ERROR_HV_FEATURE_UNAVAILABLE                                              syscall.Errno = 0xC035001E
	ERROR_HV_INSUFFICIENT_BUFFER                                              syscall.Errno = 0xC0350033
	ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS                                      syscall.Errno = 0xC0350038
	ERROR_HV_CPUID_FEATURE_VALIDATION                                         syscall.Errno = 0xC035003C
	ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION                                   syscall.Errno = 0xC035003D
	ERROR_HV_PROCESSOR_STARTUP_TIMEOUT                                        syscall.Errno = 0xC035003E
	ERROR_HV_SMX_ENABLED                                                      syscall.Errno = 0xC035003F
	ERROR_HV_INVALID_LP_INDEX                                                 syscall.Errno = 0xC0350041
	ERROR_HV_INVALID_REGISTER_VALUE                                           syscall.Errno = 0xC0350050
	ERROR_HV_INVALID_VTL_STATE                                                syscall.Errno = 0xC0350051
	ERROR_HV_NX_NOT_DETECTED                                                  syscall.Errno = 0xC0350055
	ERROR_HV_INVALID_DEVICE_ID                                                syscall.Errno = 0xC0350057
	ERROR_HV_INVALID_DEVICE_STATE                                             syscall.Errno = 0xC0350058
	ERROR_HV_PENDING_PAGE_REQUESTS                                            syscall.Errno = 0x00350059
	ERROR_HV_PAGE_REQUEST_INVALID                                             syscall.Errno = 0xC0350060
	ERROR_HV_INVALID_CPU_GROUP_ID                                             syscall.Errno = 0xC035006F
	ERROR_HV_INVALID_CPU_GROUP_STATE                                          syscall.Errno = 0xC0350070
	ERROR_HV_OPERATION_FAILED                                                 syscall.Errno = 0xC0350071
	ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE                              syscall.Errno = 0xC0350072
	ERROR_HV_INSUFFICIENT_ROOT_MEMORY                                         syscall.Errno = 0xC0350073
	ERROR_HV_NOT_PRESENT                                                      syscall.Errno = 0xC0351000
	ERROR_VID_DUPLICATE_HANDLER                                               syscall.Errno = 0xC0370001
	ERROR_VID_TOO_MANY_HANDLERS                                               syscall.Errno = 0xC0370002
	ERROR_VID_QUEUE_FULL                                                      syscall.Errno = 0xC0370003
	ERROR_VID_HANDLER_NOT_PRESENT                                             syscall.Errno = 0xC0370004
	ERROR_VID_INVALID_OBJECT_NAME                                             syscall.Errno = 0xC0370005
	ERROR_VID_PARTITION_NAME_TOO_LONG                                         syscall.Errno = 0xC0370006
	ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG                                     syscall.Errno = 0xC0370007
	ERROR_VID_PARTITION_ALREADY_EXISTS                                        syscall.Errno = 0xC0370008
	ERROR_VID_PARTITION_DOES_NOT_EXIST                                        syscall.Errno = 0xC0370009
	ERROR_VID_PARTITION_NAME_NOT_FOUND                                        syscall.Errno = 0xC037000A
	ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS                                    syscall.Errno = 0xC037000B
	ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT                                    syscall.Errno = 0xC037000C
	ERROR_VID_MB_STILL_REFERENCED                                             syscall.Errno = 0xC037000D
	ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED                                    syscall.Errno = 0xC037000E
	ERROR_VID_INVALID_NUMA_SETTINGS                                           syscall.Errno = 0xC037000F
	ERROR_VID_INVALID_NUMA_NODE_INDEX                                         syscall.Errno = 0xC0370010
	ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED                           syscall.Errno = 0xC0370011
	ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE                                     syscall.Errno = 0xC0370012
	ERROR_VID_PAGE_RANGE_OVERFLOW                                             syscall.Errno = 0xC0370013
	ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE                                    syscall.Errno = 0xC0370014
	ERROR_VID_INVALID_GPA_RANGE_HANDLE                                        syscall.Errno = 0xC0370015
	ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE                              syscall.Errno = 0xC0370016
	ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED                                syscall.Errno = 0xC0370017
	ERROR_VID_INVALID_PPM_HANDLE                                              syscall.Errno = 0xC0370018
	ERROR_VID_MBPS_ARE_LOCKED                                                 syscall.Errno = 0xC0370019
	ERROR_VID_MESSAGE_QUEUE_CLOSED                                            syscall.Errno = 0xC037001A
	ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED                                syscall.Errno = 0xC037001B
	ERROR_VID_STOP_PENDING                                                    syscall.Errno = 0xC037001C
	ERROR_VID_INVALID_PROCESSOR_STATE                                         syscall.Errno = 0xC037001D
	ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT                                 syscall.Errno = 0xC037001E
	ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED                                syscall.Errno = 0xC037001F
	ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET                                   syscall.Errno = 0xC0370020
	ERROR_VID_MMIO_RANGE_DESTROYED                                            syscall.Errno = 0xC0370021
	ERROR_VID_INVALID_CHILD_GPA_PAGE_SET                                      syscall.Errno = 0xC0370022
	ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED                                  syscall.Errno = 0xC0370023
	ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL                                      syscall.Errno = 0xC0370024
	ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE                          syscall.Errno = 0xC0370025
	ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT                                        syscall.Errno = 0xC0370026
	ERROR_VID_SAVED_STATE_CORRUPT                                             syscall.Errno = 0xC0370027
	ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM                                   syscall.Errno = 0xC0370028
	ERROR_VID_SAVED_STATE_INCOMPATIBLE                                        syscall.Errno = 0xC0370029
	ERROR_VID_VTL_ACCESS_DENIED                                               syscall.Errno = 0xC037002A
	ERROR_VMCOMPUTE_TERMINATED_DURING_START                                   syscall.Errno = 0xC0370100
	ERROR_VMCOMPUTE_IMAGE_MISMATCH                                            syscall.Errno = 0xC0370101
	ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED                                      syscall.Errno = 0xC0370102
	ERROR_VMCOMPUTE_OPERATION_PENDING                                         syscall.Errno = 0xC0370103
	ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS                                    syscall.Errno = 0xC0370104
	ERROR_VMCOMPUTE_INVALID_STATE                                             syscall.Errno = 0xC0370105
	ERROR_VMCOMPUTE_UNEXPECTED_EXIT                                           syscall.Errno = 0xC0370106
	ERROR_VMCOMPUTE_TERMINATED                                                syscall.Errno = 0xC0370107
	ERROR_VMCOMPUTE_CONNECT_FAILED                                            syscall.Errno = 0xC0370108
	ERROR_VMCOMPUTE_TIMEOUT                                                   syscall.Errno = 0xC0370109
	ERROR_VMCOMPUTE_CONNECTION_CLOSED                                         syscall.Errno = 0xC037010A
	ERROR_VMCOMPUTE_UNKNOWN_MESSAGE                                           syscall.Errno = 0xC037010B
	ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION                              syscall.Errno = 0xC037010C
	ERROR_VMCOMPUTE_INVALID_JSON                                              syscall.Errno = 0xC037010D
	ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND                                          syscall.Errno = 0xC037010E
	ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS                                     syscall.Errno = 0xC037010F
	ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED                                    syscall.Errno = 0xC0370110
	ERROR_VMCOMPUTE_PROTOCOL_ERROR                                            syscall.Errno = 0xC0370111
	ERROR_VMCOMPUTE_INVALID_LAYER                                             syscall.Errno = 0xC0370112
	ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED                                  syscall.Errno = 0xC0370113
	HCS_E_TERMINATED_DURING_START                                             Handle        = 0x80370100
	HCS_E_IMAGE_MISMATCH                                                      Handle        = 0x80370101
	HCS_E_HYPERV_NOT_INSTALLED                                                Handle        = 0x80370102
	HCS_E_INVALID_STATE                                                       Handle        = 0x80370105
	HCS_E_UNEXPECTED_EXIT                                                     Handle        = 0x80370106
	HCS_E_TERMINATED                                                          Handle        = 0x80370107
	HCS_E_CONNECT_FAILED                                                      Handle        = 0x80370108
	HCS_E_CONNECTION_TIMEOUT                                                  Handle        = 0x80370109
	HCS_E_CONNECTION_CLOSED                                                   Handle        = 0x8037010A
	HCS_E_UNKNOWN_MESSAGE                                                     Handle        = 0x8037010B
	HCS_E_UNSUPPORTED_PROTOCOL_VERSION                                        Handle        = 0x8037010C
	HCS_E_INVALID_JSON                                                        Handle        = 0x8037010D
	HCS_E_SYSTEM_NOT_FOUND                                                    Handle        = 0x8037010E
	HCS_E_SYSTEM_ALREADY_EXISTS                                               Handle        = 0x8037010F
	HCS_E_SYSTEM_ALREADY_STOPPED                                              Handle        = 0x80370110
	HCS_E_PROTOCOL_ERROR                                                      Handle        = 0x80370111
	HCS_E_INVALID_LAYER                                                       Handle        = 0x80370112
	HCS_E_WINDOWS_INSIDER_REQUIRED                                            Handle        = 0x80370113
	HCS_E_SERVICE_NOT_AVAILABLE                                               Handle        = 0x80370114
	HCS_E_OPERATION_NOT_STARTED                                               Handle        = 0x80370115
	HCS_E_OPERATION_ALREADY_STARTED                                           Handle        = 0x80370116
	HCS_E_OPERATION_PENDING                                                   Handle        = 0x80370117
	HCS_E_OPERATION_TIMEOUT                                                   Handle        = 0x80370118
	HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET                               Handle        = 0x80370119
	HCS_E_OPERATION_RESULT_ALLOCATION_FAILED                                  Handle        = 0x8037011A
	HCS_E_ACCESS_DENIED                                                       Handle        = 0x8037011B
	HCS_E_GUEST_CRITICAL_ERROR                                                Handle        = 0x8037011C
	ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND                                  syscall.Errno = 0xC0370200
	ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED                               syscall.Errno = 0x80370001
	WHV_E_UNKNOWN_CAPABILITY                                                  Handle        = 0x80370300
	WHV_E_INSUFFICIENT_BUFFER                                                 Handle        = 0x80370301
	WHV_E_UNKNOWN_PROPERTY                                                    Handle        = 0x80370302
	WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG                                       Handle        = 0x80370303
	WHV_E_INVALID_PARTITION_CONFIG                                            Handle        = 0x80370304
	WHV_E_GPA_RANGE_NOT_FOUND                                                 Handle        = 0x80370305
	WHV_E_VP_ALREADY_EXISTS                                                   Handle        = 0x80370306
	WHV_E_VP_DOES_NOT_EXIST                                                   Handle        = 0x80370307
	WHV_E_INVALID_VP_STATE                                                    Handle        = 0x80370308
	WHV_E_INVALID_VP_REGISTER_NAME                                            Handle        = 0x80370309
	ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND                                     syscall.Errno = 0xC0370400
	ERROR_VSMB_SAVED_STATE_CORRUPT                                            syscall.Errno = 0xC0370401
	ERROR_VOLMGR_INCOMPLETE_REGENERATION                                      syscall.Errno = 0x80380001
	ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION                                    syscall.Errno = 0x80380002
	ERROR_VOLMGR_DATABASE_FULL                                                syscall.Errno = 0xC0380001
	ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED                                 syscall.Errno = 0xC0380002
	ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC                               syscall.Errno = 0xC0380003
	ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED                                    syscall.Errno = 0xC0380004
	ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME                              syscall.Errno = 0xC0380005
	ERROR_VOLMGR_DISK_DUPLICATE                                               syscall.Errno = 0xC0380006
	ERROR_VOLMGR_DISK_DYNAMIC                                                 syscall.Errno = 0xC0380007
	ERROR_VOLMGR_DISK_ID_INVALID                                              syscall.Errno = 0xC0380008
	ERROR_VOLMGR_DISK_INVALID                                                 syscall.Errno = 0xC0380009
	ERROR_VOLMGR_DISK_LAST_VOTER                                              syscall.Errno = 0xC038000A
	ERROR_VOLMGR_DISK_LAYOUT_INVALID                                          syscall.Errno = 0xC038000B
	ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS               syscall.Errno = 0xC038000C
	ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED                             syscall.Errno = 0xC038000D
	ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL                             syscall.Errno = 0xC038000E
	ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS               syscall.Errno = 0xC038000F
	ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS                              syscall.Errno = 0xC0380010
	ERROR_VOLMGR_DISK_MISSING                                                 syscall.Errno = 0xC0380011
	ERROR_VOLMGR_DISK_NOT_EMPTY                                               syscall.Errno = 0xC0380012
	ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE                                        syscall.Errno = 0xC0380013
	ERROR_VOLMGR_DISK_REVECTORING_FAILED                                      syscall.Errno = 0xC0380014
	ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID                                     syscall.Errno = 0xC0380015
	ERROR_VOLMGR_DISK_SET_NOT_CONTAINED                                       syscall.Errno = 0xC0380016
	ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS                                syscall.Errno = 0xC0380017
	ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES                                 syscall.Errno = 0xC0380018
	ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED                                   syscall.Errno = 0xC0380019
	ERROR_VOLMGR_EXTENT_ALREADY_USED                                          syscall.Errno = 0xC038001A
	ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS                                        syscall.Errno = 0xC038001B
	ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION                                  syscall.Errno = 0xC038001C
	ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED                                    syscall.Errno = 0xC038001D
	ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION                                syscall.Errno = 0xC038001E
	ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH                           syscall.Errno = 0xC038001F
	ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED                                 syscall.Errno = 0xC0380020
	ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID                                    syscall.Errno = 0xC0380021
	ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS                                     syscall.Errno = 0xC0380022
	ERROR_VOLMGR_MEMBER_IN_SYNC                                               syscall.Errno = 0xC0380023
	ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE                                       syscall.Errno = 0xC0380024
	ERROR_VOLMGR_MEMBER_INDEX_INVALID                                         syscall.Errno = 0xC0380025
	ERROR_VOLMGR_MEMBER_MISSING                                               syscall.Errno = 0xC0380026
	ERROR_VOLMGR_MEMBER_NOT_DETACHED                                          syscall.Errno = 0xC0380027
	ERROR_VOLMGR_MEMBER_REGENERATING                                          syscall.Errno = 0xC0380028
	ERROR_VOLMGR_ALL_DISKS_FAILED                                             syscall.Errno = 0xC0380029
	ERROR_VOLMGR_NO_REGISTERED_USERS                                          syscall.Errno = 0xC038002A
	ERROR_VOLMGR_NO_SUCH_USER                                                 syscall.Errno = 0xC038002B
	ERROR_VOLMGR_NOTIFICATION_RESET                                           syscall.Errno = 0xC038002C
	ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID                                    syscall.Errno = 0xC038002D
	ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID                                     syscall.Errno = 0xC038002E
	ERROR_VOLMGR_PACK_DUPLICATE                                               syscall.Errno = 0xC038002F
	ERROR_VOLMGR_PACK_ID_INVALID                                              syscall.Errno = 0xC0380030
	ERROR_VOLMGR_PACK_INVALID                                                 syscall.Errno = 0xC0380031
	ERROR_VOLMGR_PACK_NAME_INVALID                                            syscall.Errno = 0xC0380032
	ERROR_VOLMGR_PACK_OFFLINE                                                 syscall.Errno = 0xC0380033
	ERROR_VOLMGR_PACK_HAS_QUORUM                                              syscall.Errno = 0xC0380034
	ERROR_VOLMGR_PACK_WITHOUT_QUORUM                                          syscall.Errno = 0xC0380035
	ERROR_VOLMGR_PARTITION_STYLE_INVALID                                      syscall.Errno = 0xC0380036
	ERROR_VOLMGR_PARTITION_UPDATE_FAILED                                      syscall.Errno = 0xC0380037
	ERROR_VOLMGR_PLEX_IN_SYNC                                                 syscall.Errno = 0xC0380038
	ERROR_VOLMGR_PLEX_INDEX_DUPLICATE                                         syscall.Errno = 0xC0380039
	ERROR_VOLMGR_PLEX_INDEX_INVALID                                           syscall.Errno = 0xC038003A
	ERROR_VOLMGR_PLEX_LAST_ACTIVE                                             syscall.Errno = 0xC038003B
	ERROR_VOLMGR_PLEX_MISSING                                                 syscall.Errno = 0xC038003C
	ERROR_VOLMGR_PLEX_REGENERATING                                            syscall.Errno = 0xC038003D
	ERROR_VOLMGR_PLEX_TYPE_INVALID                                            syscall.Errno = 0xC038003E
	ERROR_VOLMGR_PLEX_NOT_RAID5                                               syscall.Errno = 0xC038003F
	ERROR_VOLMGR_PLEX_NOT_SIMPLE                                              syscall.Errno = 0xC0380040
	ERROR_VOLMGR_STRUCTURE_SIZE_INVALID                                       syscall.Errno = 0xC0380041
	ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS                               syscall.Errno = 0xC0380042
	ERROR_VOLMGR_TRANSACTION_IN_PROGRESS                                      syscall.Errno = 0xC0380043
	ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE                                syscall.Errno = 0xC0380044
	ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK                                 syscall.Errno = 0xC0380045
	ERROR_VOLMGR_VOLUME_ID_INVALID                                            syscall.Errno = 0xC0380046
	ERROR_VOLMGR_VOLUME_LENGTH_INVALID                                        syscall.Errno = 0xC0380047
	ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE                       syscall.Errno = 0xC0380048
	ERROR_VOLMGR_VOLUME_NOT_MIRRORED                                          syscall.Errno = 0xC0380049
	ERROR_VOLMGR_VOLUME_NOT_RETAINED                                          syscall.Errno = 0xC038004A
	ERROR_VOLMGR_VOLUME_OFFLINE                                               syscall.Errno = 0xC038004B
	ERROR_VOLMGR_VOLUME_RETAINED                                              syscall.Errno = 0xC038004C
	ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID                                    syscall.Errno = 0xC038004D
	ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE                                        syscall.Errno = 0xC038004E
	ERROR_VOLMGR_BAD_BOOT_DISK                                                syscall.Errno = 0xC038004F
	ERROR_VOLMGR_PACK_CONFIG_OFFLINE                                          syscall.Errno = 0xC0380050
	ERROR_VOLMGR_PACK_CONFIG_ONLINE                                           syscall.Errno = 0xC0380051
	ERROR_VOLMGR_NOT_PRIMARY_PACK                                             syscall.Errno = 0xC0380052
	ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED                                       syscall.Errno = 0xC0380053
	ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID                              syscall.Errno = 0xC0380054
	ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID                            syscall.Errno = 0xC0380055
	ERROR_VOLMGR_VOLUME_MIRRORED                                              syscall.Errno = 0xC0380056
	ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED                                      syscall.Errno = 0xC0380057
	ERROR_VOLMGR_NO_VALID_LOG_COPIES                                          syscall.Errno = 0xC0380058
	ERROR_VOLMGR_PRIMARY_PACK_PRESENT                                         syscall.Errno = 0xC0380059
	ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID                                      syscall.Errno = 0xC038005A
	ERROR_VOLMGR_MIRROR_NOT_SUPPORTED                                         syscall.Errno = 0xC038005B
	ERROR_VOLMGR_RAID5_NOT_SUPPORTED                                          syscall.Errno = 0xC038005C
	ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED                                        syscall.Errno = 0x80390001
	ERROR_BCD_TOO_MANY_ELEMENTS                                               syscall.Errno = 0xC0390002
	ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED                                    syscall.Errno = 0x80390003
	ERROR_VHD_DRIVE_FOOTER_MISSING                                            syscall.Errno = 0xC03A0001
	ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH                                  syscall.Errno = 0xC03A0002
	ERROR_VHD_DRIVE_FOOTER_CORRUPT                                            syscall.Errno = 0xC03A0003
	ERROR_VHD_FORMAT_UNKNOWN                                                  syscall.Errno = 0xC03A0004
	ERROR_VHD_FORMAT_UNSUPPORTED_VERSION                                      syscall.Errno = 0xC03A0005
	ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH                                 syscall.Errno = 0xC03A0006
	ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION                               syscall.Errno = 0xC03A0007
	ERROR_VHD_SPARSE_HEADER_CORRUPT                                           syscall.Errno = 0xC03A0008
	ERROR_VHD_BLOCK_ALLOCATION_FAILURE                                        syscall.Errno = 0xC03A0009
	ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT                                  syscall.Errno = 0xC03A000A
	ERROR_VHD_INVALID_BLOCK_SIZE                                              syscall.Errno = 0xC03A000B
	ERROR_VHD_BITMAP_MISMATCH                                                 syscall.Errno = 0xC03A000C
	ERROR_VHD_PARENT_VHD_NOT_FOUND                                            syscall.Errno = 0xC03A000D
	ERROR_VHD_CHILD_PARENT_ID_MISMATCH                                        syscall.Errno = 0xC03A000E
	ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH                                 syscall.Errno = 0xC03A000F
	ERROR_VHD_METADATA_READ_FAILURE                                           syscall.Errno = 0xC03A0010
	ERROR_VHD_METADATA_WRITE_FAILURE                                          syscall.Errno = 0xC03A0011
	ERROR_VHD_INVALID_SIZE                                                    syscall.Errno = 0xC03A0012
	ERROR_VHD_INVALID_FILE_SIZE                                               syscall.Errno = 0xC03A0013
	ERROR_VIRTDISK_PROVIDER_NOT_FOUND                                         syscall.Errno = 0xC03A0014
	ERROR_VIRTDISK_NOT_VIRTUAL_DISK                                           syscall.Errno = 0xC03A0015
	ERROR_VHD_PARENT_VHD_ACCESS_DENIED                                        syscall.Errno = 0xC03A0016
	ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH                                      syscall.Errno = 0xC03A0017
	ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED                               syscall.Errno = 0xC03A0018
	ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT                              syscall.Errno = 0xC03A0019
	ERROR_VIRTUAL_DISK_LIMITATION                                             syscall.Errno = 0xC03A001A
	ERROR_VHD_INVALID_TYPE                                                    syscall.Errno = 0xC03A001B
	ERROR_VHD_INVALID_STATE                                                   syscall.Errno = 0xC03A001C
	ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE                               syscall.Errno = 0xC03A001D
	ERROR_VIRTDISK_DISK_ALREADY_OWNED                                         syscall.Errno = 0xC03A001E
	ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE                                   syscall.Errno = 0xC03A001F
	ERROR_CTLOG_TRACKING_NOT_INITIALIZED                                      syscall.Errno = 0xC03A0020
	ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE                                 syscall.Errno = 0xC03A0021
	ERROR_CTLOG_VHD_CHANGED_OFFLINE                                           syscall.Errno = 0xC03A0022
	ERROR_CTLOG_INVALID_TRACKING_STATE                                        syscall.Errno = 0xC03A0023
	ERROR_CTLOG_INCONSISTENT_TRACKING_FILE                                    syscall.Errno = 0xC03A0024
	ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA                                      syscall.Errno = 0xC03A0025
	ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE                          syscall.Errno = 0xC03A0026
	ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE                        syscall.Errno = 0xC03A0027
	ERROR_VHD_METADATA_FULL                                                   syscall.Errno = 0xC03A0028
	ERROR_VHD_INVALID_CHANGE_TRACKING_ID                                      syscall.Errno = 0xC03A0029
	ERROR_VHD_CHANGE_TRACKING_DISABLED                                        syscall.Errno = 0xC03A002A
	ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION                             syscall.Errno = 0xC03A0030
	ERROR_QUERY_STORAGE_ERROR                                                 syscall.Errno = 0x803A0001
	HCN_E_NETWORK_NOT_FOUND                                                   Handle        = 0x803B0001
	HCN_E_ENDPOINT_NOT_FOUND                                                  Handle        = 0x803B0002
	HCN_E_LAYER_NOT_FOUND                                                     Handle        = 0x803B0003
	HCN_E_SWITCH_NOT_FOUND                                                    Handle        = 0x803B0004
	HCN_E_SUBNET_NOT_FOUND                                                    Handle        = 0x803B0005
	HCN_E_ADAPTER_NOT_FOUND                                                   Handle        = 0x803B0006
	HCN_E_PORT_NOT_FOUND                                                      Handle        = 0x803B0007
	HCN_E_POLICY_NOT_FOUND                                                    Handle        = 0x803B0008
	HCN_E_VFP_PORTSETTING_NOT_FOUND                                           Handle        = 0x803B0009
	HCN_E_INVALID_NETWORK                                                     Handle        = 0x803B000A
	HCN_E_INVALID_NETWORK_TYPE                                                Handle        = 0x803B000B
	HCN_E_INVALID_ENDPOINT                                                    Handle        = 0x803B000C
	HCN_E_INVALID_POLICY                                                      Handle        = 0x803B000D
	HCN_E_INVALID_POLICY_TYPE                                                 Handle        = 0x803B000E
	HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION                                   Handle        = 0x803B000F
	HCN_E_NETWORK_ALREADY_EXISTS                                              Handle        = 0x803B0010
	HCN_E_LAYER_ALREADY_EXISTS                                                Handle        = 0x803B0011
	HCN_E_POLICY_ALREADY_EXISTS                                               Handle        = 0x803B0012
	HCN_E_PORT_ALREADY_EXISTS                                                 Handle        = 0x803B0013
	HCN_E_ENDPOINT_ALREADY_ATTACHED                                           Handle        = 0x803B0014
	HCN_E_REQUEST_UNSUPPORTED                                                 Handle        = 0x803B0015
	HCN_E_MAPPING_NOT_SUPPORTED                                               Handle        = 0x803B0016
	HCN_E_DEGRADED_OPERATION                                                  Handle        = 0x803B0017
	HCN_E_SHARED_SWITCH_MODIFICATION                                          Handle        = 0x803B0018
	HCN_E_GUID_CONVERSION_FAILURE                                             Handle        = 0x803B0019
	HCN_E_REGKEY_FAILURE                                                      Handle        = 0x803B001A
	HCN_E_INVALID_JSON                                                        Handle        = 0x803B001B
	HCN_E_INVALID_JSON_REFERENCE                                              Handle        = 0x803B001C
	HCN_E_ENDPOINT_SHARING_DISABLED                                           Handle        = 0x803B001D
	HCN_E_INVALID_IP                                                          Handle        = 0x803B001E
	HCN_E_SWITCH_EXTENSION_NOT_FOUND                                          Handle        = 0x803B001F
	HCN_E_MANAGER_STOPPED                                                     Handle        = 0x803B0020
	GCN_E_MODULE_NOT_FOUND                                                    Handle        = 0x803B0021
	GCN_E_NO_REQUEST_HANDLERS                                                 Handle        = 0x803B0022
	GCN_E_REQUEST_UNSUPPORTED                                                 Handle        = 0x803B0023
	GCN_E_RUNTIMEKEYS_FAILED                                                  Handle        = 0x803B0024
	GCN_E_NETADAPTER_TIMEOUT                                                  Handle        = 0x803B0025
	GCN_E_NETADAPTER_NOT_FOUND                                                Handle        = 0x803B0026
	GCN_E_NETCOMPARTMENT_NOT_FOUND                                            Handle        = 0x803B0027
	GCN_E_NETINTERFACE_NOT_FOUND                                              Handle        = 0x803B0028
	GCN_E_DEFAULTNAMESPACE_EXISTS                                             Handle        = 0x803B0029
	SDIAG_E_CANCELLED                                                         syscall.Errno = 0x803C0100
	SDIAG_E_SCRIPT                                                            syscall.Errno = 0x803C0101
	SDIAG_E_POWERSHELL                                                        syscall.Errno = 0x803C0102
	SDIAG_E_MANAGEDHOST                                                       syscall.Errno = 0x803C0103
	SDIAG_E_NOVERIFIER                                                        syscall.Errno = 0x803C0104
	SDIAG_S_CANNOTRUN                                                         syscall.Errno = 0x003C0105
	SDIAG_E_DISABLED                                                          syscall.Errno = 0x803C0106
	SDIAG_E_TRUST                                                             syscall.Errno = 0x803C0107
	SDIAG_E_CANNOTRUN                                                         syscall.Errno = 0x803C0108
	SDIAG_E_VERSION                                                           syscall.Errno = 0x803C0109
	SDIAG_E_RESOURCE                                                          syscall.Errno = 0x803C010A
	SDIAG_E_ROOTCAUSE                                                         syscall.Errno = 0x803C010B
	WPN_E_CHANNEL_CLOSED                                                      Handle        = 0x803E0100
	WPN_E_CHANNEL_REQUEST_NOT_COMPLETE                                        Handle        = 0x803E0101
	WPN_E_INVALID_APP                                                         Handle        = 0x803E0102
	WPN_E_OUTSTANDING_CHANNEL_REQUEST                                         Handle        = 0x803E0103
	WPN_E_DUPLICATE_CHANNEL                                                   Handle        = 0x803E0104
	WPN_E_PLATFORM_UNAVAILABLE                                                Handle        = 0x803E0105
	WPN_E_NOTIFICATION_POSTED                                                 Handle        = 0x803E0106
	WPN_E_NOTIFICATION_HIDDEN                                                 Handle        = 0x803E0107
	WPN_E_NOTIFICATION_NOT_POSTED                                             Handle        = 0x803E0108
	WPN_E_CLOUD_DISABLED                                                      Handle        = 0x803E0109
	WPN_E_CLOUD_INCAPABLE                                                     Handle        = 0x803E0110
	WPN_E_CLOUD_AUTH_UNAVAILABLE                                              Handle        = 0x803E011A
	WPN_E_CLOUD_SERVICE_UNAVAILABLE                                           Handle        = 0x803E011B
	WPN_E_FAILED_LOCK_SCREEN_UPDATE_INTIALIZATION                             Handle        = 0x803E011C
	WPN_E_NOTIFICATION_DISABLED                                               Handle        = 0x803E0111
	WPN_E_NOTIFICATION_INCAPABLE                                              Handle        = 0x803E0112
	WPN_E_INTERNET_INCAPABLE                                                  Handle        = 0x803E0113
	WPN_E_NOTIFICATION_TYPE_DISABLED                                          Handle        = 0x803E0114
	WPN_E_NOTIFICATION_SIZE                                                   Handle        = 0x803E0115
	WPN_E_TAG_SIZE                                                            Handle        = 0x803E0116
	WPN_E_ACCESS_DENIED                                                       Handle        = 0x803E0117
	WPN_E_DUPLICATE_REGISTRATION                                              Handle        = 0x803E0118
	WPN_E_PUSH_NOTIFICATION_INCAPABLE                                         Handle        = 0x803E0119
	WPN_E_DEV_ID_SIZE                                                         Handle        = 0x803E0120
	WPN_E_TAG_ALPHANUMERIC                                                    Handle        = 0x803E012A
	WPN_E_INVALID_HTTP_STATUS_CODE                                            Handle        = 0x803E012B
	WPN_E_OUT_OF_SESSION                                                      Handle        = 0x803E0200
	WPN_E_POWER_SAVE                                                          Handle        = 0x803E0201
	WPN_E_IMAGE_NOT_FOUND_IN_CACHE                                            Handle        = 0x803E0202
	WPN_E_ALL_URL_NOT_COMPLETED                                               Handle        = 0x803E0203
	WPN_E_INVALID_CLOUD_IMAGE                                                 Handle        = 0x803E0204
	WPN_E_NOTIFICATION_ID_MATCHED                                             Handle        = 0x803E0205
	WPN_E_CALLBACK_ALREADY_REGISTERED                                         Handle        = 0x803E0206
	WPN_E_TOAST_NOTIFICATION_DROPPED                                          Handle        = 0x803E0207
	WPN_E_STORAGE_LOCKED                                                      Handle        = 0x803E0208
	WPN_E_GROUP_SIZE                                                          Handle        = 0x803E0209
	WPN_E_GROUP_ALPHANUMERIC                                                  Handle        = 0x803E020A
	WPN_E_CLOUD_DISABLED_FOR_APP                                              Handle        = 0x803E020B
	E_MBN_CONTEXT_NOT_ACTIVATED                                               Handle        = 0x80548201
	E_MBN_BAD_SIM                                                             Handle        = 0x80548202
	E_MBN_DATA_CLASS_NOT_AVAILABLE                                            Handle        = 0x80548203
	E_MBN_INVALID_ACCESS_STRING                                               Handle        = 0x80548204
	E_MBN_MAX_ACTIVATED_CONTEXTS                                              Handle        = 0x80548205
	E_MBN_PACKET_SVC_DETACHED                                                 Handle        = 0x80548206
	E_MBN_PROVIDER_NOT_VISIBLE                                                Handle        = 0x80548207
	E_MBN_RADIO_POWER_OFF                                                     Handle        = 0x80548208
	E_MBN_SERVICE_NOT_ACTIVATED                                               Handle        = 0x80548209
	E_MBN_SIM_NOT_INSERTED                                                    Handle        = 0x8054820A
	E_MBN_VOICE_CALL_IN_PROGRESS                                              Handle        = 0x8054820B
	E_MBN_INVALID_CACHE                                                       Handle        = 0x8054820C
	E_MBN_NOT_REGISTERED                                                      Handle        = 0x8054820D
	E_MBN_PROVIDERS_NOT_FOUND                                                 Handle        = 0x8054820E
	E_MBN_PIN_NOT_SUPPORTED                                                   Handle        = 0x8054820F
	E_MBN_PIN_REQUIRED                                                        Handle        = 0x80548210
	E_MBN_PIN_DISABLED                                                        Handle        = 0x80548211
	E_MBN_FAILURE                                                             Handle        = 0x80548212
	E_MBN_INVALID_PROFILE                                                     Handle        = 0x80548218
	E_MBN_DEFAULT_PROFILE_EXIST                                               Handle        = 0x80548219
	E_MBN_SMS_ENCODING_NOT_SUPPORTED                                          Handle        = 0x80548220
	E_MBN_SMS_FILTER_NOT_SUPPORTED                                            Handle        = 0x80548221
	E_MBN_SMS_INVALID_MEMORY_INDEX                                            Handle        = 0x80548222
	E_MBN_SMS_LANG_NOT_SUPPORTED                                              Handle        = 0x80548223
	E_MBN_SMS_MEMORY_FAILURE                                                  Handle        = 0x80548224
	E_MBN_SMS_NETWORK_TIMEOUT                                                 Handle        = 0x80548225
	E_MBN_SMS_UNKNOWN_SMSC_ADDRESS                                            Handle        = 0x80548226
	E_MBN_SMS_FORMAT_NOT_SUPPORTED                                            Handle        = 0x80548227
	E_MBN_SMS_OPERATION_NOT_ALLOWED                                           Handle        = 0x80548228
	E_MBN_SMS_MEMORY_FULL                                                     Handle        = 0x80548229
	PEER_E_IPV6_NOT_INSTALLED                                                 Handle        = 0x80630001
	PEER_E_NOT_INITIALIZED                                                    Handle        = 0x80630002
	PEER_E_CANNOT_START_SERVICE                                               Handle        = 0x80630003
	PEER_E_NOT_LICENSED                                                       Handle        = 0x80630004
	PEER_E_INVALID_GRAPH                                                      Handle        = 0x80630010
	PEER_E_DBNAME_CHANGED                                                     Handle        = 0x80630011
	PEER_E_DUPLICATE_GRAPH                                                    Handle        = 0x80630012
	PEER_E_GRAPH_NOT_READY                                                    Handle        = 0x80630013
	PEER_E_GRAPH_SHUTTING_DOWN                                                Handle        = 0x80630014
	PEER_E_GRAPH_IN_USE                                                       Handle        = 0x80630015
	PEER_E_INVALID_DATABASE                                                   Handle        = 0x80630016
	PEER_E_TOO_MANY_ATTRIBUTES                                                Handle        = 0x80630017
	PEER_E_CONNECTION_NOT_FOUND                                               Handle        = 0x80630103
	PEER_E_CONNECT_SELF                                                       Handle        = 0x80630106
	PEER_E_ALREADY_LISTENING                                                  Handle        = 0x80630107
	PEER_E_NODE_NOT_FOUND                                                     Handle        = 0x80630108
	PEER_E_CONNECTION_FAILED                                                  Handle        = 0x80630109
	PEER_E_CONNECTION_NOT_AUTHENTICATED                                       Handle        = 0x8063010A
	PEER_E_CONNECTION_REFUSED                                                 Handle        = 0x8063010B
	PEER_E_CLASSIFIER_TOO_LONG                                                Handle        = 0x80630201
	PEER_E_TOO_MANY_IDENTITIES                                                Handle        = 0x80630202
	PEER_E_NO_KEY_ACCESS                                                      Handle        = 0x80630203
	PEER_E_GROUPS_EXIST                                                       Handle        = 0x80630204
	PEER_E_RECORD_NOT_FOUND                                                   Handle        = 0x80630301
	PEER_E_DATABASE_ACCESSDENIED                                              Handle        = 0x80630302
	PEER_E_DBINITIALIZATION_FAILED                                            Handle        = 0x80630303
	PEER_E_MAX_RECORD_SIZE_EXCEEDED                                           Handle        = 0x80630304
	PEER_E_DATABASE_ALREADY_PRESENT                                           Handle        = 0x80630305
	PEER_E_DATABASE_NOT_PRESENT                                               Handle        = 0x80630306
	PEER_E_IDENTITY_NOT_FOUND                                                 Handle        = 0x80630401
	PEER_E_EVENT_HANDLE_NOT_FOUND                                             Handle        = 0x80630501
	PEER_E_INVALID_SEARCH                                                     Handle        = 0x80630601
	PEER_E_INVALID_ATTRIBUTES                                                 Handle        = 0x80630602
	PEER_E_INVITATION_NOT_TRUSTED                                             Handle        = 0x80630701
	PEER_E_CHAIN_TOO_LONG                                                     Handle        = 0x80630703
	PEER_E_INVALID_TIME_PERIOD                                                Handle        = 0x80630705
	PEER_E_CIRCULAR_CHAIN_DETECTED                                            Handle        = 0x80630706
	PEER_E_CERT_STORE_CORRUPTED                                               Handle        = 0x80630801
	PEER_E_NO_CLOUD                                                           Handle        = 0x80631001
	PEER_E_CLOUD_NAME_AMBIGUOUS                                               Handle        = 0x80631005
	PEER_E_INVALID_RECORD                                                     Handle        = 0x80632010
	PEER_E_NOT_AUTHORIZED                                                     Handle        = 0x80632020
	PEER_E_PASSWORD_DOES_NOT_MEET_POLICY                                      Handle        = 0x80632021
	PEER_E_DEFERRED_VALIDATION                                                Handle        = 0x80632030
	PEER_E_INVALID_GROUP_PROPERTIES                                           Handle        = 0x80632040
	PEER_E_INVALID_PEER_NAME                                                  Handle        = 0x80632050
	PEER_E_INVALID_CLASSIFIER                                                 Handle        = 0x80632060
	PEER_E_INVALID_FRIENDLY_NAME                                              Handle        = 0x80632070
	PEER_E_INVALID_ROLE_PROPERTY                                              Handle        = 0x80632071
	PEER_E_INVALID_CLASSIFIER_PROPERTY                                        Handle        = 0x80632072
	PEER_E_INVALID_RECORD_EXPIRATION                                          Handle        = 0x80632080
	PEER_E_INVALID_CREDENTIAL_INFO                                            Handle        = 0x80632081
	PEER_E_INVALID_CREDENTIAL                                                 Handle        = 0x80632082
	PEER_E_INVALID_RECORD_SIZE                                                Handle        = 0x80632083
	PEER_E_UNSUPPORTED_VERSION                                                Handle        = 0x80632090
	PEER_E_GROUP_NOT_READY                                                    Handle        = 0x80632091
	PEER_E_GROUP_IN_USE                                                       Handle        = 0x80632092
	PEER_E_INVALID_GROUP                                                      Handle        = 0x80632093
	PEER_E_NO_MEMBERS_FOUND                                                   Handle        = 0x80632094
	PEER_E_NO_MEMBER_CONNECTIONS                                              Handle        = 0x80632095
	PEER_E_UNABLE_TO_LISTEN                                                   Handle        = 0x80632096
	PEER_E_IDENTITY_DELETED                                                   Handle        = 0x806320A0
	PEER_E_SERVICE_NOT_AVAILABLE                                              Handle        = 0x806320A1
	PEER_E_CONTACT_NOT_FOUND                                                  Handle        = 0x80636001
	PEER_S_GRAPH_DATA_CREATED                                                 Handle        = 0x00630001
	PEER_S_NO_EVENT_DATA                                                      Handle        = 0x00630002
	PEER_S_ALREADY_CONNECTED                                                  Handle        = 0x00632000
	PEER_S_SUBSCRIPTION_EXISTS                                                Handle        = 0x00636000
	PEER_S_NO_CONNECTIVITY                                                    Handle        = 0x00630005
	PEER_S_ALREADY_A_MEMBER                                                   Handle        = 0x00630006
	PEER_E_CANNOT_CONVERT_PEER_NAME                                           Handle        = 0x80634001
	PEER_E_INVALID_PEER_HOST_NAME                                             Handle        = 0x80634002
	PEER_E_NO_MORE                                                            Handle        = 0x80634003
	PEER_E_PNRP_DUPLICATE_PEER_NAME                                           Handle        = 0x80634005
	PEER_E_INVITE_CANCELLED                                                   Handle        = 0x80637000
	PEER_E_INVITE_RESPONSE_NOT_AVAILABLE                                      Handle        = 0x80637001
	PEER_E_NOT_SIGNED_IN                                                      Handle        = 0x80637003
	PEER_E_PRIVACY_DECLINED                                                   Handle        = 0x80637004
	PEER_E_TIMEOUT                                                            Handle        = 0x80637005
	PEER_E_INVALID_ADDRESS                                                    Handle        = 0x80637007
	PEER_E_FW_EXCEPTION_DISABLED                                              Handle        = 0x80637008
	PEER_E_FW_BLOCKED_BY_POLICY                                               Handle        = 0x80637009
	PEER_E_FW_BLOCKED_BY_SHIELDS_UP                                           Handle        = 0x8063700A
	PEER_E_FW_DECLINED                                                        Handle        = 0x8063700B
	UI_E_CREATE_FAILED                                                        Handle        = 0x802A0001
	UI_E_SHUTDOWN_CALLED                                                      Handle        = 0x802A0002
	UI_E_ILLEGAL_REENTRANCY                                                   Handle        = 0x802A0003
	UI_E_OBJECT_SEALED                                                        Handle        = 0x802A0004
	UI_E_VALUE_NOT_SET                                                        Handle        = 0x802A0005
	UI_E_VALUE_NOT_DETERMINED                                                 Handle        = 0x802A0006
	UI_E_INVALID_OUTPUT                                                       Handle        = 0x802A0007
	UI_E_BOOLEAN_EXPECTED                                                     Handle        = 0x802A0008
	UI_E_DIFFERENT_OWNER                                                      Handle        = 0x802A0009
	UI_E_AMBIGUOUS_MATCH                                                      Handle        = 0x802A000A
	UI_E_FP_OVERFLOW                                                          Handle        = 0x802A000B
	UI_E_WRONG_THREAD                                                         Handle        = 0x802A000C
	UI_E_STORYBOARD_ACTIVE                                                    Handle        = 0x802A0101
	UI_E_STORYBOARD_NOT_PLAYING                                               Handle        = 0x802A0102
	UI_E_START_KEYFRAME_AFTER_END                                             Handle        = 0x802A0103
	UI_E_END_KEYFRAME_NOT_DETERMINED                                          Handle        = 0x802A0104
	UI_E_LOOPS_OVERLAP                                                        Handle        = 0x802A0105
	UI_E_TRANSITION_ALREADY_USED                                              Handle        = 0x802A0106
	UI_E_TRANSITION_NOT_IN_STORYBOARD                                         Handle        = 0x802A0107
	UI_E_TRANSITION_ECLIPSED                                                  Handle        = 0x802A0108
	UI_E_TIME_BEFORE_LAST_UPDATE                                              Handle        = 0x802A0109
	UI_E_TIMER_CLIENT_ALREADY_CONNECTED                                       Handle        = 0x802A010A
	UI_E_INVALID_DIMENSION                                                    Handle        = 0x802A010B
	UI_E_PRIMITIVE_OUT_OF_BOUNDS                                              Handle        = 0x802A010C
	UI_E_WINDOW_CLOSED                                                        Handle        = 0x802A0201
	E_BLUETOOTH_ATT_INVALID_HANDLE                                            Handle        = 0x80650001
	E_BLUETOOTH_ATT_READ_NOT_PERMITTED                                        Handle        = 0x80650002
	E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED                                       Handle        = 0x80650003
	E_BLUETOOTH_ATT_INVALID_PDU                                               Handle        = 0x80650004
	E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION                               Handle        = 0x80650005
	E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED                                     Handle        = 0x80650006
	E_BLUETOOTH_ATT_INVALID_OFFSET                                            Handle        = 0x80650007
	E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION                                Handle        = 0x80650008
	E_BLUETOOTH_ATT_PREPARE_QUEUE_FULL                                        Handle        = 0x80650009
	E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND                                       Handle        = 0x8065000A
	E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG                                        Handle        = 0x8065000B
	E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE                          Handle        = 0x8065000C
	E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH                            Handle        = 0x8065000D
	E_BLUETOOTH_ATT_UNLIKELY                                                  Handle        = 0x8065000E
	E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION                                   Handle        = 0x8065000F
	E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE                                    Handle        = 0x80650010
	E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES                                    Handle        = 0x80650011
	E_BLUETOOTH_ATT_UNKNOWN_ERROR                                             Handle        = 0x80651000
	E_AUDIO_ENGINE_NODE_NOT_FOUND                                             Handle        = 0x80660001
	E_HDAUDIO_EMPTY_CONNECTION_LIST                                           Handle        = 0x80660002
	E_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED                                   Handle        = 0x80660003
	E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED                                      Handle        = 0x80660004
	E_HDAUDIO_NULL_LINKED_LIST_ENTRY                                          Handle        = 0x80660005
	STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE                             Handle        = 0x80670001
	STATEREPOSITORY_E_STATEMENT_INPROGRESS                                    Handle        = 0x80670002
	STATEREPOSITORY_E_CONFIGURATION_INVALID                                   Handle        = 0x80670003
	STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION                                  Handle        = 0x80670004
	STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED                                Handle        = 0x80670005
	STATEREPOSITORY_E_BLOCKED                                                 Handle        = 0x80670006
	STATEREPOSITORY_E_BUSY_RETRY                                              Handle        = 0x80670007
	STATEREPOSITORY_E_BUSY_RECOVERY_RETRY                                     Handle        = 0x80670008
	STATEREPOSITORY_E_LOCKED_RETRY                                            Handle        = 0x80670009
	STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY                                Handle        = 0x8067000A
	STATEREPOSITORY_E_TRANSACTION_REQUIRED                                    Handle        = 0x8067000B
	STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED                                   Handle        = 0x8067000C
	STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED                          Handle        = 0x8067000D
	STATEREPOSITORY_E_LOCKED_TIMEOUT_EXCEEDED                                 Handle        = 0x8067000E
	STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED                     Handle        = 0x8067000F
	STATEREPOSITORY_E_SERVICE_STOP_IN_PROGRESS                                Handle        = 0x80670010
	STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED                         Handle        = 0x80670011
	STATEREPOSITORY_ERROR_CACHE_CORRUPTED                                     Handle        = 0x80670012
	STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED                             Handle        = 0x00670013
	STATEREPOSITORY_TRANSACTION_IN_PROGRESS                                   Handle        = 0x00670014
	ERROR_SPACES_POOL_WAS_DELETED                                             Handle        = 0x00E70001
	ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID                                    Handle        = 0x80E70001
	ERROR_SPACES_INTERNAL_ERROR                                               Handle        = 0x80E70002
	ERROR_SPACES_RESILIENCY_TYPE_INVALID                                      Handle        = 0x80E70003
	ERROR_SPACES_DRIVE_SECTOR_SIZE_INVALID                                    Handle        = 0x80E70004
	ERROR_SPACES_DRIVE_REDUNDANCY_INVALID                                     Handle        = 0x80E70006
	ERROR_SPACES_NUMBER_OF_DATA_COPIES_INVALID                                Handle        = 0x80E70007
	ERROR_SPACES_PARITY_LAYOUT_INVALID                                        Handle        = 0x80E70008
	ERROR_SPACES_INTERLEAVE_LENGTH_INVALID                                    Handle        = 0x80E70009
	ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID                                    Handle        = 0x80E7000A
	ERROR_SPACES_NOT_ENOUGH_DRIVES                                            Handle        = 0x80E7000B
	ERROR_SPACES_EXTENDED_ERROR                                               Handle        = 0x80E7000C
	ERROR_SPACES_PROVISIONING_TYPE_INVALID                                    Handle        = 0x80E7000D
	ERROR_SPACES_ALLOCATION_SIZE_INVALID                                      Handle        = 0x80E7000E
	ERROR_SPACES_ENCLOSURE_AWARE_INVALID                                      Handle        = 0x80E7000F
	ERROR_SPACES_WRITE_CACHE_SIZE_INVALID                                     Handle        = 0x80E70010
	ERROR_SPACES_NUMBER_OF_GROUPS_INVALID                                     Handle        = 0x80E70011
	ERROR_SPACES_DRIVE_OPERATIONAL_STATE_INVALID                              Handle        = 0x80E70012
	ERROR_SPACES_ENTRY_INCOMPLETE                                             Handle        = 0x80E70013
	ERROR_SPACES_ENTRY_INVALID                                                Handle        = 0x80E70014
	ERROR_VOLSNAP_BOOTFILE_NOT_VALID                                          Handle        = 0x80820001
	ERROR_VOLSNAP_ACTIVATION_TIMEOUT                                          Handle        = 0x80820002
	ERROR_TIERING_NOT_SUPPORTED_ON_VOLUME                                     Handle        = 0x80830001
	ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS                                 Handle        = 0x80830002
	ERROR_TIERING_STORAGE_TIER_NOT_FOUND                                      Handle        = 0x80830003
	ERROR_TIERING_INVALID_FILE_ID                                             Handle        = 0x80830004
	ERROR_TIERING_WRONG_CLUSTER_NODE                                          Handle        = 0x80830005
	ERROR_TIERING_ALREADY_PROCESSING                                          Handle        = 0x80830006
	ERROR_TIERING_CANNOT_PIN_OBJECT                                           Handle        = 0x80830007
	ERROR_TIERING_FILE_IS_NOT_PINNED                                          Handle        = 0x80830008
	ERROR_NOT_A_TIERED_VOLUME                                                 Handle        = 0x80830009
	ERROR_ATTRIBUTE_NOT_PRESENT                                               Handle        = 0x8083000A
	ERROR_SECCORE_INVALID_COMMAND                                             Handle        = 0xC0E80000
	ERROR_NO_APPLICABLE_APP_LICENSES_FOUND                                    Handle        = 0xC0EA0001
	ERROR_CLIP_LICENSE_NOT_FOUND                                              Handle        = 0xC0EA0002
	ERROR_CLIP_DEVICE_LICENSE_MISSING                                         Handle        = 0xC0EA0003
	ERROR_CLIP_LICENSE_INVALID_SIGNATURE                                      Handle        = 0xC0EA0004
	ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID                           Handle        = 0xC0EA0005
	ERROR_CLIP_LICENSE_EXPIRED                                                Handle        = 0xC0EA0006
	ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE                               Handle        = 0xC0EA0007
	ERROR_CLIP_LICENSE_NOT_SIGNED                                             Handle        = 0xC0EA0008
	ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE                           Handle        = 0xC0EA0009
	ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH                                     Handle        = 0xC0EA000A
	DXGI_STATUS_OCCLUDED                                                      Handle        = 0x087A0001
	DXGI_STATUS_CLIPPED                                                       Handle        = 0x087A0002
	DXGI_STATUS_NO_REDIRECTION                                                Handle        = 0x087A0004
	DXGI_STATUS_NO_DESKTOP_ACCESS                                             Handle        = 0x087A0005
	DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE                                  Handle        = 0x087A0006
	DXGI_STATUS_MODE_CHANGED                                                  Handle        = 0x087A0007
	DXGI_STATUS_MODE_CHANGE_IN_PROGRESS                                       Handle        = 0x087A0008
	DXGI_ERROR_INVALID_CALL                                                   Handle        = 0x887A0001
	DXGI_ERROR_NOT_FOUND                                                      Handle        = 0x887A0002
	DXGI_ERROR_MORE_DATA                                                      Handle        = 0x887A0003
	DXGI_ERROR_UNSUPPORTED                                                    Handle        = 0x887A0004
	DXGI_ERROR_DEVICE_REMOVED                                                 Handle        = 0x887A0005
	DXGI_ERROR_DEVICE_HUNG                                                    Handle        = 0x887A0006
	DXGI_ERROR_DEVICE_RESET                                                   Handle        = 0x887A0007
	DXGI_ERROR_WAS_STILL_DRAWING                                              Handle        = 0x887A000A
	DXGI_ERROR_FRAME_STATISTICS_DISJOINT                                      Handle        = 0x887A000B
	DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE                                   Handle        = 0x887A000C
	DXGI_ERROR_DRIVER_INTERNAL_ERROR                                          Handle        = 0x887A0020
	DXGI_ERROR_NONEXCLUSIVE                                                   Handle        = 0x887A0021
	DXGI_ERROR_NOT_CURRENTLY_AVAILABLE                                        Handle        = 0x887A0022
	DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED                                     Handle        = 0x887A0023
	DXGI_ERROR_REMOTE_OUTOFMEMORY                                             Handle        = 0x887A0024
	DXGI_ERROR_ACCESS_LOST                                                    Handle        = 0x887A0026
	DXGI_ERROR_WAIT_TIMEOUT                                                   Handle        = 0x887A0027
	DXGI_ERROR_SESSION_DISCONNECTED                                           Handle        = 0x887A0028
	DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE                                       Handle        = 0x887A0029
	DXGI_ERROR_CANNOT_PROTECT_CONTENT                                         Handle        = 0x887A002A
	DXGI_ERROR_ACCESS_DENIED                                                  Handle        = 0x887A002B
	DXGI_ERROR_NAME_ALREADY_EXISTS                                            Handle        = 0x887A002C
	DXGI_ERROR_SDK_COMPONENT_MISSING                                          Handle        = 0x887A002D
	DXGI_ERROR_NOT_CURRENT                                                    Handle        = 0x887A002E
	DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY                                      Handle        = 0x887A0030
	DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION                                  Handle        = 0x887A0031
	DXGI_ERROR_NON_COMPOSITED_UI                                              Handle        = 0x887A0032
	DXGI_STATUS_UNOCCLUDED                                                    Handle        = 0x087A0009
	DXGI_STATUS_DDA_WAS_STILL_DRAWING                                         Handle        = 0x087A000A
	DXGI_ERROR_MODE_CHANGE_IN_PROGRESS                                        Handle        = 0x887A0025
	DXGI_STATUS_PRESENT_REQUIRED                                              Handle        = 0x087A002F
	DXGI_ERROR_CACHE_CORRUPT                                                  Handle        = 0x887A0033
	DXGI_ERROR_CACHE_FULL                                                     Handle        = 0x887A0034
	DXGI_ERROR_CACHE_HASH_COLLISION                                           Handle        = 0x887A0035
	DXGI_ERROR_ALREADY_EXISTS                                                 Handle        = 0x887A0036
	DXGI_DDI_ERR_WASSTILLDRAWING                                              Handle        = 0x887B0001
	DXGI_DDI_ERR_UNSUPPORTED                                                  Handle        = 0x887B0002
	DXGI_DDI_ERR_NONEXCLUSIVE                                                 Handle        = 0x887B0003
	D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS                                 Handle        = 0x88790001
	D3D10_ERROR_FILE_NOT_FOUND                                                Handle        = 0x88790002
	D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS                                 Handle        = 0x887C0001
	D3D11_ERROR_FILE_NOT_FOUND                                                Handle        = 0x887C0002
	D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS                                  Handle        = 0x887C0003
	D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD                  Handle        = 0x887C0004
	D3D12_ERROR_ADAPTER_NOT_FOUND                                             Handle        = 0x887E0001
	D3D12_ERROR_DRIVER_VERSION_MISMATCH                                       Handle        = 0x887E0002
	D2DERR_WRONG_STATE                                                        Handle        = 0x88990001
	D2DERR_NOT_INITIALIZED                                                    Handle        = 0x88990002
	D2DERR_UNSUPPORTED_OPERATION                                              Handle        = 0x88990003
	D2DERR_SCANNER_FAILED                                                     Handle        = 0x88990004
	D2DERR_SCREEN_ACCESS_DENIED                                               Handle        = 0x88990005
	D2DERR_DISPLAY_STATE_INVALID                                              Handle        = 0x88990006
	D2DERR_ZERO_VECTOR                                                        Handle        = 0x88990007
	D2DERR_INTERNAL_ERROR                                                     Handle        = 0x88990008
	D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED                                       Handle        = 0x88990009
	D2DERR_INVALID_CALL                                                       Handle        = 0x8899000A
	D2DERR_NO_HARDWARE_DEVICE                                                 Handle        = 0x8899000B
	D2DERR_RECREATE_TARGET                                                    Handle        = 0x8899000C
	D2DERR_TOO_MANY_SHADER_ELEMENTS                                           Handle        = 0x8899000D
	D2DERR_SHADER_COMPILE_FAILED                                              Handle        = 0x8899000E
	D2DERR_MAX_TEXTURE_SIZE_EXCEEDED                                          Handle        = 0x8899000F
	D2DERR_UNSUPPORTED_VERSION                                                Handle        = 0x88990010
	D2DERR_BAD_NUMBER                                                         Handle        = 0x88990011
	D2DERR_WRONG_FACTORY                                                      Handle        = 0x88990012
	D2DERR_LAYER_ALREADY_IN_USE                                               Handle        = 0x88990013
	D2DERR_POP_CALL_DID_NOT_MATCH_PUSH                                        Handle        = 0x88990014
	D2DERR_WRONG_RESOURCE_DOMAIN                                              Handle        = 0x88990015
	D2DERR_PUSH_POP_UNBALANCED                                                Handle        = 0x88990016
	D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT                                Handle        = 0x88990017
	D2DERR_INCOMPATIBLE_BRUSH_TYPES                                           Handle        = 0x88990018
	D2DERR_WIN32_ERROR                                                        Handle        = 0x88990019
	D2DERR_TARGET_NOT_GDI_COMPATIBLE                                          Handle        = 0x8899001A
	D2DERR_TEXT_EFFECT_IS_WRONG_TYPE                                          Handle        = 0x8899001B
	D2DERR_TEXT_RENDERER_NOT_RELEASED                                         Handle        = 0x8899001C
	D2DERR_EXCEEDS_MAX_BITMAP_SIZE                                            Handle        = 0x8899001D
	D2DERR_INVALID_GRAPH_CONFIGURATION                                        Handle        = 0x8899001E
	D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION                               Handle        = 0x8899001F
	D2DERR_CYCLIC_GRAPH                                                       Handle        = 0x88990020
	D2DERR_BITMAP_CANNOT_DRAW                                                 Handle        = 0x88990021
	D2DERR_OUTSTANDING_BITMAP_REFERENCES                                      Handle        = 0x88990022
	D2DERR_ORIGINAL_TARGET_NOT_BOUND                                          Handle        = 0x88990023
	D2DERR_INVALID_TARGET                                                     Handle        = 0x88990024
	D2DERR_BITMAP_BOUND_AS_TARGET                                             Handle        = 0x88990025
	D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES                                   Handle        = 0x88990026
	D2DERR_INTERMEDIATE_TOO_LARGE                                             Handle        = 0x88990027
	D2DERR_EFFECT_IS_NOT_REGISTERED                                           Handle        = 0x88990028
	D2DERR_INVALID_PROPERTY                                                   Handle        = 0x88990029
	D2DERR_NO_SUBPROPERTIES                                                   Handle        = 0x8899002A
	D2DERR_PRINT_JOB_CLOSED                                                   Handle        = 0x8899002B
	D2DERR_PRINT_FORMAT_NOT_SUPPORTED                                         Handle        = 0x8899002C
	D2DERR_TOO_MANY_TRANSFORM_INPUTS                                          Handle        = 0x8899002D
	D2DERR_INVALID_GLYPH_IMAGE                                                Handle        = 0x8899002E
	DWRITE_E_FILEFORMAT                                                       Handle        = 0x88985000
	DWRITE_E_UNEXPECTED                                                       Handle        = 0x88985001
	DWRITE_E_NOFONT                                                           Handle        = 0x88985002
	DWRITE_E_FILENOTFOUND                                                     Handle        = 0x88985003
	DWRITE_E_FILEACCESS                                                       Handle        = 0x88985004
	DWRITE_E_FONTCOLLECTIONOBSOLETE                                           Handle        = 0x88985005
	DWRITE_E_ALREADYREGISTERED                                                Handle        = 0x88985006
	DWRITE_E_CACHEFORMAT                                                      Handle        = 0x88985007
	DWRITE_E_CACHEVERSION                                                     Handle        = 0x88985008
	DWRITE_E_UNSUPPORTEDOPERATION                                             Handle        = 0x88985009
	DWRITE_E_TEXTRENDERERINCOMPATIBLE                                         Handle        = 0x8898500A
	DWRITE_E_FLOWDIRECTIONCONFLICTS                                           Handle        = 0x8898500B
	DWRITE_E_NOCOLOR                                                          Handle        = 0x8898500C
	DWRITE_E_REMOTEFONT                                                       Handle        = 0x8898500D
	DWRITE_E_DOWNLOADCANCELLED                                                Handle        = 0x8898500E
	DWRITE_E_DOWNLOADFAILED                                                   Handle        = 0x8898500F
	DWRITE_E_TOOMANYDOWNLOADS                                                 Handle        = 0x88985010
	WINCODEC_ERR_WRONGSTATE                                                   Handle        = 0x88982F04
	WINCODEC_ERR_VALUEOUTOFRANGE                                              Handle        = 0x88982F05
	WINCODEC_ERR_UNKNOWNIMAGEFORMAT                                           Handle        = 0x88982F07
	WINCODEC_ERR_UNSUPPORTEDVERSION                                           Handle        = 0x88982F0B
	WINCODEC_ERR_NOTINITIALIZED                                               Handle        = 0x88982F0C
	WINCODEC_ERR_ALREADYLOCKED                                                Handle        = 0x88982F0D
	WINCODEC_ERR_PROPERTYNOTFOUND                                             Handle        = 0x88982F40
	WINCODEC_ERR_PROPERTYNOTSUPPORTED                                         Handle        = 0x88982F41
	WINCODEC_ERR_PROPERTYSIZE                                                 Handle        = 0x88982F42
	WINCODEC_ERR_CODECPRESENT                                                 Handle        = 0x88982F43
	WINCODEC_ERR_CODECNOTHUMBNAIL                                             Handle        = 0x88982F44
	WINCODEC_ERR_PALETTEUNAVAILABLE                                           Handle        = 0x88982F45
	WINCODEC_ERR_CODECTOOMANYSCANLINES                                        Handle        = 0x88982F46
	WINCODEC_ERR_INTERNALERROR                                                Handle        = 0x88982F48
	WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS                             Handle        = 0x88982F49
	WINCODEC_ERR_COMPONENTNOTFOUND                                            Handle        = 0x88982F50
	WINCODEC_ERR_IMAGESIZEOUTOFRANGE                                          Handle        = 0x88982F51
	WINCODEC_ERR_TOOMUCHMETADATA                                              Handle        = 0x88982F52
	WINCODEC_ERR_BADIMAGE                                                     Handle        = 0x88982F60
	WINCODEC_ERR_BADHEADER                                                    Handle        = 0x88982F61
	WINCODEC_ERR_FRAMEMISSING                                                 Handle        = 0x88982F62
	WINCODEC_ERR_BADMETADATAHEADER                                            Handle        = 0x88982F63
	WINCODEC_ERR_BADSTREAMDATA                                                Handle        = 0x88982F70
	WINCODEC_ERR_STREAMWRITE                                                  Handle        = 0x88982F71
	WINCODEC_ERR_STREAMREAD                                                   Handle        = 0x88982F72
	WINCODEC_ERR_STREAMNOTAVAILABLE                                           Handle        = 0x88982F73
	WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT                                       Handle        = 0x88982F80
	WINCODEC_ERR_UNSUPPORTEDOPERATION                                         Handle        = 0x88982F81
	WINCODEC_ERR_INVALIDREGISTRATION                                          Handle        = 0x88982F8A
	WINCODEC_ERR_COMPONENTINITIALIZEFAILURE                                   Handle        = 0x88982F8B
	WINCODEC_ERR_INSUFFICIENTBUFFER                                           Handle        = 0x88982F8C
	WINCODEC_ERR_DUPLICATEMETADATAPRESENT                                     Handle        = 0x88982F8D
	WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE                                       Handle        = 0x88982F8E
	WINCODEC_ERR_UNEXPECTEDSIZE                                               Handle        = 0x88982F8F
	WINCODEC_ERR_INVALIDQUERYREQUEST                                          Handle        = 0x88982F90
	WINCODEC_ERR_UNEXPECTEDMETADATATYPE                                       Handle        = 0x88982F91
	WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT                               Handle        = 0x88982F92
	WINCODEC_ERR_INVALIDQUERYCHARACTER                                        Handle        = 0x88982F93
	WINCODEC_ERR_WIN32ERROR                                                   Handle        = 0x88982F94
	WINCODEC_ERR_INVALIDPROGRESSIVELEVEL                                      Handle        = 0x88982F95
	WINCODEC_ERR_INVALIDJPEGSCANINDEX                                         Handle        = 0x88982F96
	MILERR_OBJECTBUSY                                                         Handle        = 0x88980001
	MILERR_INSUFFICIENTBUFFER                                                 Handle        = 0x88980002
	MILERR_WIN32ERROR                                                         Handle        = 0x88980003
	MILERR_SCANNER_FAILED                                                     Handle        = 0x88980004
	MILERR_SCREENACCESSDENIED                                                 Handle        = 0x88980005
	MILERR_DISPLAYSTATEINVALID                                                Handle        = 0x88980006
	MILERR_NONINVERTIBLEMATRIX                                                Handle        = 0x88980007
	MILERR_ZEROVECTOR                                                         Handle        = 0x88980008
	MILERR_TERMINATED                                                         Handle        = 0x88980009
	MILERR_BADNUMBER                                                          Handle        = 0x8898000A
	MILERR_INTERNALERROR                                                      Handle        = 0x88980080
	MILERR_DISPLAYFORMATNOTSUPPORTED                                          Handle        = 0x88980084
	MILERR_INVALIDCALL                                                        Handle        = 0x88980085
	MILERR_ALREADYLOCKED                                                      Handle        = 0x88980086
	MILERR_NOTLOCKED                                                          Handle        = 0x88980087
	MILERR_DEVICECANNOTRENDERTEXT                                             Handle        = 0x88980088
	MILERR_GLYPHBITMAPMISSED                                                  Handle        = 0x88980089
	MILERR_MALFORMEDGLYPHCACHE                                                Handle        = 0x8898008A
	MILERR_GENERIC_IGNORE                                                     Handle        = 0x8898008B
	MILERR_MALFORMED_GUIDELINE_DATA                                           Handle        = 0x8898008C
	MILERR_NO_HARDWARE_DEVICE                                                 Handle        = 0x8898008D
	MILERR_NEED_RECREATE_AND_PRESENT                                          Handle        = 0x8898008E
	MILERR_ALREADY_INITIALIZED                                                Handle        = 0x8898008F
	MILERR_MISMATCHED_SIZE                                                    Handle        = 0x88980090
	MILERR_NO_REDIRECTION_SURFACE_AVAILABLE                                   Handle        = 0x88980091
	MILERR_REMOTING_NOT_SUPPORTED                                             Handle        = 0x88980092
	MILERR_QUEUED_PRESENT_NOT_SUPPORTED                                       Handle        = 0x88980093
	MILERR_NOT_QUEUING_PRESENTS                                               Handle        = 0x88980094
	MILERR_NO_REDIRECTION_SURFACE_RETRY_LATER                                 Handle        = 0x88980095
	MILERR_TOOMANYSHADERELEMNTS                                               Handle        = 0x88980096
	MILERR_MROW_READLOCK_FAILED                                               Handle        = 0x88980097
	MILERR_MROW_UPDATE_FAILED                                                 Handle        = 0x88980098
	MILERR_SHADER_COMPILE_FAILED                                              Handle        = 0x88980099
	MILERR_MAX_TEXTURE_SIZE_EXCEEDED                                          Handle        = 0x8898009A
	MILERR_QPC_TIME_WENT_BACKWARD                                             Handle        = 0x8898009B
	MILERR_DXGI_ENUMERATION_OUT_OF_SYNC                                       Handle        = 0x8898009D
	MILERR_ADAPTER_NOT_FOUND                                                  Handle        = 0x8898009E
	MILERR_COLORSPACE_NOT_SUPPORTED                                           Handle        = 0x8898009F
	MILERR_PREFILTER_NOT_SUPPORTED                                            Handle        = 0x889800A0
	MILERR_DISPLAYID_ACCESS_DENIED                                            Handle        = 0x889800A1
	UCEERR_INVALIDPACKETHEADER                                                Handle        = 0x88980400
	UCEERR_UNKNOWNPACKET                                                      Handle        = 0x88980401
	UCEERR_ILLEGALPACKET                                                      Handle        = 0x88980402
	UCEERR_MALFORMEDPACKET                                                    Handle        = 0x88980403
	UCEERR_ILLEGALHANDLE                                                      Handle        = 0x88980404
	UCEERR_HANDLELOOKUPFAILED                                                 Handle        = 0x88980405
	UCEERR_RENDERTHREADFAILURE                                                Handle        = 0x88980406
	UCEERR_CTXSTACKFRSTTARGETNULL                                             Handle        = 0x88980407
	UCEERR_CONNECTIONIDLOOKUPFAILED                                           Handle        = 0x88980408
	UCEERR_BLOCKSFULL                                                         Handle        = 0x88980409
	UCEERR_MEMORYFAILURE                                                      Handle        = 0x8898040A
	UCEERR_PACKETRECORDOUTOFRANGE                                             Handle        = 0x8898040B
	UCEERR_ILLEGALRECORDTYPE                                                  Handle        = 0x8898040C
	UCEERR_OUTOFHANDLES                                                       Handle        = 0x8898040D
	UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED                                       Handle        = 0x8898040E
	UCEERR_NO_MULTIPLE_WORKER_THREADS                                         Handle        = 0x8898040F
	UCEERR_REMOTINGNOTSUPPORTED                                               Handle        = 0x88980410
	UCEERR_MISSINGENDCOMMAND                                                  Handle        = 0x88980411
	UCEERR_MISSINGBEGINCOMMAND                                                Handle        = 0x88980412
	UCEERR_CHANNELSYNCTIMEDOUT                                                Handle        = 0x88980413
	UCEERR_CHANNELSYNCABANDONED                                               Handle        = 0x88980414
	UCEERR_UNSUPPORTEDTRANSPORTVERSION                                        Handle        = 0x88980415
	UCEERR_TRANSPORTUNAVAILABLE                                               Handle        = 0x88980416
	UCEERR_FEEDBACK_UNSUPPORTED                                               Handle        = 0x88980417
	UCEERR_COMMANDTRANSPORTDENIED                                             Handle        = 0x88980418
	UCEERR_GRAPHICSSTREAMUNAVAILABLE                                          Handle        = 0x88980419
	UCEERR_GRAPHICSSTREAMALREADYOPEN                                          Handle        = 0x88980420
	UCEERR_TRANSPORTDISCONNECTED                                              Handle        = 0x88980421
	UCEERR_TRANSPORTOVERLOADED                                                Handle        = 0x88980422
	UCEERR_PARTITION_ZOMBIED                                                  Handle        = 0x88980423
	MILAVERR_NOCLOCK                                                          Handle        = 0x88980500
	MILAVERR_NOMEDIATYPE                                                      Handle        = 0x88980501
	MILAVERR_NOVIDEOMIXER                                                     Handle        = 0x88980502
	MILAVERR_NOVIDEOPRESENTER                                                 Handle        = 0x88980503
	MILAVERR_NOREADYFRAMES                                                    Handle        = 0x88980504
	MILAVERR_MODULENOTLOADED                                                  Handle        = 0x88980505
	MILAVERR_WMPFACTORYNOTREGISTERED                                          Handle        = 0x88980506
	MILAVERR_INVALIDWMPVERSION                                                Handle        = 0x88980507
	MILAVERR_INSUFFICIENTVIDEORESOURCES                                       Handle        = 0x88980508
	MILAVERR_VIDEOACCELERATIONNOTAVAILABLE                                    Handle        = 0x88980509
	MILAVERR_REQUESTEDTEXTURETOOBIG                                           Handle        = 0x8898050A
	MILAVERR_SEEKFAILED                                                       Handle        = 0x8898050B
	MILAVERR_UNEXPECTEDWMPFAILURE                                             Handle        = 0x8898050C
	MILAVERR_MEDIAPLAYERCLOSED                                                Handle        = 0x8898050D
	MILAVERR_UNKNOWNHARDWAREERROR                                             Handle        = 0x8898050E
	MILEFFECTSERR_UNKNOWNPROPERTY                                             Handle        = 0x8898060E
	MILEFFECTSERR_EFFECTNOTPARTOFGROUP                                        Handle        = 0x8898060F
	MILEFFECTSERR_NOINPUTSOURCEATTACHED                                       Handle        = 0x88980610
	MILEFFECTSERR_CONNECTORNOTCONNECTED                                       Handle        = 0x88980611
	MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT                            Handle        = 0x88980612
	MILEFFECTSERR_RESERVED                                                    Handle        = 0x88980613
	MILEFFECTSERR_CYCLEDETECTED                                               Handle        = 0x88980614
	MILEFFECTSERR_EFFECTINMORETHANONEGRAPH                                    Handle        = 0x88980615
	MILEFFECTSERR_EFFECTALREADYINAGRAPH                                       Handle        = 0x88980616
	MILEFFECTSERR_EFFECTHASNOCHILDREN                                         Handle        = 0x88980617
	MILEFFECTSERR_ALREADYATTACHEDTOLISTENER                                   Handle        = 0x88980618
	MILEFFECTSERR_NOTAFFINETRANSFORM                                          Handle        = 0x88980619
	MILEFFECTSERR_EMPTYBOUNDS                                                 Handle        = 0x8898061A
	MILEFFECTSERR_OUTPUTSIZETOOLARGE                                          Handle        = 0x8898061B
	DWMERR_STATE_TRANSITION_FAILED                                            Handle        = 0x88980700
	DWMERR_THEME_FAILED                                                       Handle        = 0x88980701
	DWMERR_CATASTROPHIC_FAILURE                                               Handle        = 0x88980702
	DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED                                Handle        = 0x88980800
	DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED                                 Handle        = 0x88980801
	DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED                             Handle        = 0x88980802
	ONL_E_INVALID_AUTHENTICATION_TARGET                                       Handle        = 0x80860001
	ONL_E_ACCESS_DENIED_BY_TOU                                                Handle        = 0x80860002
	ONL_E_INVALID_APPLICATION                                                 Handle        = 0x80860003
	ONL_E_PASSWORD_UPDATE_REQUIRED                                            Handle        = 0x80860004
	ONL_E_ACCOUNT_UPDATE_REQUIRED                                             Handle        = 0x80860005
	ONL_E_FORCESIGNIN                                                         Handle        = 0x80860006
	ONL_E_ACCOUNT_LOCKED                                                      Handle        = 0x80860007
	ONL_E_PARENTAL_CONSENT_REQUIRED                                           Handle        = 0x80860008
	ONL_E_EMAIL_VERIFICATION_REQUIRED                                         Handle        = 0x80860009
	ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE                                       Handle        = 0x8086000A
	ONL_E_ACCOUNT_SUSPENDED_ABUSE                                             Handle        = 0x8086000B
	ONL_E_ACTION_REQUIRED                                                     Handle        = 0x8086000C
	ONL_CONNECTION_COUNT_LIMIT                                                Handle        = 0x8086000D
	ONL_E_CONNECTED_ACCOUNT_CAN_NOT_SIGNOUT                                   Handle        = 0x8086000E
	ONL_E_USER_AUTHENTICATION_REQUIRED                                        Handle        = 0x8086000F
	ONL_E_REQUEST_THROTTLED                                                   Handle        = 0x80860010
	FA_E_MAX_PERSISTED_ITEMS_REACHED                                          Handle        = 0x80270220
	FA_E_HOMEGROUP_NOT_AVAILABLE                                              Handle        = 0x80270222
	E_MONITOR_RESOLUTION_TOO_LOW                                              Handle        = 0x80270250
	E_ELEVATED_ACTIVATION_NOT_SUPPORTED                                       Handle        = 0x80270251
	E_UAC_DISABLED                                                            Handle        = 0x80270252
	E_FULL_ADMIN_NOT_SUPPORTED                                                Handle        = 0x80270253
	E_APPLICATION_NOT_REGISTERED                                              Handle        = 0x80270254
	E_MULTIPLE_EXTENSIONS_FOR_APPLICATION                                     Handle        = 0x80270255
	E_MULTIPLE_PACKAGES_FOR_FAMILY                                            Handle        = 0x80270256
	E_APPLICATION_MANAGER_NOT_RUNNING                                         Handle        = 0x80270257
	S_STORE_LAUNCHED_FOR_REMEDIATION                                          Handle        = 0x00270258
	S_APPLICATION_ACTIVATION_ERROR_HANDLED_BY_DIALOG                          Handle        = 0x00270259
	E_APPLICATION_ACTIVATION_TIMED_OUT                                        Handle        = 0x8027025A
	E_APPLICATION_ACTIVATION_EXEC_FAILURE                                     Handle        = 0x8027025B
	E_APPLICATION_TEMPORARY_LICENSE_ERROR                                     Handle        = 0x8027025C
	E_APPLICATION_TRIAL_LICENSE_EXPIRED                                       Handle        = 0x8027025D
	E_SKYDRIVE_ROOT_TARGET_FILE_SYSTEM_NOT_SUPPORTED                          Handle        = 0x80270260
	E_SKYDRIVE_ROOT_TARGET_OVERLAP                                            Handle        = 0x80270261
	E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX                                       Handle        = 0x80270262
	E_SKYDRIVE_FILE_NOT_UPLOADED                                              Handle        = 0x80270263
	E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL                                       Handle        = 0x80270264
	E_SKYDRIVE_ROOT_TARGET_VOLUME_ROOT_NOT_SUPPORTED                          Handle        = 0x80270265
	E_SYNCENGINE_FILE_SIZE_OVER_LIMIT                                         Handle        = 0x8802B001
	E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA                            Handle        = 0x8802B002
	E_SYNCENGINE_UNSUPPORTED_FILE_NAME                                        Handle        = 0x8802B003
	E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED                             Handle        = 0x8802B004
	E_SYNCENGINE_FILE_SYNC_PARTNER_ERROR                                      Handle        = 0x8802B005
	E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE                                       Handle        = 0x8802B006
	E_SYNCENGINE_FILE_IDENTIFIER_UNKNOWN                                      Handle        = 0x8802C002
	E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED                                Handle        = 0x8802C003
	E_SYNCENGINE_UNKNOWN_SERVICE_ERROR                                        Handle        = 0x8802C004
	E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE                             Handle        = 0x8802C005
	E_SYNCENGINE_REQUEST_BLOCKED_BY_SERVICE                                   Handle        = 0x8802C006
	E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR                          Handle        = 0x8802C007
	E_SYNCENGINE_FOLDER_INACCESSIBLE                                          Handle        = 0x8802D001
	E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME                                      Handle        = 0x8802D002
	E_SYNCENGINE_UNSUPPORTED_MARKET                                           Handle        = 0x8802D003
	E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED                                   Handle        = 0x8802D004
	E_SYNCENGINE_REMOTE_PATH_LENGTH_LIMIT_EXCEEDED                            Handle        = 0x8802D005
	E_SYNCENGINE_CLIENT_UPDATE_NEEDED                                         Handle        = 0x8802D006
	E_SYNCENGINE_PROXY_AUTHENTICATION_REQUIRED                                Handle        = 0x8802D007
	E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED                          Handle        = 0x8802D008
	E_SYNCENGINE_UNSUPPORTED_REPARSE_POINT                                    Handle        = 0x8802D009
	E_SYNCENGINE_STORAGE_SERVICE_BLOCKED                                      Handle        = 0x8802D00A
	E_SYNCENGINE_FOLDER_IN_REDIRECTION                                        Handle        = 0x8802D00B
	EAS_E_POLICY_NOT_MANAGED_BY_OS                                            Handle        = 0x80550001
	EAS_E_POLICY_COMPLIANT_WITH_ACTIONS                                       Handle        = 0x80550002
	EAS_E_REQUESTED_POLICY_NOT_ENFORCEABLE                                    Handle        = 0x80550003
	EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD                                     Handle        = 0x80550004
	EAS_E_REQUESTED_POLICY_PASSWORD_EXPIRATION_INCOMPATIBLE                   Handle        = 0x80550005
	EAS_E_USER_CANNOT_CHANGE_PASSWORD                                         Handle        = 0x80550006
	EAS_E_ADMINS_HAVE_BLANK_PASSWORD                                          Handle        = 0x80550007
	EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD                                       Handle        = 0x80550008
	EAS_E_LOCAL_CONTROLLED_USERS_CANNOT_CHANGE_PASSWORD                       Handle        = 0x80550009
	EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS                Handle        = 0x8055000A
	EAS_E_CONNECTED_ADMINS_NEED_TO_CHANGE_PASSWORD                            Handle        = 0x8055000B
	EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER          Handle        = 0x8055000C
	EAS_E_CURRENT_CONNECTED_USER_NEED_TO_CHANGE_PASSWORD                      Handle        = 0x8055000D
	WEB_E_UNSUPPORTED_FORMAT                                                  Handle        = 0x83750001
	WEB_E_INVALID_XML                                                         Handle        = 0x83750002
	WEB_E_MISSING_REQUIRED_ELEMENT                                            Handle        = 0x83750003
	WEB_E_MISSING_REQUIRED_ATTRIBUTE                                          Handle        = 0x83750004
	WEB_E_UNEXPECTED_CONTENT                                                  Handle        = 0x83750005
	WEB_E_RESOURCE_TOO_LARGE                                                  Handle        = 0x83750006
	WEB_E_INVALID_JSON_STRING                                                 Handle        = 0x83750007
	WEB_E_INVALID_JSON_NUMBER                                                 Handle        = 0x83750008
	WEB_E_JSON_VALUE_NOT_FOUND                                                Handle        = 0x83750009
	HTTP_E_STATUS_UNEXPECTED                                                  Handle        = 0x80190001
	HTTP_E_STATUS_UNEXPECTED_REDIRECTION                                      Handle        = 0x80190003
	HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR                                     Handle        = 0x80190004
	HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR                                     Handle        = 0x80190005
	HTTP_E_STATUS_AMBIGUOUS                                                   Handle        = 0x8019012C
	HTTP_E_STATUS_MOVED                                                       Handle        = 0x8019012D
	HTTP_E_STATUS_REDIRECT                                                    Handle        = 0x8019012E
	HTTP_E_STATUS_REDIRECT_METHOD                                             Handle        = 0x8019012F
	HTTP_E_STATUS_NOT_MODIFIED                                                Handle        = 0x80190130
	HTTP_E_STATUS_USE_PROXY                                                   Handle        = 0x80190131
	HTTP_E_STATUS_REDIRECT_KEEP_VERB                                          Handle        = 0x80190133
	HTTP_E_STATUS_BAD_REQUEST                                                 Handle        = 0x80190190
	HTTP_E_STATUS_DENIED                                                      Handle        = 0x80190191
	HTTP_E_STATUS_PAYMENT_REQ                                                 Handle        = 0x80190192
	HTTP_E_STATUS_FORBIDDEN                                                   Handle        = 0x80190193
	HTTP_E_STATUS_NOT_FOUND                                                   Handle        = 0x80190194
	HTTP_E_STATUS_BAD_METHOD                                                  Handle        = 0x80190195
	HTTP_E_STATUS_NONE_ACCEPTABLE                                             Handle        = 0x80190196
	HTTP_E_STATUS_PROXY_AUTH_REQ                                              Handle        = 0x80190197
	HTTP_E_STATUS_REQUEST_TIMEOUT                                             Handle        = 0x80190198
	HTTP_E_STATUS_CONFLICT                                                    Handle        = 0x80190199
	HTTP_E_STATUS_GONE                                                        Handle        = 0x8019019A
	HTTP_E_STATUS_LENGTH_REQUIRED                                             Handle        = 0x8019019B
	HTTP_E_STATUS_PRECOND_FAILED                                              Handle        = 0x8019019C
	HTTP_E_STATUS_REQUEST_TOO_LARGE                                           Handle        = 0x8019019D
	HTTP_E_STATUS_URI_TOO_LONG                                                Handle        = 0x8019019E
	HTTP_E_STATUS_UNSUPPORTED_MEDIA                                           Handle        = 0x8019019F
	HTTP_E_STATUS_RANGE_NOT_SATISFIABLE                                       Handle        = 0x801901A0
	HTTP_E_STATUS_EXPECTATION_FAILED                                          Handle        = 0x801901A1
	HTTP_E_STATUS_SERVER_ERROR                                                Handle        = 0x801901F4
	HTTP_E_STATUS_NOT_SUPPORTED                                               Handle        = 0x801901F5
	HTTP_E_STATUS_BAD_GATEWAY                                                 Handle        = 0x801901F6
	HTTP_E_STATUS_SERVICE_UNAVAIL                                             Handle        = 0x801901F7
	HTTP_E_STATUS_GATEWAY_TIMEOUT                                             Handle        = 0x801901F8
	HTTP_E_STATUS_VERSION_NOT_SUP                                             Handle        = 0x801901F9
	E_INVALID_PROTOCOL_OPERATION                                              Handle        = 0x83760001
	E_INVALID_PROTOCOL_FORMAT                                                 Handle        = 0x83760002
	E_PROTOCOL_EXTENSIONS_NOT_SUPPORTED                                       Handle        = 0x83760003
	E_SUBPROTOCOL_NOT_SUPPORTED                                               Handle        = 0x83760004
	E_PROTOCOL_VERSION_NOT_SUPPORTED                                          Handle        = 0x83760005
	INPUT_E_OUT_OF_ORDER                                                      Handle        = 0x80400000
	INPUT_E_REENTRANCY                                                        Handle        = 0x80400001
	INPUT_E_MULTIMODAL                                                        Handle        = 0x80400002
	INPUT_E_PACKET                                                            Handle        = 0x80400003
	INPUT_E_FRAME                                                             Handle        = 0x80400004
	INPUT_E_HISTORY                                                           Handle        = 0x80400005
	INPUT_E_DEVICE_INFO                                                       Handle        = 0x80400006
	INPUT_E_TRANSFORM                                                         Handle        = 0x80400007
	INPUT_E_DEVICE_PROPERTY                                                   Handle        = 0x80400008
	INET_E_INVALID_URL                                                        Handle        = 0x800C0002
	INET_E_NO_SESSION                                                         Handle        = 0x800C0003
	INET_E_CANNOT_CONNECT                                                     Handle        = 0x800C0004
	INET_E_RESOURCE_NOT_FOUND                                                 Handle        = 0x800C0005
	INET_E_OBJECT_NOT_FOUND                                                   Handle        = 0x800C0006
	INET_E_DATA_NOT_AVAILABLE                                                 Handle        = 0x800C0007
	INET_E_DOWNLOAD_FAILURE                                                   Handle        = 0x800C0008
	INET_E_AUTHENTICATION_REQUIRED                                            Handle        = 0x800C0009
	INET_E_NO_VALID_MEDIA                                                     Handle        = 0x800C000A
	INET_E_CONNECTION_TIMEOUT                                                 Handle        = 0x800C000B
	INET_E_INVALID_REQUEST                                                    Handle        = 0x800C000C
	INET_E_UNKNOWN_PROTOCOL                                                   Handle        = 0x800C000D
	INET_E_SECURITY_PROBLEM                                                   Handle        = 0x800C000E
	INET_E_CANNOT_LOAD_DATA                                                   Handle        = 0x800C000F
	INET_E_CANNOT_INSTANTIATE_OBJECT                                          Handle        = 0x800C0010
	INET_E_INVALID_CERTIFICATE                                                Handle        = 0x800C0019
	INET_E_REDIRECT_FAILED                                                    Handle        = 0x800C0014
	INET_E_REDIRECT_TO_DIR                                                    Handle        = 0x800C0015
	ERROR_DBG_CREATE_PROCESS_FAILURE_LOCKDOWN                                 Handle        = 0x80B00001
	ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN                                 Handle        = 0x80B00002
	ERROR_DBG_CONNECT_SERVER_FAILURE_LOCKDOWN                                 Handle        = 0x80B00003
	ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN                                   Handle        = 0x80B00004
	ERROR_IO_PREEMPTED                                                        Handle        = 0x89010001
	JSCRIPT_E_CANTEXECUTE                                                     Handle        = 0x89020001
	WEP_E_NOT_PROVISIONED_ON_ALL_VOLUMES                                      Handle        = 0x88010001
	WEP_E_FIXED_DATA_NOT_SUPPORTED                                            Handle        = 0x88010002
	WEP_E_HARDWARE_NOT_COMPLIANT                                              Handle        = 0x88010003
	WEP_E_LOCK_NOT_CONFIGURED                                                 Handle        = 0x88010004
	WEP_E_PROTECTION_SUSPENDED                                                Handle        = 0x88010005
	WEP_E_NO_LICENSE                                                          Handle        = 0x88010006
	WEP_E_OS_NOT_PROTECTED                                                    Handle        = 0x88010007
	WEP_E_UNEXPECTED_FAIL                                                     Handle        = 0x88010008
	WEP_E_BUFFER_TOO_LARGE                                                    Handle        = 0x88010009
	ERROR_SVHDX_ERROR_STORED                                                  Handle        = 0xC05C0000
	ERROR_SVHDX_ERROR_NOT_AVAILABLE                                           Handle        = 0xC05CFF00
	ERROR_SVHDX_UNIT_ATTENTION_AVAILABLE                                      Handle        = 0xC05CFF01
	ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED                          Handle        = 0xC05CFF02
	ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED                         Handle        = 0xC05CFF03
	ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED                          Handle        = 0xC05CFF04
	ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED                        Handle        = 0xC05CFF05
	ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED                   Handle        = 0xC05CFF06
	ERROR_SVHDX_RESERVATION_CONFLICT                                          Handle        = 0xC05CFF07
	ERROR_SVHDX_WRONG_FILE_TYPE                                               Handle        = 0xC05CFF08
	ERROR_SVHDX_VERSION_MISMATCH                                              Handle        = 0xC05CFF09
	ERROR_VHD_SHARED                                                          Handle        = 0xC05CFF0A
	ERROR_SVHDX_NO_INITIATOR                                                  Handle        = 0xC05CFF0B
	ERROR_VHDSET_BACKING_STORAGE_NOT_FOUND                                    Handle        = 0xC05CFF0C
	ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP                               Handle        = 0xC05D0000
	ERROR_SMB_BAD_CLUSTER_DIALECT                                             Handle        = 0xC05D0001
	WININET_E_OUT_OF_HANDLES                                                  Handle        = 0x80072EE1
	WININET_E_TIMEOUT                                                         Handle        = 0x80072EE2
	WININET_E_EXTENDED_ERROR                                                  Handle        = 0x80072EE3
	WININET_E_INTERNAL_ERROR                                                  Handle        = 0x80072EE4
	WININET_E_INVALID_URL                                                     Handle        = 0x80072EE5
	WININET_E_UNRECOGNIZED_SCHEME                                             Handle        = 0x80072EE6
	WININET_E_NAME_NOT_RESOLVED                                               Handle        = 0x80072EE7
	WININET_E_PROTOCOL_NOT_FOUND                                              Handle        = 0x80072EE8
	WININET_E_INVALID_OPTION                                                  Handle        = 0x80072EE9
	WININET_E_BAD_OPTION_LENGTH                                               Handle        = 0x80072EEA
	WININET_E_OPTION_NOT_SETTABLE                                             Handle        = 0x80072EEB
	WININET_E_SHUTDOWN                                                        Handle        = 0x80072EEC
	WININET_E_INCORRECT_USER_NAME                                             Handle        = 0x80072EED
	WININET_E_INCORRECT_PASSWORD                                              Handle        = 0x80072EEE
	WININET_E_LOGIN_FAILURE                                                   Handle        = 0x80072EEF
	WININET_E_INVALID_OPERATION                                               Handle        = 0x80072EF0
	WININET_E_OPERATION_CANCELLED                                             Handle        = 0x80072EF1
	WININET_E_INCORRECT_HANDLE_TYPE                                           Handle        = 0x80072EF2
	WININET_E_INCORRECT_HANDLE_STATE                                          Handle        = 0x80072EF3
	WININET_E_NOT_PROXY_REQUEST                                               Handle        = 0x80072EF4
	WININET_E_REGISTRY_VALUE_NOT_FOUND                                        Handle        = 0x80072EF5
	WININET_E_BAD_REGISTRY_PARAMETER                                          Handle        = 0x80072EF6
	WININET_E_NO_DIRECT_ACCESS                                                Handle        = 0x80072EF7
	WININET_E_NO_CONTEXT                                                      Handle        = 0x80072EF8
	WININET_E_NO_CALLBACK                                                     Handle        = 0x80072EF9
	WININET_E_REQUEST_PENDING                                                 Handle        = 0x80072EFA
	WININET_E_INCORRECT_FORMAT                                                Handle        = 0x80072EFB
	WININET_E_ITEM_NOT_FOUND                                                  Handle        = 0x80072EFC
	WININET_E_CANNOT_CONNECT                                                  Handle        = 0x80072EFD
	WININET_E_CONNECTION_ABORTED                                              Handle        = 0x80072EFE
	WININET_E_CONNECTION_RESET                                                Handle        = 0x80072EFF
	WININET_E_FORCE_RETRY                                                     Handle        = 0x80072F00
	WININET_E_INVALID_PROXY_REQUEST                                           Handle        = 0x80072F01
	WININET_E_NEED_UI                                                         Handle        = 0x80072F02
	WININET_E_HANDLE_EXISTS                                                   Handle        = 0x80072F04
	WININET_E_SEC_CERT_DATE_INVALID                                           Handle        = 0x80072F05
	WININET_E_SEC_CERT_CN_INVALID                                             Handle        = 0x80072F06
	WININET_E_HTTP_TO_HTTPS_ON_REDIR                                          Handle        = 0x80072F07
	WININET_E_HTTPS_TO_HTTP_ON_REDIR                                          Handle        = 0x80072F08
	WININET_E_MIXED_SECURITY                                                  Handle        = 0x80072F09
	WININET_E_CHG_POST_IS_NON_SECURE                                          Handle        = 0x80072F0A
	WININET_E_POST_IS_NON_SECURE                                              Handle        = 0x80072F0B
	WININET_E_CLIENT_AUTH_CERT_NEEDED                                         Handle        = 0x80072F0C
	WININET_E_INVALID_CA                                                      Handle        = 0x80072F0D
	WININET_E_CLIENT_AUTH_NOT_SETUP                                           Handle        = 0x80072F0E
	WININET_E_ASYNC_THREAD_FAILED                                             Handle        = 0x80072F0F
	WININET_E_REDIRECT_SCHEME_CHANGE                                          Handle        = 0x80072F10
	WININET_E_DIALOG_PENDING                                                  Handle        = 0x80072F11
	WININET_E_RETRY_DIALOG                                                    Handle        = 0x80072F12
	WININET_E_NO_NEW_CONTAINERS                                               Handle        = 0x80072F13
	WININET_E_HTTPS_HTTP_SUBMIT_REDIR                                         Handle        = 0x80072F14
	WININET_E_SEC_CERT_ERRORS                                                 Handle        = 0x80072F17
	WININET_E_SEC_CERT_REV_FAILED                                             Handle        = 0x80072F19
	WININET_E_HEADER_NOT_FOUND                                                Handle        = 0x80072F76
	WININET_E_DOWNLEVEL_SERVER                                                Handle        = 0x80072F77
	WININET_E_INVALID_SERVER_RESPONSE                                         Handle        = 0x80072F78
	WININET_E_INVALID_HEADER                                                  Handle        = 0x80072F79
	WININET_E_INVALID_QUERY_REQUEST                                           Handle        = 0x80072F7A
	WININET_E_HEADER_ALREADY_EXISTS                                           Handle        = 0x80072F7B
	WININET_E_REDIRECT_FAILED                                                 Handle        = 0x80072F7C
	WININET_E_SECURITY_CHANNEL_ERROR                                          Handle        = 0x80072F7D
	WININET_E_UNABLE_TO_CACHE_FILE                                            Handle        = 0x80072F7E
	WININET_E_TCPIP_NOT_INSTALLED                                             Handle        = 0x80072F7F
	WININET_E_DISCONNECTED                                                    Handle        = 0x80072F83
	WININET_E_SERVER_UNREACHABLE                                              Handle        = 0x80072F84
	WININET_E_PROXY_SERVER_UNREACHABLE                                        Handle        = 0x80072F85
	WININET_E_BAD_AUTO_PROXY_SCRIPT                                           Handle        = 0x80072F86
	WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT                                       Handle        = 0x80072F87
	WININET_E_SEC_INVALID_CERT                                                Handle        = 0x80072F89
	WININET_E_SEC_CERT_REVOKED                                                Handle        = 0x80072F8A
	WININET_E_FAILED_DUETOSECURITYCHECK                                       Handle        = 0x80072F8B
	WININET_E_NOT_INITIALIZED                                                 Handle        = 0x80072F8C
	WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY                               Handle        = 0x80072F8E
	WININET_E_DECODING_FAILED                                                 Handle        = 0x80072F8F
	WININET_E_NOT_REDIRECTED                                                  Handle        = 0x80072F80
	WININET_E_COOKIE_NEEDS_CONFIRMATION                                       Handle        = 0x80072F81
	WININET_E_COOKIE_DECLINED                                                 Handle        = 0x80072F82
	WININET_E_REDIRECT_NEEDS_CONFIRMATION                                     Handle        = 0x80072F88
	SQLITE_E_ERROR                                                            Handle        = 0x87AF0001
	SQLITE_E_INTERNAL                                                         Handle        = 0x87AF0002
	SQLITE_E_PERM                                                             Handle        = 0x87AF0003
	SQLITE_E_ABORT                                                            Handle        = 0x87AF0004
	SQLITE_E_BUSY                                                             Handle        = 0x87AF0005
	SQLITE_E_LOCKED                                                           Handle        = 0x87AF0006
	SQLITE_E_NOMEM                                                            Handle        = 0x87AF0007
	SQLITE_E_READONLY                                                         Handle        = 0x87AF0008
	SQLITE_E_INTERRUPT                                                        Handle        = 0x87AF0009
	SQLITE_E_IOERR                                                            Handle        = 0x87AF000A
	SQLITE_E_CORRUPT                                                          Handle        = 0x87AF000B
	SQLITE_E_NOTFOUND                                                         Handle        = 0x87AF000C
	SQLITE_E_FULL                                                             Handle        = 0x87AF000D
	SQLITE_E_CANTOPEN                                                         Handle        = 0x87AF000E
	SQLITE_E_PROTOCOL                                                         Handle        = 0x87AF000F
	SQLITE_E_EMPTY                                                            Handle        = 0x87AF0010
	SQLITE_E_SCHEMA                                                           Handle        = 0x87AF0011
	SQLITE_E_TOOBIG                                                           Handle        = 0x87AF0012
	SQLITE_E_CONSTRAINT                                                       Handle        = 0x87AF0013
	SQLITE_E_MISMATCH                                                         Handle        = 0x87AF0014
	SQLITE_E_MISUSE                                                           Handle        = 0x87AF0015
	SQLITE_E_NOLFS                                                            Handle        = 0x87AF0016
	SQLITE_E_AUTH                                                             Handle        = 0x87AF0017
	SQLITE_E_FORMAT                                                           Handle        = 0x87AF0018
	SQLITE_E_RANGE                                                            Handle        = 0x87AF0019
	SQLITE_E_NOTADB                                                           Handle        = 0x87AF001A
	SQLITE_E_NOTICE                                                           Handle        = 0x87AF001B
	SQLITE_E_WARNING                                                          Handle        = 0x87AF001C
	SQLITE_E_ROW                                                              Handle        = 0x87AF0064
	SQLITE_E_DONE                                                             Handle        = 0x87AF0065
	SQLITE_E_IOERR_READ                                                       Handle        = 0x87AF010A
	SQLITE_E_IOERR_SHORT_READ                                                 Handle        = 0x87AF020A
	SQLITE_E_IOERR_WRITE                                                      Handle        = 0x87AF030A
	SQLITE_E_IOERR_FSYNC                                                      Handle        = 0x87AF040A
	SQLITE_E_IOERR_DIR_FSYNC                                                  Handle        = 0x87AF050A
	SQLITE_E_IOERR_TRUNCATE                                                   Handle        = 0x87AF060A
	SQLITE_E_IOERR_FSTAT                                                      Handle        = 0x87AF070A
	SQLITE_E_IOERR_UNLOCK                                                     Handle        = 0x87AF080A
	SQLITE_E_IOERR_RDLOCK                                                     Handle        = 0x87AF090A
	SQLITE_E_IOERR_DELETE                                                     Handle        = 0x87AF0A0A
	SQLITE_E_IOERR_BLOCKED                                                    Handle        = 0x87AF0B0A
	SQLITE_E_IOERR_NOMEM                                                      Handle        = 0x87AF0C0A
	SQLITE_E_IOERR_ACCESS                                                     Handle        = 0x87AF0D0A
	SQLITE_E_IOERR_CHECKRESERVEDLOCK                                          Handle        = 0x87AF0E0A
	SQLITE_E_IOERR_LOCK                                                       Handle        = 0x87AF0F0A
	SQLITE_E_IOERR_CLOSE                                                      Handle        = 0x87AF100A
	SQLITE_E_IOERR_DIR_CLOSE                                                  Handle        = 0x87AF110A
	SQLITE_E_IOERR_SHMOPEN                                                    Handle        = 0x87AF120A
	SQLITE_E_IOERR_SHMSIZE                                                    Handle        = 0x87AF130A
	SQLITE_E_IOERR_SHMLOCK                                                    Handle        = 0x87AF140A
	SQLITE_E_IOERR_SHMMAP                                                     Handle        = 0x87AF150A
	SQLITE_E_IOERR_SEEK                                                       Handle        = 0x87AF160A
	SQLITE_E_IOERR_DELETE_NOENT                                               Handle        = 0x87AF170A
	SQLITE_E_IOERR_MMAP                                                       Handle        = 0x87AF180A
	SQLITE_E_IOERR_GETTEMPPATH                                                Handle        = 0x87AF190A
	SQLITE_E_IOERR_CONVPATH                                                   Handle        = 0x87AF1A0A
	SQLITE_E_IOERR_VNODE                                                      Handle        = 0x87AF1A02
	SQLITE_E_IOERR_AUTH                                                       Handle        = 0x87AF1A03
	SQLITE_E_LOCKED_SHAREDCACHE                                               Handle        = 0x87AF0106
	SQLITE_E_BUSY_RECOVERY                                                    Handle        = 0x87AF0105
	SQLITE_E_BUSY_SNAPSHOT                                                    Handle        = 0x87AF0205
	SQLITE_E_CANTOPEN_NOTEMPDIR                                               Handle        = 0x87AF010E
	SQLITE_E_CANTOPEN_ISDIR                                                   Handle        = 0x87AF020E
	SQLITE_E_CANTOPEN_FULLPATH                                                Handle        = 0x87AF030E
	SQLITE_E_CANTOPEN_CONVPATH                                                Handle        = 0x87AF040E
	SQLITE_E_CORRUPT_VTAB                                                     Handle        = 0x87AF010B
	SQLITE_E_READONLY_RECOVERY                                                Handle        = 0x87AF0108
	SQLITE_E_READONLY_CANTLOCK                                                Handle        = 0x87AF0208
	SQLITE_E_READONLY_ROLLBACK                                                Handle        = 0x87AF0308
	SQLITE_E_READONLY_DBMOVED                                                 Handle        = 0x87AF0408
	SQLITE_E_ABORT_ROLLBACK                                                   Handle        = 0x87AF0204
	SQLITE_E_CONSTRAINT_CHECK                                                 Handle        = 0x87AF0113
	SQLITE_E_CONSTRAINT_COMMITHOOK                                            Handle        = 0x87AF0213
	SQLITE_E_CONSTRAINT_FOREIGNKEY                                            Handle        = 0x87AF0313
	SQLITE_E_CONSTRAINT_FUNCTION                                              Handle        = 0x87AF0413
	SQLITE_E_CONSTRAINT_NOTNULL                                               Handle        = 0x87AF0513
	SQLITE_E_CONSTRAINT_PRIMARYKEY                                            Handle        = 0x87AF0613
	SQLITE_E_CONSTRAINT_TRIGGER                                               Handle        = 0x87AF0713
	SQLITE_E_CONSTRAINT_UNIQUE                                                Handle        = 0x87AF0813
	SQLITE_E_CONSTRAINT_VTAB                                                  Handle        = 0x87AF0913
	SQLITE_E_CONSTRAINT_ROWID                                                 Handle        = 0x87AF0A13
	SQLITE_E_NOTICE_RECOVER_WAL                                               Handle        = 0x87AF011B
	SQLITE_E_NOTICE_RECOVER_ROLLBACK                                          Handle        = 0x87AF021B
	SQLITE_E_WARNING_AUTOINDEX                                                Handle        = 0x87AF011C
	UTC_E_TOGGLE_TRACE_STARTED                                                Handle        = 0x87C51001
	UTC_E_ALTERNATIVE_TRACE_CANNOT_PREEMPT                                    Handle        = 0x87C51002
	UTC_E_AOT_NOT_RUNNING                                                     Handle        = 0x87C51003
	UTC_E_SCRIPT_TYPE_INVALID                                                 Handle        = 0x87C51004
	UTC_E_SCENARIODEF_NOT_FOUND                                               Handle        = 0x87C51005
	UTC_E_TRACEPROFILE_NOT_FOUND                                              Handle        = 0x87C51006
	UTC_E_FORWARDER_ALREADY_ENABLED                                           Handle        = 0x87C51007
	UTC_E_FORWARDER_ALREADY_DISABLED                                          Handle        = 0x87C51008
	UTC_E_EVENTLOG_ENTRY_MALFORMED                                            Handle        = 0x87C51009
	UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH                                    Handle        = 0x87C5100A
	UTC_E_SCRIPT_TERMINATED                                                   Handle        = 0x87C5100B
	UTC_E_INVALID_CUSTOM_FILTER                                               Handle        = 0x87C5100C
	UTC_E_TRACE_NOT_RUNNING                                                   Handle        = 0x87C5100D
	UTC_E_REESCALATED_TOO_QUICKLY                                             Handle        = 0x87C5100E
	UTC_E_ESCALATION_ALREADY_RUNNING                                          Handle        = 0x87C5100F
	UTC_E_PERFTRACK_ALREADY_TRACING                                           Handle        = 0x87C51010
	UTC_E_REACHED_MAX_ESCALATIONS                                             Handle        = 0x87C51011
	UTC_E_FORWARDER_PRODUCER_MISMATCH                                         Handle        = 0x87C51012
	UTC_E_INTENTIONAL_SCRIPT_FAILURE                                          Handle        = 0x87C51013
	UTC_E_SQM_INIT_FAILED                                                     Handle        = 0x87C51014
	UTC_E_NO_WER_LOGGER_SUPPORTED                                             Handle        = 0x87C51015
	UTC_E_TRACERS_DONT_EXIST                                                  Handle        = 0x87C51016
	UTC_E_WINRT_INIT_FAILED                                                   Handle        = 0x87C51017
	UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH                                  Handle        = 0x87C51018
	UTC_E_INVALID_FILTER                                                      Handle        = 0x87C51019
	UTC_E_EXE_TERMINATED                                                      Handle        = 0x87C5101A
	UTC_E_ESCALATION_NOT_AUTHORIZED                                           Handle        = 0x87C5101B
	UTC_E_SETUP_NOT_AUTHORIZED                                                Handle        = 0x87C5101C
	UTC_E_CHILD_PROCESS_FAILED                                                Handle        = 0x87C5101D
	UTC_E_COMMAND_LINE_NOT_AUTHORIZED                                         Handle        = 0x87C5101E
	UTC_E_CANNOT_LOAD_SCENARIO_EDITOR_XML                                     Handle        = 0x87C5101F
	UTC_E_ESCALATION_TIMED_OUT                                                Handle        = 0x87C51020
	UTC_E_SETUP_TIMED_OUT                                                     Handle        = 0x87C51021
	UTC_E_TRIGGER_MISMATCH                                                    Handle        = 0x87C51022
	UTC_E_TRIGGER_NOT_FOUND                                                   Handle        = 0x87C51023
	UTC_E_SIF_NOT_SUPPORTED                                                   Handle        = 0x87C51024
	UTC_E_DELAY_TERMINATED                                                    Handle        = 0x87C51025
	UTC_E_DEVICE_TICKET_ERROR                                                 Handle        = 0x87C51026
	UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED                                         Handle        = 0x87C51027
	UTC_E_API_RESULT_UNAVAILABLE                                              Handle        = 0x87C51028
	UTC_E_RPC_TIMEOUT                                                         Handle        = 0x87C51029
	UTC_E_RPC_WAIT_FAILED                                                     Handle        = 0x87C5102A
	UTC_E_API_BUSY                                                            Handle        = 0x87C5102B
	UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET                              Handle        = 0x87C5102C
	UTC_E_EXCLUSIVITY_NOT_AVAILABLE                                           Handle        = 0x87C5102D
	UTC_E_GETFILE_FILE_PATH_NOT_APPROVED                                      Handle        = 0x87C5102E
	UTC_E_ESCALATION_DIRECTORY_ALREADY_EXISTS                                 Handle        = 0x87C5102F
	UTC_E_TIME_TRIGGER_ON_START_INVALID                                       Handle        = 0x87C51030
	UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION                        Handle        = 0x87C51031
	UTC_E_TIME_TRIGGER_INVALID_TIME_RANGE                                     Handle        = 0x87C51032
	UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE                               Handle        = 0x87C51033
	UTC_E_BINARY_MISSING                                                      Handle        = 0x87C51034
	UTC_E_NETWORK_CAPTURE_NOT_ALLOWED                                         Handle        = 0x87C51035
	UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID                                      Handle        = 0x87C51036
	UTC_E_UNABLE_TO_RESOLVE_SESSION                                           Handle        = 0x87C51037
	UTC_E_THROTTLED                                                           Handle        = 0x87C51038
	UTC_E_UNAPPROVED_SCRIPT                                                   Handle        = 0x87C51039
	UTC_E_SCRIPT_MISSING                                                      Handle        = 0x87C5103A
	UTC_E_SCENARIO_THROTTLED                                                  Handle        = 0x87C5103B
	UTC_E_API_NOT_SUPPORTED                                                   Handle        = 0x87C5103C
	UTC_E_GETFILE_EXTERNAL_PATH_NOT_APPROVED                                  Handle        = 0x87C5103D
	UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED                                   Handle        = 0x87C5103E
	UTC_E_CERT_REV_FAILED                                                     Handle        = 0x87C5103F
	UTC_E_FAILED_TO_START_NDISCAP                                             Handle        = 0x87C51040
	UTC_E_KERNELDUMP_LIMIT_REACHED                                            Handle        = 0x87C51041
	UTC_E_MISSING_AGGREGATE_EVENT_TAG                                         Handle        = 0x87C51042
	UTC_E_INVALID_AGGREGATION_STRUCT                                          Handle        = 0x87C51043
	UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION                                 Handle        = 0x87C51044
	UTC_E_FILTER_MISSING_ATTRIBUTE                                            Handle        = 0x87C51045
	UTC_E_FILTER_INVALID_TYPE                                                 Handle        = 0x87C51046
	UTC_E_FILTER_VARIABLE_NOT_FOUND                                           Handle        = 0x87C51047
	UTC_E_FILTER_FUNCTION_RESTRICTED                                          Handle        = 0x87C51048
	UTC_E_FILTER_VERSION_MISMATCH                                             Handle        = 0x87C51049
	UTC_E_FILTER_INVALID_FUNCTION                                             Handle        = 0x87C51050
	UTC_E_FILTER_INVALID_FUNCTION_PARAMS                                      Handle        = 0x87C51051
	UTC_E_FILTER_INVALID_COMMAND                                              Handle        = 0x87C51052
	UTC_E_FILTER_ILLEGAL_EVAL                                                 Handle        = 0x87C51053
	UTC_E_TTTRACER_RETURNED_ERROR                                             Handle        = 0x87C51054
	UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE                                         Handle        = 0x87C51055
	UTC_E_FAILED_TO_RECEIVE_AGENT_DIAGNOSTICS                                 Handle        = 0x87C51056
	UTC_E_SCENARIO_HAS_NO_ACTIONS                                             Handle        = 0x87C51057
	UTC_E_TTTRACER_STORAGE_FULL                                               Handle        = 0x87C51058
	UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE                                   Handle        = 0x87C51059
	UTC_E_ESCALATION_CANCELLED_AT_SHUTDOWN                                    Handle        = 0x87C5105A
	UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED                                 Handle        = 0x87C5105B
	WINML_ERR_INVALID_DEVICE                                                  Handle        = 0x88900001
	WINML_ERR_INVALID_BINDING                                                 Handle        = 0x88900002
	WINML_ERR_VALUE_NOTFOUND                                                  Handle        = 0x88900003
	WINML_ERR_SIZE_MISMATCH                                                   Handle        = 0x88900004
)

+ f 3815bbaa8adf5400041954decc56e8889eb56eb20bfc30053e7799703af0fc95 vendor/golang.org/x/sys/windows/zknownfolderids_windows.go
utf8file 150
// Code generated by 'mkknownfolderids.bash'; DO NOT EDIT.

package windows

type KNOWNFOLDERID GUID

var (
	FOLDERID_NetworkFolder          = &KNOWNFOLDERID{0xd20beec4, 0x5ca8, 0x4905, [8]byte{0xae, 0x3b, 0xbf, 0x25, 0x1e, 0xa0, 0x9b, 0x53}}
	FOLDERID_ComputerFolder         = &KNOWNFOLDERID{0x0ac0837c, 0xbbf8, 0x452a, [8]byte{0x85, 0x0d, 0x79, 0xd0, 0x8e, 0x66, 0x7c, 0xa7}}
	FOLDERID_InternetFolder         = &KNOWNFOLDERID{0x4d9f7874, 0x4e0c, 0x4904, [8]byte{0x96, 0x7b, 0x40, 0xb0, 0xd2, 0x0c, 0x3e, 0x4b}}
	FOLDERID_ControlPanelFolder     = &KNOWNFOLDERID{0x82a74aeb, 0xaeb4, 0x465c, [8]byte{0xa0, 0x14, 0xd0, 0x97, 0xee, 0x34, 0x6d, 0x63}}
	FOLDERID_PrintersFolder         = &KNOWNFOLDERID{0x76fc4e2d, 0xd6ad, 0x4519, [8]byte{0xa6, 0x63, 0x37, 0xbd, 0x56, 0x06, 0x81, 0x85}}
	FOLDERID_SyncManagerFolder      = &KNOWNFOLDERID{0x43668bf8, 0xc14e, 0x49b2, [8]byte{0x97, 0xc9, 0x74, 0x77, 0x84, 0xd7, 0x84, 0xb7}}
	FOLDERID_SyncSetupFolder        = &KNOWNFOLDERID{0x0f214138, 0xb1d3, 0x4a90, [8]byte{0xbb, 0xa9, 0x27, 0xcb, 0xc0, 0xc5, 0x38, 0x9a}}
	FOLDERID_ConflictFolder         = &KNOWNFOLDERID{0x4bfefb45, 0x347d, 0x4006, [8]byte{0xa5, 0xbe, 0xac, 0x0c, 0xb0, 0x56, 0x71, 0x92}}
	FOLDERID_SyncResultsFolder      = &KNOWNFOLDERID{0x289a9a43, 0xbe44, 0x4057, [8]byte{0xa4, 0x1b, 0x58, 0x7a, 0x76, 0xd7, 0xe7, 0xf9}}
	FOLDERID_RecycleBinFolder       = &KNOWNFOLDERID{0xb7534046, 0x3ecb, 0x4c18, [8]byte{0xbe, 0x4e, 0x64, 0xcd, 0x4c, 0xb7, 0xd6, 0xac}}
	FOLDERID_ConnectionsFolder      = &KNOWNFOLDERID{0x6f0cd92b, 0x2e97, 0x45d1, [8]byte{0x88, 0xff, 0xb0, 0xd1, 0x86, 0xb8, 0xde, 0xdd}}
	FOLDERID_Fonts                  = &KNOWNFOLDERID{0xfd228cb7, 0xae11, 0x4ae3, [8]byte{0x86, 0x4c, 0x16, 0xf3, 0x91, 0x0a, 0xb8, 0xfe}}
	FOLDERID_Desktop                = &KNOWNFOLDERID{0xb4bfcc3a, 0xdb2c, 0x424c, [8]byte{0xb0, 0x29, 0x7f, 0xe9, 0x9a, 0x87, 0xc6, 0x41}}
	FOLDERID_Startup                = &KNOWNFOLDERID{0xb97d20bb, 0xf46a, 0x4c97, [8]byte{0xba, 0x10, 0x5e, 0x36, 0x08, 0x43, 0x08, 0x54}}
	FOLDERID_Programs               = &KNOWNFOLDERID{0xa77f5d77, 0x2e2b, 0x44c3, [8]byte{0xa6, 0xa2, 0xab, 0xa6, 0x01, 0x05, 0x4a, 0x51}}
	FOLDERID_StartMenu              = &KNOWNFOLDERID{0x625b53c3, 0xab48, 0x4ec1, [8]byte{0xba, 0x1f, 0xa1, 0xef, 0x41, 0x46, 0xfc, 0x19}}
	FOLDERID_Recent                 = &KNOWNFOLDERID{0xae50c081, 0xebd2, 0x438a, [8]byte{0x86, 0x55, 0x8a, 0x09, 0x2e, 0x34, 0x98, 0x7a}}
	FOLDERID_SendTo                 = &KNOWNFOLDERID{0x8983036c, 0x27c0, 0x404b, [8]byte{0x8f, 0x08, 0x10, 0x2d, 0x10, 0xdc, 0xfd, 0x74}}
	FOLDERID_Documents              = &KNOWNFOLDERID{0xfdd39ad0, 0x238f, 0x46af, [8]byte{0xad, 0xb4, 0x6c, 0x85, 0x48, 0x03, 0x69, 0xc7}}
	FOLDERID_Favorites              = &KNOWNFOLDERID{0x1777f761, 0x68ad, 0x4d8a, [8]byte{0x87, 0xbd, 0x30, 0xb7, 0x59, 0xfa, 0x33, 0xdd}}
	FOLDERID_NetHood                = &KNOWNFOLDERID{0xc5abbf53, 0xe17f, 0x4121, [8]byte{0x89, 0x00, 0x86, 0x62, 0x6f, 0xc2, 0xc9, 0x73}}
	FOLDERID_PrintHood              = &KNOWNFOLDERID{0x9274bd8d, 0xcfd1, 0x41c3, [8]byte{0xb3, 0x5e, 0xb1, 0x3f, 0x55, 0xa7, 0x58, 0xf4}}
	FOLDERID_Templates              = &KNOWNFOLDERID{0xa63293e8, 0x664e, 0x48db, [8]byte{0xa0, 0x79, 0xdf, 0x75, 0x9e, 0x05, 0x09, 0xf7}}
	FOLDERID_CommonStartup          = &KNOWNFOLDERID{0x82a5ea35, 0xd9cd, 0x47c5, [8]byte{0x96, 0x29, 0xe1, 0x5d, 0x2f, 0x71, 0x4e, 0x6e}}
	FOLDERID_CommonPrograms         = &KNOWNFOLDERID{0x0139d44e, 0x6afe, 0x49f2, [8]byte{0x86, 0x90, 0x3d, 0xaf, 0xca, 0xe6, 0xff, 0xb8}}
	FOLDERID_CommonStartMenu        = &KNOWNFOLDERID{0xa4115719, 0xd62e, 0x491d, [8]byte{0xaa, 0x7c, 0xe7, 0x4b, 0x8b, 0xe3, 0xb0, 0x67}}
	FOLDERID_PublicDesktop          = &KNOWNFOLDERID{0xc4aa340d, 0xf20f, 0x4863, [8]byte{0xaf, 0xef, 0xf8, 0x7e, 0xf2, 0xe6, 0xba, 0x25}}
	FOLDERID_ProgramData            = &KNOWNFOLDERID{0x62ab5d82, 0xfdc1, 0x4dc3, [8]byte{0xa9, 0xdd, 0x07, 0x0d, 0x1d, 0x49, 0x5d, 0x97}}
	FOLDERID_CommonTemplates        = &KNOWNFOLDERID{0xb94237e7, 0x57ac, 0x4347, [8]byte{0x91, 0x51, 0xb0, 0x8c, 0x6c, 0x32, 0xd1, 0xf7}}
	FOLDERID_PublicDocuments        = &KNOWNFOLDERID{0xed4824af, 0xdce4, 0x45a8, [8]byte{0x81, 0xe2, 0xfc, 0x79, 0x65, 0x08, 0x36, 0x34}}
	FOLDERID_RoamingAppData         = &KNOWNFOLDERID{0x3eb685db, 0x65f9, 0x4cf6, [8]byte{0xa0, 0x3a, 0xe3, 0xef, 0x65, 0x72, 0x9f, 0x3d}}
	FOLDERID_LocalAppData           = &KNOWNFOLDERID{0xf1b32785, 0x6fba, 0x4fcf, [8]byte{0x9d, 0x55, 0x7b, 0x8e, 0x7f, 0x15, 0x70, 0x91}}
	FOLDERID_LocalAppDataLow        = &KNOWNFOLDERID{0xa520a1a4, 0x1780, 0x4ff6, [8]byte{0xbd, 0x18, 0x16, 0x73, 0x43, 0xc5, 0xaf, 0x16}}
	FOLDERID_InternetCache          = &KNOWNFOLDERID{0x352481e8, 0x33be, 0x4251, [8]byte{0xba, 0x85, 0x60, 0x07, 0xca, 0xed, 0xcf, 0x9d}}
	FOLDERID_Cookies                = &KNOWNFOLDERID{0x2b0f765d, 0xc0e9, 0x4171, [8]byte{0x90, 0x8e, 0x08, 0xa6, 0x11, 0xb8, 0x4f, 0xf6}}
	FOLDERID_History                = &KNOWNFOLDERID{0xd9dc8a3b, 0xb784, 0x432e, [8]byte{0xa7, 0x81, 0x5a, 0x11, 0x30, 0xa7, 0x59, 0x63}}
	FOLDERID_System                 = &KNOWNFOLDERID{0x1ac14e77, 0x02e7, 0x4e5d, [8]byte{0xb7, 0x44, 0x2e, 0xb1, 0xae, 0x51, 0x98, 0xb7}}
	FOLDERID_SystemX86              = &KNOWNFOLDERID{0xd65231b0, 0xb2f1, 0x4857, [8]byte{0xa4, 0xce, 0xa8, 0xe7, 0xc6, 0xea, 0x7d, 0x27}}
	FOLDERID_Windows                = &KNOWNFOLDERID{0xf38bf404, 0x1d43, 0x42f2, [8]byte{0x93, 0x05, 0x67, 0xde, 0x0b, 0x28, 0xfc, 0x23}}
	FOLDERID_Profile                = &KNOWNFOLDERID{0x5e6c858f, 0x0e22, 0x4760, [8]byte{0x9a, 0xfe, 0xea, 0x33, 0x17, 0xb6, 0x71, 0x73}}
	FOLDERID_Pictures               = &KNOWNFOLDERID{0x33e28130, 0x4e1e, 0x4676, [8]byte{0x83, 0x5a, 0x98, 0x39, 0x5c, 0x3b, 0xc3, 0xbb}}
	FOLDERID_ProgramFilesX86        = &KNOWNFOLDERID{0x7c5a40ef, 0xa0fb, 0x4bfc, [8]byte{0x87, 0x4a, 0xc0, 0xf2, 0xe0, 0xb9, 0xfa, 0x8e}}
	FOLDERID_ProgramFilesCommonX86  = &KNOWNFOLDERID{0xde974d24, 0xd9c6, 0x4d3e, [8]byte{0xbf, 0x91, 0xf4, 0x45, 0x51, 0x20, 0xb9, 0x17}}
	FOLDERID_ProgramFilesX64        = &KNOWNFOLDERID{0x6d809377, 0x6af0, 0x444b, [8]byte{0x89, 0x57, 0xa3, 0x77, 0x3f, 0x02, 0x20, 0x0e}}
	FOLDERID_ProgramFilesCommonX64  = &KNOWNFOLDERID{0x6365d5a7, 0x0f0d, 0x45e5, [8]byte{0x87, 0xf6, 0x0d, 0xa5, 0x6b, 0x6a, 0x4f, 0x7d}}
	FOLDERID_ProgramFiles           = &KNOWNFOLDERID{0x905e63b6, 0xc1bf, 0x494e, [8]byte{0xb2, 0x9c, 0x65, 0xb7, 0x32, 0xd3, 0xd2, 0x1a}}
	FOLDERID_ProgramFilesCommon     = &KNOWNFOLDERID{0xf7f1ed05, 0x9f6d, 0x47a2, [8]byte{0xaa, 0xae, 0x29, 0xd3, 0x17, 0xc6, 0xf0, 0x66}}
	FOLDERID_UserProgramFiles       = &KNOWNFOLDERID{0x5cd7aee2, 0x2219, 0x4a67, [8]byte{0xb8, 0x5d, 0x6c, 0x9c, 0xe1, 0x56, 0x60, 0xcb}}
	FOLDERID_UserProgramFilesCommon = &KNOWNFOLDERID{0xbcbd3057, 0xca5c, 0x4622, [8]byte{0xb4, 0x2d, 0xbc, 0x56, 0xdb, 0x0a, 0xe5, 0x16}}
	FOLDERID_AdminTools             = &KNOWNFOLDERID{0x724ef170, 0xa42d, 0x4fef, [8]byte{0x9f, 0x26, 0xb6, 0x0e, 0x84, 0x6f, 0xba, 0x4f}}
	FOLDERID_CommonAdminTools       = &KNOWNFOLDERID{0xd0384e7d, 0xbac3, 0x4797, [8]byte{0x8f, 0x14, 0xcb, 0xa2, 0x29, 0xb3, 0x92, 0xb5}}
	FOLDERID_Music                  = &KNOWNFOLDERID{0x4bd8d571, 0x6d19, 0x48d3, [8]byte{0xbe, 0x97, 0x42, 0x22, 0x20, 0x08, 0x0e, 0x43}}
	FOLDERID_Videos                 = &KNOWNFOLDERID{0x18989b1d, 0x99b5, 0x455b, [8]byte{0x84, 0x1c, 0xab, 0x7c, 0x74, 0xe4, 0xdd, 0xfc}}
	FOLDERID_Ringtones              = &KNOWNFOLDERID{0xc870044b, 0xf49e, 0x4126, [8]byte{0xa9, 0xc3, 0xb5, 0x2a, 0x1f, 0xf4, 0x11, 0xe8}}
	FOLDERID_PublicPictures         = &KNOWNFOLDERID{0xb6ebfb86, 0x6907, 0x413c, [8]byte{0x9a, 0xf7, 0x4f, 0xc2, 0xab, 0xf0, 0x7c, 0xc5}}
	FOLDERID_PublicMusic            = &KNOWNFOLDERID{0x3214fab5, 0x9757, 0x4298, [8]byte{0xbb, 0x61, 0x92, 0xa9, 0xde, 0xaa, 0x44, 0xff}}
	FOLDERID_PublicVideos           = &KNOWNFOLDERID{0x2400183a, 0x6185, 0x49fb, [8]byte{0xa2, 0xd8, 0x4a, 0x39, 0x2a, 0x60, 0x2b, 0xa3}}
	FOLDERID_PublicRingtones        = &KNOWNFOLDERID{0xe555ab60, 0x153b, 0x4d17, [8]byte{0x9f, 0x04, 0xa5, 0xfe, 0x99, 0xfc, 0x15, 0xec}}
	FOLDERID_ResourceDir            = &KNOWNFOLDERID{0x8ad10c31, 0x2adb, 0x4296, [8]byte{0xa8, 0xf7, 0xe4, 0x70, 0x12, 0x32, 0xc9, 0x72}}
	FOLDERID_LocalizedResourcesDir  = &KNOWNFOLDERID{0x2a00375e, 0x224c, 0x49de, [8]byte{0xb8, 0xd1, 0x44, 0x0d, 0xf7, 0xef, 0x3d, 0xdc}}
	FOLDERID_CommonOEMLinks         = &KNOWNFOLDERID{0xc1bae2d0, 0x10df, 0x4334, [8]byte{0xbe, 0xdd, 0x7a, 0xa2, 0x0b, 0x22, 0x7a, 0x9d}}
	FOLDERID_CDBurning              = &KNOWNFOLDERID{0x9e52ab10, 0xf80d, 0x49df, [8]byte{0xac, 0xb8, 0x43, 0x30, 0xf5, 0x68, 0x78, 0x55}}
	FOLDERID_UserProfiles           = &KNOWNFOLDERID{0x0762d272, 0xc50a, 0x4bb0, [8]byte{0xa3, 0x82, 0x69, 0x7d, 0xcd, 0x72, 0x9b, 0x80}}
	FOLDERID_Playlists              = &KNOWNFOLDERID{0xde92c1c7, 0x837f, 0x4f69, [8]byte{0xa3, 0xbb, 0x86, 0xe6, 0x31, 0x20, 0x4a, 0x23}}
	FOLDERID_SamplePlaylists        = &KNOWNFOLDERID{0x15ca69b3, 0x30ee, 0x49c1, [8]byte{0xac, 0xe1, 0x6b, 0x5e, 0xc3, 0x72, 0xaf, 0xb5}}
	FOLDERID_SampleMusic            = &KNOWNFOLDERID{0xb250c668, 0xf57d, 0x4ee1, [8]byte{0xa6, 0x3c, 0x29, 0x0e, 0xe7, 0xd1, 0xaa, 0x1f}}
	FOLDERID_SamplePictures         = &KNOWNFOLDERID{0xc4900540, 0x2379, 0x4c75, [8]byte{0x84, 0x4b, 0x64, 0xe6, 0xfa, 0xf8, 0x71, 0x6b}}
	FOLDERID_SampleVideos           = &KNOWNFOLDERID{0x859ead94, 0x2e85, 0x48ad, [8]byte{0xa7, 0x1a, 0x09, 0x69, 0xcb, 0x56, 0xa6, 0xcd}}
	FOLDERID_PhotoAlbums            = &KNOWNFOLDERID{0x69d2cf90, 0xfc33, 0x4fb7, [8]byte{0x9a, 0x0c, 0xeb, 0xb0, 0xf0, 0xfc, 0xb4, 0x3c}}
	FOLDERID_Public                 = &KNOWNFOLDERID{0xdfdf76a2, 0xc82a, 0x4d63, [8]byte{0x90, 0x6a, 0x56, 0x44, 0xac, 0x45, 0x73, 0x85}}
	FOLDERID_ChangeRemovePrograms   = &KNOWNFOLDERID{0xdf7266ac, 0x9274, 0x4867, [8]byte{0x8d, 0x55, 0x3b, 0xd6, 0x61, 0xde, 0x87, 0x2d}}
	FOLDERID_AppUpdates             = &KNOWNFOLDERID{0xa305ce99, 0xf527, 0x492b, [8]byte{0x8b, 0x1a, 0x7e, 0x76, 0xfa, 0x98, 0xd6, 0xe4}}
	FOLDERID_AddNewPrograms         = &KNOWNFOLDERID{0xde61d971, 0x5ebc, 0x4f02, [8]byte{0xa3, 0xa9, 0x6c, 0x82, 0x89, 0x5e, 0x5c, 0x04}}
	FOLDERID_Downloads              = &KNOWNFOLDERID{0x374de290, 0x123f, 0x4565, [8]byte{0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b}}
	FOLDERID_PublicDownloads        = &KNOWNFOLDERID{0x3d644c9b, 0x1fb8, 0x4f30, [8]byte{0x9b, 0x45, 0xf6, 0x70, 0x23, 0x5f, 0x79, 0xc0}}
	FOLDERID_SavedSearches          = &KNOWNFOLDERID{0x7d1d3a04, 0xdebb, 0x4115, [8]byte{0x95, 0xcf, 0x2f, 0x29, 0xda, 0x29, 0x20, 0xda}}
	FOLDERID_QuickLaunch            = &KNOWNFOLDERID{0x52a4f021, 0x7b75, 0x48a9, [8]byte{0x9f, 0x6b, 0x4b, 0x87, 0xa2, 0x10, 0xbc, 0x8f}}
	FOLDERID_Contacts               = &KNOWNFOLDERID{0x56784854, 0xc6cb, 0x462b, [8]byte{0x81, 0x69, 0x88, 0xe3, 0x50, 0xac, 0xb8, 0x82}}
	FOLDERID_SidebarParts           = &KNOWNFOLDERID{0xa75d362e, 0x50fc, 0x4fb7, [8]byte{0xac, 0x2c, 0xa8, 0xbe, 0xaa, 0x31, 0x44, 0x93}}
	FOLDERID_SidebarDefaultParts    = &KNOWNFOLDERID{0x7b396e54, 0x9ec5, 0x4300, [8]byte{0xbe, 0x0a, 0x24, 0x82, 0xeb, 0xae, 0x1a, 0x26}}
	FOLDERID_PublicGameTasks        = &KNOWNFOLDERID{0xdebf2536, 0xe1a8, 0x4c59, [8]byte{0xb6, 0xa2, 0x41, 0x45, 0x86, 0x47, 0x6a, 0xea}}
	FOLDERID_GameTasks              = &KNOWNFOLDERID{0x054fae61, 0x4dd8, 0x4787, [8]byte{0x80, 0xb6, 0x09, 0x02, 0x20, 0xc4, 0xb7, 0x00}}
	FOLDERID_SavedGames             = &KNOWNFOLDERID{0x4c5c32ff, 0xbb9d, 0x43b0, [8]byte{0xb5, 0xb4, 0x2d, 0x72, 0xe5, 0x4e, 0xaa, 0xa4}}
	FOLDERID_Games                  = &KNOWNFOLDERID{0xcac52c1a, 0xb53d, 0x4edc, [8]byte{0x92, 0xd7, 0x6b, 0x2e, 0x8a, 0xc1, 0x94, 0x34}}
	FOLDERID_SEARCH_MAPI            = &KNOWNFOLDERID{0x98ec0e18, 0x2098, 0x4d44, [8]byte{0x86, 0x44, 0x66, 0x97, 0x93, 0x15, 0xa2, 0x81}}
	FOLDERID_SEARCH_CSC             = &KNOWNFOLDERID{0xee32e446, 0x31ca, 0x4aba, [8]byte{0x81, 0x4f, 0xa5, 0xeb, 0xd2, 0xfd, 0x6d, 0x5e}}
	FOLDERID_Links                  = &KNOWNFOLDERID{0xbfb9d5e0, 0xc6a9, 0x404c, [8]byte{0xb2, 0xb2, 0xae, 0x6d, 0xb6, 0xaf, 0x49, 0x68}}
	FOLDERID_UsersFiles             = &KNOWNFOLDERID{0xf3ce0f7c, 0x4901, 0x4acc, [8]byte{0x86, 0x48, 0xd5, 0xd4, 0x4b, 0x04, 0xef, 0x8f}}
	FOLDERID_UsersLibraries         = &KNOWNFOLDERID{0xa302545d, 0xdeff, 0x464b, [8]byte{0xab, 0xe8, 0x61, 0xc8, 0x64, 0x8d, 0x93, 0x9b}}
	FOLDERID_SearchHome             = &KNOWNFOLDERID{0x190337d1, 0xb8ca, 0x4121, [8]byte{0xa6, 0x39, 0x6d, 0x47, 0x2d, 0x16, 0x97, 0x2a}}
	FOLDERID_OriginalImages         = &KNOWNFOLDERID{0x2c36c0aa, 0x5812, 0x4b87, [8]byte{0xbf, 0xd0, 0x4c, 0xd0, 0xdf, 0xb1, 0x9b, 0x39}}
	FOLDERID_DocumentsLibrary       = &KNOWNFOLDERID{0x7b0db17d, 0x9cd2, 0x4a93, [8]byte{0x97, 0x33, 0x46, 0xcc, 0x89, 0x02, 0x2e, 0x7c}}
	FOLDERID_MusicLibrary           = &KNOWNFOLDERID{0x2112ab0a, 0xc86a, 0x4ffe, [8]byte{0xa3, 0x68, 0x0d, 0xe9, 0x6e, 0x47, 0x01, 0x2e}}
	FOLDERID_PicturesLibrary        = &KNOWNFOLDERID{0xa990ae9f, 0xa03b, 0x4e80, [8]byte{0x94, 0xbc, 0x99, 0x12, 0xd7, 0x50, 0x41, 0x04}}
	FOLDERID_VideosLibrary          = &KNOWNFOLDERID{0x491e922f, 0x5643, 0x4af4, [8]byte{0xa7, 0xeb, 0x4e, 0x7a, 0x13, 0x8d, 0x81, 0x74}}
	FOLDERID_RecordedTVLibrary      = &KNOWNFOLDERID{0x1a6fdba2, 0xf42d, 0x4358, [8]byte{0xa7, 0x98, 0xb7, 0x4d, 0x74, 0x59, 0x26, 0xc5}}
	FOLDERID_HomeGroup              = &KNOWNFOLDERID{0x52528a6b, 0xb9e3, 0x4add, [8]byte{0xb6, 0x0d, 0x58, 0x8c, 0x2d, 0xba, 0x84, 0x2d}}
	FOLDERID_HomeGroupCurrentUser   = &KNOWNFOLDERID{0x9b74b6a3, 0x0dfd, 0x4f11, [8]byte{0x9e, 0x78, 0x5f, 0x78, 0x00, 0xf2, 0xe7, 0x72}}
	FOLDERID_DeviceMetadataStore    = &KNOWNFOLDERID{0x5ce4a5e9, 0xe4eb, 0x479d, [8]byte{0xb8, 0x9f, 0x13, 0x0c, 0x02, 0x88, 0x61, 0x55}}
	FOLDERID_Libraries              = &KNOWNFOLDERID{0x1b3ea5dc, 0xb587, 0x4786, [8]byte{0xb4, 0xef, 0xbd, 0x1d, 0xc3, 0x32, 0xae, 0xae}}
	FOLDERID_PublicLibraries        = &KNOWNFOLDERID{0x48daf80b, 0xe6cf, 0x4f4e, [8]byte{0xb8, 0x00, 0x0e, 0x69, 0xd8, 0x4e, 0xe3, 0x84}}
	FOLDERID_UserPinned             = &KNOWNFOLDERID{0x9e3995ab, 0x1f9c, 0x4f13, [8]byte{0xb8, 0x27, 0x48, 0xb2, 0x4b, 0x6c, 0x71, 0x74}}
	FOLDERID_ImplicitAppShortcuts   = &KNOWNFOLDERID{0xbcb5256f, 0x79f6, 0x4cee, [8]byte{0xb7, 0x25, 0xdc, 0x34, 0xe4, 0x02, 0xfd, 0x46}}
	FOLDERID_AccountPictures        = &KNOWNFOLDERID{0x008ca0b1, 0x55b4, 0x4c56, [8]byte{0xb8, 0xa8, 0x4d, 0xe4, 0xb2, 0x99, 0xd3, 0xbe}}
	FOLDERID_PublicUserTiles        = &KNOWNFOLDERID{0x0482af6c, 0x08f1, 0x4c34, [8]byte{0x8c, 0x90, 0xe1, 0x7e, 0xc9, 0x8b, 0x1e, 0x17}}
	FOLDERID_AppsFolder             = &KNOWNFOLDERID{0x1e87508d, 0x89c2, 0x42f0, [8]byte{0x8a, 0x7e, 0x64, 0x5a, 0x0f, 0x50, 0xca, 0x58}}
	FOLDERID_StartMenuAllPrograms   = &KNOWNFOLDERID{0xf26305ef, 0x6948, 0x40b9, [8]byte{0xb2, 0x55, 0x81, 0x45, 0x3d, 0x09, 0xc7, 0x85}}
	FOLDERID_CommonStartMenuPlaces  = &KNOWNFOLDERID{0xa440879f, 0x87a0, 0x4f7d, [8]byte{0xb7, 0x00, 0x02, 0x07, 0xb9, 0x66, 0x19, 0x4a}}
	FOLDERID_ApplicationShortcuts   = &KNOWNFOLDERID{0xa3918781, 0xe5f2, 0x4890, [8]byte{0xb3, 0xd9, 0xa7, 0xe5, 0x43, 0x32, 0x32, 0x8c}}
	FOLDERID_RoamingTiles           = &KNOWNFOLDERID{0x00bcfc5a, 0xed94, 0x4e48, [8]byte{0x96, 0xa1, 0x3f, 0x62, 0x17, 0xf2, 0x19, 0x90}}
	FOLDERID_RoamedTileImages       = &KNOWNFOLDERID{0xaaa8d5a5, 0xf1d6, 0x4259, [8]byte{0xba, 0xa8, 0x78, 0xe7, 0xef, 0x60, 0x83, 0x5e}}
	FOLDERID_Screenshots            = &KNOWNFOLDERID{0xb7bede81, 0xdf94, 0x4682, [8]byte{0xa7, 0xd8, 0x57, 0xa5, 0x26, 0x20, 0xb8, 0x6f}}
	FOLDERID_CameraRoll             = &KNOWNFOLDERID{0xab5fb87b, 0x7ce2, 0x4f83, [8]byte{0x91, 0x5d, 0x55, 0x08, 0x46, 0xc9, 0x53, 0x7b}}
	FOLDERID_SkyDrive               = &KNOWNFOLDERID{0xa52bba46, 0xe9e1, 0x435f, [8]byte{0xb3, 0xd9, 0x28, 0xda, 0xa6, 0x48, 0xc0, 0xf6}}
	FOLDERID_OneDrive               = &KNOWNFOLDERID{0xa52bba46, 0xe9e1, 0x435f, [8]byte{0xb3, 0xd9, 0x28, 0xda, 0xa6, 0x48, 0xc0, 0xf6}}
	FOLDERID_SkyDriveDocuments      = &KNOWNFOLDERID{0x24d89e24, 0x2f19, 0x4534, [8]byte{0x9d, 0xde, 0x6a, 0x66, 0x71, 0xfb, 0xb8, 0xfe}}
	FOLDERID_SkyDrivePictures       = &KNOWNFOLDERID{0x339719b5, 0x8c47, 0x4894, [8]byte{0x94, 0xc2, 0xd8, 0xf7, 0x7a, 0xdd, 0x44, 0xa6}}
	FOLDERID_SkyDriveMusic          = &KNOWNFOLDERID{0xc3f2459e, 0x80d6, 0x45dc, [8]byte{0xbf, 0xef, 0x1f, 0x76, 0x9f, 0x2b, 0xe7, 0x30}}
	FOLDERID_SkyDriveCameraRoll     = &KNOWNFOLDERID{0x767e6811, 0x49cb, 0x4273, [8]byte{0x87, 0xc2, 0x20, 0xf3, 0x55, 0xe1, 0x08, 0x5b}}
	FOLDERID_SearchHistory          = &KNOWNFOLDERID{0x0d4c3db6, 0x03a3, 0x462f, [8]byte{0xa0, 0xe6, 0x08, 0x92, 0x4c, 0x41, 0xb5, 0xd4}}
	FOLDERID_SearchTemplates        = &KNOWNFOLDERID{0x7e636bfe, 0xdfa9, 0x4d5e, [8]byte{0xb4, 0x56, 0xd7, 0xb3, 0x98, 0x51, 0xd8, 0xa9}}
	FOLDERID_CameraRollLibrary      = &KNOWNFOLDERID{0x2b20df75, 0x1eda, 0x4039, [8]byte{0x80, 0x97, 0x38, 0x79, 0x82, 0x27, 0xd5, 0xb7}}
	FOLDERID_SavedPictures          = &KNOWNFOLDERID{0x3b193882, 0xd3ad, 0x4eab, [8]byte{0x96, 0x5a, 0x69, 0x82, 0x9d, 0x1f, 0xb5, 0x9f}}
	FOLDERID_SavedPicturesLibrary   = &KNOWNFOLDERID{0xe25b5812, 0xbe88, 0x4bd9, [8]byte{0x94, 0xb0, 0x29, 0x23, 0x34, 0x77, 0xb6, 0xc3}}
	FOLDERID_RetailDemo             = &KNOWNFOLDERID{0x12d4c69e, 0x24ad, 0x4923, [8]byte{0xbe, 0x19, 0x31, 0x32, 0x1c, 0x43, 0xa7, 0x67}}
	FOLDERID_Device                 = &KNOWNFOLDERID{0x1c2ac1dc, 0x4358, 0x4b6c, [8]byte{0x97, 0x33, 0xaf, 0x21, 0x15, 0x65, 0x76, 0xf0}}
	FOLDERID_DevelopmentFiles       = &KNOWNFOLDERID{0xdbe8e08e, 0x3053, 0x4bbc, [8]byte{0xb1, 0x83, 0x2a, 0x7b, 0x2b, 0x19, 0x1e, 0x59}}
	FOLDERID_Objects3D              = &KNOWNFOLDERID{0x31c0dd25, 0x9439, 0x4f12, [8]byte{0xbf, 0x41, 0x7f, 0xf4, 0xed, 0xa3, 0x87, 0x22}}
	FOLDERID_AppCaptures            = &KNOWNFOLDERID{0xedc0fe71, 0x98d8, 0x4f4a, [8]byte{0xb9, 0x20, 0xc8, 0xdc, 0x13, 0x3c, 0xb1, 0x65}}
	FOLDERID_LocalDocuments         = &KNOWNFOLDERID{0xf42ee2d3, 0x909f, 0x4907, [8]byte{0x88, 0x71, 0x4c, 0x22, 0xfc, 0x0b, 0xf7, 0x56}}
	FOLDERID_LocalPictures          = &KNOWNFOLDERID{0x0ddd015d, 0xb06c, 0x45d5, [8]byte{0x8c, 0x4c, 0xf5, 0x97, 0x13, 0x85, 0x46, 0x39}}
	FOLDERID_LocalVideos            = &KNOWNFOLDERID{0x35286a68, 0x3c57, 0x41a1, [8]byte{0xbb, 0xb1, 0x0e, 0xae, 0x73, 0xd7, 0x6c, 0x95}}
	FOLDERID_LocalMusic             = &KNOWNFOLDERID{0xa0c69a99, 0x21c8, 0x4671, [8]byte{0x87, 0x03, 0x79, 0x34, 0x16, 0x2f, 0xcf, 0x1d}}
	FOLDERID_LocalDownloads         = &KNOWNFOLDERID{0x7d83ee9b, 0x2244, 0x4e70, [8]byte{0xb1, 0xf5, 0x53, 0x93, 0x04, 0x2a, 0xf1, 0xe4}}
	FOLDERID_RecordedCalls          = &KNOWNFOLDERID{0x2f8b40c2, 0x83ed, 0x48ee, [8]byte{0xb3, 0x83, 0xa1, 0xf1, 0x57, 0xec, 0x6f, 0x9a}}
	FOLDERID_AllAppMods             = &KNOWNFOLDERID{0x7ad67899, 0x66af, 0x43ba, [8]byte{0x91, 0x56, 0x6a, 0xad, 0x42, 0xe6, 0xc5, 0x96}}
	FOLDERID_CurrentAppMods         = &KNOWNFOLDERID{0x3db40b20, 0x2a30, 0x4dbe, [8]byte{0x91, 0x7e, 0x77, 0x1d, 0xd2, 0x1d, 0xd0, 0x99}}
	FOLDERID_AppDataDesktop         = &KNOWNFOLDERID{0xb2c5e279, 0x7add, 0x439f, [8]byte{0xb2, 0x8c, 0xc4, 0x1f, 0xe1, 0xbb, 0xf6, 0x72}}
	FOLDERID_AppDataDocuments       = &KNOWNFOLDERID{0x7be16610, 0x1f7f, 0x44ac, [8]byte{0xbf, 0xf0, 0x83, 0xe1, 0x5f, 0x2f, 0xfc, 0xa1}}
	FOLDERID_AppDataFavorites       = &KNOWNFOLDERID{0x7cfbefbc, 0xde1f, 0x45aa, [8]byte{0xb8, 0x43, 0xa5, 0x42, 0xac, 0x53, 0x6c, 0xc9}}
	FOLDERID_AppDataProgramData     = &KNOWNFOLDERID{0x559d40a3, 0xa036, 0x40fa, [8]byte{0xaf, 0x61, 0x84, 0xcb, 0x43, 0x0a, 0x4d, 0x34}}
)

+ f a42518bea31316a80ea1413f3af5a57e4f2155edbe402b3f95daf7ff2c2f75ab vendor/golang.org/x/sys/windows/zsyscall_windows.go
utf8file 4052
// Code generated by 'go generate'; DO NOT EDIT.

package windows

import (
	"syscall"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return nil
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modadvapi32 = NewLazySystemDLL("advapi32.dll")
	modkernel32 = NewLazySystemDLL("kernel32.dll")
	modshell32  = NewLazySystemDLL("shell32.dll")
	moduserenv  = NewLazySystemDLL("userenv.dll")
	modmswsock  = NewLazySystemDLL("mswsock.dll")
	modcrypt32  = NewLazySystemDLL("crypt32.dll")
	moduser32   = NewLazySystemDLL("user32.dll")
	modole32    = NewLazySystemDLL("ole32.dll")
	modntdll    = NewLazySystemDLL("ntdll.dll")
	modpsapi    = NewLazySystemDLL("psapi.dll")
	modws2_32   = NewLazySystemDLL("ws2_32.dll")
	moddnsapi   = NewLazySystemDLL("dnsapi.dll")
	modiphlpapi = NewLazySystemDLL("iphlpapi.dll")
	modsecur32  = NewLazySystemDLL("secur32.dll")
	modnetapi32 = NewLazySystemDLL("netapi32.dll")
	modwtsapi32 = NewLazySystemDLL("wtsapi32.dll")

	procRegisterEventSourceW                                 = modadvapi32.NewProc("RegisterEventSourceW")
	procDeregisterEventSource                                = modadvapi32.NewProc("DeregisterEventSource")
	procReportEventW                                         = modadvapi32.NewProc("ReportEventW")
	procOpenSCManagerW                                       = modadvapi32.NewProc("OpenSCManagerW")
	procCloseServiceHandle                                   = modadvapi32.NewProc("CloseServiceHandle")
	procCreateServiceW                                       = modadvapi32.NewProc("CreateServiceW")
	procOpenServiceW                                         = modadvapi32.NewProc("OpenServiceW")
	procDeleteService                                        = modadvapi32.NewProc("DeleteService")
	procStartServiceW                                        = modadvapi32.NewProc("StartServiceW")
	procQueryServiceStatus                                   = modadvapi32.NewProc("QueryServiceStatus")
	procQueryServiceLockStatusW                              = modadvapi32.NewProc("QueryServiceLockStatusW")
	procControlService                                       = modadvapi32.NewProc("ControlService")
	procStartServiceCtrlDispatcherW                          = modadvapi32.NewProc("StartServiceCtrlDispatcherW")
	procSetServiceStatus                                     = modadvapi32.NewProc("SetServiceStatus")
	procChangeServiceConfigW                                 = modadvapi32.NewProc("ChangeServiceConfigW")
	procQueryServiceConfigW                                  = modadvapi32.NewProc("QueryServiceConfigW")
	procChangeServiceConfig2W                                = modadvapi32.NewProc("ChangeServiceConfig2W")
	procQueryServiceConfig2W                                 = modadvapi32.NewProc("QueryServiceConfig2W")
	procEnumServicesStatusExW                                = modadvapi32.NewProc("EnumServicesStatusExW")
	procQueryServiceStatusEx                                 = modadvapi32.NewProc("QueryServiceStatusEx")
	procNotifyServiceStatusChangeW                           = modadvapi32.NewProc("NotifyServiceStatusChangeW")
	procGetLastError                                         = modkernel32.NewProc("GetLastError")
	procLoadLibraryW                                         = modkernel32.NewProc("LoadLibraryW")
	procLoadLibraryExW                                       = modkernel32.NewProc("LoadLibraryExW")
	procFreeLibrary                                          = modkernel32.NewProc("FreeLibrary")
	procGetProcAddress                                       = modkernel32.NewProc("GetProcAddress")
	procGetModuleFileNameW                                   = modkernel32.NewProc("GetModuleFileNameW")
	procGetModuleHandleExW                                   = modkernel32.NewProc("GetModuleHandleExW")
	procGetVersion                                           = modkernel32.NewProc("GetVersion")
	procFormatMessageW                                       = modkernel32.NewProc("FormatMessageW")
	procExitProcess                                          = modkernel32.NewProc("ExitProcess")
	procIsWow64Process                                       = modkernel32.NewProc("IsWow64Process")
	procCreateFileW                                          = modkernel32.NewProc("CreateFileW")
	procReadFile                                             = modkernel32.NewProc("ReadFile")
	procWriteFile                                            = modkernel32.NewProc("WriteFile")
	procGetOverlappedResult                                  = modkernel32.NewProc("GetOverlappedResult")
	procSetFilePointer                                       = modkernel32.NewProc("SetFilePointer")
	procCloseHandle                                          = modkernel32.NewProc("CloseHandle")
	procGetStdHandle                                         = modkernel32.NewProc("GetStdHandle")
	procSetStdHandle                                         = modkernel32.NewProc("SetStdHandle")
	procFindFirstFileW                                       = modkernel32.NewProc("FindFirstFileW")
	procFindNextFileW                                        = modkernel32.NewProc("FindNextFileW")
	procFindClose                                            = modkernel32.NewProc("FindClose")
	procGetFileInformationByHandle                           = modkernel32.NewProc("GetFileInformationByHandle")
	procGetFileInformationByHandleEx                         = modkernel32.NewProc("GetFileInformationByHandleEx")
	procGetCurrentDirectoryW                                 = modkernel32.NewProc("GetCurrentDirectoryW")
	procSetCurrentDirectoryW                                 = modkernel32.NewProc("SetCurrentDirectoryW")
	procCreateDirectoryW                                     = modkernel32.NewProc("CreateDirectoryW")
	procRemoveDirectoryW                                     = modkernel32.NewProc("RemoveDirectoryW")
	procDeleteFileW                                          = modkernel32.NewProc("DeleteFileW")
	procMoveFileW                                            = modkernel32.NewProc("MoveFileW")
	procMoveFileExW                                          = modkernel32.NewProc("MoveFileExW")
	procLockFileEx                                           = modkernel32.NewProc("LockFileEx")
	procUnlockFileEx                                         = modkernel32.NewProc("UnlockFileEx")
	procGetComputerNameW                                     = modkernel32.NewProc("GetComputerNameW")
	procGetComputerNameExW                                   = modkernel32.NewProc("GetComputerNameExW")
	procSetEndOfFile                                         = modkernel32.NewProc("SetEndOfFile")
	procGetSystemTimeAsFileTime                              = modkernel32.NewProc("GetSystemTimeAsFileTime")
	procGetSystemTimePreciseAsFileTime                       = modkernel32.NewProc("GetSystemTimePreciseAsFileTime")
	procGetTimeZoneInformation                               = modkernel32.NewProc("GetTimeZoneInformation")
	procCreateIoCompletionPort                               = modkernel32.NewProc("CreateIoCompletionPort")
	procGetQueuedCompletionStatus                            = modkernel32.NewProc("GetQueuedCompletionStatus")
	procPostQueuedCompletionStatus                           = modkernel32.NewProc("PostQueuedCompletionStatus")
	procCancelIo                                             = modkernel32.NewProc("CancelIo")
	procCancelIoEx                                           = modkernel32.NewProc("CancelIoEx")
	procCreateProcessW                                       = modkernel32.NewProc("CreateProcessW")
	procOpenProcess                                          = modkernel32.NewProc("OpenProcess")
	procShellExecuteW                                        = modshell32.NewProc("ShellExecuteW")
	procSHGetKnownFolderPath                                 = modshell32.NewProc("SHGetKnownFolderPath")
	procTerminateProcess                                     = modkernel32.NewProc("TerminateProcess")
	procGetExitCodeProcess                                   = modkernel32.NewProc("GetExitCodeProcess")
	procGetStartupInfoW                                      = modkernel32.NewProc("GetStartupInfoW")
	procGetProcessTimes                                      = modkernel32.NewProc("GetProcessTimes")
	procDuplicateHandle                                      = modkernel32.NewProc("DuplicateHandle")
	procWaitForSingleObject                                  = modkernel32.NewProc("WaitForSingleObject")
	procWaitForMultipleObjects                               = modkernel32.NewProc("WaitForMultipleObjects")
	procGetTempPathW                                         = modkernel32.NewProc("GetTempPathW")
	procCreatePipe                                           = modkernel32.NewProc("CreatePipe")
	procGetFileType                                          = modkernel32.NewProc("GetFileType")
	procCryptAcquireContextW                                 = modadvapi32.NewProc("CryptAcquireContextW")
	procCryptReleaseContext                                  = modadvapi32.NewProc("CryptReleaseContext")
	procCryptGenRandom                                       = modadvapi32.NewProc("CryptGenRandom")
	procGetEnvironmentStringsW                               = modkernel32.NewProc("GetEnvironmentStringsW")
	procFreeEnvironmentStringsW                              = modkernel32.NewProc("FreeEnvironmentStringsW")
	procGetEnvironmentVariableW                              = modkernel32.NewProc("GetEnvironmentVariableW")
	procSetEnvironmentVariableW                              = modkernel32.NewProc("SetEnvironmentVariableW")
	procCreateEnvironmentBlock                               = moduserenv.NewProc("CreateEnvironmentBlock")
	procDestroyEnvironmentBlock                              = moduserenv.NewProc("DestroyEnvironmentBlock")
	procGetTickCount64                                       = modkernel32.NewProc("GetTickCount64")
	procSetFileTime                                          = modkernel32.NewProc("SetFileTime")
	procGetFileAttributesW                                   = modkernel32.NewProc("GetFileAttributesW")
	procSetFileAttributesW                                   = modkernel32.NewProc("SetFileAttributesW")
	procGetFileAttributesExW                                 = modkernel32.NewProc("GetFileAttributesExW")
	procGetCommandLineW                                      = modkernel32.NewProc("GetCommandLineW")
	procCommandLineToArgvW                                   = modshell32.NewProc("CommandLineToArgvW")
	procLocalFree                                            = modkernel32.NewProc("LocalFree")
	procSetHandleInformation                                 = modkernel32.NewProc("SetHandleInformation")
	procFlushFileBuffers                                     = modkernel32.NewProc("FlushFileBuffers")
	procGetFullPathNameW                                     = modkernel32.NewProc("GetFullPathNameW")
	procGetLongPathNameW                                     = modkernel32.NewProc("GetLongPathNameW")
	procGetShortPathNameW                                    = modkernel32.NewProc("GetShortPathNameW")
	procCreateFileMappingW                                   = modkernel32.NewProc("CreateFileMappingW")
	procMapViewOfFile                                        = modkernel32.NewProc("MapViewOfFile")
	procUnmapViewOfFile                                      = modkernel32.NewProc("UnmapViewOfFile")
	procFlushViewOfFile                                      = modkernel32.NewProc("FlushViewOfFile")
	procVirtualLock                                          = modkernel32.NewProc("VirtualLock")
	procVirtualUnlock                                        = modkernel32.NewProc("VirtualUnlock")
	procVirtualAlloc                                         = modkernel32.NewProc("VirtualAlloc")
	procVirtualFree                                          = modkernel32.NewProc("VirtualFree")
	procVirtualProtect                                       = modkernel32.NewProc("VirtualProtect")
	procTransmitFile                                         = modmswsock.NewProc("TransmitFile")
	procReadDirectoryChangesW                                = modkernel32.NewProc("ReadDirectoryChangesW")
	procCertOpenSystemStoreW                                 = modcrypt32.NewProc("CertOpenSystemStoreW")
	procCertOpenStore                                        = modcrypt32.NewProc("CertOpenStore")
	procCertEnumCertificatesInStore                          = modcrypt32.NewProc("CertEnumCertificatesInStore")
	procCertAddCertificateContextToStore                     = modcrypt32.NewProc("CertAddCertificateContextToStore")
	procCertCloseStore                                       = modcrypt32.NewProc("CertCloseStore")
	procCertGetCertificateChain                              = modcrypt32.NewProc("CertGetCertificateChain")
	procCertFreeCertificateChain                             = modcrypt32.NewProc("CertFreeCertificateChain")
	procCertCreateCertificateContext                         = modcrypt32.NewProc("CertCreateCertificateContext")
	procCertFreeCertificateContext                           = modcrypt32.NewProc("CertFreeCertificateContext")
	procCertVerifyCertificateChainPolicy                     = modcrypt32.NewProc("CertVerifyCertificateChainPolicy")
	procRegOpenKeyExW                                        = modadvapi32.NewProc("RegOpenKeyExW")
	procRegCloseKey                                          = modadvapi32.NewProc("RegCloseKey")
	procRegQueryInfoKeyW                                     = modadvapi32.NewProc("RegQueryInfoKeyW")
	procRegEnumKeyExW                                        = modadvapi32.NewProc("RegEnumKeyExW")
	procRegQueryValueExW                                     = modadvapi32.NewProc("RegQueryValueExW")
	procGetCurrentProcessId                                  = modkernel32.NewProc("GetCurrentProcessId")
	procGetConsoleMode                                       = modkernel32.NewProc("GetConsoleMode")
	procSetConsoleMode                                       = modkernel32.NewProc("SetConsoleMode")
	procGetConsoleScreenBufferInfo                           = modkernel32.NewProc("GetConsoleScreenBufferInfo")
	procWriteConsoleW                                        = modkernel32.NewProc("WriteConsoleW")
	procReadConsoleW                                         = modkernel32.NewProc("ReadConsoleW")
	procCreateToolhelp32Snapshot                             = modkernel32.NewProc("CreateToolhelp32Snapshot")
	procProcess32FirstW                                      = modkernel32.NewProc("Process32FirstW")
	procProcess32NextW                                       = modkernel32.NewProc("Process32NextW")
	procThread32First                                        = modkernel32.NewProc("Thread32First")
	procThread32Next                                         = modkernel32.NewProc("Thread32Next")
	procDeviceIoControl                                      = modkernel32.NewProc("DeviceIoControl")
	procCreateSymbolicLinkW                                  = modkernel32.NewProc("CreateSymbolicLinkW")
	procCreateHardLinkW                                      = modkernel32.NewProc("CreateHardLinkW")
	procGetCurrentThreadId                                   = modkernel32.NewProc("GetCurrentThreadId")
	procCreateEventW                                         = modkernel32.NewProc("CreateEventW")
	procCreateEventExW                                       = modkernel32.NewProc("CreateEventExW")
	procOpenEventW                                           = modkernel32.NewProc("OpenEventW")
	procSetEvent                                             = modkernel32.NewProc("SetEvent")
	procResetEvent                                           = modkernel32.NewProc("ResetEvent")
	procPulseEvent                                           = modkernel32.NewProc("PulseEvent")
	procCreateMutexW                                         = modkernel32.NewProc("CreateMutexW")
	procCreateMutexExW                                       = modkernel32.NewProc("CreateMutexExW")
	procOpenMutexW                                           = modkernel32.NewProc("OpenMutexW")
	procReleaseMutex                                         = modkernel32.NewProc("ReleaseMutex")
	procSleepEx                                              = modkernel32.NewProc("SleepEx")
	procCreateJobObjectW                                     = modkernel32.NewProc("CreateJobObjectW")
	procAssignProcessToJobObject                             = modkernel32.NewProc("AssignProcessToJobObject")
	procTerminateJobObject                                   = modkernel32.NewProc("TerminateJobObject")
	procSetErrorMode                                         = modkernel32.NewProc("SetErrorMode")
	procResumeThread                                         = modkernel32.NewProc("ResumeThread")
	procSetPriorityClass                                     = modkernel32.NewProc("SetPriorityClass")
	procGetPriorityClass                                     = modkernel32.NewProc("GetPriorityClass")
	procSetInformationJobObject                              = modkernel32.NewProc("SetInformationJobObject")
	procGenerateConsoleCtrlEvent                             = modkernel32.NewProc("GenerateConsoleCtrlEvent")
	procGetProcessId                                         = modkernel32.NewProc("GetProcessId")
	procOpenThread                                           = modkernel32.NewProc("OpenThread")
	procSetProcessPriorityBoost                              = modkernel32.NewProc("SetProcessPriorityBoost")
	procDefineDosDeviceW                                     = modkernel32.NewProc("DefineDosDeviceW")
	procDeleteVolumeMountPointW                              = modkernel32.NewProc("DeleteVolumeMountPointW")
	procFindFirstVolumeW                                     = modkernel32.NewProc("FindFirstVolumeW")
	procFindFirstVolumeMountPointW                           = modkernel32.NewProc("FindFirstVolumeMountPointW")
	procFindNextVolumeW                                      = modkernel32.NewProc("FindNextVolumeW")
	procFindNextVolumeMountPointW                            = modkernel32.NewProc("FindNextVolumeMountPointW")
	procFindVolumeClose                                      = modkernel32.NewProc("FindVolumeClose")
	procFindVolumeMountPointClose                            = modkernel32.NewProc("FindVolumeMountPointClose")
	procGetDiskFreeSpaceExW                                  = modkernel32.NewProc("GetDiskFreeSpaceExW")
	procGetDriveTypeW                                        = modkernel32.NewProc("GetDriveTypeW")
	procGetLogicalDrives                                     = modkernel32.NewProc("GetLogicalDrives")
	procGetLogicalDriveStringsW                              = modkernel32.NewProc("GetLogicalDriveStringsW")
	procGetVolumeInformationW                                = modkernel32.NewProc("GetVolumeInformationW")
	procGetVolumeInformationByHandleW                        = modkernel32.NewProc("GetVolumeInformationByHandleW")
	procGetVolumeNameForVolumeMountPointW                    = modkernel32.NewProc("GetVolumeNameForVolumeMountPointW")
	procGetVolumePathNameW                                   = modkernel32.NewProc("GetVolumePathNameW")
	procGetVolumePathNamesForVolumeNameW                     = modkernel32.NewProc("GetVolumePathNamesForVolumeNameW")
	procQueryDosDeviceW                                      = modkernel32.NewProc("QueryDosDeviceW")
	procSetVolumeLabelW                                      = modkernel32.NewProc("SetVolumeLabelW")
	procSetVolumeMountPointW                                 = modkernel32.NewProc("SetVolumeMountPointW")
	procMessageBoxW                                          = moduser32.NewProc("MessageBoxW")
	procExitWindowsEx                                        = moduser32.NewProc("ExitWindowsEx")
	procInitiateSystemShutdownExW                            = modadvapi32.NewProc("InitiateSystemShutdownExW")
	procSetProcessShutdownParameters                         = modkernel32.NewProc("SetProcessShutdownParameters")
	procGetProcessShutdownParameters                         = modkernel32.NewProc("GetProcessShutdownParameters")
	procCLSIDFromString                                      = modole32.NewProc("CLSIDFromString")
	procStringFromGUID2                                      = modole32.NewProc("StringFromGUID2")
	procCoCreateGuid                                         = modole32.NewProc("CoCreateGuid")
	procCoTaskMemFree                                        = modole32.NewProc("CoTaskMemFree")
	procRtlGetVersion                                        = modntdll.NewProc("RtlGetVersion")
	procRtlGetNtVersionNumbers                               = modntdll.NewProc("RtlGetNtVersionNumbers")
	procGetProcessPreferredUILanguages                       = modkernel32.NewProc("GetProcessPreferredUILanguages")
	procGetThreadPreferredUILanguages                        = modkernel32.NewProc("GetThreadPreferredUILanguages")
	procGetUserPreferredUILanguages                          = modkernel32.NewProc("GetUserPreferredUILanguages")
	procGetSystemPreferredUILanguages                        = modkernel32.NewProc("GetSystemPreferredUILanguages")
	procEnumProcesses                                        = modpsapi.NewProc("EnumProcesses")
	procWSAStartup                                           = modws2_32.NewProc("WSAStartup")
	procWSACleanup                                           = modws2_32.NewProc("WSACleanup")
	procWSAIoctl                                             = modws2_32.NewProc("WSAIoctl")
	procsocket                                               = modws2_32.NewProc("socket")
	procsendto                                               = modws2_32.NewProc("sendto")
	procrecvfrom                                             = modws2_32.NewProc("recvfrom")
	procsetsockopt                                           = modws2_32.NewProc("setsockopt")
	procgetsockopt                                           = modws2_32.NewProc("getsockopt")
	procbind                                                 = modws2_32.NewProc("bind")
	procconnect                                              = modws2_32.NewProc("connect")
	procgetsockname                                          = modws2_32.NewProc("getsockname")
	procgetpeername                                          = modws2_32.NewProc("getpeername")
	proclisten                                               = modws2_32.NewProc("listen")
	procshutdown                                             = modws2_32.NewProc("shutdown")
	procclosesocket                                          = modws2_32.NewProc("closesocket")
	procAcceptEx                                             = modmswsock.NewProc("AcceptEx")
	procGetAcceptExSockaddrs                                 = modmswsock.NewProc("GetAcceptExSockaddrs")
	procWSARecv                                              = modws2_32.NewProc("WSARecv")
	procWSASend                                              = modws2_32.NewProc("WSASend")
	procWSARecvFrom                                          = modws2_32.NewProc("WSARecvFrom")
	procWSASendTo                                            = modws2_32.NewProc("WSASendTo")
	procgethostbyname                                        = modws2_32.NewProc("gethostbyname")
	procgetservbyname                                        = modws2_32.NewProc("getservbyname")
	procntohs                                                = modws2_32.NewProc("ntohs")
	procgetprotobyname                                       = modws2_32.NewProc("getprotobyname")
	procDnsQuery_W                                           = moddnsapi.NewProc("DnsQuery_W")
	procDnsRecordListFree                                    = moddnsapi.NewProc("DnsRecordListFree")
	procDnsNameCompare_W                                     = moddnsapi.NewProc("DnsNameCompare_W")
	procGetAddrInfoW                                         = modws2_32.NewProc("GetAddrInfoW")
	procFreeAddrInfoW                                        = modws2_32.NewProc("FreeAddrInfoW")
	procGetIfEntry                                           = modiphlpapi.NewProc("GetIfEntry")
	procGetAdaptersInfo                                      = modiphlpapi.NewProc("GetAdaptersInfo")
	procSetFileCompletionNotificationModes                   = modkernel32.NewProc("SetFileCompletionNotificationModes")
	procWSAEnumProtocolsW                                    = modws2_32.NewProc("WSAEnumProtocolsW")
	procGetAdaptersAddresses                                 = modiphlpapi.NewProc("GetAdaptersAddresses")
	procGetACP                                               = modkernel32.NewProc("GetACP")
	procMultiByteToWideChar                                  = modkernel32.NewProc("MultiByteToWideChar")
	procTranslateNameW                                       = modsecur32.NewProc("TranslateNameW")
	procGetUserNameExW                                       = modsecur32.NewProc("GetUserNameExW")
	procNetUserGetInfo                                       = modnetapi32.NewProc("NetUserGetInfo")
	procNetGetJoinInformation                                = modnetapi32.NewProc("NetGetJoinInformation")
	procNetApiBufferFree                                     = modnetapi32.NewProc("NetApiBufferFree")
	procLookupAccountSidW                                    = modadvapi32.NewProc("LookupAccountSidW")
	procLookupAccountNameW                                   = modadvapi32.NewProc("LookupAccountNameW")
	procConvertSidToStringSidW                               = modadvapi32.NewProc("ConvertSidToStringSidW")
	procConvertStringSidToSidW                               = modadvapi32.NewProc("ConvertStringSidToSidW")
	procGetLengthSid                                         = modadvapi32.NewProc("GetLengthSid")
	procCopySid                                              = modadvapi32.NewProc("CopySid")
	procAllocateAndInitializeSid                             = modadvapi32.NewProc("AllocateAndInitializeSid")
	procCreateWellKnownSid                                   = modadvapi32.NewProc("CreateWellKnownSid")
	procIsWellKnownSid                                       = modadvapi32.NewProc("IsWellKnownSid")
	procFreeSid                                              = modadvapi32.NewProc("FreeSid")
	procEqualSid                                             = modadvapi32.NewProc("EqualSid")
	procGetSidIdentifierAuthority                            = modadvapi32.NewProc("GetSidIdentifierAuthority")
	procGetSidSubAuthorityCount                              = modadvapi32.NewProc("GetSidSubAuthorityCount")
	procGetSidSubAuthority                                   = modadvapi32.NewProc("GetSidSubAuthority")
	procIsValidSid                                           = modadvapi32.NewProc("IsValidSid")
	procCheckTokenMembership                                 = modadvapi32.NewProc("CheckTokenMembership")
	procOpenProcessToken                                     = modadvapi32.NewProc("OpenProcessToken")
	procOpenThreadToken                                      = modadvapi32.NewProc("OpenThreadToken")
	procImpersonateSelf                                      = modadvapi32.NewProc("ImpersonateSelf")
	procRevertToSelf                                         = modadvapi32.NewProc("RevertToSelf")
	procSetThreadToken                                       = modadvapi32.NewProc("SetThreadToken")
	procLookupPrivilegeValueW                                = modadvapi32.NewProc("LookupPrivilegeValueW")
	procAdjustTokenPrivileges                                = modadvapi32.NewProc("AdjustTokenPrivileges")
	procAdjustTokenGroups                                    = modadvapi32.NewProc("AdjustTokenGroups")
	procGetTokenInformation                                  = modadvapi32.NewProc("GetTokenInformation")
	procSetTokenInformation                                  = modadvapi32.NewProc("SetTokenInformation")
	procDuplicateTokenEx                                     = modadvapi32.NewProc("DuplicateTokenEx")
	procGetUserProfileDirectoryW                             = moduserenv.NewProc("GetUserProfileDirectoryW")
	procGetSystemDirectoryW                                  = modkernel32.NewProc("GetSystemDirectoryW")
	procGetWindowsDirectoryW                                 = modkernel32.NewProc("GetWindowsDirectoryW")
	procGetSystemWindowsDirectoryW                           = modkernel32.NewProc("GetSystemWindowsDirectoryW")
	procWTSQueryUserToken                                    = modwtsapi32.NewProc("WTSQueryUserToken")
	procWTSEnumerateSessionsW                                = modwtsapi32.NewProc("WTSEnumerateSessionsW")
	procWTSFreeMemory                                        = modwtsapi32.NewProc("WTSFreeMemory")
	procGetSecurityInfo                                      = modadvapi32.NewProc("GetSecurityInfo")
	procSetSecurityInfo                                      = modadvapi32.NewProc("SetSecurityInfo")
	procGetNamedSecurityInfoW                                = modadvapi32.NewProc("GetNamedSecurityInfoW")
	procSetNamedSecurityInfoW                                = modadvapi32.NewProc("SetNamedSecurityInfoW")
	procBuildSecurityDescriptorW                             = modadvapi32.NewProc("BuildSecurityDescriptorW")
	procInitializeSecurityDescriptor                         = modadvapi32.NewProc("InitializeSecurityDescriptor")
	procGetSecurityDescriptorControl                         = modadvapi32.NewProc("GetSecurityDescriptorControl")
	procGetSecurityDescriptorDacl                            = modadvapi32.NewProc("GetSecurityDescriptorDacl")
	procGetSecurityDescriptorSacl                            = modadvapi32.NewProc("GetSecurityDescriptorSacl")
	procGetSecurityDescriptorOwner                           = modadvapi32.NewProc("GetSecurityDescriptorOwner")
	procGetSecurityDescriptorGroup                           = modadvapi32.NewProc("GetSecurityDescriptorGroup")
	procGetSecurityDescriptorLength                          = modadvapi32.NewProc("GetSecurityDescriptorLength")
	procGetSecurityDescriptorRMControl                       = modadvapi32.NewProc("GetSecurityDescriptorRMControl")
	procIsValidSecurityDescriptor                            = modadvapi32.NewProc("IsValidSecurityDescriptor")
	procSetSecurityDescriptorControl                         = modadvapi32.NewProc("SetSecurityDescriptorControl")
	procSetSecurityDescriptorDacl                            = modadvapi32.NewProc("SetSecurityDescriptorDacl")
	procSetSecurityDescriptorSacl                            = modadvapi32.NewProc("SetSecurityDescriptorSacl")
	procSetSecurityDescriptorOwner                           = modadvapi32.NewProc("SetSecurityDescriptorOwner")
	procSetSecurityDescriptorGroup                           = modadvapi32.NewProc("SetSecurityDescriptorGroup")
	procSetSecurityDescriptorRMControl                       = modadvapi32.NewProc("SetSecurityDescriptorRMControl")
	procConvertStringSecurityDescriptorToSecurityDescriptorW = modadvapi32.NewProc("ConvertStringSecurityDescriptorToSecurityDescriptorW")
	procConvertSecurityDescriptorToStringSecurityDescriptorW = modadvapi32.NewProc("ConvertSecurityDescriptorToStringSecurityDescriptorW")
	procMakeAbsoluteSD                                       = modadvapi32.NewProc("MakeAbsoluteSD")
	procMakeSelfRelativeSD                                   = modadvapi32.NewProc("MakeSelfRelativeSD")
	procSetEntriesInAclW                                     = modadvapi32.NewProc("SetEntriesInAclW")
)

func RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procRegisterEventSourceW.Addr(), 2, uintptr(unsafe.Pointer(uncServerName)), uintptr(unsafe.Pointer(sourceName)), 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DeregisterEventSource(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procDeregisterEventSource.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) {
	r1, _, e1 := syscall.Syscall9(procReportEventW.Addr(), 9, uintptr(log), uintptr(etype), uintptr(category), uintptr(eventId), uintptr(usrSId), uintptr(numStrings), uintptr(dataSize), uintptr(unsafe.Pointer(strings)), uintptr(unsafe.Pointer(rawData)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procOpenSCManagerW.Addr(), 3, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(databaseName)), uintptr(access))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CloseServiceHandle(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procCloseServiceHandle.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall15(procCreateServiceW.Addr(), 13, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(unsafe.Pointer(displayName)), uintptr(access), uintptr(srvType), uintptr(startType), uintptr(errCtl), uintptr(unsafe.Pointer(pathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procOpenServiceW.Addr(), 3, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(access))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DeleteService(service Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procDeleteService.Addr(), 1, uintptr(service), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procStartServiceW.Addr(), 3, uintptr(service), uintptr(numArgs), uintptr(unsafe.Pointer(argVectors)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) {
	r1, _, e1 := syscall.Syscall(procQueryServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(status)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryServiceLockStatus(mgr Handle, lockStatus *QUERY_SERVICE_LOCK_STATUS, bufSize uint32, bytesNeeded *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procQueryServiceLockStatusW.Addr(), 4, uintptr(mgr), uintptr(unsafe.Pointer(lockStatus)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) {
	r1, _, e1 := syscall.Syscall(procControlService.Addr(), 3, uintptr(service), uintptr(control), uintptr(unsafe.Pointer(status)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) {
	r1, _, e1 := syscall.Syscall(procStartServiceCtrlDispatcherW.Addr(), 1, uintptr(unsafe.Pointer(serviceTable)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) {
	r1, _, e1 := syscall.Syscall(procSetServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(serviceStatus)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall12(procChangeServiceConfigW.Addr(), 11, uintptr(service), uintptr(serviceType), uintptr(startType), uintptr(errorControl), uintptr(unsafe.Pointer(binaryPathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), uintptr(unsafe.Pointer(displayName)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procQueryServiceConfigW.Addr(), 4, uintptr(service), uintptr(unsafe.Pointer(serviceConfig)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) {
	r1, _, e1 := syscall.Syscall(procChangeServiceConfig2W.Addr(), 3, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(info)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procQueryServiceConfig2W.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall12(procEnumServicesStatusExW.Addr(), 10, uintptr(mgr), uintptr(infoLevel), uintptr(serviceType), uintptr(serviceState), uintptr(unsafe.Pointer(services)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), uintptr(unsafe.Pointer(servicesReturned)), uintptr(unsafe.Pointer(resumeHandle)), uintptr(unsafe.Pointer(groupName)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryServiceStatusEx(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procQueryServiceStatusEx.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func NotifyServiceStatusChange(service Handle, notifyMask uint32, notifier *SERVICE_NOTIFY) (ret error) {
	r0, _, _ := syscall.Syscall(procNotifyServiceStatusChangeW.Addr(), 3, uintptr(service), uintptr(notifyMask), uintptr(unsafe.Pointer(notifier)))
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func GetLastError() (lasterr error) {
	r0, _, _ := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)
	if r0 != 0 {
		lasterr = syscall.Errno(r0)
	}
	return
}

func LoadLibrary(libname string) (handle Handle, err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(libname)
	if err != nil {
		return
	}
	return _LoadLibrary(_p0)
}

func _LoadLibrary(libname *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procLoadLibraryW.Addr(), 1, uintptr(unsafe.Pointer(libname)), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(libname)
	if err != nil {
		return
	}
	return _LoadLibraryEx(_p0, zero, flags)
}

func _LoadLibraryEx(libname *uint16, zero Handle, flags uintptr) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procLoadLibraryExW.Addr(), 3, uintptr(unsafe.Pointer(libname)), uintptr(zero), uintptr(flags))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FreeLibrary(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFreeLibrary.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetProcAddress(module Handle, procname string) (proc uintptr, err error) {
	var _p0 *byte
	_p0, err = syscall.BytePtrFromString(procname)
	if err != nil {
		return
	}
	return _GetProcAddress(module, _p0)
}

func _GetProcAddress(module Handle, procname *byte) (proc uintptr, err error) {
	r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), uintptr(unsafe.Pointer(procname)), 0)
	proc = uintptr(r0)
	if proc == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetModuleFileName(module Handle, filename *uint16, size uint32) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetModuleFileNameW.Addr(), 3, uintptr(module), uintptr(unsafe.Pointer(filename)), uintptr(size))
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetModuleHandleEx(flags uint32, moduleName *uint16, module *Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGetModuleHandleExW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(moduleName)), uintptr(unsafe.Pointer(module)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVersion() (ver uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetVersion.Addr(), 0, 0, 0, 0)
	ver = uint32(r0)
	if ver == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) {
	var _p0 *uint16
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, _, e1 := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ExitProcess(exitcode uint32) {
	syscall.Syscall(procExitProcess.Addr(), 1, uintptr(exitcode), 0, 0)
	return
}

func IsWow64Process(handle Handle, isWow64 *bool) (err error) {
	var _p0 uint32
	if *isWow64 {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procIsWow64Process.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(&_p0)), 0)
	*isWow64 = _p0 != 0
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile Handle) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall9(procCreateFileW.Addr(), 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReadFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r1, _, e1 := syscall.Syscall6(procReadFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WriteFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r1, _, e1 := syscall.Syscall6(procWriteFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetOverlappedResult(handle Handle, overlapped *Overlapped, done *uint32, wait bool) (err error) {
	var _p0 uint32
	if wait {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall6(procGetOverlappedResult.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(done)), uintptr(_p0), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) {
	r0, _, e1 := syscall.Syscall6(procSetFilePointer.Addr(), 4, uintptr(handle), uintptr(lowoffset), uintptr(unsafe.Pointer(highoffsetptr)), uintptr(whence), 0, 0)
	newlowoffset = uint32(r0)
	if newlowoffset == 0xffffffff {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CloseHandle(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procCloseHandle.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetStdHandle(stdhandle uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetStdHandle.Addr(), 1, uintptr(stdhandle), 0, 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetStdHandle(stdhandle uint32, handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procSetStdHandle.Addr(), 2, uintptr(stdhandle), uintptr(handle), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procFindFirstFileW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func findNextFile1(handle Handle, data *win32finddata1) (err error) {
	r1, _, e1 := syscall.Syscall(procFindNextFileW.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindClose(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFindClose.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error) {
	r1, _, e1 := syscall.Syscall(procGetFileInformationByHandle.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFileInformationByHandleEx(handle Handle, class uint32, outBuffer *byte, outBufferLen uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetFileInformationByHandleEx.Addr(), 4, uintptr(handle), uintptr(class), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferLen), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetCurrentDirectoryW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetCurrentDirectory(path *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procSetCurrentDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) {
	r1, _, e1 := syscall.Syscall(procCreateDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func RemoveDirectory(path *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procRemoveDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DeleteFile(path *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procDeleteFileW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func MoveFile(from *uint16, to *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procMoveFileW.Addr(), 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(flags))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LockFileEx(file Handle, flags uint32, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall6(procLockFileEx.Addr(), 6, uintptr(file), uintptr(flags), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(unsafe.Pointer(overlapped)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func UnlockFileEx(file Handle, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall6(procUnlockFileEx.Addr(), 5, uintptr(file), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetComputerName(buf *uint16, n *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetComputerNameExW.Addr(), 3, uintptr(nametype), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetEndOfFile(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procSetEndOfFile.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetSystemTimeAsFileTime(time *Filetime) {
	syscall.Syscall(procGetSystemTimeAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)
	return
}

func GetSystemTimePreciseAsFileTime(time *Filetime) {
	syscall.Syscall(procGetSystemTimePreciseAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)
	return
}

func GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetTimeZoneInformation.Addr(), 1, uintptr(unsafe.Pointer(tzi)), 0, 0)
	rc = uint32(r0)
	if rc == 0xffffffff {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateIoCompletionPort.Addr(), 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetQueuedCompletionStatus.Addr(), 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall6(procPostQueuedCompletionStatus.Addr(), 4, uintptr(cphandle), uintptr(qty), uintptr(key), uintptr(unsafe.Pointer(overlapped)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CancelIo(s Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procCancelIo.Addr(), 1, uintptr(s), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CancelIoEx(s Handle, o *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall(procCancelIoEx.Addr(), 2, uintptr(s), uintptr(unsafe.Pointer(o)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) {
	var _p0 uint32
	if inheritHandles {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall12(procCreateProcessW.Addr(), 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error) {
	var _p0 uint32
	if inheritHandle {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall(procOpenProcess.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(processId))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) {
	r1, _, e1 := syscall.Syscall6(procShellExecuteW.Addr(), 6, uintptr(hwnd), uintptr(unsafe.Pointer(verb)), uintptr(unsafe.Pointer(file)), uintptr(unsafe.Pointer(args)), uintptr(unsafe.Pointer(cwd)), uintptr(showCmd))
	if r1 <= 32 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) {
	r0, _, _ := syscall.Syscall6(procSHGetKnownFolderPath.Addr(), 4, uintptr(unsafe.Pointer(id)), uintptr(flags), uintptr(token), uintptr(unsafe.Pointer(path)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func TerminateProcess(handle Handle, exitcode uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procTerminateProcess.Addr(), 2, uintptr(handle), uintptr(exitcode), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetExitCodeProcess(handle Handle, exitcode *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetExitCodeProcess.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetStartupInfo(startupInfo *StartupInfo) (err error) {
	r1, _, e1 := syscall.Syscall(procGetStartupInfoW.Addr(), 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetProcessTimes.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(creationTime)), uintptr(unsafe.Pointer(exitTime)), uintptr(unsafe.Pointer(kernelTime)), uintptr(unsafe.Pointer(userTime)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) {
	var _p0 uint32
	if bInheritHandle {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall9(procDuplicateHandle.Addr(), 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) {
	r0, _, e1 := syscall.Syscall(procWaitForSingleObject.Addr(), 2, uintptr(handle), uintptr(waitMilliseconds), 0)
	event = uint32(r0)
	if event == 0xffffffff {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func waitForMultipleObjects(count uint32, handles uintptr, waitAll bool, waitMilliseconds uint32) (event uint32, err error) {
	var _p0 uint32
	if waitAll {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall6(procWaitForMultipleObjects.Addr(), 4, uintptr(count), uintptr(handles), uintptr(_p0), uintptr(waitMilliseconds), 0, 0)
	event = uint32(r0)
	if event == 0xffffffff {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCreatePipe.Addr(), 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFileType(filehandle Handle) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetFileType.Addr(), 1, uintptr(filehandle), 0, 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCryptAcquireContextW.Addr(), 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CryptReleaseContext(provhandle Handle, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procCryptReleaseContext.Addr(), 2, uintptr(provhandle), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) {
	r1, _, e1 := syscall.Syscall(procCryptGenRandom.Addr(), 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetEnvironmentStrings() (envs *uint16, err error) {
	r0, _, e1 := syscall.Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0)
	envs = (*uint16)(unsafe.Pointer(r0))
	if envs == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FreeEnvironmentStrings(envs *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procFreeEnvironmentStringsW.Addr(), 1, uintptr(unsafe.Pointer(envs)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetEnvironmentVariableW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(buffer)), uintptr(size))
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetEnvironmentVariable(name *uint16, value *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procSetEnvironmentVariableW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateEnvironmentBlock(block **uint16, token Token, inheritExisting bool) (err error) {
	var _p0 uint32
	if inheritExisting {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procCreateEnvironmentBlock.Addr(), 3, uintptr(unsafe.Pointer(block)), uintptr(token), uintptr(_p0))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DestroyEnvironmentBlock(block *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procDestroyEnvironmentBlock.Addr(), 1, uintptr(unsafe.Pointer(block)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getTickCount64() (ms uint64) {
	r0, _, _ := syscall.Syscall(procGetTickCount64.Addr(), 0, 0, 0, 0)
	ms = uint64(r0)
	return
}

func SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error) {
	r1, _, e1 := syscall.Syscall6(procSetFileTime.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFileAttributes(name *uint16) (attrs uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetFileAttributesW.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
	attrs = uint32(r0)
	if attrs == INVALID_FILE_ATTRIBUTES {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetFileAttributes(name *uint16, attrs uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procSetFileAttributesW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(attrs), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) {
	r1, _, e1 := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(level), uintptr(unsafe.Pointer(info)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetCommandLine() (cmd *uint16) {
	r0, _, _ := syscall.Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0)
	cmd = (*uint16)(unsafe.Pointer(r0))
	return
}

func CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error) {
	r0, _, e1 := syscall.Syscall(procCommandLineToArgvW.Addr(), 2, uintptr(unsafe.Pointer(cmd)), uintptr(unsafe.Pointer(argc)), 0)
	argv = (*[8192]*[8192]uint16)(unsafe.Pointer(r0))
	if argv == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LocalFree(hmem Handle) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procLocalFree.Addr(), 1, uintptr(hmem), 0, 0)
	handle = Handle(r0)
	if handle != 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procSetHandleInformation.Addr(), 3, uintptr(handle), uintptr(mask), uintptr(flags))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FlushFileBuffers(handle Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFlushFileBuffers.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, uintptr(unsafe.Pointer(path)), uintptr(buflen), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(fname)), 0, 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetLongPathNameW.Addr(), 3, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(buf)), uintptr(buflen))
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetShortPathNameW.Addr(), 3, uintptr(unsafe.Pointer(longpath)), uintptr(unsafe.Pointer(shortpath)), uintptr(buflen))
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error) {
	r0, _, e1 := syscall.Syscall6(procMapViewOfFile.Addr(), 5, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0)
	addr = uintptr(r0)
	if addr == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func UnmapViewOfFile(addr uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, uintptr(addr), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FlushViewOfFile(addr uintptr, length uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procFlushViewOfFile.Addr(), 2, uintptr(addr), uintptr(length), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func VirtualLock(addr uintptr, length uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procVirtualLock.Addr(), 2, uintptr(addr), uintptr(length), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func VirtualUnlock(addr uintptr, length uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procVirtualUnlock.Addr(), 2, uintptr(addr), uintptr(length), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) {
	r0, _, e1 := syscall.Syscall6(procVirtualAlloc.Addr(), 4, uintptr(address), uintptr(size), uintptr(alloctype), uintptr(protect), 0, 0)
	value = uintptr(r0)
	if value == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procVirtualFree.Addr(), 3, uintptr(address), uintptr(size), uintptr(freetype))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procVirtualProtect.Addr(), 4, uintptr(address), uintptr(size), uintptr(newprotect), uintptr(unsafe.Pointer(oldprotect)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procTransmitFile.Addr(), 7, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) {
	var _p0 uint32
	if watchSubTree {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall9(procReadDirectoryChangesW.Addr(), 8, uintptr(handle), uintptr(unsafe.Pointer(buf)), uintptr(buflen), uintptr(_p0), uintptr(mask), uintptr(unsafe.Pointer(retlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) {
	r0, _, e1 := syscall.Syscall(procCertOpenSystemStoreW.Addr(), 2, uintptr(hprov), uintptr(unsafe.Pointer(name)), 0)
	store = Handle(r0)
	if store == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCertOpenStore.Addr(), 5, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) {
	r0, _, e1 := syscall.Syscall(procCertEnumCertificatesInStore.Addr(), 2, uintptr(store), uintptr(unsafe.Pointer(prevContext)), 0)
	context = (*CertContext)(unsafe.Pointer(r0))
	if context == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) {
	r1, _, e1 := syscall.Syscall6(procCertAddCertificateContextToStore.Addr(), 4, uintptr(store), uintptr(unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(unsafe.Pointer(storeContext)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertCloseStore(store Handle, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procCertCloseStore.Addr(), 2, uintptr(store), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) {
	r1, _, e1 := syscall.Syscall9(procCertGetCertificateChain.Addr(), 8, uintptr(engine), uintptr(unsafe.Pointer(leaf)), uintptr(unsafe.Pointer(time)), uintptr(additionalStore), uintptr(unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(chainCtx)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertFreeCertificateChain(ctx *CertChainContext) {
	syscall.Syscall(procCertFreeCertificateChain.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)
	return
}

func CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) {
	r0, _, e1 := syscall.Syscall(procCertCreateCertificateContext.Addr(), 3, uintptr(certEncodingType), uintptr(unsafe.Pointer(certEncoded)), uintptr(encodedLen))
	context = (*CertContext)(unsafe.Pointer(r0))
	if context == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertFreeCertificateContext(ctx *CertContext) (err error) {
	r1, _, e1 := syscall.Syscall(procCertFreeCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) {
	r1, _, e1 := syscall.Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, uintptr(policyOID), uintptr(unsafe.Pointer(chain)), uintptr(unsafe.Pointer(para)), uintptr(unsafe.Pointer(status)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall6(procRegOpenKeyExW.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(unsafe.Pointer(result)), 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func RegCloseKey(key Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall(procRegCloseKey.Addr(), 1, uintptr(key), 0, 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) {
	r0, _, _ := syscall.Syscall12(procRegQueryInfoKeyW.Addr(), 12, uintptr(key), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(subkeysLen)), uintptr(unsafe.Pointer(maxSubkeyLen)), uintptr(unsafe.Pointer(maxClassLen)), uintptr(unsafe.Pointer(valuesLen)), uintptr(unsafe.Pointer(maxValueNameLen)), uintptr(unsafe.Pointer(maxValueLen)), uintptr(unsafe.Pointer(saLen)), uintptr(unsafe.Pointer(lastWriteTime)))
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) {
	r0, _, _ := syscall.Syscall9(procRegEnumKeyExW.Addr(), 8, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(lastWriteTime)), 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) {
	r0, _, _ := syscall.Syscall6(procRegQueryValueExW.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(valtype)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(buflen)))
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func GetCurrentProcessId() (pid uint32) {
	r0, _, _ := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0)
	pid = uint32(r0)
	return
}

func GetConsoleMode(console Handle, mode *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(mode)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetConsoleMode(console Handle, mode uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(console), uintptr(mode), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) {
	r1, _, e1 := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(info)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) {
	r1, _, e1 := syscall.Syscall6(procWriteConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(towrite), uintptr(unsafe.Pointer(written)), uintptr(unsafe.Pointer(reserved)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) {
	r1, _, e1 := syscall.Syscall6(procReadConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(toread), uintptr(unsafe.Pointer(read)), uintptr(unsafe.Pointer(inputControl)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procCreateToolhelp32Snapshot.Addr(), 2, uintptr(flags), uintptr(processId), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) {
	r1, _, e1 := syscall.Syscall(procProcess32FirstW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) {
	r1, _, e1 := syscall.Syscall(procProcess32NextW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Thread32First(snapshot Handle, threadEntry *ThreadEntry32) (err error) {
	r1, _, e1 := syscall.Syscall(procThread32First.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(threadEntry)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error) {
	r1, _, e1 := syscall.Syscall(procThread32Next.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(threadEntry)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall9(procDeviceIoControl.Addr(), 8, uintptr(handle), uintptr(ioControlCode), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(unsafe.Pointer(bytesReturned)), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procCreateSymbolicLinkW.Addr(), 3, uintptr(unsafe.Pointer(symlinkfilename)), uintptr(unsafe.Pointer(targetfilename)), uintptr(flags))
	if r1&0xff == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procCreateHardLinkW.Addr(), 3, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(existingfilename)), uintptr(reserved))
	if r1&0xff == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetCurrentThreadId() (id uint32) {
	r0, _, _ := syscall.Syscall(procGetCurrentThreadId.Addr(), 0, 0, 0, 0)
	id = uint32(r0)
	return
}

func CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateEventW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(manualReset), uintptr(initialState), uintptr(unsafe.Pointer(name)), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateEventExW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) {
	var _p0 uint32
	if inheritHandle {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall(procOpenEventW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetEvent(event Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procSetEvent.Addr(), 1, uintptr(event), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ResetEvent(event Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procResetEvent.Addr(), 1, uintptr(event), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func PulseEvent(event Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procPulseEvent.Addr(), 1, uintptr(event), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateMutex(mutexAttrs *SecurityAttributes, initialOwner bool, name *uint16) (handle Handle, err error) {
	var _p0 uint32
	if initialOwner {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall(procCreateMutexW.Addr(), 3, uintptr(unsafe.Pointer(mutexAttrs)), uintptr(_p0), uintptr(unsafe.Pointer(name)))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CreateMutexEx(mutexAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateMutexExW.Addr(), 4, uintptr(unsafe.Pointer(mutexAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenMutex(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) {
	var _p0 uint32
	if inheritHandle {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall(procOpenMutexW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ReleaseMutex(mutex Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procReleaseMutex.Addr(), 1, uintptr(mutex), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SleepEx(milliseconds uint32, alertable bool) (ret uint32) {
	var _p0 uint32
	if alertable {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, _ := syscall.Syscall(procSleepEx.Addr(), 2, uintptr(milliseconds), uintptr(_p0), 0)
	ret = uint32(r0)
	return
}

func CreateJobObject(jobAttr *SecurityAttributes, name *uint16) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procCreateJobObjectW.Addr(), 2, uintptr(unsafe.Pointer(jobAttr)), uintptr(unsafe.Pointer(name)), 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func AssignProcessToJobObject(job Handle, process Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procAssignProcessToJobObject.Addr(), 2, uintptr(job), uintptr(process), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func TerminateJobObject(job Handle, exitCode uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procTerminateJobObject.Addr(), 2, uintptr(job), uintptr(exitCode), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetErrorMode(mode uint32) (ret uint32) {
	r0, _, _ := syscall.Syscall(procSetErrorMode.Addr(), 1, uintptr(mode), 0, 0)
	ret = uint32(r0)
	return
}

func ResumeThread(thread Handle) (ret uint32, err error) {
	r0, _, e1 := syscall.Syscall(procResumeThread.Addr(), 1, uintptr(thread), 0, 0)
	ret = uint32(r0)
	if ret == 0xffffffff {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetPriorityClass(process Handle, priorityClass uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procSetPriorityClass.Addr(), 2, uintptr(process), uintptr(priorityClass), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetPriorityClass(process Handle) (ret uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetPriorityClass.Addr(), 1, uintptr(process), 0, 0)
	ret = uint32(r0)
	if ret == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error) {
	r0, _, e1 := syscall.Syscall6(procSetInformationJobObject.Addr(), 4, uintptr(job), uintptr(JobObjectInformationClass), uintptr(JobObjectInformation), uintptr(JobObjectInformationLength), 0, 0)
	ret = int(r0)
	if ret == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGenerateConsoleCtrlEvent.Addr(), 2, uintptr(ctrlEvent), uintptr(processGroupID), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetProcessId(process Handle) (id uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetProcessId.Addr(), 1, uintptr(process), 0, 0)
	id = uint32(r0)
	if id == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenThread(desiredAccess uint32, inheritHandle bool, threadId uint32) (handle Handle, err error) {
	var _p0 uint32
	if inheritHandle {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall(procOpenThread.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(threadId))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetProcessPriorityBoost(process Handle, disable bool) (err error) {
	var _p0 uint32
	if disable {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procSetProcessPriorityBoost.Addr(), 2, uintptr(process), uintptr(_p0), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procDefineDosDeviceW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procDeleteVolumeMountPointW.Addr(), 1, uintptr(unsafe.Pointer(volumeMountPoint)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procFindFirstVolumeW.Addr(), 2, uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procFindFirstVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procFindNextVolumeW.Addr(), 3, uintptr(findVolume), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procFindNextVolumeMountPointW.Addr(), 3, uintptr(findVolumeMountPoint), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindVolumeClose(findVolume Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFindVolumeClose.Addr(), 1, uintptr(findVolume), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFindVolumeMountPointClose.Addr(), 1, uintptr(findVolumeMountPoint), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetDiskFreeSpaceEx(directoryName *uint16, freeBytesAvailableToCaller *uint64, totalNumberOfBytes *uint64, totalNumberOfFreeBytes *uint64) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetDiskFreeSpaceExW.Addr(), 4, uintptr(unsafe.Pointer(directoryName)), uintptr(unsafe.Pointer(freeBytesAvailableToCaller)), uintptr(unsafe.Pointer(totalNumberOfBytes)), uintptr(unsafe.Pointer(totalNumberOfFreeBytes)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetDriveType(rootPathName *uint16) (driveType uint32) {
	r0, _, _ := syscall.Syscall(procGetDriveTypeW.Addr(), 1, uintptr(unsafe.Pointer(rootPathName)), 0, 0)
	driveType = uint32(r0)
	return
}

func GetLogicalDrives() (drivesBitMask uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetLogicalDrives.Addr(), 0, 0, 0, 0)
	drivesBitMask = uint32(r0)
	if drivesBitMask == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetLogicalDriveStringsW.Addr(), 2, uintptr(bufferLength), uintptr(unsafe.Pointer(buffer)), 0)
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procGetVolumeInformationW.Addr(), 8, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procGetVolumeInformationByHandleW.Addr(), 8, uintptr(file), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetVolumeNameForVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferlength))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetVolumePathNameW.Addr(), 3, uintptr(unsafe.Pointer(fileName)), uintptr(unsafe.Pointer(volumePathName)), uintptr(bufferLength))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetVolumePathNamesForVolumeNameW.Addr(), 4, uintptr(unsafe.Pointer(volumeName)), uintptr(unsafe.Pointer(volumePathNames)), uintptr(bufferLength), uintptr(unsafe.Pointer(returnLength)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) {
	r0, _, e1 := syscall.Syscall(procQueryDosDeviceW.Addr(), 3, uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)), uintptr(max))
	n = uint32(r0)
	if n == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procSetVolumeLabelW.Addr(), 2, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeName)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procSetVolumeMountPointW.Addr(), 2, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func MessageBox(hwnd Handle, text *uint16, caption *uint16, boxtype uint32) (ret int32, err error) {
	r0, _, e1 := syscall.Syscall6(procMessageBoxW.Addr(), 4, uintptr(hwnd), uintptr(unsafe.Pointer(text)), uintptr(unsafe.Pointer(caption)), uintptr(boxtype), 0, 0)
	ret = int32(r0)
	if ret == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ExitWindowsEx(flags uint32, reason uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procExitWindowsEx.Addr(), 2, uintptr(flags), uintptr(reason), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func InitiateSystemShutdownEx(machineName *uint16, message *uint16, timeout uint32, forceAppsClosed bool, rebootAfterShutdown bool, reason uint32) (err error) {
	var _p0 uint32
	if forceAppsClosed {
		_p0 = 1
	} else {
		_p0 = 0
	}
	var _p1 uint32
	if rebootAfterShutdown {
		_p1 = 1
	} else {
		_p1 = 0
	}
	r1, _, e1 := syscall.Syscall6(procInitiateSystemShutdownExW.Addr(), 6, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(message)), uintptr(timeout), uintptr(_p0), uintptr(_p1), uintptr(reason))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetProcessShutdownParameters(level uint32, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procSetProcessShutdownParameters.Addr(), 2, uintptr(level), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetProcessShutdownParameters(level *uint32, flags *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetProcessShutdownParameters.Addr(), 2, uintptr(unsafe.Pointer(level)), uintptr(unsafe.Pointer(flags)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) {
	r0, _, _ := syscall.Syscall(procCLSIDFromString.Addr(), 2, uintptr(unsafe.Pointer(lpsz)), uintptr(unsafe.Pointer(pclsid)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func stringFromGUID2(rguid *GUID, lpsz *uint16, cchMax int32) (chars int32) {
	r0, _, _ := syscall.Syscall(procStringFromGUID2.Addr(), 3, uintptr(unsafe.Pointer(rguid)), uintptr(unsafe.Pointer(lpsz)), uintptr(cchMax))
	chars = int32(r0)
	return
}

func coCreateGuid(pguid *GUID) (ret error) {
	r0, _, _ := syscall.Syscall(procCoCreateGuid.Addr(), 1, uintptr(unsafe.Pointer(pguid)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func CoTaskMemFree(address unsafe.Pointer) {
	syscall.Syscall(procCoTaskMemFree.Addr(), 1, uintptr(address), 0, 0)
	return
}

func rtlGetVersion(info *OsVersionInfoEx) (ret error) {
	r0, _, _ := syscall.Syscall(procRtlGetVersion.Addr(), 1, uintptr(unsafe.Pointer(info)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func rtlGetNtVersionNumbers(majorVersion *uint32, minorVersion *uint32, buildNumber *uint32) {
	syscall.Syscall(procRtlGetNtVersionNumbers.Addr(), 3, uintptr(unsafe.Pointer(majorVersion)), uintptr(unsafe.Pointer(minorVersion)), uintptr(unsafe.Pointer(buildNumber)))
	return
}

func getProcessPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetProcessPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getThreadPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetThreadPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetUserPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSystemPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetSystemPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func EnumProcesses(processIds []uint32, bytesReturned *uint32) (err error) {
	var _p0 *uint32
	if len(processIds) > 0 {
		_p0 = &processIds[0]
	}
	r1, _, e1 := syscall.Syscall(procEnumProcesses.Addr(), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(processIds)), uintptr(unsafe.Pointer(bytesReturned)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSAStartup(verreq uint32, data *WSAData) (sockerr error) {
	r0, _, _ := syscall.Syscall(procWSAStartup.Addr(), 2, uintptr(verreq), uintptr(unsafe.Pointer(data)), 0)
	if r0 != 0 {
		sockerr = syscall.Errno(r0)
	}
	return
}

func WSACleanup() (err error) {
	r1, _, e1 := syscall.Syscall(procWSACleanup.Addr(), 0, 0, 0, 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) {
	r1, _, e1 := syscall.Syscall9(procWSAIoctl.Addr(), 9, uintptr(s), uintptr(iocc), uintptr(unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(unsafe.Pointer(cbbr)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func socket(af int32, typ int32, protocol int32) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procsocket.Addr(), 3, uintptr(af), uintptr(typ), uintptr(protocol))
	handle = Handle(r0)
	if handle == InvalidHandle {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r1, _, e1 := syscall.Syscall6(procsendto.Addr(), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(tolen))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func recvfrom(s Handle, buf []byte, flags int32, from *RawSockaddrAny, fromlen *int32) (n int32, err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, _, e1 := syscall.Syscall6(procrecvfrom.Addr(), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int32(r0)
	if n == -1 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) {
	r1, _, e1 := syscall.Syscall6(procsetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(optlen), 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) {
	r1, _, e1 := syscall.Syscall6(procgetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(unsafe.Pointer(optlen)), 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func bind(s Handle, name unsafe.Pointer, namelen int32) (err error) {
	r1, _, e1 := syscall.Syscall(procbind.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func connect(s Handle, name unsafe.Pointer, namelen int32) (err error) {
	r1, _, e1 := syscall.Syscall(procconnect.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) {
	r1, _, e1 := syscall.Syscall(procgetsockname.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) {
	r1, _, e1 := syscall.Syscall(procgetpeername.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func listen(s Handle, backlog int32) (err error) {
	r1, _, e1 := syscall.Syscall(proclisten.Addr(), 2, uintptr(s), uintptr(backlog), 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func shutdown(s Handle, how int32) (err error) {
	r1, _, e1 := syscall.Syscall(procshutdown.Addr(), 2, uintptr(s), uintptr(how), 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Closesocket(s Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procclosesocket.Addr(), 1, uintptr(s), 0, 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := syscall.Syscall9(procAcceptEx.Addr(), 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) {
	syscall.Syscall9(procGetAcceptExSockaddrs.Addr(), 8, uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(lrsa)), uintptr(unsafe.Pointer(lrsalen)), uintptr(unsafe.Pointer(rrsa)), uintptr(unsafe.Pointer(rrsalen)), 0)
	return
}

func WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) {
	r1, _, e1 := syscall.Syscall9(procWSARecv.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) {
	r1, _, e1 := syscall.Syscall9(procWSASend.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) {
	r1, _, e1 := syscall.Syscall9(procWSARecvFrom.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32, overlapped *Overlapped, croutine *byte) (err error) {
	r1, _, e1 := syscall.Syscall9(procWSASendTo.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(to)), uintptr(tolen), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
	if r1 == socket_error {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetHostByName(name string) (h *Hostent, err error) {
	var _p0 *byte
	_p0, err = syscall.BytePtrFromString(name)
	if err != nil {
		return
	}
	return _GetHostByName(_p0)
}

func _GetHostByName(name *byte) (h *Hostent, err error) {
	r0, _, e1 := syscall.Syscall(procgethostbyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
	h = (*Hostent)(unsafe.Pointer(r0))
	if h == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetServByName(name string, proto string) (s *Servent, err error) {
	var _p0 *byte
	_p0, err = syscall.BytePtrFromString(name)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = syscall.BytePtrFromString(proto)
	if err != nil {
		return
	}
	return _GetServByName(_p0, _p1)
}

func _GetServByName(name *byte, proto *byte) (s *Servent, err error) {
	r0, _, e1 := syscall.Syscall(procgetservbyname.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(proto)), 0)
	s = (*Servent)(unsafe.Pointer(r0))
	if s == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func Ntohs(netshort uint16) (u uint16) {
	r0, _, _ := syscall.Syscall(procntohs.Addr(), 1, uintptr(netshort), 0, 0)
	u = uint16(r0)
	return
}

func GetProtoByName(name string) (p *Protoent, err error) {
	var _p0 *byte
	_p0, err = syscall.BytePtrFromString(name)
	if err != nil {
		return
	}
	return _GetProtoByName(_p0)
}

func _GetProtoByName(name *byte) (p *Protoent, err error) {
	r0, _, e1 := syscall.Syscall(procgetprotobyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
	p = (*Protoent)(unsafe.Pointer(r0))
	if p == nil {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {
	var _p0 *uint16
	_p0, status = syscall.UTF16PtrFromString(name)
	if status != nil {
		return
	}
	return _DnsQuery(_p0, qtype, options, extra, qrs, pr)
}

func _DnsQuery(name *uint16, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {
	r0, _, _ := syscall.Syscall6(procDnsQuery_W.Addr(), 6, uintptr(unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))
	if r0 != 0 {
		status = syscall.Errno(r0)
	}
	return
}

func DnsRecordListFree(rl *DNSRecord, freetype uint32) {
	syscall.Syscall(procDnsRecordListFree.Addr(), 2, uintptr(unsafe.Pointer(rl)), uintptr(freetype), 0)
	return
}

func DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) {
	r0, _, _ := syscall.Syscall(procDnsNameCompare_W.Addr(), 2, uintptr(unsafe.Pointer(name1)), uintptr(unsafe.Pointer(name2)), 0)
	same = r0 != 0
	return
}

func GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) {
	r0, _, _ := syscall.Syscall6(procGetAddrInfoW.Addr(), 4, uintptr(unsafe.Pointer(nodename)), uintptr(unsafe.Pointer(servicename)), uintptr(unsafe.Pointer(hints)), uintptr(unsafe.Pointer(result)), 0, 0)
	if r0 != 0 {
		sockerr = syscall.Errno(r0)
	}
	return
}

func FreeAddrInfoW(addrinfo *AddrinfoW) {
	syscall.Syscall(procFreeAddrInfoW.Addr(), 1, uintptr(unsafe.Pointer(addrinfo)), 0, 0)
	return
}

func GetIfEntry(pIfRow *MibIfRow) (errcode error) {
	r0, _, _ := syscall.Syscall(procGetIfEntry.Addr(), 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)
	if r0 != 0 {
		errcode = syscall.Errno(r0)
	}
	return
}

func GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) {
	r0, _, _ := syscall.Syscall(procGetAdaptersInfo.Addr(), 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)
	if r0 != 0 {
		errcode = syscall.Errno(r0)
	}
	return
}

func SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) {
	r1, _, e1 := syscall.Syscall(procSetFileCompletionNotificationModes.Addr(), 2, uintptr(handle), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) {
	r0, _, e1 := syscall.Syscall(procWSAEnumProtocolsW.Addr(), 3, uintptr(unsafe.Pointer(protocols)), uintptr(unsafe.Pointer(protocolBuffer)), uintptr(unsafe.Pointer(bufferLength)))
	n = int32(r0)
	if n == -1 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) {
	r0, _, _ := syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(adapterAddresses)), uintptr(unsafe.Pointer(sizePointer)), 0)
	if r0 != 0 {
		errcode = syscall.Errno(r0)
	}
	return
}

func GetACP() (acp uint32) {
	r0, _, _ := syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0)
	acp = uint32(r0)
	return
}

func MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) {
	r0, _, e1 := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(codePage), uintptr(dwFlags), uintptr(unsafe.Pointer(str)), uintptr(nstr), uintptr(unsafe.Pointer(wchar)), uintptr(nwchar))
	nwrite = int32(r0)
	if nwrite == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procTranslateNameW.Addr(), 5, uintptr(unsafe.Pointer(accName)), uintptr(accNameFormat), uintptr(desiredNameFormat), uintptr(unsafe.Pointer(translatedName)), uintptr(unsafe.Pointer(nSize)), 0)
	if r1&0xff == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetUserNameExW.Addr(), 3, uintptr(nameFormat), uintptr(unsafe.Pointer(nameBuffre)), uintptr(unsafe.Pointer(nSize)))
	if r1&0xff == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) {
	r0, _, _ := syscall.Syscall6(procNetUserGetInfo.Addr(), 4, uintptr(unsafe.Pointer(serverName)), uintptr(unsafe.Pointer(userName)), uintptr(level), uintptr(unsafe.Pointer(buf)), 0, 0)
	if r0 != 0 {
		neterr = syscall.Errno(r0)
	}
	return
}

func NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) {
	r0, _, _ := syscall.Syscall(procNetGetJoinInformation.Addr(), 3, uintptr(unsafe.Pointer(server)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(bufType)))
	if r0 != 0 {
		neterr = syscall.Errno(r0)
	}
	return
}

func NetApiBufferFree(buf *byte) (neterr error) {
	r0, _, _ := syscall.Syscall(procNetApiBufferFree.Addr(), 1, uintptr(unsafe.Pointer(buf)), 0, 0)
	if r0 != 0 {
		neterr = syscall.Errno(r0)
	}
	return
}

func LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procLookupAccountSidW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procLookupAccountNameW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(accountName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sidLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procConvertSidToStringSidW.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(stringSid)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) {
	r1, _, e1 := syscall.Syscall(procConvertStringSidToSidW.Addr(), 2, uintptr(unsafe.Pointer(stringSid)), uintptr(unsafe.Pointer(sid)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetLengthSid(sid *SID) (len uint32) {
	r0, _, _ := syscall.Syscall(procGetLengthSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	len = uint32(r0)
	return
}

func CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) {
	r1, _, e1 := syscall.Syscall(procCopySid.Addr(), 3, uintptr(destSidLen), uintptr(unsafe.Pointer(destSid)), uintptr(unsafe.Pointer(srcSid)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) {
	r1, _, e1 := syscall.Syscall12(procAllocateAndInitializeSid.Addr(), 11, uintptr(unsafe.Pointer(identAuth)), uintptr(subAuth), uintptr(subAuth0), uintptr(subAuth1), uintptr(subAuth2), uintptr(subAuth3), uintptr(subAuth4), uintptr(subAuth5), uintptr(subAuth6), uintptr(subAuth7), uintptr(unsafe.Pointer(sid)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func createWellKnownSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID, sid *SID, sizeSid *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCreateWellKnownSid.Addr(), 4, uintptr(sidType), uintptr(unsafe.Pointer(domainSid)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sizeSid)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func isWellKnownSid(sid *SID, sidType WELL_KNOWN_SID_TYPE) (isWellKnown bool) {
	r0, _, _ := syscall.Syscall(procIsWellKnownSid.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(sidType), 0)
	isWellKnown = r0 != 0
	return
}

func FreeSid(sid *SID) (err error) {
	r1, _, e1 := syscall.Syscall(procFreeSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	if r1 != 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) {
	r0, _, _ := syscall.Syscall(procEqualSid.Addr(), 2, uintptr(unsafe.Pointer(sid1)), uintptr(unsafe.Pointer(sid2)), 0)
	isEqual = r0 != 0
	return
}

func getSidIdentifierAuthority(sid *SID) (authority *SidIdentifierAuthority) {
	r0, _, _ := syscall.Syscall(procGetSidIdentifierAuthority.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	authority = (*SidIdentifierAuthority)(unsafe.Pointer(r0))
	return
}

func getSidSubAuthorityCount(sid *SID) (count *uint8) {
	r0, _, _ := syscall.Syscall(procGetSidSubAuthorityCount.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	count = (*uint8)(unsafe.Pointer(r0))
	return
}

func getSidSubAuthority(sid *SID, index uint32) (subAuthority *uint32) {
	r0, _, _ := syscall.Syscall(procGetSidSubAuthority.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(index), 0)
	subAuthority = (*uint32)(unsafe.Pointer(r0))
	return
}

func isValidSid(sid *SID) (isValid bool) {
	r0, _, _ := syscall.Syscall(procIsValidSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	isValid = r0 != 0
	return
}

func checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) {
	r1, _, e1 := syscall.Syscall(procCheckTokenMembership.Addr(), 3, uintptr(tokenHandle), uintptr(unsafe.Pointer(sidToCheck)), uintptr(unsafe.Pointer(isMember)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenProcessToken(process Handle, access uint32, token *Token) (err error) {
	r1, _, e1 := syscall.Syscall(procOpenProcessToken.Addr(), 3, uintptr(process), uintptr(access), uintptr(unsafe.Pointer(token)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func OpenThreadToken(thread Handle, access uint32, openAsSelf bool, token *Token) (err error) {
	var _p0 uint32
	if openAsSelf {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall6(procOpenThreadToken.Addr(), 4, uintptr(thread), uintptr(access), uintptr(_p0), uintptr(unsafe.Pointer(token)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func ImpersonateSelf(impersonationlevel uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procImpersonateSelf.Addr(), 1, uintptr(impersonationlevel), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func RevertToSelf() (err error) {
	r1, _, e1 := syscall.Syscall(procRevertToSelf.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetThreadToken(thread *Handle, token Token) (err error) {
	r1, _, e1 := syscall.Syscall(procSetThreadToken.Addr(), 2, uintptr(unsafe.Pointer(thread)), uintptr(token), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LookupPrivilegeValue(systemname *uint16, name *uint16, luid *LUID) (err error) {
	r1, _, e1 := syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3, uintptr(unsafe.Pointer(systemname)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(luid)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func AdjustTokenPrivileges(token Token, disableAllPrivileges bool, newstate *Tokenprivileges, buflen uint32, prevstate *Tokenprivileges, returnlen *uint32) (err error) {
	var _p0 uint32
	if disableAllPrivileges {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(unsafe.Pointer(newstate)), uintptr(buflen), uintptr(unsafe.Pointer(prevstate)), uintptr(unsafe.Pointer(returnlen)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) {
	var _p0 uint32
	if resetToDefault {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall6(procAdjustTokenGroups.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(unsafe.Pointer(newstate)), uintptr(buflen), uintptr(unsafe.Pointer(prevstate)), uintptr(unsafe.Pointer(returnlen)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procGetTokenInformation.Addr(), 5, uintptr(token), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), uintptr(unsafe.Pointer(returnedLen)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procSetTokenInformation.Addr(), 4, uintptr(token), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func DuplicateTokenEx(existingToken Token, desiredAccess uint32, tokenAttributes *SecurityAttributes, impersonationLevel uint32, tokenType uint32, newToken *Token) (err error) {
	r1, _, e1 := syscall.Syscall6(procDuplicateTokenEx.Addr(), 6, uintptr(existingToken), uintptr(desiredAccess), uintptr(unsafe.Pointer(tokenAttributes)), uintptr(impersonationLevel), uintptr(tokenType), uintptr(unsafe.Pointer(newToken)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetUserProfileDirectoryW.Addr(), 3, uintptr(t), uintptr(unsafe.Pointer(dir)), uintptr(unsafe.Pointer(dirLen)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
	len = uint32(r0)
	if len == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetWindowsDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
	len = uint32(r0)
	if len == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSystemWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetSystemWindowsDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
	len = uint32(r0)
	if len == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WTSQueryUserToken(session uint32, token *Token) (err error) {
	r1, _, e1 := syscall.Syscall(procWTSQueryUserToken.Addr(), 2, uintptr(session), uintptr(unsafe.Pointer(token)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WTSEnumerateSessions(handle Handle, reserved uint32, version uint32, sessions **WTS_SESSION_INFO, count *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procWTSEnumerateSessionsW.Addr(), 5, uintptr(handle), uintptr(reserved), uintptr(version), uintptr(unsafe.Pointer(sessions)), uintptr(unsafe.Pointer(count)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WTSFreeMemory(ptr uintptr) {
	syscall.Syscall(procWTSFreeMemory.Addr(), 1, uintptr(ptr), 0, 0)
	return
}

func getSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {
	r0, _, _ := syscall.Syscall9(procGetSecurityInfo.Addr(), 8, uintptr(handle), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(sd)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) {
	syscall.Syscall9(procSetSecurityInfo.Addr(), 7, uintptr(handle), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), 0, 0)
	return
}

func getNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {
	var _p0 *uint16
	_p0, ret = syscall.UTF16PtrFromString(objectName)
	if ret != nil {
		return
	}
	return _getNamedSecurityInfo(_p0, objectType, securityInformation, owner, group, dacl, sacl, sd)
}

func _getNamedSecurityInfo(objectName *uint16, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {
	r0, _, _ := syscall.Syscall9(procGetNamedSecurityInfoW.Addr(), 8, uintptr(unsafe.Pointer(objectName)), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(sd)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func SetNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) {
	var _p0 *uint16
	_p0, ret = syscall.UTF16PtrFromString(objectName)
	if ret != nil {
		return
	}
	return _SetNamedSecurityInfo(_p0, objectType, securityInformation, owner, group, dacl, sacl)
}

func _SetNamedSecurityInfo(objectName *uint16, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) {
	r0, _, _ := syscall.Syscall9(procSetNamedSecurityInfoW.Addr(), 7, uintptr(unsafe.Pointer(objectName)), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func buildSecurityDescriptor(owner *TRUSTEE, group *TRUSTEE, countAccessEntries uint32, accessEntries *EXPLICIT_ACCESS, countAuditEntries uint32, auditEntries *EXPLICIT_ACCESS, oldSecurityDescriptor *SECURITY_DESCRIPTOR, sizeNewSecurityDescriptor *uint32, newSecurityDescriptor **SECURITY_DESCRIPTOR) (ret error) {
	r0, _, _ := syscall.Syscall9(procBuildSecurityDescriptorW.Addr(), 9, uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(countAccessEntries), uintptr(unsafe.Pointer(accessEntries)), uintptr(countAuditEntries), uintptr(unsafe.Pointer(auditEntries)), uintptr(unsafe.Pointer(oldSecurityDescriptor)), uintptr(unsafe.Pointer(sizeNewSecurityDescriptor)), uintptr(unsafe.Pointer(newSecurityDescriptor)))
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func initializeSecurityDescriptor(absoluteSD *SECURITY_DESCRIPTOR, revision uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procInitializeSecurityDescriptor.Addr(), 2, uintptr(unsafe.Pointer(absoluteSD)), uintptr(revision), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, control *SECURITY_DESCRIPTOR_CONTROL, revision *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorControl.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(control)), uintptr(unsafe.Pointer(revision)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent *bool, dacl **ACL, daclDefaulted *bool) (err error) {
	var _p0 uint32
	if *daclPresent {
		_p0 = 1
	} else {
		_p0 = 0
	}
	var _p1 uint32
	if *daclDefaulted {
		_p1 = 1
	} else {
		_p1 = 0
	}
	r1, _, e1 := syscall.Syscall6(procGetSecurityDescriptorDacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(&_p0)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(&_p1)), 0, 0)
	*daclPresent = _p0 != 0
	*daclDefaulted = _p1 != 0
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent *bool, sacl **ACL, saclDefaulted *bool) (err error) {
	var _p0 uint32
	if *saclPresent {
		_p0 = 1
	} else {
		_p0 = 0
	}
	var _p1 uint32
	if *saclDefaulted {
		_p1 = 1
	} else {
		_p1 = 0
	}
	r1, _, e1 := syscall.Syscall6(procGetSecurityDescriptorSacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(&_p0)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(&_p1)), 0, 0)
	*saclPresent = _p0 != 0
	*saclDefaulted = _p1 != 0
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner **SID, ownerDefaulted *bool) (err error) {
	var _p0 uint32
	if *ownerDefaulted {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorOwner.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(&_p0)))
	*ownerDefaulted = _p0 != 0
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) {
	var _p0 uint32
	if *groupDefaulted {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorGroup.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(&_p0)))
	*groupDefaulted = _p0 != 0
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getSecurityDescriptorLength(sd *SECURITY_DESCRIPTOR) (len uint32) {
	r0, _, _ := syscall.Syscall(procGetSecurityDescriptorLength.Addr(), 1, uintptr(unsafe.Pointer(sd)), 0, 0)
	len = uint32(r0)
	return
}

func getSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) (ret error) {
	r0, _, _ := syscall.Syscall(procGetSecurityDescriptorRMControl.Addr(), 2, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(rmControl)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func isValidSecurityDescriptor(sd *SECURITY_DESCRIPTOR) (isValid bool) {
	r0, _, _ := syscall.Syscall(procIsValidSecurityDescriptor.Addr(), 1, uintptr(unsafe.Pointer(sd)), 0, 0)
	isValid = r0 != 0
	return
}

func setSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, controlBitsOfInterest SECURITY_DESCRIPTOR_CONTROL, controlBitsToSet SECURITY_DESCRIPTOR_CONTROL) (err error) {
	r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorControl.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(controlBitsOfInterest), uintptr(controlBitsToSet))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent bool, dacl *ACL, daclDefaulted bool) (err error) {
	var _p0 uint32
	if daclPresent {
		_p0 = 1
	} else {
		_p0 = 0
	}
	var _p1 uint32
	if daclDefaulted {
		_p1 = 1
	} else {
		_p1 = 0
	}
	r1, _, e1 := syscall.Syscall6(procSetSecurityDescriptorDacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(_p0), uintptr(unsafe.Pointer(dacl)), uintptr(_p1), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent bool, sacl *ACL, saclDefaulted bool) (err error) {
	var _p0 uint32
	if saclPresent {
		_p0 = 1
	} else {
		_p0 = 0
	}
	var _p1 uint32
	if saclDefaulted {
		_p1 = 1
	} else {
		_p1 = 0
	}
	r1, _, e1 := syscall.Syscall6(procSetSecurityDescriptorSacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(_p0), uintptr(unsafe.Pointer(sacl)), uintptr(_p1), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner *SID, ownerDefaulted bool) (err error) {
	var _p0 uint32
	if ownerDefaulted {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorOwner.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(owner)), uintptr(_p0))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group *SID, groupDefaulted bool) (err error) {
	var _p0 uint32
	if groupDefaulted {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorGroup.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(group)), uintptr(_p0))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) {
	syscall.Syscall(procSetSecurityDescriptorRMControl.Addr(), 2, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(rmControl)), 0)
	return
}

func convertStringSecurityDescriptorToSecurityDescriptor(str string, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(str)
	if err != nil {
		return
	}
	return _convertStringSecurityDescriptorToSecurityDescriptor(_p0, revision, sd, size)
}

func _convertStringSecurityDescriptorToSecurityDescriptor(str *uint16, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procConvertStringSecurityDescriptorToSecurityDescriptorW.Addr(), 4, uintptr(unsafe.Pointer(str)), uintptr(revision), uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(size)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func convertSecurityDescriptorToStringSecurityDescriptor(sd *SECURITY_DESCRIPTOR, revision uint32, securityInformation SECURITY_INFORMATION, str **uint16, strLen *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procConvertSecurityDescriptorToStringSecurityDescriptorW.Addr(), 5, uintptr(unsafe.Pointer(sd)), uintptr(revision), uintptr(securityInformation), uintptr(unsafe.Pointer(str)), uintptr(unsafe.Pointer(strLen)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func makeAbsoluteSD(selfRelativeSD *SECURITY_DESCRIPTOR, absoluteSD *SECURITY_DESCRIPTOR, absoluteSDSize *uint32, dacl *ACL, daclSize *uint32, sacl *ACL, saclSize *uint32, owner *SID, ownerSize *uint32, group *SID, groupSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall12(procMakeAbsoluteSD.Addr(), 11, uintptr(unsafe.Pointer(selfRelativeSD)), uintptr(unsafe.Pointer(absoluteSD)), uintptr(unsafe.Pointer(absoluteSDSize)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(daclSize)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(saclSize)), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(ownerSize)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(groupSize)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func makeSelfRelativeSD(absoluteSD *SECURITY_DESCRIPTOR, selfRelativeSD *SECURITY_DESCRIPTOR, selfRelativeSDSize *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procMakeSelfRelativeSD.Addr(), 3, uintptr(unsafe.Pointer(absoluteSD)), uintptr(unsafe.Pointer(selfRelativeSD)), uintptr(unsafe.Pointer(selfRelativeSDSize)))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) {
	r0, _, _ := syscall.Syscall6(procSetEntriesInAclW.Addr(), 4, uintptr(countExplicitEntries), uintptr(unsafe.Pointer(explicitEntries)), uintptr(unsafe.Pointer(oldACL)), uintptr(unsafe.Pointer(newACL)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

- f e55659c2412bb5e6929ded5a3e8336e958a8f436911b7c657a94b1554bc08cad vendor/modules.txt
+ f 028adc0e522773fa9abc3b5c0488cb67246c43d5647d7565db07f99af0e61a3a vendor/modules.txt
dmppatch 47
@@ -1,36 +1,104 @@
-# github.com/fatih/color v1.7.0%0A
+# github.com/davecgh/go-spew v1.1.1%0Agithub.com/davecgh/go-spew/spew%0A# github.com/fatih/color v1.9.0%0A
 gith
@@ -120,77 +120,49 @@
 lor%0A
-# github.com/frankbraun/codechain v0.0.0-20191218191456-6ac37deb05ba%0A
+# github.com/frankbraun/codechain v1.0.1%0A
 gith
@@ -197,16 +197,56 @@
 archive%0A
+github.com/frankbraun/codechain/command%0A
 github.c
@@ -391,150 +391,48 @@
 ype%0A
-github.com/frankbraun/codechain/internal/ascii85%0Agithub.com/frankbraun/codechain/internal/base64%0Agithub.com/frankbraun/codechain/internal/def%0A
+github.com/frankbraun/codechain/keyfile%0A
 gith
@@ -656,16 +656,189 @@
 in/util%0A
+github.com/frankbraun/codechain/util/ascii85%0Agithub.com/frankbraun/codechain/util/base64%0Agithub.com/frankbraun/codechain/util/bzero%0Agithub.com/frankbraun/codechain/util/def%0A
 github.c
@@ -867,24 +867,65 @@
 n/util/file%0A
+github.com/frankbraun/codechain/util/git%0A
 github.com/f
@@ -1085,16 +1085,63 @@
 homedir%0A
+github.com/frankbraun/codechain/util/interrupt%0A
 github.c
@@ -1219,16 +1219,106 @@
 til/log%0A
+github.com/frankbraun/codechain/util/seckey%0Agithub.com/frankbraun/codechain/util/terminal%0A
 github.c
@@ -1572,65 +1572,120 @@
 tty%0A
-# golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413%0A
+# golang.org/x/crypto v0.0.0-20200115085410-6d4e4cb37c7d%0Agolang.org/x/crypto/argon2%0Agolang.org/x/crypto/blake2b%0A
 gola
@@ -1818,62 +1818,95 @@
 lsa%0A
-# golang.org/x/sys v0.0.0-20191218084908-4a24b4065292%0A
+golang.org/x/crypto/ssh/terminal%0A# golang.org/x/sys v0.0.0-20200116001909-b77594299b42%0A
 gola
@@ -1944,8 +1944,33 @@
 ys/unix%0A
+golang.org/x/sys/windows%0A
treehash 186d91903ea869a492f21c5af34ca1c025dd90c854882a5fd011efe00b0bf1cf
